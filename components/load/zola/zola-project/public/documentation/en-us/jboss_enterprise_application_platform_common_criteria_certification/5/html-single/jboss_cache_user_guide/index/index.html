<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir.min.css">
        




    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_Bwzy34i9pSdDlzGALvqVwG4fpgGp08KLMAkClGNY9M4.css" />



<link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir-doc-toc.min.css" />



        
        <!--#include virtual="/includes/head/index.html" -->

        
        <title>
JBoss Cache User Guide - JBoss Enterprise Application Platform Common Criteria Certification 5
</title>
        
<meta name="product" content="JBoss Enterprise Application Platform Common Criteria Certification" />
<meta name="documentation_version" content="5" />
<meta name="documentKind" content="documentation" />
<meta name="portal_content_subtype" content="title" />
<meta name="lastModifiedDate" content="2017-11-28T18:42:59.000Z" />


        
            
        
        
            
                
                
                <!-- mimir_solr_yesindex -->
                <meta name="mimir_solr_yesindex" content="true" />
            
        
    </head>

    <body class="mimir-body">

        
        

        
        <div id="page-wrap" class="page-wrap">
            <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">
                <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
                <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

                <header class="masthead" id="masthead">

                    
                    <!--#include virtual="/includes/header/index.html" -->

                    
                    
                    
                        
                    
                    
                        <div class="breadcrumbs">
                            <div id="breadcrumbs" class="container">
                                
                                <a href="/">Home</a>
                                
                                <a href="/products/">Product Documentation</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/7.2.3/">JBoss Enterprise Application Platform Common Criteria Certification</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/5/">5</a>
                                
                                
                                JBoss Cache User Guide
                                
                            </div>
                        </div>
                    
                </header>

                <main id="cp-main" class="portal-content-area">
                    <div id="cp-content" class="main-content">
                        
                        <main class="container mimir-docs">
                            
                            <bdo>
                                

<script type="module" src="/mimir/scripts/mimir-doc-toc.min.js"></script>






<div class="docs-grid">

    <nav id="mimir-doc-toc" class="mimir-doc-toc">
      <div class="mimir-doc-toc-inner">
          <!-- single-page -->
        
            
              <ol>
                <li>
                        
                        <a href="#">JBoss Cache User Guide</a>
                    </li><li>
                        <a href="#preface">
                            Preface
                        </a>
                    </li><li>
                        <a href="#idm140119323457440">
                            I. Introduction to JBoss Cache
                        </a><ol>
                <li>
                        <a href="#introduction">
                            1. Overview
                        </a><ol>
                <li>
                        <a href="#idm140119305353584">
                            1.1. What is JBoss Cache?
                        </a><ol>
                <li>
                        <a href="#idm140119306494112">
                            1.1.1. And what is POJO Cache?
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119307083456">
                            1.2. Summary of Features
                        </a><ol>
                <li>
                        <a href="#idm140119312944864">
                            1.2.1. Caching objects
                        </a>
                    </li><li>
                        <a href="#idm140119304287280">
                            1.2.2. Local and clustered modes
                        </a>
                    </li><li>
                        <a href="#idm140119302380768">
                            1.2.3. Clustered caches and transactions
                        </a>
                    </li><li>
                        <a href="#idm140119302376800">
                            1.2.4. Thread safety
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119323296144">
                            1.3.  Requirements 
                        </a>
                    </li><li>
                        <a href="#idm140119323291760">
                            1.4. License
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#api">
                            2. User API
                        </a><ol>
                <li>
                        <a href="#idm140119310599296">
                            2.1. API Classes
                        </a>
                    </li><li>
                        <a href="#api.create_start">
                            2.2. Instantiating and Starting the Cache
                        </a>
                    </li><li>
                        <a href="#idm140119308432784">
                            2.3. Caching and Retrieving Data
                        </a><ol>
                <li>
                        <a href="#idm140119322231968">
                            2.3.1. Organizing Your Data and Using the Node Structure
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#basic_api.fqn">
                            2.4.  The Fqn Class 
                        </a>
                    </li><li>
                        <a href="#idm140119305256688">
                            2.5. Stopping and Destroying the Cache
                        </a>
                    </li><li>
                        <a href="#idm140119323245920">
                            2.6. Cache Modes
                        </a>
                    </li><li>
                        <a href="#api.listener">
                            2.7.  Adding a Cache Listener - registering for cache events 
                        </a><ol>
                <li>
                        <a href="#idm140119302752096">
                            2.7.1. Synchronous and Asynchronous Notifications
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119302748784">
                            2.8. Using Cache Loaders
                        </a>
                    </li><li>
                        <a href="#idm140119302736160">
                            2.9. Using Eviction Policies
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration">
                            3. Configuration
                        </a><ol>
                <li>
                        <a href="#idm140119300066176">
                            3.1. Configuration Overview
                        </a>
                    </li><li>
                        <a href="#configuration.creation">
                            3.2. Creating a Configuration 
                        </a><ol>
                <li>
                        <a href="#idm140119305705488">
                            3.2.1. Parsing an XML-based Configuration File
                        </a>
                    </li><li>
                        <a href="#configuration.validation">
                            3.2.2. Validating Configuration Files
                        </a>
                    </li><li>
                        <a href="#idm140119307140880">
                            3.2.3. Programmatic Configuration
                        </a>
                    </li><li>
                        <a href="#idm140119322718960">
                            3.2.4. Using an IOC Framework
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration.elements">
                            3.3. Composition of a Configuration Object 
                        </a>
                    </li><li>
                        <a href="#idm140119300658992">
                            3.4. Dynamic Reconfiguration
                        </a><ol>
                <li>
                        <a href="#configuration.options">
                            3.4.1. Overriding the Configuration via the Option API
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#batching">
                            4. Batching API
                        </a><ol>
                <li>
                        <a href="#batching.intro">
                            4.1. Introduction
                        </a>
                    </li><li>
                        <a href="#batching.configuring">
                            4.2. Configuring batching
                        </a>
                    </li><li>
                        <a href="#batching.api">
                            4.3. Batching API
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#deployment">
                            5. Deploying JBoss Cache
                        </a><ol>
                <li>
                        <a href="#deployment.standalone">
                            5.1. Standalone Use/Programatic Deployment
                        </a>
                    </li><li>
                        <a href="#deployment.microcontainer">
                            5.2. Via JBoss Microcontainer (JBoss AS 5.x)
                        </a>
                    </li><li>
                        <a href="#idm140119300644512">
                            5.3. Automatic binding to JNDI in JBoss AS
                        </a>
                    </li><li>
                        <a href="#idm140119308294736">
                            5.4. Runtime Management Information
                        </a><ol>
                <li>
                        <a href="#jmx.mbeans">
                            5.4.1. JBoss Cache MBeans
                        </a>
                    </li><li>
                        <a href="#jmx.registration">
                            5.4.2. Registering the CacheJmxWrapper with the MBeanServer
                        </a>
                    </li><li>
                        <a href="#jmx.statistics">
                            5.4.3. JBoss Cache Statistics
                        </a>
                    </li><li>
                        <a href="#idm140119306255056">
                            5.4.4. Receiving JMX Notifications
                        </a>
                    </li><li>
                        <a href="#jconsole">
                            5.4.5. Accessing Cache MBeans in a Standalone Environment using the jconsole Utility
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#compatibility">
                            6. Version Compatibility and Interoperability
                        </a><ol>
                <li>
                        <a href="#idm140119306934128">
                            6.1. API compatibility
                        </a>
                    </li><li>
                        <a href="#idm140119312954912">
                            6.2. Wire-level interoperability
                        </a>
                    </li><li>
                        <a href="#idm140119307177728">
                            6.3. Compatibility Matrix
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119321757264">
                            II. JBoss Cache Architecture
                        </a><ol>
                <li>
                        <a href="#architecture">
                            7. Architecture
                        </a><ol>
                <li>
                        <a href="#architecture.tree_structure">
                            7.1. Data Structures Within The Cache
                        </a>
                    </li><li>
                        <a href="#architecture.SPI_interfaces">
                            7.2. SPI Interfaces
                        </a>
                    </li><li>
                        <a href="#architecture.invocations">
                            7.3. Method Invocations On Nodes
                        </a><ol>
                <li>
                        <a href="#architecture.interceptors">
                            7.3.1. Interceptors
                        </a>
                    </li><li>
                        <a href="#architecture.commands">
                            7.3.2. Commands and Visitors
                        </a>
                    </li><li>
                        <a href="#architecture.invocationcontext">
                            7.3.3. InvocationContexts
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#architecture.managers">
                            7.4. Managers For Subsystems
                        </a><ol>
                <li>
                        <a href="#architecture.rpcmanager">
                            7.4.1. RpcManager
                        </a>
                    </li><li>
                        <a href="#architecture.buddymanager">
                            7.4.2. BuddyManager
                        </a>
                    </li><li>
                        <a href="#architecture.cacheloadermanager">
                            7.4.3. CacheLoaderManager
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#architecture.marshalling">
                            7.5. Marshalling And Wire Formats
                        </a><ol>
                <li>
                        <a href="#idm140119305993744">
                            7.5.1. The Marshaller Interface
                        </a>
                    </li><li>
                        <a href="#idm140119305226960">
                            7.5.2. VersionAwareMarshaller
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#architecture.regions">
                            7.6. Class Loading and Regions
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering">
                            8. Cache Modes and Clustering
                        </a><ol>
                <li>
                        <a href="#idm140119305162512">
                            8.1. Cache Replication Modes
                        </a><ol>
                <li>
                        <a href="#idm140119311661168">
                            8.1.1. Local Mode
                        </a>
                    </li><li>
                        <a href="#idm140119311525888">
                            8.1.2. Replicated Caches
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119308095264">
                            8.2. Invalidation
                        </a>
                    </li><li>
                        <a href="#idm140119308091104">
                            8.3. State Transfer
                        </a><ol>
                <li>
                        <a href="#idm140119308089152">
                            8.3.1. State Transfer Types
                        </a>
                    </li><li>
                        <a href="#idm140119308087072">
                            8.3.2. Byte array and streaming based state transfer
                        </a>
                    </li><li>
                        <a href="#idm140119308084112">
                            8.3.3. Full and partial state transfer
                        </a>
                    </li><li>
                        <a href="#idm140119307356160">
                            8.3.4. Transient ("in-memory") and persistent state transfer
                        </a>
                    </li><li>
                        <a href="#idm140119299394560">
                            8.3.5. Configuring State Transfer
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#cache_loaders">
                            9. Cache Loaders
                        </a><ol>
                <li>
                        <a href="#idm140119299438272">
                            9.1. The CacheLoader Interface and Lifecycle
                        </a>
                    </li><li>
                        <a href="#idm140119318081616">
                            9.2. Configuration
                        </a><ol>
                <li>
                        <a href="#sscl">
                            9.2.1. Singleton Store Configuration
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#cl.impls">
                            9.3. Shipped Implementations
                        </a><ol>
                <li>
                        <a href="#idm140119300619184">
                            9.3.1. File system based cache loaders
                        </a>
                    </li><li>
                        <a href="#idm140119308069424">
                            9.3.2. Cache loaders that delegate to other caches
                        </a>
                    </li><li>
                        <a href="#cl.jdbc">
                            9.3.3. JDBCCacheLoader
                        </a>
                    </li><li>
                        <a href="#cl.s3">
                            9.3.4. S3CacheLoader
                        </a>
                    </li><li>
                        <a href="#cl.tcp">
                            9.3.5. TcpDelegatingCacheLoader
                        </a>
                    </li><li>
                        <a href="#cl.transforming">
                            9.3.6. Transforming Cache Loaders
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#cl.pass">
                            9.4. Cache Passivation
                        </a><ol>
                <li>
                        <a href="#idm140119299911968">
                            9.4.1. Cache Loader Behavior with Passivation Disabled vs. Enabled
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119299899856">
                            9.5. Strategies
                        </a><ol>
                <li>
                        <a href="#idm140119299898448">
                            9.5.1. Local Cache With Store
                        </a>
                    </li><li>
                        <a href="#idm140119299895936">
                            9.5.2. Replicated Caches With All Caches Sharing The Same Store
                        </a>
                    </li><li>
                        <a href="#idm140119299888416">
                            9.5.3. Replicated Caches With Only One Cache Having A Store
                        </a>
                    </li><li>
                        <a href="#idm140119299880624">
                            9.5.4. Replicated Caches With Each Cache Having Its Own Store
                        </a>
                    </li><li>
                        <a href="#idm140119299866704">
                            9.5.5. Hierarchical Caches
                        </a>
                    </li><li>
                        <a href="#idm140119299861232">
                            9.5.6. Multiple Cache Loaders
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#eviction_policies">
                            10. Eviction
                        </a><ol>
                <li>
                        <a href="#eviction.design">
                            10.1. Design
                        </a><ol>
                <li>
                        <a href="#idm140119305343232">
                            10.1.1. Collecting Statistics
                        </a>
                    </li><li>
                        <a href="#idm140119306476320">
                            10.1.2. Determining Which Nodes to Evict
                        </a>
                    </li><li>
                        <a href="#idm140119305066448">
                            10.1.3. How Nodes are Evicted
                        </a>
                    </li><li>
                        <a href="#idm140119305946592">
                            10.1.4. Eviction threads
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#regions">
                            10.2. Eviction Regions
                        </a><ol>
                <li>
                        <a href="#idm140119308244912">
                            10.2.1. Resident Nodes
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119312890016">
                            10.3. Configuring Eviction
                        </a><ol>
                <li>
                        <a href="#eviction.basic_cfg">
                            10.3.1. Basic Configuration
                        </a>
                    </li><li>
                        <a href="#idm140119299362400">
                            10.3.2. Programmatic Configuration
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#eviction.shipped">
                            10.4. Shipped Eviction Policies
                        </a><ol>
                <li>
                        <a href="#idm140119299353936">
                            10.4.1. LRUAlgorithm - Least Recently Used
                        </a>
                    </li><li>
                        <a href="#idm140119300018768">
                            10.4.2. FIFOAlgorithm - First In, First Out
                        </a>
                    </li><li>
                        <a href="#idm140119300012848">
                            10.4.3. MRUAlgorithm - Most Recently Used
                        </a>
                    </li><li>
                        <a href="#idm140119299329776">
                            10.4.4. LFUAlgorithm - Least Frequently Used
                        </a>
                    </li><li>
                        <a href="#idm140119299320208">
                            10.4.5. ExpirationAlgorithm
                        </a>
                    </li><li>
                        <a href="#idm140119299308320">
                            10.4.6. ElementSizeAlgorithm - Eviction based on number of key/value pairs in a node
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transactions">
                            11. Transactions and Concurrency
                        </a><ol>
                <li>
                        <a href="#transactions.concurrent">
                            11.1. Concurrent Access
                        </a><ol>
                <li>
                        <a href="#transactions.locks.mvcc">
                            11.1.1. Multi-Version Concurrency Control (MVCC)
                        </a>
                    </li><li>
                        <a href="#transactions.locks.dep">
                            11.1.2. Pessimistic and Optimistic Locking Schemes
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transactions.jta">
                            11.2. JTA Support
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119323312560">
                            III. JBoss Cache Configuration References
                        </a><ol>
                <li>
                        <a href="#configuration_reference_chapter">
                            12. Configuration References
                        </a><ol>
                <li>
                        <a href="#sample_xml_file">
                            12.1. Sample XML Configuration File
                        </a><ol>
                <li>
                        <a href="#idm140119306711472">
                            12.1.1. XML validation
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration_reference">
                            12.2. Configuration File Quick Reference
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#jmx_reference">
                            13. JMX References
                        </a><ol>
                <li>
                        <a href="#jmx_reference.statistics">
                            13.1. JBoss Cache Statistics
                        </a>
                    </li><li>
                        <a href="#jmx_reference.notifications">
                            13.2. JMX MBean Notifications
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140119307487280">
                            Legal Notice
                        </a>
                    </li>
            </ol>
            
        
      </div>
    </nav>

    
    <div class="pvof-doc__wrapper" id="doc-wrapper">
        <section class="mimir-doc-title" id="mimir-doc--jboss_cache_user_guide">
            <h1 class="title">JBoss Cache User Guide</h1>
        </section>
        <body><div xml:lang="en-US" class="book" id="idm140119323461616" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JBoss Enterprise Application Platform Common Criteria Certification</span> <span class="productnumber">5</span></div><div><h2 class="subtitle">for Use with JBoss Enterprise Application Platform 5 Common Criteria Certification</h2></div><p class="edition">Edition 5.1.0</p><div><h3 class="corpauthor">
		<span class="inlinemediaobject"><object data="https://access.redhat.com/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/a78399a6916bd5b945caa082f6c4fa4e/title_logo.svg" type="image/svg+xml"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/20c014cff25dbc2aeb4126383228ede4/title_logo.png" alt="" /></object></span>

	</h3></div><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">Manik</span> <span class="surname">Surtani</span></h3><code class="email"><a class="email mimir-link-warn" href="mailto:manik@jboss.org" title="This content is not included in Mimir.">manik@jboss.org</a></code></div><div class="author"><h3 class="author"><span class="firstname">Brian</span> <span class="surname">Stansberry</span></h3><code class="email"><a class="email mimir-link-warn" href="mailto:brian.stansberry@jboss.com" title="This content is not included in Mimir.">brian.stansberry@jboss.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Galder</span> <span class="surname">Zamarreño</span></h3><code class="email"><a class="email mimir-link-warn" href="mailto:galder.zamarreno@jboss.com" title="This content is not included in Mimir.">galder.zamarreno@jboss.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Mircea</span> <span class="surname">Markus</span></h3><code class="email"><a class="email mimir-link-warn" href="mailto:mircea.markus@jboss.com" title="This content is not included in Mimir.">mircea.markus@jboss.com</a></code></div></div></div><div><p class="copyright">Copyright © 2011 Red Hat, Inc</p></div><div><a href="#idm140119307487280">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
			This book is the User Guide for Cache of the JBoss Enterprise Application Platform 5.1.0.
		</div></div></div></div></div><div xml:lang="en-US" class="preface" id="preface" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div><div class="para">
		This is the official JBoss Cache Users' Guide. Along with its accompanying documents (an FAQ, a tutorial and a whole set of documents on POJO Cache), this is freely available on the JBoss Cache <a href="http://www.jboss.org/jbosscache" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">documentation website</a>.
	</div><div class="para">
		When used, JBoss Cache refers to JBoss Cache Core, a tree-structured, clustered, transactional cache. POJO Cache, also a part of the JBoss Cache distribution, is documented separately. (POJO Cache is a cache that deals with Plain Old Java Objects, complete with object relationships, with the ability to cluster such POJOs while maintaining their relationships. Please see the POJO Cache documentation for more information about this.)
	</div><div class="para">
		This book is targeted at developers wishing to use JBoss Cache as either a standalone in-memory cache, a distributed or replicated cache, a clustering library, or an in-memory database. It is targeted at application developers who wish to use JBoss Cache in their code base, as well as "OEM" developers who wish to build on and extend JBoss Cache features. As such, this book is split into two major sections - one detailing the "User" API and the other going much deeper into specialist topics and the JBoss Cache architecture.
	</div><div class="para">
		In general, a good knowledge of the Java programming language along with a strong appreciation and understanding of transactions and concurrent programming is necessary. No prior knowledge of JBoss Application Server is expected or required.
	</div><div class="para">
		For further discussion, use the user forum available on the JBoss Cache <a href="http://www.jboss.org/jbosscache" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">website.</a> We also provide a mechanism for tracking bug reports and feature requests on the JBoss Cache <a href="http://jira.jboss.com/jira/browse/JBCACHE" class="mimir-link-warn" title="Mimir does not include content from: jira.jboss.com">JIRA issue tracker</a>.
	</div><div class="para">
		If you are interested in the development of JBoss Cache or in translating this documentation into other languages, we'd love to hear from you. Please post a message on the JBoss Cache <a href="http://www.jboss.org/jbosscache" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">user forum</a> or contact us by using the JBoss Cache <a href="https://lists.jboss.org/mailman/listinfo/jbosscache-dev" class="mimir-link-warn" title="Mimir does not include content from: lists.jboss.org">developer mailing list</a>.
	</div><div class="para">
		This book is specifically targeted at the JBoss Cache release of the same version number. It may not apply to older or newer releases of JBoss Cache. It is important that you use the documentation appropriate to the version of JBoss Cache you intend to use.
	</div><div class="para">
		I always appreciate feedback, suggestions and corrections, and these should be directed to the <a href="https://lists.jboss.org/mailman/listinfo/jbosscache-dev" class="mimir-link-warn" title="Mimir does not include content from: lists.jboss.org">developer mailing list</a> rather than direct emails to any of the authors. We hope you find this book useful, and wish you happy reading!
	</div><div class="para">
		<span class="bold bold"><strong>Manik Surtani</strong></span>, October 2008
	</div></div><div class="part" id="idm140119323457440"><div class="titlepage"><div><div><h1 class="title">Part I. Introduction to JBoss Cache</h1></div></div></div><div class="partintro" id="idm140119323456432"><div><!--Empty--></div><div class="para">
				This section covers what developers would need to quickly start using JBoss Cache in their projects. It covers an overview of the concepts and API, configuration and deployment information.
			</div></div><div xml:lang="en-US" class="chapter" id="introduction" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 1. Overview</h2></div></div></div><div class="section" id="idm140119305353584"><div class="titlepage"><div><div><h2 class="title">1.1. What is JBoss Cache?</h2></div></div></div><div class="para">
			JBoss Cache is a tree-structured, clustered, transactional cache. It can be used in a standalone, non-clustered environment, to cache frequently accessed data in memory thereby removing data retrieval or calculation bottlenecks while providing "enterprise" features such as <a href="http://java.sun.com/products/jta" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">JTA</a> compatibility, eviction and persistence.
		</div><div class="para">
			JBoss Cache is also a clustered cache, and can be used in a cluster to replicate state providing a high degree of failover. A variety of replication modes are supported, including invalidation and buddy replication, and network communications can either be synchronous or asynchronous.
		</div><div class="para">
			When used in a clustered mode, the cache is an effective mechanism of building high availability, fault tolerance and even load balancing into custom applications and frameworks. For example, the <a href="http://www.jboss.org/projects/jbossas/" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JBoss Application Server</a> and Red Hat's <a href="http://www.jboss.com" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">Enterprise Application Platform</a> make extensive use of JBoss Cache to cluster services such as HTTP and <a href="http://java.sun.com/products/ejb/" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">EJB</a> sessions, as well as providing a distributed entity cache for <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" class="mimir-link-warn" title="Mimir does not include content from: en.wikipedia.org">JPA</a>.
		</div><div class="section" id="idm140119306494112"><div class="titlepage"><div><div><h3 class="title">1.1.1. And what is POJO Cache?</h3></div></div></div><div class="para">
				POJO Cache is an extension of the core JBoss Cache API. POJO Cache offers additional functionality such as: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							maintaining object references even after replication or persistence
						</div></li><li class="listitem"><div class="para">
							fine grained replication, where only modified object fields are replicated
						</div></li><li class="listitem"><div class="para">
							"API-less" clustering model where POJOs are simply annotated as being clustered
						</div></li></ul></div>

			</div><div class="para">
				POJO Cache has a complete and separate set of documentation, including a Users' Guide, FAQ and tutorial all available on the JBoss Cache <a href="http://www.jboss.org/jbosscache" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">documentation website</a>. As such, POJO Cache will not be discussed further in this book.
			</div></div></div><div class="section" id="idm140119307083456"><div class="titlepage"><div><div><h2 class="title">1.2. Summary of Features</h2></div></div></div><div class="section" id="idm140119312944864"><div class="titlepage"><div><div><h3 class="title">1.2.1. Caching objects</h3></div></div></div><div class="para">
				JBoss Cache offers a simple and straightforward API, where data - simple Java objects - can be placed in the cache. Based on configuration options selected, this data may be one or all of: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							cached in-memory for efficient, thread-safe retrieval
						</div></li><li class="listitem"><div class="para">
							replicated to some or all cache instances in a cluster
						</div></li><li class="listitem"><div class="para">
							persisted to disk and/or a remote, in-memory cache cluster ("far-cache")
						</div></li><li class="listitem"><div class="para">
							garbage collected from memory when memory runs low, and passivated to disk so state isn't lost
						</div></li></ul></div>
				 In addition, JBoss Cache offers a rich set of enterprise-class features: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							being able to participate in <a href="http://java.sun.com/products/jta" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">JTA</a> transactions (works with most Java EE compliant transaction managers).
						</div></li><li class="listitem"><div class="para">
							attach to JMX consoles and provide runtime statistics on the state of the cache.
						</div></li><li class="listitem"><div class="para">
							allow client code to attach listeners and receive notifications on cache events.
						</div></li><li class="listitem"><div class="para">
							allow grouping of cache operations into batches, for efficient replication
						</div></li></ul></div>

			</div></div><div class="section" id="idm140119304287280"><div class="titlepage"><div><div><h3 class="title">1.2.2. Local and clustered modes</h3></div></div></div><div class="para">
				The cache is organized as a tree, with a single root. Each node in the tree essentially contains a map, which acts as a store for key/value pairs. The only requirement placed on objects that are cached is that they implement <code class="literal">java.io.Serializable</code>.
			</div><div class="para">
				JBoss Cache can be either local or replicated. Local caches exist only within the scope of the JVM in which they are created, whereas replicated caches propagate any changes to some or all other caches in the same cluster. A cluster may span different hosts on a network or just different JVMs on a single host.
			</div></div><div class="section" id="idm140119302380768"><div class="titlepage"><div><div><h3 class="title">1.2.3. Clustered caches and transactions</h3></div></div></div><div class="para">
				When a change is made to an object in the cache and that change is done in the context of a transaction, the replication of changes is deferred until the transaction completes successfully. All modifications are kept in a list associated with the transaction of the caller. When the transaction commits, changes are replicated. Otherwise, on a rollback, we simply undo the changes locally and discard the modification list, resulting in zero network traffic and overhead. For example, if a caller makes 100 modifications and then rolls back the transaction, nothing is replicated, resulting in no network traffic.
			</div><div class="para">
				If a caller has no transaction or batch associated with it, modifications are replicated immediately. E.g. in the example used earlier, 100 messages would be broadcast for each modification. In this sense, running without a batch or transaction can be thought of as analogous as running with auto-commit switched on in JDBC terminology, where each operation is committed automatically and immediately.
			</div><div class="para">
				JBoss Cache works out of the box with most popular transaction managers, and even provides an API where custom transaction manager lookups can be written.
			</div><div class="para">
				All of the above holds true for batches as well, which has similar behavior.
			</div></div><div class="section" id="idm140119302376800"><div class="titlepage"><div><div><h3 class="title">1.2.4. Thread safety</h3></div></div></div><div class="para">
				The cache is completely thread-safe. It employs multi-versioned concurrency control (MVCC) to ensure thread safety between readers and writers, while maintaining a high degree of concurrency. The specific MVCC implementation used in JBoss Cache allows for reader threads to be completely free of locks and synchronized blocks, ensuring a very high degree of performance for read-heavy applications. It also uses custom, highly performant lock implementations that employ modern compare-and-swap techniques for writer threads, which are tuned to multi-core CPU architectures.
			</div><div class="para">
				Multi-versioned concurrency control (MVCC) is the default locking scheme since JBoss Cache 3.x. Optimistic and pessimistic locking schemes from older versions of JBoss Cache are still available but are deprecated in favor of MVCC, and will be removed in future releases. Use of these deprecated locking schemes are strongly discouraged.
			</div><div class="para">
				The JBoss Cache MVCC implementation only supports READ_COMMITTED and REPEATABLE_READ isolation levels, corresponding to their database equivalents. See the section on <a class="xref" href="#transactions">Chapter 11, <em>Transactions and Concurrency</em></a> for details on MVCC.
			</div></div></div><div class="section" id="idm140119323296144"><div class="titlepage"><div><div><h2 class="title">1.3.  Requirements </h2></div></div></div><div class="para">
			JBoss Cache requires a Java 5.0 (or newer) compatible virtual machine and set of libraries, and is developed and tested on Sun's JDK 5.0 and JDK 6.
		</div><div class="para">
			In addition to Java 5.0, at a minimum, JBoss Cache has dependencies on <a href="http://www.jgroups.org" class="mimir-link-warn" title="Mimir does not include content from: www.jgroups.org">JGroups</a>, and Apache's <a href="http://jakarta.apache.org/commons/logging/" class="mimir-link-warn" title="Mimir does not include content from: jakarta.apache.org">commons-logging</a>. JBoss Cache ships with all dependent libraries necessary to run out of the box, as well as several optional jars for optional features.
		</div></div><div class="section" id="idm140119323291760"><div class="titlepage"><div><div><h2 class="title">1.4. License</h2></div></div></div><div class="para">
			JBoss Cache is an open source project, using the business and OEM-friendly <a href="http://www.opensource.org/" class="mimir-link-warn" title="Mimir does not include content from: www.opensource.org">OSI-approved</a> <a href="http://www.gnu.org/copyleft/lesser.html" class="mimir-link-warn" title="Mimir does not include content from: www.gnu.org">LGPL license.</a> Commercial development support, production support and training for JBoss Cache is available through <a href="http://www.jboss.com" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">JBoss, a division of Red Hat Inc.</a>
		</div></div></div><div xml:lang="en-US" class="chapter" id="api" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 2. User API</h2></div></div></div><div class="section" id="idm140119310599296"><div class="titlepage"><div><div><h2 class="title">2.1. API Classes</h2></div></div></div><div class="para">
			The <code class="literal">Cache</code> interface is the primary mechanism for interacting with JBoss Cache. It is constructed and optionally started using the <code class="literal">CacheFactory</code>. The <code class="literal">CacheFactory</code> allows you to create a <code class="literal">Cache</code> either from a <code class="literal">Configuration</code> object or an XML file. The cache organizes data into a tree structure, made up of nodes. Once you have a reference to a <code class="literal">Cache</code>, you can use it to look up <code class="literal">Node</code> objects in the tree structure, and store data in the tree. 
			<div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/b36690d1d3459d8dd989c62b76f37199/PublicAPI.png" width="444" /></div>

		</div><div class="para">
			Note that the diagram above only depicts some of the more popular API methods. Reviewing the Javadoc for the above interfaces is the best way to learn the API. Below, we cover some of the main points.
		</div></div><div class="section" id="api.create_start"><div class="titlepage"><div><div><h2 class="title">2.2. Instantiating and Starting the Cache</h2></div></div></div><div class="para">
			An instance of the <code class="literal">Cache</code> interface can only be created via a <code class="literal">CacheFactory</code>. This is unlike JBoss Cache 1.x, where an instance of the old <code class="literal">TreeCache</code> class could be directly instantiated.
		</div><div class="para">
			The <code class="literal">CacheFactory</code> provides a number of overloaded methods for creating a <code class="literal">Cache</code>, but they all fundamentally do the same thing: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Gain access to a <code class="literal">Configuration</code>, either by having one passed in as a method parameter or by parsing XML content and constructing one. The XML content can come from a provided input stream, from a classpath or filesystem location. See the <a class="xref" href="#configuration">Chapter 3, <em>Configuration</em></a> for more on obtaining a <code class="literal">Configuration</code>.
					</div></li><li class="listitem"><div class="para">
						Instantiate the <code class="literal">Cache</code> and provide it with a reference to the <code class="literal">Configuration</code>.
					</div></li><li class="listitem"><div class="para">
						Optionally invoke the cache's <code class="literal">create()</code> and <code class="literal">start()</code> methods.
					</div></li></ul></div>

		</div><div class="para">
			Here is an example of the simplest mechanism for creating and starting a cache, using the default configuration values:
		</div><pre class="programlisting JAVA JAVA">
   CacheFactory factory = new DefaultCacheFactory();
   Cache cache = factory.createCache();
</pre><div class="para">
			In this example, we tell the <code class="literal">CacheFactory</code> to find and parse a configuration file on the classpath:
		</div><pre class="programlisting JAVA JAVA">
   CacheFactory factory = new DefaultCacheFactory();
   Cache cache = factory.createCache("cache-configuration.xml");
</pre><div class="para">
			In this example, we configure the cache from a file, but want to programatically change a configuration element. So, we tell the factory not to start the cache, and instead do it ourselves:
		</div><pre class="programlisting JAVA JAVA">
   CacheFactory factory = new DefaultCacheFactory();
   Cache cache = factory.createCache("/opt/configurations/cache-configuration.xml", false);
   Configuration config = cache.getConfiguration();
   config.setClusterName(this.getClusterName());

   // Have to create and start cache before using it
   cache.create();
   cache.start();
</pre></div><div class="section" id="idm140119308432784"><div class="titlepage"><div><div><h2 class="title">2.3. Caching and Retrieving Data</h2></div></div></div><div class="para">
			Next, lets use the <code class="literal">Cache</code> API to access a <code class="literal">Node</code> in the cache and then do some simple reads and writes to that node.
		</div><pre class="programlisting JAVA JAVA">
   // Let's get a hold of the root node.
   Node rootNode = cache.getRoot();

   // Remember, JBoss Cache stores data in a tree structure.
   // All nodes in the tree structure are identified by Fqn objects.
   Fqn peterGriffinFqn = Fqn.fromString("/griffin/peter");

   // Create a new Node
   Node peterGriffin = rootNode.addChild(peterGriffinFqn);

   // let's store some data in the node
   peterGriffin.put("isCartoonCharacter", Boolean.TRUE);
   peterGriffin.put("favoriteDrink", new Beer());

   // some tests (just assume this code is in a JUnit test case)
   assertTrue(peterGriffin.get("isCartoonCharacter"));
   assertEquals(peterGriffinFqn, peterGriffin.getFqn());
   assertTrue(rootNode.hasChild(peterGriffinFqn));

   Set keys = new HashSet();
   keys.add("isCartoonCharacter");
   keys.add("favoriteDrink");

   assertEquals(keys, peterGriffin.getKeys());

   // let's remove some data from the node
   peterGriffin.remove("favoriteDrink");

   assertNull(peterGriffin.get("favoriteDrink");

   // let's remove the node altogether
   rootNode.removeChild(peterGriffinFqn);

   assertFalse(rootNode.hasChild(peterGriffinFqn));
</pre><div class="para">
			The <code class="literal">Cache</code> interface also exposes put/get/remove operations that take an <a class="xref" href="#basic_api.fqn">Section 2.4, “ The <code class="literal">Fqn</code> Class ”</a> as an argument, for convenience:
		</div><pre class="programlisting JAVA JAVA">
   Fqn peterGriffinFqn = Fqn.fromString("/griffin/peter");

   cache.put(peterGriffinFqn, "isCartoonCharacter", Boolean.TRUE);
   cache.put(peterGriffinFqn, "favoriteDrink", new Beer());

   assertTrue(peterGriffin.get(peterGriffinFqn, "isCartoonCharacter"));
   assertTrue(cache.getRootNode().hasChild(peterGriffinFqn));

   cache.remove(peterGriffinFqn, "favoriteDrink");

   assertNull(cache.get(peterGriffinFqn, "favoriteDrink");

   cache.removeNode(peterGriffinFqn);

   assertFalse(cache.getRootNode().hasChild(peterGriffinFqn));
</pre><div class="section" id="idm140119322231968"><div class="titlepage"><div><div><h3 class="title">2.3.1. Organizing Your Data and Using the Node Structure</h3></div></div></div><div class="para">
				A Node should be viewed as a named logical grouping of data. A node should be used to contain data for a single data record, for example information about a particular person or account. It should be kept in mind that all aspects of the cache - locking, cache loading, replication and eviction - happen on a per-node basis. As such, anything grouped together by being stored in a single node will be treated as a single atomic unit.
			</div></div></div><div class="section" id="basic_api.fqn"><div class="titlepage"><div><div><h2 class="title">2.4.  The <code class="literal">Fqn</code> Class </h2></div></div></div><div class="para">
			The previous section used the <code class="literal">Fqn</code> class in its examples; now let's learn a bit more about that class.
		</div><div class="para">
			A Fully Qualified Name (Fqn) encapsulates a list of names which represent a path to a particular location in the cache's tree structure. The elements in the list are typically <code class="literal">String</code>s but can be any <code class="literal">Object</code> or a mix of different types.
		</div><div class="para">
			This path can be absolute (i.e., relative to the root node), or relative to any node in the cache. Reading the documentation on each API call that makes use of <code class="literal">Fqn</code> will tell you whether the API expects a relative or absolute <code class="literal">Fqn</code>.
		</div><div class="para">
			The <code class="literal">Fqn</code> class provides are variety of factory methods; see the Javadoc for all the possibilities. The following illustrates the most commonly used approaches to creating an Fqn:
		</div><pre class="programlisting JAVA JAVA">
   // Create an Fqn pointing to node 'Joe' under parent node 'Smith'
   // under the 'people' section of the tree
	    
   // Parse it from a String
   Fqn abc = Fqn.fromString("/people/Smith/Joe/");
	    
   // Here we want to use types other than String
   Fqn acctFqn = Fqn.fromElements("accounts", "NY", new Integer(12345));
</pre><div class="para">
			Note that
		</div><pre class="programlisting JAVA JAVA">Fqn f = Fqn.fromElements("a", "b", "c");</pre><div class="para">
			is the same as
		</div><pre class="programlisting JAVA JAVA">Fqn f = Fqn.fromString("/a/b/c");</pre></div><div class="section" id="idm140119305256688"><div class="titlepage"><div><div><h2 class="title">2.5. Stopping and Destroying the Cache</h2></div></div></div><div class="para">
			It is good practice to stop and destroy your cache when you are done using it, particularly if it is a clustered cache and has thus used a JGroups channel. Stopping and destroying a cache ensures resources like network sockets and maintenance threads are properly cleaned up.
		</div><pre class="programlisting JAVA JAVA">
   cache.stop();
   cache.destroy();
</pre><div class="para">
			Not also that a cache that has had <code class="literal">stop()</code> invoked on it can be started again with a new call to <code class="literal">start()</code> . Similarly, a cache that has had <code class="literal">destroy()</code> invoked on it can be created again with a new call to <code class="literal">create()</code> (and then started again with a <code class="literal">start()</code> call).
		</div></div><div class="section" id="idm140119323245920"><div class="titlepage"><div><div><h2 class="title">2.6. Cache Modes</h2></div></div></div><div class="para">
			Although technically not part of the API, the <span class="emphasis"><em>mode</em></span> in which the cache is configured to operate affects the cluster-wide behavior of any <code class="literal">put</code> or <code class="literal">remove</code> operation, so we'll briefly mention the various modes here.
		</div><div class="para">
			JBoss Cache modes are denoted by the <code class="literal">org.jboss.cache.config.Configuration.CacheMode</code> enumeration. They consist of: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="emphasis"><em>LOCAL</em></span> - local, non-clustered cache. Local caches don't join a cluster and don't communicate with other caches in a cluster.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>REPL_SYNC</em></span> - synchronous replication. Replicated caches replicate all changes to the other caches in the cluster. Synchronous replication means that changes are replicated and the caller blocks until replication acknowledgements are received.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>REPL_ASYNC</em></span> - asynchronous replication. Similar to REPL_SYNC above, replicated caches replicate all changes to the other caches in the cluster. Being asynchronous, the caller does not block until replication acknowledgements are received.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>INVALIDATION_SYNC</em></span> - if a cache is configured for invalidation rather than replication, every time data is changed in a cache other caches in the cluster receive a message informing them that their data is now stale and should be evicted from memory. This reduces replication overhead while still being able to invalidate stale data on remote caches.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>INVALIDATION_ASYNC</em></span> - as above, except this invalidation mode causes invalidation messages to be broadcast asynchronously.
					</div></li></ul></div>

		</div><div class="para">
			See the <a class="xref" href="#clustering">Chapter 8, <em>Cache Modes and Clustering</em></a> for more details on how cache mode affects behavior. See the <a class="xref" href="#configuration">Chapter 3, <em>Configuration</em></a> for info on how to configure things like cache mode.
		</div></div><div class="section" id="api.listener"><div class="titlepage"><div><div><h2 class="title">2.7.  Adding a Cache Listener - registering for cache events </h2></div></div></div><div class="para">
			JBoss Cache provides a convenient mechanism for registering notifications on cache events.
		</div><pre class="programlisting JAVA JAVA">
   Object myListener = new MyCacheListener();
   cache.addCacheListener(myListener);
</pre><div class="para">
			Similar methods exist for removing or querying registered listeners. See the Javadocs on the <code class="literal">Cache</code> interface for more details.
		</div><div class="para">
			Basically any public class can be used as a listener, provided it is annotated with the <code class="literal">@CacheListener</code> annotation. In addition, the class needs to have one or more methods annotated with one of the method-level annotations (in the <code class="literal">org.jboss.cache.notifications.annotation</code> package). Methods annotated as such need to be public, have a void return type, and accept a single parameter of type <code class="literal">org.jboss.cache.notifications.event.Event</code> or one of its subtypes. 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">@CacheStarted</code> - methods annotated such receive a notification when the cache is started. Methods need to accept a parameter type which is assignable from <code class="literal">CacheStartedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@CacheStopped</code> - methods annotated such receive a notification when the cache is stopped. Methods need to accept a parameter type which is assignable from <code class="literal">CacheStoppedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeCreated</code> - methods annotated such receive a notification when a node is created. Methods need to accept a parameter type which is assignable from <code class="literal">NodeCreatedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeRemoved</code> - methods annotated such receive a notification when a node is removed. Methods need to accept a parameter type which is assignable from <code class="literal">NodeRemovedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeModified</code> - methods annotated such receive a notification when a node is modified. Methods need to accept a parameter type which is assignable from <code class="literal">NodeModifiedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeMoved</code> - methods annotated such receive a notification when a node is moved. Methods need to accept a parameter type which is assignable from <code class="literal">NodeMovedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeVisited</code> - methods annotated such receive a notification when a node is started. Methods need to accept a parameter type which is assignable from <code class="literal">NodeVisitedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeLoaded</code> - methods annotated such receive a notification when a node is loaded from a <code class="literal">CacheLoader</code> . Methods need to accept a parameter type which is assignable from <code class="literal">NodeLoadedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeEvicted</code> - methods annotated such receive a notification when a node is evicted from memory. Methods need to accept a parameter type which is assignable from <code class="literal">NodeEvictedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeInvalidated</code> - methods annotated such receive a notification when a node is evicted from memory due to a remote invalidation event. Methods need to accept a parameter type which is assignable from <code class="literal">NodeInvalidatedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodeActivated</code> - methods annotated such receive a notification when a node is activated. Methods need to accept a parameter type which is assignable from <code class="literal">NodeActivatedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@NodePassivated</code> - methods annotated such receive a notification when a node is passivated. Methods need to accept a parameter type which is assignable from <code class="literal">NodePassivatedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@TransactionRegistered</code> - methods annotated such receive a notification when the cache registers a <code class="literal">javax.transaction.Synchronization</code> with a registered transaction manager. Methods need to accept a parameter type which is assignable from <code class="literal">TransactionRegisteredEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@TransactionCompleted</code> - methods annotated such receive a notification when the cache receives a commit or rollback call from a registered transaction manager. Methods need to accept a parameter type which is assignable from <code class="literal">TransactionCompletedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@ViewChanged</code> - methods annotated such receive a notification when the group structure of the cluster changes. Methods need to accept a parameter type which is assignable from <code class="literal">ViewChangedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@CacheBlocked</code> - methods annotated such receive a notification when the cluster requests that cache operations are blocked for a state transfer event. Methods need to accept a parameter type which is assignable from <code class="literal">CacheBlockedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@CacheUnblocked</code> - methods annotated such receive a notification when the cluster requests that cache operations are unblocked after a state transfer event. Methods need to accept a parameter type which is assignable from <code class="literal">CacheUnblockedEvent</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">@BuddyGroupChanged</code> - methods annotated such receive a notification when a node changes its buddy group, perhaps due to a buddy falling out of the cluster or a newer, closer buddy joining. Methods need to accept a parameter type which is assignable from <code class="literal">BuddyGroupChangedEvent</code>.
					</div></li></ul></div>

		</div><div class="para">
			Refer to the Javadocs on the annotations as well as the <code class="literal">Event</code> subtypes for details of what is passed in to your method, and when.
		</div><div class="para">
			Example:
		</div><pre class="programlisting JAVA JAVA">
   @CacheListener
   public class MyListener
   {

      @CacheStarted
      @CacheStopped
      public void cacheStartStopEvent(Event e)
      {
         switch (e.getType())
         {
            case CACHE_STARTED:
               System.out.println("Cache has started");
               break;
            case CACHE_STOPPED:
               System.out.println("Cache has stopped");
               break;
         }
      }

      @NodeCreated
      @NodeRemoved
      @NodeVisited
      @NodeModified
      @NodeMoved
      public void logNodeEvent(NodeEvent ne)
      {
         log("An event on node " + ne.getFqn() + " has occured");
      }
   }
</pre><div class="section" id="idm140119302752096"><div class="titlepage"><div><div><h3 class="title">2.7.1. Synchronous and Asynchronous Notifications</h3></div></div></div><div class="para">
				By default, all notifications are synchronous, in that they happen on the thread of the caller which generated the event. As such, it is good practise to ensure cache listener implementations don't hold up the thread in long-running tasks. Alternatively, you could set the <code class="literal">CacheListener.sync</code> attribute to <code class="literal">false</code>, in which case you will not be notified in the caller's thread. See the <a class="xref" href="#element.listeners">Table 12.13, “The <code class="literal">&lt;listeners /&gt;</code> Element”</a> on tuning this thread pool and size of blocking queue.
			</div></div></div><div class="section" id="idm140119302748784"><div class="titlepage"><div><div><h2 class="title">2.8. Using Cache Loaders</h2></div></div></div><div class="para">
			Cache loaders are an important part of JBoss Cache. They allow persistence of nodes to disk or to remote cache clusters, and allow for passivation when caches run out of memory. In addition, cache loaders allow JBoss Cache to perform 'warm starts', where in-memory state can be preloaded from persistent storage. JBoss Cache ships with a number of cache loader implementations. 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.FileCacheLoader</code> - a basic, filesystem based cache loader that persists data to disk. Non-transactional and not very performant, but a very simple solution. Used mainly for testing and not recommended for production use.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.JDBCCacheLoader</code> - uses a JDBC connection to store data. Connections could be created and maintained in an internal pool (uses the c3p0 pooling library) or from a configured DataSource. The database this CacheLoader connects to could be local or remotely located.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.BdbjeCacheLoader</code> - uses Oracle's BerkeleyDB file-based transactional database to persist data. Transactional and very performant, but potentially restrictive license.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.JdbmCacheLoader</code> - an open source alternative to the BerkeleyDB.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.tcp.TcpCacheLoader</code> - uses a TCP socket to "persist" data to a remote cluster, using <a href="http://www.jboss.org/community/docs/DOC-10292" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">a "far cache" pattern</a>.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.loader.ClusteredCacheLoader</code> - used as a "read-only" cache loader, where other nodes in the cluster are queried for state. Useful when full state transfer is too expensive and it is preferred that state is lazily loaded.
					</div></li></ul></div>
			 These cache loaders, along with advanced aspects and tuning issues, are discussed in the <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a>.
		</div></div><div class="section" id="idm140119302736160"><div class="titlepage"><div><div><h2 class="title">2.9. Using Eviction Policies</h2></div></div></div><div class="para">
			Eviction policies are the counterpart to cache loaders. They are necessary to make sure the cache does not run out of memory and when the cache starts to fill, an eviction algorithm running in a separate thread evicts in-memory state and frees up memory. If configured with a cache loader, the state can then be retrieved from the cache loader if needed.
		</div><div class="para">
			Eviction policies can be configured on a per-region basis, so different subtrees in the cache could have different eviction preferences. JBoss Cache ships with several eviction policies: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.LRUPolicy</code> - an eviction policy that evicts the least recently used nodes when thresholds are hit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.LFUPolicy</code> - an eviction policy that evicts the least frequently used nodes when thresholds are hit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.MRUPolicy</code> - an eviction policy that evicts the most recently used nodes when thresholds are hit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.FIFOPolicy</code> - an eviction policy that creates a first-in-first-out queue and evicts the oldest nodes when thresholds are hit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.ExpirationPolicy</code> - an eviction policy that selects nodes for eviction based on an expiry time each node is configured with.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">org.jboss.cache.eviction.ElementSizePolicy</code> - an eviction policy that selects nodes for eviction based on the number of key/value pairs held in the node.
					</div></li></ul></div>
			 Detailed configuration and implementing custom eviction policies are discussed in the <a class="xref" href="#eviction_policies">Chapter 10, <em>Eviction</em></a>.
		</div></div></div><div xml:lang="en-US" class="chapter" id="configuration" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 3. Configuration</h2></div></div></div><div class="section" id="idm140119300066176"><div class="titlepage"><div><div><h2 class="title">3.1. Configuration Overview</h2></div></div></div><div class="para">
			The <code class="literal">org.jboss.cache.config.Configuration</code> class (along with its <a class="xref" href="#configuration.elements">Section 3.3, “Composition of a <code class="literal">Configuration</code> Object ”</a>) is a Java Bean that encapsulates the configuration of the <code class="literal">Cache</code> and all of its architectural elements (cache loaders, evictions policies, etc.)
		</div><div class="para">
			The <code class="literal">Configuration</code> exposes numerous properties which are summarized in the <a class="xref" href="#configuration_reference">Section 12.2, “Configuration File Quick Reference”</a> section of this book and many of which are discussed in later chapters. Any time you see a configuration option discussed in this book, you can assume that the <code class="literal">Configuration</code> class or one of its component parts exposes a simple property setter/getter for that configuration option.
		</div></div><div class="section" id="configuration.creation"><div class="titlepage"><div><div><h2 class="title">3.2. Creating a <code class="literal">Configuration</code> </h2></div></div></div><div class="para">
			As discussed in the <a class="xref" href="#api.create_start">Section 2.2, “Instantiating and Starting the Cache”</a>, before a <code class="literal">Cache</code> can be created, the <code class="literal">CacheFactory</code> must be provided with a <code class="literal">Configuration</code> object or with a file name or input stream to use to parse a <code class="literal">Configuration</code> from XML. The following sections describe how to accomplish this.
		</div><div class="section" id="idm140119305705488"><div class="titlepage"><div><div><h3 class="title">3.2.1. Parsing an XML-based Configuration File</h3></div></div></div><div class="para">
				The most convenient way to configure JBoss Cache is via an XML file. The JBoss Cache distribution ships with a number of configuration files for common use cases. It is recommended that these files be used as a starting point, and tweaked to meet specific needs.
			</div><div class="para">
				The simplest example of a configuration XML file, a cache configured to run in LOCAL mode, looks like this:
			</div><pre class="programlisting XML XML">

&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;
&lt;/jbosscache&gt;


</pre><div class="para">
				This file uses sensible defaults for isolation levels, lock acquisition timeouts, locking modes, etc. Another, more complete, sample XML file is included in the <a class="xref" href="#sample_xml_file">Section 12.1, “Sample XML Configuration File”</a> section of this book, along with <a class="xref" href="#configuration_reference">Section 12.2, “Configuration File Quick Reference”</a> explaining the various options.
			</div></div><div class="section" id="configuration.validation"><div class="titlepage"><div><div><h3 class="title">3.2.2. Validating Configuration Files</h3></div></div></div><div class="para">
				By default JBoss Cache will validate your XML configuration file against an XML schema and throw an exception if the configuration is invalid. This can be overridden with the <code class="literal">-Djbosscache.config.validate=false</code> JVM parameter. Alternately, you could specify your own schema to validate against, using the <code class="literal">-Djbosscache.config.schemaLocation=url</code> parameter.
			</div><div class="para">
				By default though, configuration files are validated against the JBoss Cache configuration schema, which is included in the <code class="literal">jbosscache-core.jar</code> or on <code class="literal">http://www.jboss.org/jbosscache/jbosscache-config-3.0.xsd</code>. Most XML editing tools can be used with this schema to ensure the configuration file you create is correct and valid.
			</div></div><div class="section" id="idm140119307140880"><div class="titlepage"><div><div><h3 class="title">3.2.3. Programmatic Configuration</h3></div></div></div><div class="para">
				In addition to the XML-based configuration above, the <code class="literal">Configuration</code> can be built up programatically, using the simple property mutators exposed by <code class="literal">Configuration</code> and its components. When constructed, the <code class="literal">Configuration</code> object is preset with JBoss Cache defaults and can even be used as-is for a quick start.
			</div><pre class="programlisting JAVA JAVA">
Configuration config = new Configuration();
config.setTransactionManagerLookupClass( 
  GenericTransactionManagerLookup.class.getName() 
  );
config.setIsolationLevel(IsolationLevel.READ_COMMITTED);
config.setCacheMode(CacheMode.LOCAL);
config.setLockAcquisitionTimeout(15000);

CacheFactory factory = new DefaultCacheFactory();
Cache cache = factory.createCache(config);
</pre><div class="para">
				Even the above fairly simple configuration is pretty tedious programming; hence the preferred use of XML-based configuration. However, if your application requires it, there is no reason not to use XML-based configuration for most of the attributes, and then access the <code class="literal">Configuration</code> object to programatically change a few items from the defaults, add an eviction region, etc.
			</div><div class="para">
				Note that configuration values may not be changed programmatically when a cache is running, except those annotated as <code class="literal">@Dynamic</code> . Dynamic properties are also marked as such in the <a class="xref" href="#configuration_reference">Section 12.2, “Configuration File Quick Reference”</a> table. Attempting to change a non-dynamic property will result in a <code class="literal">ConfigurationException</code> .
			</div></div><div class="section" id="idm140119322718960"><div class="titlepage"><div><div><h3 class="title">3.2.4. Using an IOC Framework</h3></div></div></div><div class="para">
				The <code class="literal">Configuration</code> class and its <a class="xref" href="#configuration.elements">Section 3.3, “Composition of a <code class="literal">Configuration</code> Object ”</a> are all Java Beans that expose all configuration elements via simple setters and getters. Therefore, any good IOC framework such as JBoss Microcontainer should be able to build up a <code class="literal">Configuration</code> from an XML file in the framework's own format. See the <a class="xref" href="#deployment.microcontainer">Section 5.2, “Via JBoss Microcontainer (JBoss AS 5.x)”</a> section for an example of this.
			</div></div></div><div class="section" id="configuration.elements"><div class="titlepage"><div><div><h2 class="title">3.3. Composition of a <code class="literal">Configuration</code> Object </h2></div></div></div><div class="para">
			A <code class="literal">Configuration</code> is composed of a number of subobjects: 
			<div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/73fa885d7f456673478d4e6ce1b02b08/Configuration.png" width="444" /></div>

		</div><div class="para">
			Following is a brief overview of the components of a <code class="literal">Configuration</code> . See the Javadoc and the linked chapters in this book for a more complete explanation of the configurations associated with each component. 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">Configuration</code> : top level object in the hierarchy; exposes the configuration properties listed in the <a class="xref" href="#configuration_reference">Section 12.2, “Configuration File Quick Reference”</a> section of this book.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">BuddyReplicationConfig</code> : only relevant if <a class="xref" href="#br">Section 8.1.2.2, “Buddy Replication”</a> is used. General buddy replication configuration options. Must include a:
					</div></li><li class="listitem"><div class="para">
						<code class="literal">BuddyLocatorConfig</code> : implementation-specific configuration object for the <code class="literal">BuddyLocator</code> implementation being used. What configuration elements are exposed depends on the needs of the <code class="literal">BuddyLocator</code> implementation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">EvictionConfig</code> : only relevant if <a class="xref" href="#eviction_policies">Chapter 10, <em>Eviction</em></a> is used. General eviction configuration options. Must include at least one:
					</div></li><li class="listitem"><div class="para">
						<code class="literal">EvictionRegionConfig</code> : one for each eviction region; names the region, etc. Must include a:
					</div></li><li class="listitem"><div class="para">
						<code class="literal">EvictionAlgorithmConfig</code> : implementation-specific configuration object for the <code class="literal">EvictionAlgorithm</code> implementation being used. What configuration elements are exposed depends on the needs of the <code class="literal">EvictionAlgorithm</code> implementation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">CacheLoaderConfig</code> : only relevant if a <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a> is used. General cache loader configuration options. Must include at least one:
					</div></li><li class="listitem"><div class="para">
						<code class="literal">IndividualCacheLoaderConfig</code> : implementation-specific configuration object for the <code class="literal">CacheLoader</code> implementation being used. What configuration elements are exposed depends on the needs of the <code class="literal">CacheLoader</code> implementation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">RuntimeConfig</code> : exposes to cache clients certain information about the cache's runtime environment (e.g. membership in buddy replication groups if <a class="xref" href="#br">Section 8.1.2.2, “Buddy Replication”</a> is used.) Also allows direct injection into the cache of needed external services like a JTA <code class="literal">TransactionManager</code> or a JGroups <code class="literal">ChannelFactory</code> .
					</div></li></ul></div>

		</div></div><div class="section" id="idm140119300658992"><div class="titlepage"><div><div><h2 class="title">3.4. Dynamic Reconfiguration</h2></div></div></div><div class="para">
			Dynamically changing the configuration of <span class="emphasis"><em>some</em></span> options while the cache is running is supported, by programmatically obtaining the <code class="literal">Configuration</code> object from the running cache and changing values. E.g.,
		</div><pre class="programlisting JAVA JAVA">
   Configuration liveConfig = cache.getConfiguration();
   liveConfig.setLockAcquisitionTimeout(2000);
</pre><div class="para">
			A complete listing of which options may be changed dynamically is in the <a class="xref" href="#configuration_reference">Section 12.2, “Configuration File Quick Reference”</a> section. An <code class="literal">org.jboss.cache.config.ConfigurationException</code> will be thrown if you attempt to change a setting that is not dynamic.
		</div><div class="section" id="configuration.options"><div class="titlepage"><div><div><h3 class="title">3.4.1. Overriding the Configuration via the Option API</h3></div></div></div><div class="para">
				The Option API allows you to override certain behaviors of the cache on a per invocation basis. This involves creating an instance of <code class="literal">org.jboss.cache.config.Option</code> , setting the options you wish to override on the <code class="literal">Option</code> object and passing it in the <code class="literal">InvocationContext</code> before invoking your method on the cache.
			</div><div class="para">
				E.g., to force a write lock when reading data (when used in a transaction, this provides semantics similar to SELECT FOR UPDATE in a database)
			</div><pre class="programlisting JAVA JAVA">
      // first start a transaction
      cache.getInvocationContext().getOptionOverrides().setForceWriteLock(true);
      Node n = cache.getNode(Fqn.fromString("/a/b/c"));
      // make changes to the node
      // commit transaction
</pre><div class="para">
				E.g., to suppress replication of a put call in a REPL_SYNC cache:
			</div><pre class="programlisting JAVA JAVA">
      Node node = cache.getChild(Fqn.fromString("/a/b/c"));
      cache.getInvocationContext().getOptionOverrides().setLocalOnly(true);
      node.put("localCounter", new Integer(2));
</pre><div class="para">
				See the Javadocs on the <code class="literal">Option</code> class for details on the options available.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="batching" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 4. Batching API</h2></div></div></div><div class="section" id="batching.intro"><div class="titlepage"><div><div><h2 class="title">4.1. Introduction</h2></div></div></div><div class="para">
			The batching API, introduced in JBoss Cache 3.x, is intended as a mechanism to batch the way calls are replicated independent of JTA transactions.
		</div><div class="para">
			This is useful when you want to batch up replication calls within a scope finer than that of any ongoing JTA transactions.
		</div></div><div class="section" id="batching.configuring"><div class="titlepage"><div><div><h2 class="title">4.2. Configuring batching</h2></div></div></div><div class="para">
			To use batching, you need to enable invocation batching in your cache configuration, either on the <code class="literal">Configuration</code> object:
		</div><pre class="programlisting JAVA JAVA">
   Configuration.setInvocationBatchingEnabled(true);
</pre><div class="para">
			or in your XML file:
		</div><pre class="programlisting XML XML">
   &lt;invocationBatching enabled="true"/&gt;
</pre><div class="para">
			By default, invocation batching is disabled. Note that you do <span class="emphasis"><em>not</em></span> have to have a transaction manager defined to use batching.
		</div></div><div class="section" id="batching.api"><div class="titlepage"><div><div><h2 class="title">4.3. Batching API</h2></div></div></div><div class="para">
			Once you have configured your cache to use batching, you use it by calling <code class="literal">startBatch()</code> and <code class="literal">endBatch()</code> on <code class="literal">Cache</code>. E.g.,
		</div><pre class="programlisting JAVA JAVA">
   Cache cache = getCache();

   // not using a batch
   cache.put("/a", "key", "value"); // will replicate immediately

   // using a batch
   cache.startBatch();
   cache.put("/a", "key", "value");
   cache.put("/b", "key", "value");
   cache.put("/c", "key", "value");
   cache.endBatch(true); // This will now replicate the modifications since the batch was started.

   cache.startBatch();
   cache.put("/a", "key", "value");
   cache.put("/b", "key", "value");
   cache.put("/c", "key", "value");
   cache.endBatch(false); // This will "discard" changes made in the batch

</pre></div></div><div xml:lang="en-US" class="chapter" id="deployment" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 5. Deploying JBoss Cache</h2></div></div></div><div class="section" id="deployment.standalone"><div class="titlepage"><div><div><h2 class="title">5.1. Standalone Use/Programatic Deployment</h2></div></div></div><div class="para">
			When used in a standalone Java program, all that needs to be done is to instantiate the cache using the <code class="literal">CacheFactory</code> and a <code class="literal">Configuration</code> instance or an XML file, as discussed in the <a class="xref" href="#api.create_start">Section 2.2, “Instantiating and Starting the Cache”</a> and <a class="xref" href="#configuration.creation">Section 3.2, “Creating a <code class="literal">Configuration</code> ”</a> chapters.
		</div><div class="para">
			The same techniques can be used when an application running in an application server wishes to programatically deploy a cache rather than relying on an application server's deployment features. An example of this would be a webapp deploying a cache via a <code class="literal">javax.servlet.ServletContextListener</code>.
		</div><div class="para">
			After creation, you could share your cache instance among different application components either by using an IOC container such as JBoss Microcontainer, or by binding it to JNDI, or simply holding a static reference to the cache.
		</div><div class="para">
			If, after deploying your cache you wish to expose a management interface to it in JMX, see <a class="xref" href="#jmx.registration">Section 5.4.2, “Registering the CacheJmxWrapper with the MBeanServer”</a>.
		</div></div><div class="section" id="deployment.microcontainer"><div class="titlepage"><div><div><h2 class="title">5.2. Via JBoss Microcontainer (JBoss AS 5.x)</h2></div></div></div><div class="para">
			Beginning with AS 5, JBoss AS supports deployment of POJO services via deployment of a file whose name ends with <code class="literal">-jboss-beans.xml</code>. A POJO service is one whose implementation is via a "Plain Old Java Object", meaning a simple java bean that isn't required to implement any special interfaces or extend any particular superclass. A <code class="literal">Cache</code> is a POJO service, and all the components in a <code class="literal">Configuration</code> are also POJOs, so deploying a cache in this way is a natural step.
		</div><div class="para">
			Deployment of the cache is done using the JBoss Microcontainer that forms the core of JBoss AS. JBoss Microcontainer is a sophisticated IOC framework similar to Spring. A <code class="literal">-jboss-beans.xml</code> file is basically a descriptor that tells the IOC framework how to assemble the various beans that make up a POJO service.
		</div><div class="para">
			For each configurable option exposed by the <code class="literal">Configuration</code> components, a getter/setter must be defined in the configuration class. This is required so that JBoss Microcontainer can, in typical IOC way, call these methods when the corresponding properties have been configured.
		</div><div class="para">
			You need to ensure that the <code class="literal">jbosscache-core.jar</code> and <code class="literal">jgroups.jar</code> libraries are in your server's <code class="literal">lib</code> directory. This is usually the case when you use JBoss AS in its <code class="literal">all</code> configuration. Note that you will have to bring in any optional jars you require, such as <code class="literal">jdbm.jar</code> based on your cache configuration.
		</div><div class="para">
			The following is an example <code class="literal">-beans.xml</code> file. If you look in the <code class="literal">server/all/deploy</code> directory of a JBoss AS 5 installation, you can find several more examples.
		</div><pre class="programlisting XML XML">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- First we create a Configuration object for the cache --&gt;
   &lt;bean name="ExampleCacheConfig"
   		 class="org.jboss.cache.config.Configuration"&gt;
      
      &lt;!-- Externally injected services --&gt;  
      &lt;property name="runtimeConfig"&gt;
         &lt;bean class="org.jboss.cache.config.RuntimeConfig"&gt;
            &lt;property name="transactionManager"&gt;
               &lt;inject bean="jboss:service=TransactionManager" 
                       property="TransactionManager"/&gt;
            &lt;/property&gt;
            &lt;property name="muxChannelFactory"&gt;&lt;inject bean="JChannelFactory"/&gt;&lt;/property&gt;
         &lt;/bean&gt;
      &lt;/property&gt;
      
      &lt;property name="multiplexerStack"&gt;udp&lt;/property&gt;

      &lt;property name="clusterName"&gt;Example-EntityCache&lt;/property&gt;
        
      &lt;property name="isolationLevel"&gt;REPEATABLE_READ&lt;/property&gt;

      &lt;property name="cacheMode"&gt;REPL_SYNC&lt;/property&gt;

      &lt;property name="stateRetrievalTimeout"&gt;15000&lt;/property&gt;

      &lt;property name="syncReplTimeout"&gt;20000&lt;/property&gt;

      &lt;property name="lockAcquisitionTimeout"&gt;15000&lt;/property&gt;
        
      &lt;property name="exposeManagementStatistics"&gt;true&lt;/property&gt;
   &lt;/bean&gt;
   
   &lt;!-- Factory to build the Cache. --&gt;
   &lt;bean name="DefaultCacheFactory" class="org.jboss.cache.DefaultCacheFactory"&gt;      
      &lt;constructor factoryClass="org.jboss.cache.DefaultCacheFactory"
                   factoryMethod="getInstance" /&gt;
   &lt;/bean&gt;
   
   &lt;!-- The cache itself --&gt;
   &lt;bean name="ExampleCache" class="org.jboss.cache.Cache"&gt;
      
      &lt;constructor factoryMethod="createCache"&gt;
          &lt;factory bean="DefaultCacheFactory"/&gt;
          &lt;parameter class="org.jboss.cache.config.Configuration"&gt;&lt;inject bean="ExampleCacheConfig"/&gt;&lt;/parameter&gt;
          &lt;parameter class="boolean"&gt;false&lt;/parameter&gt;
      &lt;/constructor&gt;
          
   &lt;/bean&gt;

&lt;/deployment&gt;
</pre><div class="para">
			See <a href="http://www.jboss.org/jbossmc" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">the JBoss Microcontainer documentation</a> for details on the above syntax. Basically, each <code class="literal">bean</code> element represents an object and is used to create a <code class="literal">Configuration</code> and its <a class="xref" href="#configuration.elements">Section 3.3, “Composition of a <code class="literal">Configuration</code> Object ”</a> The <code class="literal">DefaultCacheFactory</code> bean constructs the cache, conceptually doing the same thing as is shown in the <a class="xref" href="#api.create_start">Section 2.2, “Instantiating and Starting the Cache”</a> chapter.
		</div><div class="para">
			An interesting thing to note in the above example is the use of the <code class="literal">RuntimeConfig</code> object. External resources like a <code class="literal">TransactionManager</code> and a JGroups <code class="literal">ChannelFactory</code> that are visible to the microcontainer are dependency injected into the <code class="literal">RuntimeConfig</code>. The assumption here is that in some other deployment descriptor in the AS, the referenced beans have already been described.
		</div></div><div class="section" id="idm140119300644512"><div class="titlepage"><div><div><h2 class="title">5.3. Automatic binding to JNDI in JBoss AS</h2></div></div></div><div class="para">
			This feature is not available as of the time of this writing. We will add a wiki page describing how to use it once it becomes available.
		</div></div><div class="section" id="idm140119308294736"><div class="titlepage"><div><div><h2 class="title">5.4. Runtime Management Information</h2></div></div></div><div class="para">
			JBoss Cache includes JMX MBeans to expose cache functionality and provide statistics that can be used to analyze cache operations. JBoss Cache can also broadcast cache events as MBean notifications for handling via JMX monitoring tools.
		</div><div class="section" id="jmx.mbeans"><div class="titlepage"><div><div><h3 class="title">5.4.1. JBoss Cache MBeans</h3></div></div></div><div class="para">
				JBoss Cache provides an MBean that can be registered with your environments JMX server to allow access to the cache instance via JMX. This MBean is the <code class="literal">org.jboss.cache.jmx.CacheJmxWrapper</code>. It is a StandardMBean, so its MBean interface is <code class="literal">org.jboss.cache.jmx.CacheJmxWrapperMBean</code>. This MBean can be used to: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Get a reference to the underlying <code class="literal">Cache</code>.
						</div></li><li class="listitem"><div class="para">
							Invoke create/start/stop/destroy lifecycle operations on the underlying <code class="literal">Cache</code>.
						</div></li><li class="listitem"><div class="para">
							Inspect various details about the cache's current state (number of nodes, lock information, etc.)
						</div></li><li class="listitem"><div class="para">
							See numerous details about the cache's configuration, and change those configuration items that can be changed when the cache has already been started.
						</div></li></ul></div>
				 See the <code class="literal">CacheJmxWrapperMBean</code> Javadoc for more details.
			</div><div class="para">
				If a <code class="literal">CacheJmxWrapper</code> is registered, JBoss Cache also provides MBeans for several other internal components and subsystems. These MBeans are used to capture and expose statistics related to the subsystems they represent. They are hierarchically associated with the <code class="literal">CacheJmxWrapper</code> MBean and have service names that reflect this relationship. For example, a replication interceptor MBean for the <code class="literal">jboss.cache:service=TomcatClusteringCache</code> instance will be accessible through the service named <code class="literal">jboss.cache:service=TomcatClusteringCache,cache-interceptor=ReplicationInterceptor</code>.
			</div></div><div class="section" id="jmx.registration"><div class="titlepage"><div><div><h3 class="title">5.4.2. Registering the CacheJmxWrapper with the MBeanServer</h3></div></div></div><div class="para">
				The best way to ensure the <code class="literal">CacheJmxWrapper</code> is registered in JMX depends on how you are deploying your cache.
			</div><div class="section" id="jmx.registration.programatic.construct"><div class="titlepage"><div><div><h4 class="title">5.4.2.1. Programatic Registration with a Cache instance</h4></div></div></div><div class="para">
					Simplest way to do this is to create your <code class="literal">Cache</code> and pass it to the <code class="literal">JmxRegistrationManager</code> constructor.
				</div><pre class="programlisting JAVA JAVA">
   CacheFactory factory = new DefaultCacheFactory();
   // Build but don't start the cache
   // (although it would work OK if we started it)
   Cache cache = factory.createCache("cache-configuration.xml");

   MBeanServer server = getMBeanServer(); // however you do it
   ObjectName on = new ObjectName("jboss.cache:service=Cache");
   
   JmxRegistrationManager jmxManager = new JmxRegistrationManager(server, cache, on);
   jmxManager.registerAllMBeans();

   ... use the cache

   ... on application shutdown

   jmxManager.unregisterAllMBeans();
   cache.stop();

</pre></div><div class="section" id="jmx.registration.programatic.cfg"><div class="titlepage"><div><div><h4 class="title">5.4.2.2. Programatic Registration with a Configuration instance</h4></div></div></div><div class="para">
					Alternatively, build a <code class="literal">Configuration</code> object and pass it to the <code class="literal">CacheJmxWrapper</code>. The wrapper will construct the <code class="literal">Cache</code> on your behalf.
				</div><pre class="programlisting JAVA JAVA">
   Configuration config = buildConfiguration(); // whatever it does

   CacheJmxWrapperMBean wrapper = new CacheJmxWrapper(config);
   MBeanServer server = getMBeanServer(); // however you do it
   ObjectName on = new ObjectName("jboss.cache:service=TreeCache");
   server.registerMBean(wrapper, on);

   // Call to wrapper.create() will build the Cache if one wasn't injected
   wrapper.create();
   wrapper.start();

   // Now that it's built, created and started, get the cache from the wrapper
   Cache cache = wrapper.getCache();

   ... use the cache

   ... on application shutdown

   wrapper.stop();
   wrapper.destroy();
</pre></div><div class="section" id="idm140119307710624"><div class="titlepage"><div><div><h4 class="title">5.4.2.3. JMX-Based Deployment in JBoss AS (JBoss AS 5.x)</h4></div></div></div><div class="para">
					<code class="literal">CacheJmxWrapper</code> is a POJO, so the microcontainer has no problem creating one. The trick is getting it to register your bean in JMX. This can be done by specifying the <code class="literal">org.jboss.aop.microcontainer.aspects.jmx.JMX</code> annotation on the <code class="literal">CacheJmxWrapper</code> bean:
				</div><pre class="programlisting XML XML">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- First we create a Configuration object for the cache --&gt;
   &lt;bean name="ExampleCacheConfig"
   		 class="org.jboss.cache.config.Configuration"&gt;
      
      ... build up the Configuration
      
   &lt;/bean&gt;
   
   &lt;!-- Factory to build the Cache. --&gt;
   &lt;bean name="DefaultCacheFactory" class="org.jboss.cache.DefaultCacheFactory"&gt;      
      &lt;constructor factoryClass="org.jboss.cache.DefaultCacheFactory"
                   factoryMethod="getInstance" /&gt;
   &lt;/bean&gt;
   
   &lt;!-- The cache itself --&gt;
   &lt;bean name="ExampleCache" class="org.jboss.cache.CacheImpl"&gt;
      
      &lt;constructor factoryMethod="createnewInstance"&gt;
          &lt;factory bean="DefaultCacheFactory"/&gt;
          &lt;parameter&gt;&lt;inject bean="ExampleCacheConfig"/&gt;&lt;/parameter&gt;
          &lt;parameter&gt;false&lt;/parameter&gt;
      &lt;/constructor&gt;
          
   &lt;/bean&gt;
   
   &lt;!-- JMX Management --&gt;
   &lt;bean name="ExampleCacheJmxWrapper" class="org.jboss.cache.jmx.CacheJmxWrapper"&gt;
      
      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX(name="jboss.cache:service=ExampleTreeCache", 
                         exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class, 
                         registerDirectly=true)&lt;/annotation&gt;
      
      &lt;constructor&gt;
          &lt;parameter&gt;&lt;inject bean="ExampleCache"/&gt;&lt;/parameter&gt;
      &lt;/constructor&gt;
          
   &lt;/bean&gt;

&lt;/deployment&gt;
</pre><div class="para">
					As discussed in the <a class="xref" href="#jmx.registration">Section 5.4.2, “Registering the CacheJmxWrapper with the MBeanServer”</a> section, <code class="literal">CacheJmxWrapper</code> can do the work of building, creating and starting the <code class="literal">Cache</code> if it is provided with a <code class="literal">Configuration</code>. With the microcontainer, this is the preferred approach, as it saves the boilerplate XML needed to create the <code class="literal">CacheFactory</code>.
				</div><pre class="programlisting XML XML">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- First we create a Configuration object for the cache --&gt;
   &lt;bean name="ExampleCacheConfig"
   		 class="org.jboss.cache.config.Configuration"&gt;
      
      ... build up the Configuration
      
   &lt;/bean&gt;
    
   &lt;bean name="ExampleCache" class="org.jboss.cache.jmx.CacheJmxWrapper"&gt;
      
      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
        (name="jboss.cache:service=ExampleTreeCache", 
        exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class, 
        registerDirectly=true)&lt;/annotation&gt;
      
      &lt;constructor&gt;
          &lt;parameter&gt;&lt;inject bean="ExampleCacheConfig"/&gt;&lt;/parameter&gt;
      &lt;/constructor&gt;
          
   &lt;/bean&gt;

&lt;/deployment&gt;
</pre></div></div><div class="section" id="jmx.statistics"><div class="titlepage"><div><div><h3 class="title">5.4.3. JBoss Cache Statistics</h3></div></div></div><div class="para">
				JBoss Cache captures statistics in its interceptors and various other components, and exposes these statistics through a set of MBeans. Gathering of statistics is enabled by default; this can be disabled for a specific cache instance through the <code class="literal">Configuration.setExposeManagementStatistics()</code> setter. Note that the majority of the statistics are provided by the <code class="literal">CacheMgmtInterceptor</code>, so this MBean is the most significant in this regard. If you want to disable all statistics for performance reasons, you set <code class="literal">Configuration.setExposeManagementStatistics(false)</code> and this will prevent the <code class="literal">CacheMgmtInterceptor</code> from being included in the cache's interceptor stack when the cache is started.
			</div><div class="para">
				If a <code class="literal">CacheJmxWrapper</code> is registered with JMX, the wrapper also ensures that an MBean is registered in JMX for each interceptor and component that exposes statistics. 
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Note that if the <code class="literal">CacheJmxWrapper</code> is not registered in JMX, the interceptor MBeans will not be registered either. The JBoss Cache 1.4 releases included code that would try to "discover" an <code class="literal">MBeanServer</code> and automatically register the interceptor MBeans with it. For JBoss Cache 2.x we decided that this sort of "discovery" of the JMX environment was beyond the proper scope of a caching library, so we removed this functionality.
					</div></div></div>
				 . Management tools can then access those MBeans to examine the statistics. See the section in the <a class="xref" href="#jmx_reference.statistics">Section 13.1, “JBoss Cache Statistics”</a> pertaining to the statistics that are made available via JMX.
			</div></div><div class="section" id="idm140119306255056"><div class="titlepage"><div><div><h3 class="title">5.4.4. Receiving JMX Notifications</h3></div></div></div><div class="para">
				JBoss Cache users can register a listener to receive cache events described earlier in the <a class="xref" href="#api.listener">Section 2.7, “ Adding a Cache Listener - registering for cache events ”</a> chapter. Users can alternatively utilize the cache's management information infrastructure to receive these events via JMX notifications. Cache events are accessible as notifications by registering a <code class="literal">NotificationListener</code> for the <code class="literal">CacheJmxWrapper</code>.
			</div><div class="para">
				See the section in the <a class="xref" href="#jmx_reference.notifications">Section 13.2, “JMX MBean Notifications”</a> pertaining to JMX notifications for a list of notifications that can be received through the <code class="literal">CacheJmxWrapper</code>.
			</div><div class="para">
				The following is an example of how to programmatically receive cache notifications when running in a JBoss AS environment. In this example, the client uses a filter to specify which events are of interest.
			</div><pre class="programlisting JAVA JAVA">
   MyListener listener = new MyListener();
   NotificationFilterSupport filter = null;

   // get reference to MBean server
   Context ic = new InitialContext();
   MBeanServerConnection server = (MBeanServerConnection)ic.lookup("jmx/invoker/RMIAdaptor");

   // get reference to CacheMgmtInterceptor MBean
   String cache_service = "jboss.cache:service=TomcatClusteringCache";
   ObjectName mgmt_name = new ObjectName(cache_service);

   // configure a filter to only receive node created and removed events
   filter = new NotificationFilterSupport();
   filter.disableAllTypes();
   filter.enableType(CacheNotificationBroadcaster.NOTIF_NODE_CREATED);
   filter.enableType(CacheNotificationBroadcaster.NOTIF_NODE_REMOVED);

   // register the listener with a filter
   // leave the filter null to receive all cache events
   server.addNotificationListener(mgmt_name, listener, filter, null);

   // ...

   // on completion of processing, unregister the listener
   server.removeNotificationListener(mgmt_name, listener, filter, null);
</pre><div class="para">
				The following is the simple notification listener implementation used in the previous example.
			</div><pre class="programlisting JAVA JAVA">
   private class MyListener implements NotificationListener, Serializable
   {
      public void handleNotification(Notification notification, Object handback)
      {
         String message = notification.getMessage();
         String type = notification.getType();
         Object userData = notification.getUserData();

         System.out.println(type + ": " + message);

         if (userData == null)
         {
            System.out.println("notification data is null");
         }
         else if (userData instanceof String)
         {
            System.out.println("notification data: " + (String) userData);
         }
         else if (userData instanceof Object[])
         {
            Object[] ud = (Object[]) userData;
            for (Object data : ud)
            {
               System.out.println("notification data: " + data.toString());
            }
         }
         else
         {
            System.out.println("notification data class: " + userData.getClass().getName());
         }
      }
   }
</pre><div class="para">
				Note that the JBoss Cache management implementation only listens to cache events after a client registers to receive MBean notifications. As soon as no clients are registered for notifications, the MBean will remove itself as a cache listener.
			</div></div><div class="section" id="jconsole"><div class="titlepage"><div><div><h3 class="title">5.4.5. Accessing Cache MBeans in a Standalone Environment using the <code class="literal">jconsole</code> Utility</h3></div></div></div><div class="para">
				JBoss Cache MBeans are easily accessed when running cache instances in an application server that provides an MBean server interface such as JBoss JMX Console. Refer to your server documentation for instructions on how to access MBeans running in a server's MBean container.
			</div><div class="para">
				In addition, though, JBoss Cache MBeans are also accessible when running in a non-server environment using your JDK's <code class="literal">jconsole</code> tool. When running a standalone cache outside of an application server, you can access the cache's MBeans as follows.
			</div><div class="para">
				<div class="orderedlist"><ol><li class="listitem"><div class="para">
							Set the system property <code class="literal">-Dcom.sun.management.jmxremote</code> when starting the JVM where the cache will run.
						</div></li><li class="listitem"><div class="para">
							Once the JVM is running, start the <code class="literal">jconsole</code> utility, located in your JDK's <code class="literal">/bin</code> directory.
						</div></li><li class="listitem"><div class="para">
							When the utility loads, you will be able to select your running JVM and connect to it. The JBoss Cache MBeans will be available on the MBeans panel.
						</div></li></ol></div>

			</div><div class="para">
				Note that the <code class="literal">jconsole</code> utility will automatically register as a listener for cache notifications when connected to a JVM running JBoss Cache instances.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="compatibility" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Version Compatibility and Interoperability</h2></div></div></div><div class="section" id="idm140119306934128"><div class="titlepage"><div><div><h2 class="title">6.1. API compatibility</h2></div></div></div><div class="para">
			Within a major version, releases of JBoss Cache are meant to be compatible and interoperable. Compatible in the sense that it should be possible to upgrade an application from one version to another by simply replacing jars. Interoperable in the sense that if two different versions of JBoss Cache are used in the same cluster, they should be able to exchange replication and state transfer messages. Note however that interoperability requires use of the same JGroups version in all nodes in the cluster. In most cases, the version of JGroups used by a version of JBoss Cache can be upgraded.
		</div><div class="para">
			As such, JBoss Cache 2.x.x is not API or binary compatible with prior 1.x.x versions. On the other hand, JBoss Cache 2.1.x will be API and binary compatible with 2.0.x.
		</div><div class="para">
			We have made best efforts, however, to keep JBoss Cache 3.x both binary and API compatible with 2.x. Still, it is recommended that client code is updated not to use deprecated methods, classes and configuration files.
		</div></div><div class="section" id="idm140119312954912"><div class="titlepage"><div><div><h2 class="title">6.2. Wire-level interoperability</h2></div></div></div><div class="para">
			A configuration parameter, <code class="literal">Configuration.setReplicationVersion()</code>, is available and is used to control the wire format of inter-cache communications. They can be wound back from more efficient and newer protocols to "compatible" versions when talking to older releases. This mechanism allows us to improve JBoss Cache by using more efficient wire formats while still providing a means to preserve interoperability.
		</div></div><div class="section" id="idm140119307177728"><div class="titlepage"><div><div><h2 class="title">6.3. Compatibility Matrix</h2></div></div></div><div class="para">
			A <a href="http://www.jboss.org/jbosscache/compatibility/index.html" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">compatibility matrix</a> is maintained on the JBoss Cache website, which contains information on different versions of JBoss Cache, JGroups and JBoss Application Server.
		</div></div></div></div><div class="part" id="idm140119321757264"><div class="titlepage"><div><div><h1 class="title">Part II. JBoss Cache Architecture</h1></div></div></div><div class="partintro" id="idm140119321756144"><div><!--Empty--></div><div class="para">
				This section digs deeper into the JBoss Cache architecture, and is meant for developers wishing to use the more advanced cache features,extend or enhance the cache, write plugins, or are just looking for detailed knowledge of how things work under the hood.
			</div></div><div xml:lang="en-US" class="chapter" id="architecture" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Architecture</h2></div></div></div><div class="section" id="architecture.tree_structure"><div class="titlepage"><div><div><h2 class="title">7.1. Data Structures Within The Cache</h2></div></div></div><div class="para">
			A <code class="literal">Cache</code> consists of a collection of <code class="literal">Node</code> instances, organised in a tree structure. Each <code class="literal">Node</code> contains a <code class="literal">Map</code> which holds the data objects to be cached. It is important to note that the structure is a mathematical tree, and not a graph; each <code class="literal">Node</code> has one and only one parent, and the root node is denoted by the constant fully qualified name, <code class="literal">Fqn.ROOT</code>.
		</div><div class="para">
			<div class="figure" id="idm140119306361504"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/1c2fece21a997fc9853f06d78bbfc406/TreeCacheArchitecture.png" width="444" alt="Data structured as a tree" /></div></div><p class="title"><strong>Figure 7.1. Data structured as a tree</strong></p></div>
			 In the diagram above, each box represents a JVM. You see 2 caches in separate JVMs, replicating data to each other.
		</div><div class="para">
			Any modifications (see <a class="xref" href="#api">Chapter 2, <em>User API</em></a>) in one cache instance will be replicated to the other cache. Naturally, you can have more than 2 caches in a cluster. Depending on the transactional settings, this replication will occur either after each modification or at the end of a transaction, at commit time. When a new cache is created, it can optionally acquire the contents from one of the existing caches on startup.
		</div></div><div class="section" id="architecture.SPI_interfaces"><div class="titlepage"><div><div><h2 class="title">7.2. SPI Interfaces</h2></div></div></div><div class="para">
			In addition to <code class="literal">Cache</code> and <code class="literal">Node</code> interfaces, JBoss Cache exposes more powerful <code class="literal">CacheSPI</code> and <code class="literal">NodeSPI</code> interfaces, which offer more control over the internals of JBoss Cache. These interfaces are not intended for general use, but are designed for people who wish to extend and enhance JBoss Cache, or write custom <code class="literal">Interceptor</code> or <code class="literal">CacheLoader</code> instances.
		</div><div class="figure" id="idm140119306997824"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/3b017aa1d9ab3f5862152359dd681850/SPI.png" width="444" alt="SPI Interfaces" /></div></div><p class="title"><strong>Figure 7.2. SPI Interfaces</strong></p></div><div class="para">
			The <code class="literal">CacheSPI</code> interface cannot be created, but is injected into <code class="literal">Interceptor</code> and <code class="literal">CacheLoader</code> implementations by the <code class="literal">setCache(CacheSPI cache)</code> methods on these interfaces. <code class="literal">CacheSPI</code> extends <code class="literal">Cache</code> so all the functionality of the basic API is also available.
		</div><div class="para">
			Similarly, a <code class="literal">NodeSPI</code> interface cannot be created. Instead, one is obtained by performing operations on <code class="literal">CacheSPI</code>, obtained as above. For example, <code class="literal">Cache.getRoot() : Node</code> is overridden as <code class="literal">CacheSPI.getRoot() : NodeSPI</code>.
		</div><div class="para">
			It is important to note that directly casting a <code class="literal">Cache</code> or <code class="literal">Node</code> to its SPI counterpart is not recommended and is bad practice, since the inheritace of interfaces it is not a contract that is guaranteed to be upheld moving forward. The exposed public APIs, on the other hand, is guaranteed to be upheld.
		</div></div><div class="section" id="architecture.invocations"><div class="titlepage"><div><div><h2 class="title">7.3. Method Invocations On Nodes</h2></div></div></div><div class="para">
			Since the cache is essentially a collection of nodes, aspects such as clustering, persistence, eviction, etc. need to be applied to these nodes when operations are invoked on the cache as a whole or on individual nodes. To achieve this in a clean, modular and extensible manner, an interceptor chain is used. The chain is built up of a series of interceptors, each one adding an aspect or particular functionality. The chain is built when the cache is created, based on the configuration used.
		</div><div class="para">
			It is important to note that the <code class="literal">NodeSPI</code> offers some methods (such as the <code class="literal">xxxDirect()</code> method family) that operate on a node directly without passing through the interceptor stack. Plugin authors should note that using such methods will affect the aspects of the cache that may need to be applied, such as locking, replication, etc. To put it simply, don't use such methods unless you <span class="emphasis"><em>really</em></span> know what you're doing!
		</div><div class="section" id="architecture.interceptors"><div class="titlepage"><div><div><h3 class="title">7.3.1. Interceptors</h3></div></div></div><div class="para">
				JBoss Cache essentially is a core data structure - an implementation of <code class="literal">DataContainer</code> - and aspects and features are implemented using interceptors in front of this data structure. A <code class="literal">CommandInterceptor</code> is an abstract class, interceptor implementations extend this.
			</div><div class="para">
				<code class="literal">CommandInterceptor</code> implements the <code class="literal">Visitor</code> interface so it is able to alter commands in a strongly typed manner as the command makes its way to the data structure. More on visitors and commands in the next section.
			</div><div class="para">
				Interceptor implementations are chained together in the <code class="literal">InterceptorChain</code> class, which dispatches a command across the chain of interceptors. A special interceptor, the <code class="literal">CallInterceptor</code>, always sits at the end of this chain to invoke the command being passed up the chain by calling the command's <code class="literal">process()</code> method.
			</div><div class="para">
				JBoss Cache ships with several interceptors, representing different behavioral aspects, some of which are: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">TxInterceptor</code> - looks for ongoing transactions and registers with transaction managers to participate in synchronization events
						</div></li><li class="listitem"><div class="para">
							<code class="literal">ReplicationInterceptor</code> - replicates state across a cluster using the RpcManager class
						</div></li><li class="listitem"><div class="para">
							<code class="literal">CacheLoaderInterceptor</code> - loads data from a persistent store if the data requested is not available in memory
						</div></li></ul></div>
				 The interceptor chain configured for your cache instance can be obtained and inspected by calling <code class="literal">CacheSPI.getInterceptorChain()</code>, which returns an ordered <code class="literal">List</code> of interceptors in the order in which they would be encountered by a command.
			</div><div class="section" id="architecture.custom_interceptors"><div class="titlepage"><div><div><h4 class="title">7.3.1.1. Writing Custom Interceptors</h4></div></div></div><div class="para">
					Custom interceptors to add specific aspects or features can be written by extending <code class="literal">CommandInterceptor</code> and overriding the relevant <code class="literal">visitXXX()</code> methods based on the commands you are interested in intercepting. There are other abstract interceptors you could extend instead, such as the <code class="literal">PrePostProcessingCommandInterceptor</code> and the <code class="literal">SkipCheckChainedInterceptor</code>. Please see their respective javadocs for details on the extra features provided.
				</div><div class="para">
					The custom interceptor will need to be added to the interceptor chain by using the <code class="literal">Cache.addInterceptor()</code> methods. See the javadocs on these methods for details.
				</div><div class="para">
					Adding custom interceptors via XML is also supported, please see the <a class="xref" href="#configuration_reference_chapter">Chapter 12, <em>Configuration References</em></a> for details.
				</div></div></div><div class="section" id="architecture.commands"><div class="titlepage"><div><div><h3 class="title">7.3.2. Commands and Visitors</h3></div></div></div><div class="para">
				Internally, JBoss Cache uses a command/visitor pattern to execute API calls. Whenever a method is called on the cache interface, the <code class="literal">CacheInvocationDelegate</code>, which implements the <code class="literal">Cache</code> interface, creates an instance of <code class="literal">VisitableCommand</code> and dispatches this command up a chain of interceptors. Interceptors, which implement the <code class="literal">Visitor</code> interface, are able to handle <code class="literal">VisitableCommand</code>s they are interested in, and add behavior to the command.
			</div><div class="para">
				Each command contains all knowledge of the command being executed such as parameters used and processing behavior, encapsulated in a <code class="literal">process()</code> method. For example, the <code class="literal">RemoveNodeCommand</code> is created and passed up the interceptor chain when <code class="literal">Cache.removeNode()</code> is called, and <code class="literal">RemoveNodeCommand.process()</code> has the necessary knowledge of how to remove a node from the data structure.
			</div><div class="para">
				In addition to being visitable, commands are also replicable. The JBoss Cache marshallers know how to efficiently marshal commands and invoke them on remote cache instances using an internal RPC mechanism based on JGroups.
			</div></div><div class="section" id="architecture.invocationcontext"><div class="titlepage"><div><div><h3 class="title">7.3.3. InvocationContexts</h3></div></div></div><div class="para">
				<code class="literal">InvocationContext</code> holds intermediate state for the duration of a single invocation, and is set up and destroyed by the <code class="literal">InvocationContextInterceptor</code> which sits at the start of the interceptor chain.
			</div><div class="para">
				<code class="literal">InvocationContext</code>, as its name implies, holds contextual information associated with a single cache method invocation. Contextual information includes associated <code class="literal">javax.transaction.Transaction</code> or <code class="literal">org.jboss.cache.transaction.GlobalTransaction</code>, method invocation origin ( <code class="literal">InvocationContext.isOriginLocal()</code> ) as well as <a class="xref" href="#configuration.options">Section 3.4.1, “Overriding the Configuration via the Option API”</a>, and information around which nodes have been locked, etc.
			</div><div class="para">
				The <code class="literal">InvocationContext</code> can be obtained by calling <code class="literal">Cache.getInvocationContext()</code>.
			</div></div></div><div class="section" id="architecture.managers"><div class="titlepage"><div><div><h2 class="title">7.4. Managers For Subsystems</h2></div></div></div><div class="para">
			Some aspects and functionality is shared by more than a single interceptor. Some of these have been encapsulated into managers, for use by various interceptors, and are made available by the <code class="literal">CacheSPI</code> interface.
		</div><div class="section" id="architecture.rpcmanager"><div class="titlepage"><div><div><h3 class="title">7.4.1. RpcManager</h3></div></div></div><div class="para">
				This class is responsible for calls made via the JGroups channel for all RPC calls to remote caches, and encapsulates the JGroups channel used.
			</div></div><div class="section" id="architecture.buddymanager"><div class="titlepage"><div><div><h3 class="title">7.4.2. BuddyManager</h3></div></div></div><div class="para">
				This class manages buddy groups and invokes group organization remote calls to organize a cluster of caches into smaller sub-groups.
			</div></div><div class="section" id="architecture.cacheloadermanager"><div class="titlepage"><div><div><h3 class="title">7.4.3. CacheLoaderManager</h3></div></div></div><div class="para">
				Sets up and configures cache loaders. This class wraps individual <code class="literal">CacheLoader</code> instances in delegating classes, such as <code class="literal">SingletonStoreCacheLoader</code> or <code class="literal">AsyncCacheLoader</code>, or may add the <code class="literal">CacheLoader</code> to a chain using the <code class="literal">ChainingCacheLoader</code>.
			</div></div></div><div class="section" id="architecture.marshalling"><div class="titlepage"><div><div><h2 class="title">7.5. Marshalling And Wire Formats</h2></div></div></div><div class="para">
			Early versions of JBoss Cache simply wrote cached data to the network by writing to an <code class="literal">ObjectOutputStream</code> during replication. Over various releases in the JBoss Cache 1.x.x series this approach was gradually deprecated in favor of a more mature marshalling framework. In the JBoss Cache 2.x.x series, this is the only officially supported and recommended mechanism for writing objects to datastreams.
		</div><div class="figure" id="idm140119305996528"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/1b511d3d31a3cf6bb92eee8a6c94eadf/Marshaller.png" width="444" alt="The Marshaller interface" /></div></div><p class="title"><strong>Figure 7.3. The Marshaller interface</strong></p></div><div class="section" id="idm140119305993744"><div class="titlepage"><div><div><h3 class="title">7.5.1. The Marshaller Interface</h3></div></div></div><div class="para">
				The <code class="literal">Marshaller</code> interface extends <code class="literal">RpcDispatcher.Marshaller</code> from JGroups. This interface has two main implementations - a delegating <code class="literal">VersionAwareMarshaller</code> and a concrete <code class="literal">CacheMarshaller300</code> .
			</div><div class="para">
				The marshaller can be obtained by calling <code class="literal">CacheSPI.getMarshaller()</code>, and defaults to the <code class="literal">VersionAwareMarshaller</code>. Users may also write their own marshallers by implementing the <code class="literal">Marshaller</code> interface or extending the <code class="literal">AbstractMarshaller</code> class, and adding it to their configuration by using the <code class="literal">Configuration.setMarshallerClass()</code> setter.
			</div></div><div class="section" id="idm140119305226960"><div class="titlepage"><div><div><h3 class="title">7.5.2. VersionAwareMarshaller</h3></div></div></div><div class="para">
				As the name suggests, this marshaller adds a version <code class="literal">short</code> to the start of any stream when writing, enabling similar <code class="literal">VersionAwareMarshaller</code> instances to read the version short and know which specific marshaller implementation to delegate the call to. For example, <code class="literal">CacheMarshaller200</code> is the marshaller for JBoss Cache 2.0.x. JBoss Cache 3.0.x ships with <code class="literal">CacheMarshaller300</code> with an improved wire protocol. Using a <code class="literal">VersionAwareMarshaller</code> helps achieve wire protocol compatibility between minor releases but still affords us the flexibility to tweak and improve the wire protocol between minor or micro releases.
			</div></div></div><div class="section" id="architecture.regions"><div class="titlepage"><div><div><h2 class="title">7.6. Class Loading and Regions</h2></div></div></div><div class="para">
			When used to cluster state of application servers, applications deployed in the application tend to put instances of objects specific to their application in the cache (or in an <code class="literal">HttpSession</code> object) which would require replication. It is common for application servers to assign separate <code class="literal">ClassLoader</code> instances to each application deployed, but have JBoss Cache libraries referenced by the application server's <code class="literal">ClassLoader</code>.
		</div><div class="para">
			To enable us to successfully marshall and unmarshall objects from such class loaders, we use a concept called regions. A region is a portion of the cache which share a common class loader (a region also has other uses - see <a class="xref" href="#eviction_policies">Chapter 10, <em>Eviction</em></a>).
		</div><div class="para">
			A region is created by using the <code class="literal">Cache.getRegion(Fqn fqn, boolean createIfNotExists)</code> method, and returns an implementation of the <code class="literal">Region</code> interface. Once a region is obtained, a class loader for the region can be set or unset, and the region can be activated/deactivated. By default, regions are active unless the <code class="literal">InactiveOnStartup</code> configuration attribute is set to <code class="literal">true</code>.
		</div></div></div><div xml:lang="en-US" class="chapter" id="clustering" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Cache Modes and Clustering</h2></div></div></div><div class="para">
		This chapter talks about aspects around clustering JBoss Cache.
	</div><div class="section" id="idm140119305162512"><div class="titlepage"><div><div><h2 class="title">8.1. Cache Replication Modes</h2></div></div></div><div class="para">
			JBoss Cache can be configured to be either local (standalone) or clustered. If in a cluster, the cache can be configured to replicate changes, or to invalidate changes. A detailed discussion on this follows.
		</div><div class="section" id="idm140119311661168"><div class="titlepage"><div><div><h3 class="title">8.1.1. Local Mode</h3></div></div></div><div class="para">
				Local caches don't join a cluster and don't communicate with other caches in a cluster. The dependency on the JGroups library is still there, although a JGroups channel is not started.
			</div></div><div class="section" id="idm140119311525888"><div class="titlepage"><div><div><h3 class="title">8.1.2. Replicated Caches</h3></div></div></div><div class="para">
				Replicated caches replicate all changes to some or all of the other cache instances in the cluster. Replication can either happen after each modification (no transactions or batches), or at the end of a transaction or batch.
			</div><div class="para">
				Replication can be synchronous or asynchronous. Use of either one of the options is application dependent. Synchronous replication blocks the caller (e.g. on a <code class="literal">put()</code> ) until the modifications have been replicated successfully to all nodes in a cluster. Asynchronous replication performs replication in the background (the <code class="literal">put()</code> returns immediately). JBoss Cache also offers a replication queue, where modifications are replicated periodically (i.e. interval-based), or when the queue size exceeds a number of elements, or a combination thereof. A replication queue can therefore offer much higher performance as the actual replication is performed by a background thread.
			</div><div class="para">
				Asynchronous replication is faster (no caller blocking), because synchronous replication requires acknowledgments from all nodes in a cluster that they received and applied the modification successfully (round-trip time). However, when a synchronous replication returns successfully, the caller knows for sure that all modifications have been applied to all cache instances, whereas this is not be the case with asynchronous replication. With asynchronous replication, errors are simply written to a log. Even when using transactions, a transaction may succeed but replication may not succeed on all cache instances.
			</div><div class="section" id="replication.tx"><div class="titlepage"><div><div><h4 class="title">8.1.2.1. Replicated Caches and Transactions</h4></div></div></div><div class="para">
					When using transactions, replication only occurs at the transaction boundary - i.e., when a transaction commits. This results in minimizing replication traffic since a single modification is broadcast rather than a series of individual modifications, and can be a lot more efficient than not using transactions. Another effect of this is that if a transaction were to roll back, nothing is broadcast across a cluster.
				</div><div class="para">
					Depending on whether you are running your cluster in asynchronous or synchronous mode, JBoss Cache will use either a single phase or <a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol" class="mimir-link-warn" title="Mimir does not include content from: en.wikipedia.org">two-phase commit</a> protocol, respectively.
				</div><div class="section" id="idm140119306470912"><div class="titlepage"><div><div><h5 class="title">8.1.2.1.1. One Phase Commits</h5></div></div></div><div class="para">
						Used when your cache mode is REPL_ASYNC. All modifications are replicated in a single call, which instructs remote caches to apply the changes to their local in-memory state and commit locally. Remote errors/rollbacks are never fed back to the originator of the transaction since the communication is asynchronous.
					</div></div><div class="section" id="idm140119310953840"><div class="titlepage"><div><div><h5 class="title">8.1.2.1.2. Two Phase Commits</h5></div></div></div><div class="para">
						Used when your cache mode is REPL_SYNC. Upon committing your transaction, JBoss Cache broadcasts a prepare call, which carries all modifications relevant to the transaction. Remote caches then acquire local locks on their in-memory state and apply the modifications. Once all remote caches respond to the prepare call, the originator of the transaction broadcasts a commit. This instructs all remote caches to commit their data. If any of the caches fail to respond to the prepare phase, the originator broadcasts a rollback.
					</div><div class="para">
						Note that although the prepare phase is synchronous, the commit and rollback phases are asynchronous. This is because <a href="http://java.sun.com/products/jta/" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">Sun's JTA specification </a> does not specify how transactional resources should deal with failures at this stage of a transaction; and other resources participating in the transaction may have indeterminate state anyway. As such, we do away with the overhead of synchronous communication for this phase of the transaction. That said, they can be forced to be synchronous using the <code class="literal">SyncCommitPhase</code> and <code class="literal">SyncRollbackPhase</code> configuration attributes.
					</div></div></div><div class="section" id="br"><div class="titlepage"><div><div><h4 class="title">8.1.2.2. Buddy Replication</h4></div></div></div><div class="para">
					Buddy Replication allows you to suppress replicating your data to all instances in a cluster. Instead, each instance picks one or more 'buddies' in the cluster, and only replicates to these specific buddies. This greatly helps scalability as there is no longer a memory and network traffic impact every time another instance is added to a cluster.
				</div><div class="para">
					One of the most common use cases of Buddy Replication is when a replicated cache is used by a servlet container to store HTTP session data. One of the pre-requisites to buddy replication working well and being a real benefit is the use of <span class="emphasis"><em>session affinity </em></span> , more casually known as <span class="emphasis"><em>sticky sessions </em></span> in HTTP session replication speak. What this means is that if certain data is frequently accessed, it is desirable that this is always accessed on one instance rather than in a round-robin fashion as this helps the cache cluster optimize how it chooses buddies, where it stores data, and minimizes replication traffic.
				</div><div class="para">
					If this is not possible, Buddy Replication may prove to be more of an overhead than a benefit.
				</div><div class="section" id="idm140119306576000"><div class="titlepage"><div><div><h5 class="title">8.1.2.2.1. Selecting Buddies</h5></div></div></div><div class="figure" id="idm140119306575200"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/a7faffa58fe98af5c367ae74bc4c43b3/BuddyReplication.png" width="444" alt="BuddyLocator" /></div></div><p class="title"><strong>Figure 8.1. BuddyLocator</strong></p></div><div class="para">
						Buddy Replication uses an instance of a <code class="literal">BuddyLocator</code> which contains the logic used to select buddies in a network. JBoss Cache currently ships with a single implementation, <code class="literal">NextMemberBuddyLocator</code>, which is used as a default if no implementation is provided. The <code class="literal">NextMemberBuddyLocator</code> selects the next member in the cluster, as the name suggests, and guarantees an even spread of buddies for each instance.
					</div><div class="para">
						The <code class="literal">NextMemberBuddyLocator</code> takes in 2 parameters, both optional. 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<code class="literal">numBuddies</code> - specifies how many buddies each instance should pick to back its data onto. This defaults to 1.
								</div></li><li class="listitem"><div class="para">
									<code class="literal">ignoreColocatedBuddies</code> - means that each instance will <span class="emphasis"><em>try</em></span> to select a buddy on a different physical host. If not able to do so though, it will fall back to co-located instances. This defaults to <code class="literal">true</code> .
								</div></li></ul></div>

					</div></div><div class="section" id="idm140119304718688"><div class="titlepage"><div><div><h5 class="title">8.1.2.2.2. BuddyPools</h5></div></div></div><div class="para">
						Also known as <span class="emphasis"><em>replication groups</em></span>, a buddy pool is an optional construct where each instance in a cluster may be configured with a buddy pool name. Think of this as an 'exclusive club membership' where when selecting buddies, <code class="literal">BuddyLocator</code> s that support buddy pools would try and select buddies sharing the same buddy pool name. This allows system administrators a degree of flexibility and control over how buddies are selected. For example, a sysadmin may put two instances on two separate physical servers that may be on two separate physical racks in the same buddy pool. So rather than picking an instance on a different host on the same rack, <code class="literal">BuddyLocator</code> s would rather pick the instance in the same buddy pool, on a separate rack which may add a degree of redundancy.
					</div></div><div class="section" id="idm140119307255952"><div class="titlepage"><div><div><h5 class="title">8.1.2.2.3. Failover</h5></div></div></div><div class="para">
						In the unfortunate event of an instance crashing, it is assumed that the client connecting to the cache (directly or indirectly, via some other service such as HTTP session replication) is able to redirect the request to any other random cache instance in the cluster. This is where a concept of Data Gravitation comes in.
					</div><div class="para">
						Data Gravitation is a concept where if a request is made on a cache in the cluster and the cache does not contain this information, it asks other instances in the cluster for the data. In other words, data is lazily transferred, migrating <span class="emphasis"><em>only</em></span> when other nodes ask for it. This strategy prevents a network storm effect where lots of data is pushed around healthy nodes because only one (or a few) of them die.
					</div><div class="para">
						If the data is not found in the primary section of some node, it would (optionally) ask other instances to check in the backup data they store for other caches. This means that even if a cache containing your session dies, other instances will still be able to access this data by asking the cluster to search through their backups for this data.
					</div><div class="para">
						Once located, this data is transferred to the instance which requested it and is added to this instance's data tree. The data is then (optionally) removed from all other instances (and backups) so that if session affinity is used, the affinity should now be to this new cache instance which has just <span class="emphasis"><em>taken ownership </em></span> of this data.
					</div><div class="para">
						Data Gravitation is implemented as an interceptor. The following (all optional) configuration properties pertain to data gravitation. 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<code class="literal">dataGravitationRemoveOnFind</code> - forces all remote caches that own the data or hold backups for the data to remove that data, thereby making the requesting cache the new data owner. This removal, of course, only happens after the new owner finishes replicating data to its buddy. If set to <code class="literal">false</code> an evict is broadcast instead of a remove, so any state persisted in cache loaders will remain. This is useful if you have a shared cache loader configured. Defaults to <code class="literal">true</code> .
								</div></li><li class="listitem"><div class="para">
									<code class="literal">dataGravitationSearchBackupTrees</code> - Asks remote instances to search through their backups as well as main data trees. Defaults to <code class="literal">true</code> . The resulting effect is that if this is <code class="literal">true</code> then backup nodes can respond to data gravitation requests in addition to data owners.
								</div></li><li class="listitem"><div class="para">
									<code class="literal">autoDataGravitation</code> - Whether data gravitation occurs for every cache miss. By default this is set to <code class="literal">false</code> to prevent unnecessary network calls. Most use cases will know when it may need to gravitate data and will pass in an <code class="literal">Option</code> to enable data gravitation on a per-invocation basis. If <code class="literal">autoDataGravitation</code> is <code class="literal">true</code> this <code class="literal">Option</code> is unnecessary.
								</div></li></ul></div>

					</div></div><div class="section" id="idm140119308097632"><div class="titlepage"><div><div><h5 class="title">8.1.2.2.4. Configuration</h5></div></div></div><div class="para">
						See the <a class="xref" href="#configuration_reference_chapter">Chapter 12, <em>Configuration References</em></a> for details on configuring buddy replication.
					</div></div></div></div></div><div class="section" id="idm140119308095264"><div class="titlepage"><div><div><h2 class="title">8.2. Invalidation</h2></div></div></div><div class="para">
			If a cache is configured for invalidation rather than replication, every time data is changed in a cache other caches in the cluster receive a message informing them that their data is now stale and should be evicted from memory. Invalidation, when used with a shared cache loader (see chapter on <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a>) would cause remote caches to refer to the shared cache loader to retrieve modified data. The benefit of this is twofold: network traffic is minimized as invalidation messages are very small compared to replicating updated data, and also that other caches in the cluster look up modified data in a lazy manner, only when needed.
		</div><div class="para">
			Invalidation messages are sent after each modification (no transactions or batches), or at the end of a transaction or batch, upon successful commit. This is usually more efficient as invalidation messages can be optimized for the transaction as a whole rather than on a per-modification basis.
		</div><div class="para">
			Invalidation too can be synchronous or asynchronous, and just as in the case of replication, synchronous invalidation blocks until all caches in the cluster receive invalidation messages and have evicted stale data while asynchronous invalidation works in a 'fire-and-forget' mode, where invalidation messages are broadcast but doesn't block and wait for responses.
		</div></div><div class="section" id="idm140119308091104"><div class="titlepage"><div><div><h2 class="title">8.3. State Transfer</h2></div></div></div><div class="para">
			<span class="emphasis"><em>State Transfer</em></span> refers to the process by which a JBoss Cache instance prepares itself to begin providing a service by acquiring the current state from another cache instance and integrating that state into its own state.
		</div><div class="section" id="idm140119308089152"><div class="titlepage"><div><div><h3 class="title">8.3.1. State Transfer Types</h3></div></div></div><div class="para">
				There are three divisions of state transfer types depending on a point of view related to state transfer. First, in the context of particular state transfer implementation, the underlying plumbing, there are two starkly different state transfer types: byte array and streaming based state transfer. Second, state transfer can be full or partial state transfer depending on a subtree being transferred. Entire cache tree transfer represents full transfer while transfer of a particular subtree represents partial state transfer. And finally state transfer can be "in-memory" and "persistent" transfer depending on a particular use of cache.
			</div></div><div class="section" id="idm140119308087072"><div class="titlepage"><div><div><h3 class="title">8.3.2. Byte array and streaming based state transfer</h3></div></div></div><div class="para">
				Byte array based transfer was a default and only transfer methodology for cache in all previous releases up to 2.0. Byte array based transfer loads entire state transferred into a byte array and sends it to a state receiving member. Major limitation of this approach is that the state transfer that is very large (&gt;1GB) would likely result in OutOfMemoryException. Streaming state transfer provides an InputStream to a state reader and an OutputStream to a state writer. OutputStream and InputStream abstractions enable state transfer in byte chunks thus resulting in smaller memory requirements. For example, if application state is represented as a tree whose aggregate size is 1GB, rather than having to provide a 1GB byte array streaming state transfer transfers the state in chunks of N bytes where N is user configurable.
			</div><div class="para">
				Byte array and streaming based state transfer are completely API transparent, interchangeable, and statically configured through a standard cache configuration XML file. Refer to JGroups documentation on how to change from one type of transfer to another.
			</div></div><div class="section" id="idm140119308084112"><div class="titlepage"><div><div><h3 class="title">8.3.3. Full and partial state transfer</h3></div></div></div><div class="para">
				If either in-memory or persistent state transfer is enabled, a full or partial state transfer will be done at various times, depending on how the cache is used. "Full" state transfer refers to the transfer of the state related to the entire tree -- i.e. the root node and all nodes below it. A "partial" state transfer is one where just a portion of the tree is transferred -- i.e. a node at a given Fqn and all nodes below it.
			</div><div class="para">
				If either in-memory or persistent state transfer is enabled, state transfer will occur at the following times:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						Initial state transfer. This occurs when the cache is first started (as part of the processing of the <code class="literal">start()</code> method). This is a full state transfer. The state is retrieved from the cache instance that has been operational the longest. <a href="#ftn.idm140119307369920" class="footnote"><sup class="footnote" id="idm140119307369920">[1]</sup></a> If there is any problem receiving or integrating the state, the cache will not start.
					</div><div class="para">
						Initial state transfer will occur unless:
					</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
								The cache's <code class="literal">InactiveOnStartup</code> property is <code class="literal">true</code>. This property is used in conjunction with region-based marshalling.
							</div></li><li class="listitem"><div class="para">
								Buddy replication is used. See below for more on state transfer with buddy replication.
							</div></li></ol></div></li><li class="listitem"><div class="para">
						Partial state transfer following region activation. When region-based marshalling is used, the application needs to register a specific class loader with the cache. This class loader is used to unmarshall the state for a specific region (subtree) of the cache.
					</div><div class="para">
						After registration, the application calls <code class="literal">cache.getRegion(fqn, true).activate()</code>, which initiates a partial state transfer of the relevant subtree's state. The request is first made to the oldest cache instance in the cluster. However, if that instance responds with no state, it is then requested from each instance in turn until one either provides state or all instances have been queried.
					</div><div class="para">
						Typically when region-based marshalling is used, the cache's <code class="literal">InactiveOnStartup</code> property is set to <code class="literal">true</code>. This suppresses initial state transfer, which would fail due to the inability to deserialize the transferred state.
					</div></li><li class="listitem"><div class="para">
						Buddy replication. When buddy replication is used, initial state transfer is disabled. Instead, when a cache instance joins the cluster, it becomes the buddy of one or more other instances, and one or more other instances become its buddy. Each time an instance determines it has a new buddy providing backup for it, it pushes its current state to the new buddy. This "pushing" of state to the new buddy is slightly different from other forms of state transfer, which are based on a "pull" approach (i.e. recipient asks for and receives state). However, the process of preparing and integrating the state is the same.
					</div><div class="para">
						This "push" of state upon buddy group formation only occurs if the <code class="literal">InactiveOnStartup</code> property is set to <code class="literal">false</code>. If it is <code class="literal">true</code>, state transfer amongst the buddies only occurs when the application activates the region on the various members of the group.
					</div><div class="para">
						Partial state transfer following a region activation call is slightly different in the buddy replication case as well. Instead of requesting the partial state from one cache instance, and trying all instances until one responds, with buddy replication the instance that is activating a region will request partial state from each instance for which it is serving as a backup.
					</div></li></ol></div></div><div class="section" id="idm140119307356160"><div class="titlepage"><div><div><h3 class="title">8.3.4. Transient ("in-memory") and persistent state transfer</h3></div></div></div><div class="para">
				The state that is acquired and integrated can consist of two basic types:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						"Transient" or "in-memory" state. This consists of the actual in-memory state of another cache instance - the contents of the various in-memory nodes in the cache that is providing state are serialized and transferred; the recipient deserializes the data, creates corresponding nodes in its own in-memory tree, and populates them with the transferred data.
					</div><div class="para">
						"In-memory" state transfer is enabled by setting the cache's <code class="literal">FetchInMemoryState</code> configuration attribute to <code class="literal">true</code>.
					</div></li><li class="listitem"><div class="para">
						"Persistent" state. Only applicable if a non-shared cache loader is used. The state stored in the state-provider cache's persistent store is deserialized and transferred; the recipient passes the data to its own cache loader, which persists it to the recipient's persistent store.
					</div><div class="para">
						"Persistent" state transfer is enabled by setting a cache loader's <code class="literal">fetchPersistentState</code> attribute to <code class="literal">true</code>. If multiple cache loaders are configured in a chain, only one can have this property set to true; otherwise you will get an exception at startup.
					</div><div class="para">
						Persistent state transfer with a shared cache loader does not make sense, as the same persistent store that provides the data will just end up receiving it. Therefore, if a shared cache loader is used, the cache will not allow a persistent state transfer even if a cache loader has <code class="literal">fetchPersistentState</code> set to <code class="literal">true</code>.
					</div></li></ol></div><div class="para">
				Which of these types of state transfer is appropriate depends on the usage of the cache.
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						If a write-through cache loader is used, the current cache state is fully represented by the persistent state. Data may have been evicted from the in-memory state, but it will still be in the persistent store. In this case, if the cache loader is not shared, persistent state transfer is used to ensure the new cache has the correct state. In-memory state can be transferred as well if the desire is to have a "hot" cache -- one that has all relevant data in memory when the cache begins providing service. (Note that the <code class="literal">&lt;preload&gt;</code> element in the <code class="literal">&lt;loaders&gt;</code> configuration element can be used as well to provide a "warm" or "hot" cache without requiring an in-memory state transfer. This approach somewhat reduces the burden on the cache instance providing state, but increases the load on the persistent store on the recipient side.)
					</div></li><li class="listitem"><div class="para">
						If a cache loader is used with passivation, the full representation of the state can only be obtained by combining the in-memory (i.e. non-passivated) and persistent (i.e. passivated) states. Therefore an in-memory state transfer is necessary. A persistent state transfer is necessary if the cache loader is not shared.
					</div></li><li class="listitem"><div class="para">
						If no cache loader is used and the cache is solely a write-aside cache (i.e. one that is used to cache data that can also be found in a persistent store, e.g. a database), whether or not in-memory state should be transferred depends on whether or not a "hot" cache is desired.
					</div></li></ol></div></div><div class="section" id="idm140119299394560"><div class="titlepage"><div><div><h3 class="title">8.3.5. Configuring State Transfer</h3></div></div></div><div class="para">
				To ensure state transfer behaves as expected, it is important that all nodes in the cluster are configured with the same settings for persistent and transient state. This is because byte array based transfers, when requested, rely only on the requester's configuration while stream based transfers rely on both the requester and sender's configuration, and this is expected to be identical.
			</div></div></div><div class="footnotes"><br/><hr width="100" align="left"/><div id="ftn.idm140119307369920" class="footnote"><div class="para"><a href="#idm140119307369920" class="para"><sup class="para">[1] </sup></a>
							The longest operating cache instance is always, in JGroups terms, the coordinator.
						</div></div></div></div><div xml:lang="en-US" class="chapter" id="cache_loaders" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Cache Loaders</h2></div></div></div><div class="para">
		JBoss Cache can use a <code class="literal">CacheLoader</code> to back up the in-memory cache to a backend datastore. If JBoss Cache is configured with a cache loader, then the following features are provided: 
		<div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Whenever a cache element is accessed, and that element is not in the cache (e.g. due to eviction or due to server restart), then the cache loader transparently loads the element into the cache if found in the backend store.
				</div></li><li class="listitem"><div class="para">
					Whenever an element is modified, added or removed, then that modification is persisted in the backend store via the cache loader. If transactions are used, all modifications created within a transaction are persisted. To this end, the <code class="literal">CacheLoader</code> takes part in the two phase commit protocol run by the transaction manager, although it does not do so explicitly.
				</div></li></ul></div>

	</div><div class="section" id="idm140119299438272"><div class="titlepage"><div><div><h2 class="title">9.1. The CacheLoader Interface and Lifecycle</h2></div></div></div><div class="figure" id="idm140119306647616"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/c72972f40722b69699088e1e4f21e4ee/CacheLoader.png" width="444" alt="The CacheLoader interface" /></div></div><p class="title"><strong>Figure 9.1. The CacheLoader interface</strong></p></div><div class="para">
			The interaction between JBoss Cache and a <code class="literal">CacheLoader</code> implementation is as follows. When <code class="literal">CacheLoaderConfiguration</code> (see below) is non-null, an instance of each configured <code class="literal">CacheLoader</code> is created when the cache is created, and started when the cache is started.
		</div><div class="para">
			<code class="literal">CacheLoader.create()</code> and <code class="literal">CacheLoader.start()</code> are called when the cache is started. Correspondingly, <code class="literal">stop()</code> and <code class="literal">destroy()</code> are called when the cache is stopped.
		</div><div class="para">
			Next, <code class="literal">setConfig()</code> and <code class="literal">setCache()</code> are called. The latter can be used to store a reference to the cache, the former is used to configure this instance of the <code class="literal">CacheLoader</code> . For example, here a database cache loader could establish a connection to the database.
		</div><div class="para">
			The <code class="literal">CacheLoader</code> interface has a set of methods that are called when no transactions are used: <code class="literal">get()</code> , <code class="literal">put()</code> , <code class="literal">remove()</code> and <code class="literal">removeData()</code> : they get/set/remove the value immediately. These methods are described as javadoc comments in the interface.
		</div><div class="para">
			Then there are three methods that are used with transactions: <code class="literal">prepare()</code> , <code class="literal">commit()</code> and <code class="literal">rollback()</code> . The <code class="literal">prepare()</code> method is called when a transaction is to be committed. It has a transaction object and a list of modfications as argument. The transaction object can be used as a key into a hashmap of transactions, where the values are the lists of modifications. Each modification list has a number of <code class="literal">Modification</code> elements, which represent the changes made to a cache for a given transaction. When <code class="literal">prepare()</code> returns successfully, then the cache loader <span class="emphasis"><em>must</em></span> be able to commit (or rollback) the transaction successfully.
		</div><div class="para">
			JBoss Cache takes care of calling prepare(), commit() and rollback() on the cache loaders at the right time.
		</div><div class="para">
			The <code class="literal">commit()</code> method tells the cache loader to commit the transaction, and the <code class="literal">rollback()</code> method tells the cache loader to discard the changes associated with that transaction.
		</div><div class="para">
			See the javadocs on this interface for a detailed explanation on each method and the contract implementations would need to fulfill.
		</div></div><div class="section" id="idm140119318081616"><div class="titlepage"><div><div><h2 class="title">9.2. Configuration</h2></div></div></div><div class="para">
			Cache loaders are configured as follows in the JBoss Cache XML file. Note that you can define several cache loaders, in a chain. The impact is that the cache will look at all of the cache loaders in the order they've been configured, until it finds a valid, non-null element of data. When performing writes, all cache loaders are written to, except if the <code class="literal">ignoreModifications</code> element has been set to <code class="literal">true</code> for a specific cache loader. See the configuration section below for details.
		</div><pre class="programlisting XML XML">
...

&lt;!-- Cache loader config block --&gt;
&lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
&lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;!-- Fqns to preload --&gt;
         &lt;node fqn="/some/stuff"/&gt;
      &lt;/preload&gt;
      &lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="true"
              ignoreModifications="false" purgeOnStartup="false"&gt;
         &lt;properties&gt;
            cache.jdbc.driver=com.mysql.jdbc.Driver
            cache.jdbc.url=jdbc:mysql://localhost:3306/jbossdb
            cache.jdbc.user=root
            cache.jdbc.password=
         &lt;/properties&gt;
      &lt;/loader&gt;
  &lt;/loaders&gt;
</pre><div class="para">
			The <code class="literal">class</code> element defines the class of the cache loader implementation. (Note that, because of a bug in the properties editor in JBoss AS, backslashes in variables for Windows filenames might not get expanded correctly, so replace="false" may be necessary). Note that an implementation of cache loader has to have an empty constructor.
		</div><div class="para">
			The <code class="literal">properties</code> element defines a configuration specific to the given implementation. The filesystem-based implementation for example defines the root directory to be used, whereas a database implementation might define the database URL, name and password to establish a database connection. This configuration is passed to the cache loader implementation via <code class="literal">CacheLoader.setConfig(Properties)</code>. Note that backspaces may have to be escaped.
		</div><div class="para">
			<code class="literal">preload</code> allows us to define a list of nodes, or even entire subtrees, that are visited by the cache on startup, in order to preload the data associated with those nodes. The default ("/") loads the entire data available in the backend store into the cache, which is probably not a good idea given that the data in the backend store might be large. As an example, <code class="literal">/a, /product/catalogue </code> loads the subtrees <code class="literal">/a</code> and <code class="literal">/product/catalogue</code> into the cache, but nothing else. Anything else is loaded lazily when accessed. Preloading makes sense when one anticipates using elements under a given subtree frequently. .
		</div><div class="para">
			<code class="literal">fetchPersistentState</code> determines whether or not to fetch the persistent state of a cache when joining a cluster. Only one configured cache loader may set this property to true; if more than one cache loader does so, a configuration exception will be thrown when starting your cache service.
		</div><div class="para">
			<code class="literal">async</code> determines whether writes to the cache loader block until completed, or are run on a separate thread so writes return immediately. If this is set to true, an instance of <code class="literal">org.jboss.cache.loader.AsyncCacheLoader</code> is constructed with an instance of the actual cache loader to be used. The <code class="literal">AsyncCacheLoader</code> then delegates all requests to the underlying cache loader, using a separate thread if necessary. See the Javadocs on <code class="literal">AsyncCacheLoader</code> for more details. If unspecified, the <code class="literal">async</code> element defaults to <code class="literal">false</code>.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				There is always the possibility of dirty reads since all writes are performed asynchronously, and it is thus impossible to guarantee when (and even if) a write succeeds. This needs to be kept in mind when setting the <code class="literal">async</code> element to true.
			</div></div></div><div class="para">
			<code class="literal">ignoreModifications</code> determines whether write methods are pushed down to the specific cache loader. Situations may arise where transient application data should only reside in a file based cache loader on the same server as the in-memory cache, for example, with a further shared <code class="literal">JDBCCacheLoader</code> used by all servers in the network. This feature allows you to write to the 'local' file cache loader but not the shared <code class="literal">JDBCCacheLoader</code>. This property defaults to <code class="literal">false</code>, so writes are propagated to all cache loaders configured.
		</div><div class="para">
			<code class="literal">purgeOnStatup</code> empties the specified cache loader (if <code class="literal">ignoreModifications</code> is <code class="literal">false</code>) when the cache loader starts up.
		</div><div class="para">
			<code class="literal">shared</code> indicates that the cache loader is shared among different cache instances, for example where all instances in a cluster use the same JDBC settings t talk to the same remote, shared database. Setting this to <code class="literal">true</code> prevents repeated and unnecessary writes of the same data to the cache loader by different cache instances. Default value is <code class="literal">false</code> .
		</div><div class="section" id="sscl"><div class="titlepage"><div><div><h3 class="title">9.2.1. Singleton Store Configuration</h3></div></div></div><pre class="programlisting XML XML">
 &lt;loaders passivation="false" shared="true"&gt;
    &lt;preload&gt;
       &lt;node fqn="/a/b/c"/&gt;
       &lt;node fqn="/f/r/s"/&gt;
    &lt;/preload&gt;

    &lt;!-- we can now have multiple cache loaders, which get chained --&gt;
    &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="false"
         ignoreModifications="false" purgeOnStartup="false"&gt;
       &lt;properties&gt;
         cache.jdbc.datasource=java:/DefaultDS
       &lt;/properties&gt;
       &lt;singletonStore enabled="true" class="org.jboss.cache.loader.SingletonStoreCacheLoader"&gt;
          &lt;properties&gt;
             pushStateWhenCoordinator=true
             pushStateWhenCoordinatorTimeout=20000
          &lt;/properties&gt;
       &lt;/singletonStore&gt;
    &lt;/loader&gt;
 &lt;/loaders&gt;
</pre><div class="para">
				<code class="literal">singletonStore</code> element enables modifications to be stored by only one node in the cluster, the coordinator. Essentially, whenever any data comes in to some node it is always replicated so as to keep the caches' in-memory states in sync; the coordinator, though, has the sole responsibility of pushing that state to disk. This functionality can be activated setting the <code class="literal">enabled</code> subelement to true in all nodes, but again only the coordinator of the cluster will store the modifications in the underlying cache loader as defined in <code class="literal">loader</code> element. You cannot define a cache loader as <code class="literal">shared</code> and with <code class="literal">singletonStore</code> enabled at the same time. Default value for <code class="literal">enabled</code> is <code class="literal">false</code>.
			</div><div class="para">
				Optionally, within the <code class="literal">singletonStore</code> element, you can define a <code class="literal">class</code> element that specifies the implementation class that provides the singleton store functionality. This class must extend <code class="literal">org.jboss.cache.loader.AbstractDelegatingCacheLoader</code>, and if absent, it defaults to <code class="literal">org.jboss.cache.loader.SingletonStoreCacheLoader</code>.
			</div><div class="para">
				The <code class="literal">properties</code> subelement defines properties that allow changing the behavior of the class providing the singleton store functionality. By default, <code class="literal">pushStateWhenCoordinator</code> and <code class="literal">pushStateWhenCoordinatorTimeout</code> properties have been defined, but more could be added as required by the user-defined class providing singleton store functionality.
			</div><div class="para">
				<code class="literal">pushStateWhenCoordinator</code> allows the in-memory state to be pushed to the cache store when a node becomes the coordinator, as a result of the new election of coordinator due to a cluster topology change. This can be very useful in situations where the coordinator crashes and there's a gap in time until the new coordinator is elected. During this time, if this property was set to <code class="literal">false</code> and the cache was updated, these changes would never be persisted. Setting this property to <code class="literal">true</code> would ensure that any changes during this process also get stored in the cache loader. You would also want to set this property to <code class="literal">true</code> if each node's cache loader is configured with a different location. Default value is <code class="literal">true</code>.
			</div><div class="para">
				<code class="literal">pushStateWhenCoordinatorTimeout</code> is only relevant if <code class="literal">pushStateWhenCoordinator</code> is <code class="literal">true</code> in which case, sets the maximum number of milliseconds that the process of pushing the in-memory state to the underlying cache loader should take, reporting a <code class="literal">PushStateException</code> if exceeded. Default value is 20000.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Setting up a cache loader as a singleton and using cache passivation (via evictions) can lead to undesired effects. If a node is to be passivated as a result of an eviction, while the cluster is in the process of electing a new coordinator, the data will be lost. This is because no coordinator is active at that time and therefore, none of the nodes in the cluster will store the passivated node. A new coordinator is elected in the cluster when either, the coordinator leaves the cluster, the coordinator crashes or stops responding.
				</div></div></div></div></div><div class="section" id="cl.impls"><div class="titlepage"><div><div><h2 class="title">9.3. Shipped Implementations</h2></div></div></div><div class="para">
			The currently available implementations shipped with JBoss Cache are as follows.
		</div><div class="section" id="idm140119300619184"><div class="titlepage"><div><div><h3 class="title">9.3.1. File system based cache loaders</h3></div></div></div><div class="para">
				JBoss Cache ships with several cache loaders that utilize the file system as a data store. They all require that the <code class="literal">&lt;loader&gt;&lt;properties&gt;</code> configuration element contains a <code class="literal">location</code> property, which maps to a directory to be used as a persistent store (e.g., <code class="literal">location=/tmp/myDataStore</code> ). Used mainly for testing and not recommended for production use.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">FileCacheLoader</code>, which is a simple filesystem-based implementation. By default, this cache loader checks for any potential character portability issues in the location or tree node names, for example invalid characters, producing warning messages. These checks can be disabled adding <code class="literal">check.character.portability</code> property to the <code class="literal">&lt;properties&gt;</code> element and setting it to <code class="literal">false</code> (e.g., <code class="literal">check.character.portability=false</code> ).
					</div><div class="para">
						The FileCacheLoader has some severe limitations which restrict its use in a production environment, or if used in such an environment, it should be used with due care and sufficient understanding of these limitations.
					</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
								Due to the way the FileCacheLoader represents a tree structure on disk (directories and files) traversal is inefficient for deep trees.
							</div></li><li class="listitem"><div class="para">
								Usage on shared filesystems like NFS, Windows shares, etc. should be avoided as these do not implement proper file locking and can cause data corruption.
							</div></li><li class="listitem"><div class="para">
								Usage with an isolation level of NONE can cause corrupt writes as multiple threads attempt to write to the same file.
							</div></li><li class="listitem"><div class="para">
								File systems are inherently not transactional, so when attempting to use your cache in a transactional context, failures when writing to the file (which happens during the commit phase) cannot be recovered.
							</div></li></ul></div><div class="para">
						As a rule of thumb, it is recommended that the FileCacheLoader not be used in a highly concurrent, transactional or stressful environment, and its use is restricted to testing.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">BdbjeCacheLoader</code> , which is a cache loader implementation based on the Oracle/Sleepycat's <a href="http://www.oracle.com/database/berkeley-db/index.html" class="mimir-link-warn" title="Mimir does not include content from: www.oracle.com">BerkeleyDB Java Edition</a>.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">JdbmCacheLoader</code>, which is a cache loader implementation based on the <a href="http://jdbm.sourceforge.net/" class="mimir-link-warn" title="Mimir does not include content from: jdbm.sourceforge.net">JDBM engine</a>, a fast and free alternative to BerkeleyDB.
					</div></li></ul></div><div class="para">
				Note that the BerkeleyDB implementation is much more efficient than the filesystem-based implementation, and provides transactional guarantees, but requires a commercial license if distributed with an application (see <a href="http://www.oracle.com/database/berkeley-db/index.html" class="mimir-link-warn" title="Mimir does not include content from: www.oracle.com">http://www.oracle.com/database/berkeley-db/index.html</a> for details).
			</div></div><div class="section" id="idm140119308069424"><div class="titlepage"><div><div><h3 class="title">9.3.2. Cache loaders that delegate to other caches</h3></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">LocalDelegatingCacheLoader</code> , which enables loading from and storing to another local (same JVM) cache.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">ClusteredCacheLoader</code>, which allows querying of other caches in the same cluster for in-memory data via the same clustering protocols used to replicate data. Writes are <span class="emphasis"><em>not</em></span> 'stored' though, as replication would take care of any updates needed. You need to specify a property called <code class="literal">timeout</code>, a long value telling the cache loader how many milliseconds to wait for responses from the cluster before assuming a null value. For example, <code class="literal">timeout = 3000</code> would use a timeout value of 3 seconds.
					</div></li></ul></div></div><div class="section" id="cl.jdbc"><div class="titlepage"><div><div><h3 class="title">9.3.3. JDBCCacheLoader</h3></div></div></div><div class="para">
				JBossCache is distributed with a JDBC-based cache loader implementation that stores/loads nodes' state into a relational database. The implementing class is <code class="literal">org.jboss.cache.loader.JDBCCacheLoader</code>.
			</div><div class="para">
				The current implementation uses just one table. Each row in the table represents one node and contains three columns: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							column for <code class="literal">Fqn</code> (which is also a primary key column)
						</div></li><li class="listitem"><div class="para">
							column for node contents (attribute/value pairs)
						</div></li><li class="listitem"><div class="para">
							column for parent <code class="literal">Fqn</code>
						</div></li></ul></div>

			</div><div class="para">
				<code class="literal">Fqn</code>s are stored as strings. Node content is stored as a BLOB.
			</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
					JBoss Cache does not impose any limitations on the types of objects used in <code class="literal">Fqn</code> but this implementation of cache loader requires <code class="literal">Fqn</code> to contain only objects of type <code class="literal">java.lang.String</code>. Another limitation for <code class="literal">Fqn</code> is its length. Since <code class="literal">Fqn</code> is a primary key, its default column type is <code class="literal">VARCHAR</code> which can store text values up to some maximum length determined by the database in use.
				</div></div></div><div class="para">
				See <a href="http://www.jboss.org/community/docs/DOC-10864" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">this wiki page</a> for configuration tips with specific database systems.
			</div><div class="section" id="idm140119308050400"><div class="titlepage"><div><div><h4 class="title">9.3.3.1. JDBCCacheLoader configuration</h4></div></div></div><div class="section" id="idm140119308049632"><div class="titlepage"><div><div><h5 class="title">9.3.3.1.1. Table configuration</h5></div></div></div><div class="para">
						Table and column names as well as column types are configurable with the following properties. 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.table.name</em></span> - the name of the table. Can be prepended with schema name for the given table: <code class="literal">{schema_name}.{table_name}</code>. The default value is 'jbosscache'.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.table.primarykey</em></span> - the name of the primary key for the table. The default value is 'jbosscache_pk'.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.table.create</em></span> - can be true or false. Indicates whether to create the table during startup. If true, the table is created if it doesn't already exist. The default value is true.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.table.drop</em></span> - can be true or false. Indicates whether to drop the table during shutdown. The default value is true.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.fqn.column</em></span> - FQN column name. The default value is 'fqn'.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.fqn.type</em></span> - FQN column type. The default value is 'varchar(255)'.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.node.column</em></span> - node contents column name. The default value is 'node'.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.node.type</em></span> - node contents column type. The default value is 'blob'. This type must specify a valid binary data type for the database being used.
								</div></li></ul></div>

					</div></div><div class="section" id="idm140119308035248"><div class="titlepage"><div><div><h5 class="title">9.3.3.1.2. DataSource</h5></div></div></div><div class="para">
						If you are using JBossCache in a managed environment (e.g., an application server) you can specify the JNDI name of the DataSource you want to use. 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.datasource</em></span> - JNDI name of the DataSource. The default value is <code class="literal">java:/DefaultDS</code> .
								</div></li></ul></div>

					</div></div><div class="section" id="idm140119308031296"><div class="titlepage"><div><div><h5 class="title">9.3.3.1.3. JDBC driver</h5></div></div></div><div class="para">
						If you are <span class="emphasis"><em>not</em></span> using DataSource you have the following properties to configure database access using a JDBC driver. 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.driver</em></span> - fully qualified JDBC driver name.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.url</em></span> - URL to connect to the database.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.user</em></span> - user name to connect to the database.
								</div></li><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.password</em></span> - password to connect to the database.
								</div></li></ul></div>

					</div></div><div class="section" id="idm140119308023168"><div class="titlepage"><div><div><h5 class="title">9.3.3.1.4. c3p0 connection pooling</h5></div></div></div><div class="para">
						JBoss Cache implements JDBC connection pooling when running outside of an application server standalone using the c3p0:JDBC DataSources/Resource Pools library. In order to enable it, just edit the following property: 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<span class="emphasis"><em>cache.jdbc.connection.factory</em></span> - Connection factory class name. If not set, it defaults to standard non-pooled implementation. To enable c3p0 pooling, just set the connection factory class for c3p0. See example below.
								</div></li></ul></div>

					</div><div class="para">
						You can also set any c3p0 parameters in the same cache loader properties section but don't forget to start the property name with 'c3p0.'. To find a list of available properties, please check the c3p0 documentation for the c3p0 library version distributed in <a href="http://sourceforge.net/projects/c3p0" class="mimir-link-warn" title="Mimir does not include content from: sourceforge.net">c3p0:JDBC DataSources/Resource Pools</a> . Also, in order to provide quick and easy way to try out different pooling parameters, any of these properties can be set via a System property overriding any values these properties might have in the JBoss Cache XML configuration file, for example: <code class="literal">-Dc3p0.maxPoolSize=20</code> . If a c3p0 property is not defined in either the configuration file or as a System property, default value, as indicated in the c3p0 documentation, will apply.
					</div></div><div class="section" id="idm140119299980400"><div class="titlepage"><div><div><h5 class="title">9.3.3.1.5. Configuration example</h5></div></div></div><div class="para">
						Below is an example of a JDBCCacheLoader using Oracle as database. The CacheLoaderConfiguration XML element contains an arbitrary set of properties which define the database-related configuration.
					</div><pre class="programlisting XML XML">
&lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;node fqn="/some/stuff"/&gt;
      &lt;/preload&gt;
      &lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="true"
              ignoreModifications="false" purgeOnStartup="false"&gt;
         &lt;properties&gt;
            cache.jdbc.table.name=jbosscache
            cache.jdbc.table.create=true
            cache.jdbc.table.drop=true
            cache.jdbc.table.primarykey=jbosscache_pk
            cache.jdbc.fqn.column=fqn
            cache.jdbc.fqn.type=VARCHAR(255)
            cache.jdbc.node.column=node
            cache.jdbc.node.type=BLOB
            cache.jdbc.parent.column=parent
            cache.jdbc.driver=oracle.jdbc.OracleDriver
            cache.jdbc.url=jdbc:oracle:thin:@localhost:1521:JBOSSDB
            cache.jdbc.user=SCOTT
            cache.jdbc.password=TIGER
          &lt;/properties&gt;
      &lt;/loader&gt;
  &lt;/loaders&gt;
</pre><div class="para">
						As an alternative to configuring the entire JDBC connection, the name of an existing data source can be given:
					</div><pre class="programlisting XML XML">
 &lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;node fqn="/some/stuff"/&gt;
      &lt;/preload&gt;
      &lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="true"
              ignoreModifications="false" purgeOnStartup="false"&gt;
         &lt;properties&gt;
            cache.jdbc.datasource=java:/DefaultDS
         &lt;/properties&gt;
      &lt;/loader&gt;
  &lt;/loaders&gt;
</pre><div class="para">
						Configuration example for a cache loader using c3p0 JDBC connection pooling:
					</div><pre class="programlisting XML XML">
 &lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;node fqn="/some/stuff"/&gt;
      &lt;/preload&gt;
      &lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="false" fetchPersistentState="true"
              ignoreModifications="false" purgeOnStartup="false"&gt;
         &lt;properties&gt;
            cache.jdbc.table.name=jbosscache
            cache.jdbc.table.create=true
            cache.jdbc.table.drop=true
            cache.jdbc.table.primarykey=jbosscache_pk
            cache.jdbc.fqn.column=fqn
            cache.jdbc.fqn.type=VARCHAR(255)
            cache.jdbc.node.column=node
            cache.jdbc.node.type=BLOB
            cache.jdbc.parent.column=parent
            cache.jdbc.driver=oracle.jdbc.OracleDriver
            cache.jdbc.url=jdbc:oracle:thin:@localhost:1521:JBOSSDB
            cache.jdbc.user=SCOTT
            cache.jdbc.password=TIGER
            cache.jdbc.connection.factory=org.jboss.cache.loader.C3p0ConnectionFactory
            c3p0.maxPoolSize=20
            c3p0.checkoutTimeout=5000
         &lt;/properties&gt;
      &lt;/loader&gt;
   &lt;/loaders&gt;
</pre></div></div></div><div class="section" id="cl.s3"><div class="titlepage"><div><div><h3 class="title">9.3.4. S3CacheLoader</h3></div></div></div><div class="para">
				The <code class="literal">S3CacheLoader</code> uses the <a href="http://aws.amazon.com/" class="mimir-link-warn" title="Mimir does not include content from: aws.amazon.com">Amazon S3</a> (Simple Storage Solution) for storing cache data. Since Amazon S3 is remote network storage and has fairly high latency, it is really best for caches that store large pieces of data, such as media or files. But consider this cache loader over the JDBC or file system based cache loaders if you want remotely managed, highly reliable storage. Or, use it for applications running on Amazon's EC2 (Elastic Compute Cloud).
			</div><div class="para">
				If you're planning to use Amazon S3 for storage, consider using it with JBoss Cache. JBoss Cache itself provides in-memory caching for your data to minimize the amount of remote access calls, thus reducing the latency and cost of fetching your Amazon S3 data. With cache replication, you are also able to load data from your local cluster without having to remotely access it every time.
			</div><div class="para">
				Note that Amazon S3 does not support transactions. If transactions are used in your application then there is some possibility of state inconsistency when using this cache loader. However, writes are atomic, in that if a write fails nothing is considered written and data is never corrupted.
			</div><div class="para">
				Data is stored in keys based on the Fqn of the Node and Node data is serialized as a java.util.Map using the <code class="literal">CacheSPI.getMarshaller()</code> instance. Read the javadoc on how data is structured and stored. Data is stored using Java serialization. Be aware this means data is not readily accessible over HTTP to non-JBoss Cache clients. Your feedback and help would be appreciated to extend this cache loader for that purpose.
			</div><div class="para">
				With this cache loader, single-key operations such as <code class="literal">Node.remove(Object)</code> and <code class="literal">Node.put(Object, Object)</code> are the slowest as data is stored in a single Map instance. Use bulk operations such as <code class="literal">Node.replaceAll(Map)</code> and <code class="literal">Node.clearData()</code> for more efficiency. Try the <code class="literal">cache.s3.optimize</code> option as well.
			</div><div class="section" id="idm140119299963728"><div class="titlepage"><div><div><h4 class="title">9.3.4.1. Amazon S3 Library</h4></div></div></div><div class="para">
					The S3 cache loader is provided with the default distribution but requires a library to access the service at runtime. This runtime library may be obtained through a Sourceforge Maven Repository. Include the following sections in your pom.xml file:
				</div><pre class="programlisting XML XML">
      &lt;repository&gt;
         &lt;id&gt;e-xml.sourceforge.net&lt;/id&gt;
         &lt;url&gt;http://e-xml.sourceforge.net/maven2/repository&lt;/url&gt;
      &lt;/repository&gt;
        ...
      &lt;dependency&gt;
         &lt;groupId&gt;net.noderunner&lt;/groupId&gt;
         &lt;artifactId&gt;amazon-s3&lt;/artifactId&gt;
         &lt;version&gt;1.0.0.0&lt;/version&gt;
         &lt;scope&gt;runtime&lt;/scope&gt;
      &lt;/dependency&gt;

</pre><div class="para">
					If you do not use Maven, you can still download the amazon-s3 library by navigating the repository or through <a href="http://e-xml.sourceforge.net/maven2/repository/net/noderunner/amazon-s3/1.0.0.0/amazon-s3-1.0.0.0.jar" class="mimir-link-warn" title="Mimir does not include content from: e-xml.sourceforge.net"> this URL</a>.
				</div></div><div class="section" id="idm140119299959824"><div class="titlepage"><div><div><h4 class="title">9.3.4.2. Configuration</h4></div></div></div><div class="para">
					At a minimum, you must configure your Amazon S3 access key and secret access key. The following configuration keys are listed in general order of utility.
				</div><div class="para">
					<div class="itemizedlist"><ul><li class="listitem"><div class="para">
								<code class="literal">cache.s3.accessKeyId</code> - Amazon S3 Access Key, available from your account profile.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.secretAccessKey</code> - Amazon S3 Secret Access Key, available from your account profile. As this is a password, be careful not to distribute it or include this secret key in built software.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.secure</code> - The default is <code class="literal">false</code>: Traffic is sent unencrypted over the public Internet. Set to <code class="literal">true</code> to use HTTPS. Note that unencrypted uploads and downloads use less CPU.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.bucket</code> - Name of the bucket to store data. For different caches using the same access key, use a different bucket name. Read the S3 documentation on the definition of a bucket. The default value is <code class="literal">jboss-cache</code>.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.callingFormat</code> - One of<code class="literal">PATH</code>, <code class="literal">SUBDOMAIN</code>, or <code class="literal">VANITY</code>. Read the S3 documentation on the use of calling domains. The default value is <code class="literal">SUBDOMAIN</code>.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.optimize</code> - The default is <code class="literal">false</code>. If true, <code class="literal">put(Map)</code> operations replace the data stored at an Fqn rather than attempt to fetch and merge. (This option is fairly experimental at the moment.)
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.parentCache</code> - The default is <code class="literal">true</code>. Set this value to <code class="literal">false</code> if you are using multiple caches sharing the same S3 bucket, that remove parent nodes of nodes being created in other caches. (This is not a common use case.)
							</div><div class="para">
								JBoss Cache stores nodes in a tree format and automatically creates intermediate parent nodes as necessary. The S3 cache loader must also create these parent nodes as well to allow for operations such as <code class="literal">getChildrenNames</code> to work properly. Checking if all parent nodes exists for every <code class="literal">put</code> operation is fairly expensive, so by default the cache loader caches the existence of these parent nodes.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">cache.s3.location</code> - This choses a primary storage location for your data to reduce loading and retrieval latency. Set to <code class="literal">EU</code> to store data in Europe. The default is<code class="literal">null</code>, to store data in the United States.
							</div></li></ul></div>

				</div></div></div><div class="section" id="cl.tcp"><div class="titlepage"><div><div><h3 class="title">9.3.5. TcpDelegatingCacheLoader</h3></div></div></div><div class="para">
				This cache loader allows to delegate loads and stores to another instance of JBoss Cache, which could reside (a) in the same address space, (b) in a different process on the same host, or (c) in a different process on a different host.
			</div><div class="para">
				A TcpDelegatingCacheLoader talks to a remote <code class="literal">org.jboss.cache.loader.tcp.TcpCacheServer</code> , which can be a standalone process started on the command line, or embedded as an MBean inside JBoss AS. The <code class="literal">TcpCacheServer</code> has a reference to another JBoss Cache instance, which it can create itself, or which is given to it (e.g. by JBoss, using dependency injection).
			</div><div class="para">
				As of JBoss Cache 2.1.0, the <code class="literal">TcpDelegatingCacheLoader</code> transparently handles reconnects if the connection to the TcpCacheServer is lost.
			</div><div class="para">
				The TcpDelegatingCacheLoader is configured with the host and port of the remote TcpCacheServer, and uses this to communicate to it. In addition, 2 new optional parameters are used to control transparent reconnecting to the TcpCacheServer. The <code class="literal">timeout</code> property (defaults to 5000) specifies the length of time the cache loader must continue retrying to connect to the TcpCacheServer before giving up and throwing an exception. The <code class="literal">reconnectWaitTime</code> (defaults to 500) is how long the cache loader should wait before attempting a reconnect if it detects a communication failure. The last two parameters can be used to add a level of fault tolerance to the cache loader, do deal with TcpCacheServer restarts.
			</div><div class="para">
				The configuration looks as follows:
			</div><pre class="programlisting XML XML">
 &lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;node fqn="/"/&gt;
      &lt;/preload&gt;
      &lt;!-- if passivation is true, only the first cache loader is used; the rest are ignored --&gt;
      &lt;loader class="org.jboss.cache.loader.TcpDelegatingCacheLoader"&gt;
         &lt;properties&gt;
            host=myRemoteServer
            port=7500
            timeout=10000
            reconnectWaitTime=250
         &lt;/properties&gt;
      &lt;/loader&gt;
   &lt;/loaders&gt;
</pre><div class="para">
				This means this instance of JBoss Cache will delegate all load and store requests to the remote TcpCacheServer running on <code class="literal">myRemoteServer:7500</code> .
			</div><div class="para">
				A typical use case could be multiple replicated instances of JBoss Cache in the same cluster, all delegating to the same TcpCacheServer instance. The TcpCacheServer might itself delegate to a database via JDBCCacheLoader, but the point here is that - if we have 5 nodes all accessing the same dataset - they will load the data from the TcpCacheServer, which has do execute one SQL statement per unloaded data set. If the nodes went directly to the database, then we'd have the same SQL executed multiple times. So TcpCacheServer serves as a natural cache in front of the DB (assuming that a network round trip is faster than a DB access (which usually also include a network round trip)).
			</div><div class="para">
				To alleviate single point of failure, we could configure several cache loaders. The first cache loader is a ClusteredCacheLoader, the second a TcpDelegatingCacheLoader, and the last a JDBCacheLoader, effectively defining our cost of access to a cache in increasing order.
			</div></div><div class="section" id="cl.transforming"><div class="titlepage"><div><div><h3 class="title">9.3.6. Transforming Cache Loaders</h3></div></div></div><div class="para">
				The way cached data is written to <code class="literal">FileCacheLoader</code> and <code class="literal">JDBCCacheLoader</code> based cache stores has changed in JBoss Cache 2.0 in such way that these cache loaders now write and read data using the same marhalling framework used to replicate data across the network. Such change is trivial for replication purposes as it just requires the rest of the nodes to understand this format. However, changing the format of the data in cache stores brings up a new problem: how do users, which have their data stored in JBoss Cache 1.x.x format, migrate their stores to JBoss Cache 2.0 format?
			</div><div class="para">
				With this in mind, JBoss Cache 2.0 comes with two cache loader implementations called <code class="literal">org.jboss.cache.loader.TransformingFileCacheLoader</code> and <code class="literal">org.jboss.cache.loader.TransformingJDBCCacheLoader</code> located within the optional jbosscache-cacheloader-migration.jar file. These are one-off cache loaders that read data from the cache store in JBoss Cache 1.x.x format and write data to cache stores in JBoss Cache 2.0 format.
			</div><div class="para">
				The idea is for users to modify their existing cache configuration file(s) momentarily to use these cache loaders and for them to create a small Java application that creates an instance of this cache, recursively reads the entire cache and writes the data read back into the cache. Once the data is transformed, users can revert back to their original cache configuration file(s). In order to help the users with this task, a cache loader migration example has been constructed which can be located under the <code class="literal">examples/cacheloader-migration</code> directory within the JBoss Cache distribution. This example, called <code class="literal">examples.TransformStore</code> , is independent of the actual data stored in the cache as it writes back whatever it was read recursively. It is highly recommended that anyone interested in porting their data run this example first, which contains a <code class="literal">readme.txt</code> file with detailed information about the example itself, and also use it as base for their own application.
			</div></div></div><div class="section" id="cl.pass"><div class="titlepage"><div><div><h2 class="title">9.4. Cache Passivation</h2></div></div></div><div class="para">
			A cache loader can be used to enforce node passivation and activation on eviction in a cache.
		</div><div class="para">
			<span class="emphasis"><em>Cache Passivation</em></span> is the process of removing an object from in-memory cache and writing it to a secondary data store (e.g., file system, database) on eviction. <span class="emphasis"><em>Cache Activation </em></span> is the process of restoring an object from the data store into the in-memory cache when it's needed to be used. In both cases, the configured cache loader will be used to read from the data store and write to the data store.
		</div><div class="para">
			When an eviction policy in effect evicts a node from the cache, if passivation is enabled, a notification that the node is being passivated will be emitted to the cache listeners and the node and its children will be stored in the cache loader store. When a user attempts to retrieve a node that was evicted earlier, the node is loaded (lazy loaded) from the cache loader store into memory. When the node and its children have been loaded, they're removed from the cache loader and a notification is emitted to the cache listeners that the node has been activated.
		</div><div class="para">
			To enable cache passivation/activation, you can set <code class="literal">passivation</code> to true. The default is <code class="literal">false</code> . When passivation is used, only the first cache loader configured is used and all others are ignored.
		</div><div class="section" id="idm140119299911968"><div class="titlepage"><div><div><h3 class="title">9.4.1. Cache Loader Behavior with Passivation Disabled vs. Enabled</h3></div></div></div><div class="para">
				When passivation is disabled, whenever an element is modified, added or removed, then that modification is persisted in the backend store via the cache loader. There is no direct relationship between eviction and cache loading. If you don't use eviction, what's in the persistent store is basically a copy of what's in memory. If you do use eviction, what's in the persistent store is basically a superset of what's in memory (i.e. it includes nodes that have been evicted from memory).
			</div><div class="para">
				When passivation is enabled, there is a direct relationship between eviction and the cache loader. Writes to the persistent store via the cache loader only occur as part of the eviction process. Data is deleted from the persistent store when the application reads it back into memory. In this case, what's in memory and what's in the persistent store are two subsets of the total information set, with no intersection between the subsets.
			</div><div class="para">
				Following is a simple example, showing what state is in RAM and in the persistent store after each step of a 6 step process:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						Insert /A
					</div></li><li class="listitem"><div class="para">
						Insert /B
					</div></li><li class="listitem"><div class="para">
						Eviction thread runs, evicts /A
					</div></li><li class="listitem"><div class="para">
						Read /A
					</div></li><li class="listitem"><div class="para">
						Eviction thread runs, evicts /B
					</div></li><li class="listitem"><div class="para">
						Remove /B
					</div></li></ol></div><div class="para">
				When passivation is disabled:
			</div><pre class="programlisting">
                1) Memory: /A Disk: /A
                2) Memory: /A, /B Disk: /A, /B
                3) Memory: /B Disk: /A, /B
                4) Memory: /A, /B Disk: /A, /B
                5) Memory: /A Disk: /A, /B
                6) Memory: /A Disk: /A
</pre><div class="para">
				When passivation is enabled:
			</div><pre class="programlisting">
                1) Memory: /A Disk:
                2) Memory: /A, /B Disk:
                3) Memory: /B Disk: /A
                4) Memory: /A, /B Disk:
                5) Memory: /A Disk: /B
                6) Memory: /A Disk:
</pre></div></div><div class="section" id="idm140119299899856"><div class="titlepage"><div><div><h2 class="title">9.5. Strategies</h2></div></div></div><div class="para">
			This section discusses different patterns of combining different cache loader types and configuration options to achieve specific outcomes.
		</div><div class="section" id="idm140119299898448"><div class="titlepage"><div><div><h3 class="title">9.5.1. Local Cache With Store</h3></div></div></div><div class="para">
				This is the simplest case. We have a JBoss Cache instance, whose cache mode is <code class="literal">LOCAL</code> , therefore no replication is going on. The cache loader simply loads non-existing elements from the store and stores modifications back to the store. When the cache is started, depending on the <code class="literal">preload</code> element, certain data can be preloaded, so that the cache is partly warmed up.
			</div></div><div class="section" id="idm140119299895936"><div class="titlepage"><div><div><h3 class="title">9.5.2. Replicated Caches With All Caches Sharing The Same Store</h3></div></div></div><div class="para">
				The following figure shows 2 JBoss Cache instances sharing the same backend store:
			</div><div class="figure" id="idm140119299894640"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/b60377e94b80fbc31725773f83a91a85/SharedCacheLoader.png" width="444" alt="2 nodes sharing a backend store" /></div></div><p class="title"><strong>Figure 9.2. 2 nodes sharing a backend store</strong></p></div><div class="para">
				Both nodes have a cache loader that accesses a common shared backend store. This could for example be a shared filesystem (using the FileCacheLoader), or a shared database. Because both nodes access the same store, they don't necessarily need state transfer on startup. 
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Of course they can enable state transfer, if they want to have a warm or hot cache after startup.
					</div></div></div>
				 Rather, the <code class="literal">FetchInMemoryState</code> attribute could be set to false, resulting in a 'cold' cache, that gradually warms up as elements are accessed and loaded for the first time. This would mean that individual caches in a cluster might have different in-memory state at any given time (largely depending on their preloading and eviction strategies).
			</div><div class="para">
				When storing a value, the writer takes care of storing the change in the backend store. For example, if node1 made change C1 and node2 C2, then node1 would tell its cache loader to store C1, and node2 would tell its cache loader to store C2.
			</div></div><div class="section" id="idm140119299888416"><div class="titlepage"><div><div><h3 class="title">9.5.3. Replicated Caches With Only One Cache Having A Store</h3></div></div></div><div class="figure" id="idm140119299887648"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/1c12feb396e1ff5274092012fd2cf381/OnlyOneCacheLoader.png" width="444" alt="2 nodes but only one accesses the backend store" /></div></div><p class="title"><strong>Figure 9.3. 2 nodes but only one accesses the backend store</strong></p></div><div class="para">
				This is a similar case to the previous one, but here only one node in the cluster interacts with a backend store via its cache loader. All other nodes perform in-memory replication. The idea here is all application state is kept in memory in each node, with the existence of multiple caches making the data highly available. (This assumes that a client that needs the data is able to somehow fail over from one cache to another.) The single persistent backend store then provides a backup copy of the data in case all caches in the cluster fail or need to be restarted.
			</div><div class="para">
				Note that here it may make sense for the cache loader to store changes asynchronously, that is <span class="emphasis"><em>not</em></span> on the caller's thread, in order not to slow down the cluster by accessing (for example) a database. This is a non-issue when using asynchronous replication.
			</div><div class="para">
				A weakness with this architecture is that the cache with access to the cache loader becomes a single point of failure. Furthermore, if the cluster is restarted, the cache with the cache loader must be started first (easy to forget). A solution to the first problem is to configure a cache loader on each node, but set the <code class="literal">singletonStore</code> configuration to <code class="literal">true</code>. With this kind of setup, one but only one node will always be writing to a persistent store. However, this complicates the restart problem, as before restarting you need to determine which cache was writing before the shutdown/failure and then start that cache first.
			</div></div><div class="section" id="idm140119299880624"><div class="titlepage"><div><div><h3 class="title">9.5.4. Replicated Caches With Each Cache Having Its Own Store</h3></div></div></div><div class="figure" id="idm140119299879856"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/2c9e8177818c7c6260b592a9ab613dda/LocalCacheLoader.png" width="444" alt="2 nodes each having its own backend store" /></div></div><p class="title"><strong>Figure 9.4. 2 nodes each having its own backend store</strong></p></div><div class="para">
				Here, each node has its own datastore. Modifications to the cache are (a) replicated across the cluster and (b) persisted using the cache loader. This means that all datastores have exactly the same state. When replicating changes synchronously and in a transaction, the two-phase commit protocol takes care that all modifications are replicated and persisted in each datastore, or none is replicated and persisted (atomic updates).
			</div><div class="para">
				Note that JBoss Cache is <span class="emphasis"><em>not</em></span> an XA Resource, that means it doesn't implement recovery. When used with a transaction manager that supports recovery, this functionality is not available.
			</div><div class="para">
				The challenge here is state transfer: when a new node starts it needs to do the following:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						Tell the coordinator (oldest node in a cluster) to send it the state. This is always a full state transfer, overwriting any state that may already be present.
					</div></li><li class="listitem"><div class="para">
						The coordinator then needs to wait until all in-flight transactions have completed. During this time, it will not allow for new transactions to be started.
					</div></li><li class="listitem"><div class="para">
						Then the coordinator asks its cache loader for the entire state using <code class="literal">loadEntireState()</code> . It then sends back that state to the new node.
					</div></li><li class="listitem"><div class="para">
						The new node then tells its cache loader to store that state in its store, overwriting the old state. This is the <code class="literal">CacheLoader.storeEntireState()</code> method
					</div></li><li class="listitem"><div class="para">
						As an option, the transient (in-memory) state can be transferred as well during the state transfer.
					</div></li><li class="listitem"><div class="para">
						The new node now has the same state in its backend store as everyone else in the cluster, and modifications received from other nodes will now be persisted using the local cache loader.
					</div></li></ol></div></div><div class="section" id="idm140119299866704"><div class="titlepage"><div><div><h3 class="title">9.5.5. Hierarchical Caches</h3></div></div></div><div class="para">
				If you need to set up a hierarchy within a single JVM, you can use the <code class="literal">LocalDelegatingCacheLoader</code> . This type of hierarchy can currently only be set up programmatically.
			</div><div class="para">
				Hierarchical caches could also be set up spanning more than one JVM or server, using the <code class="literal">TcpDelegatingCacheLoader</code> . 
				<div class="figure" id="idm140119299864304"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/458abae59743554a90612b3e5706c20e/DelegatingCacheLoader.png" width="444" alt="TCP delegating cache loader" /></div></div><p class="title"><strong>Figure 9.5. TCP delegating cache loader</strong></p></div>

			</div></div><div class="section" id="idm140119299861232"><div class="titlepage"><div><div><h3 class="title">9.5.6. Multiple Cache Loaders</h3></div></div></div><div class="para">
				You can set up more than one cache loader in a chain. Internally, a delegating <code class="literal">ChainingCacheLoader</code> is used, with references to each cache loader you have configured. Use cases vary depending on the type of cache loaders used in the chain. One example is using a filesystem based cache loader, co-located on the same host as the JVM, used as an overflow for memory. This ensures data is available relatively easily and with low cost. An additional remote cache loader, such as a <code class="literal">TcpDelegatingCacheLoader</code> provides resilience between server restarts.
			</div><div class="figure" id="idm140119299858720"><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/a95fb5bebcd827cf3d29d8cf8a85ae06/MultipleCacheLoaders.png" width="444" alt="Multiple cache loaders in a chain" /></div></div><p class="title"><strong>Figure 9.6. Multiple cache loaders in a chain</strong></p></div></div></div></div><div xml:lang="en-US" class="chapter" id="eviction_policies" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Eviction</h2></div></div></div><div class="para">
		Eviction controls JBoss Cache's memory management by restricting how many nodes are allowed to be stored in memory, and for how long. Memory constraints on servers mean caches cannot grow indefinitely, so eviction needs to occur to prevent out of memory errors. Eviction is most often used alongside <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a>.
	</div><div class="section" id="eviction.design"><div class="titlepage"><div><div><h2 class="title">10.1. Design</h2></div></div></div><div class="para">
			Eviction in JBoss Cache is designed around four concepts: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						1. Collecting statistics
					</div></li><li class="listitem"><div class="para">
						2. Determining which nodes to evict
					</div></li><li class="listitem"><div class="para">
						3. How nodes are evicted
					</div></li><li class="listitem"><div class="para">
						4. Eviction threads.
					</div></li></ul></div>
			 In addition, Regions play a key role in eviction, as eviction is always configured on a per-region basis so that different subtrees in the cache can have different eviction characteristics.
		</div><div class="section" id="idm140119305343232"><div class="titlepage"><div><div><h3 class="title">10.1.1. Collecting Statistics</h3></div></div></div><div class="para">
				This is done on the caller's thread whenever anyone interacts with the cache. If eviction is enabled, an <code class="literal">EvictionInterceptor</code> is added to the interceptor chain and events are recorded in an event queue. Events are denoted by the <code class="literal">EvictionEvent</code> class. Event queues are held on specific Regions so each region has its own event queue.
			</div><div class="para">
				This aspect of eviction is not configurable, except that the <code class="literal">EvictionInterceptor</code> is either added to the interceptor chain or not, depending on whether eviction is enabled.
			</div></div><div class="section" id="idm140119306476320"><div class="titlepage"><div><div><h3 class="title">10.1.2. Determining Which Nodes to Evict</h3></div></div></div><div class="para">
				An <code class="literal">EvictionAlgorithm</code> implementation processes the eviction queue to decide which nodes to evict. JBoss Cache ships with a number of implementations, including <code class="literal">FIFOAlgorithm</code>, <code class="literal">LRUAlgorithm</code>, <code class="literal">LFUAlgorithm</code>, etc. Each implementation has a corresponding <code class="literal">EvictionAlgorithmConfig</code> implementation with configuration details for the algorithm.
			</div><div class="para">
				Custom <code class="literal">EvictionAlgorithm</code> implementations can be provided by implementing the interface or extending one of the provided implementations.
			</div><div class="para">
				Algorithms are executed by calling its <code class="literal">process()</code> method and passing in the event queue to process. This is typically done by calling <code class="literal">Region.processEvictionQueues()</code>, which will locate the Algorithm assigned to the region.
			</div></div><div class="section" id="idm140119305066448"><div class="titlepage"><div><div><h3 class="title">10.1.3. How Nodes are Evicted</h3></div></div></div><div class="para">
				Once the <code class="literal">EvictionAlgorithm</code> decides which nodes to evict, it uses an implementation of <code class="literal">EvictionActionPolicy</code> to determine how to evict nodes. This is configurable on a per-region basis, and defaults to <code class="literal">DefaultEvictionActionPolicy</code>, which invokes <code class="literal">Cache.evict()</code> for each node that needs to be evicted.
			</div><div class="para">
				JBoss Cache also ships with <code class="literal">RemoveOnEvictActionPolicy</code>, which calls <code class="literal">Cache.removeNode()</code> for each node that needs to be evicted, instead of <code class="literal">Cache.evict()</code>.
			</div><div class="para">
				Custom <code class="literal">EvictionActionPolicy</code> implementations can be used as well.
			</div></div><div class="section" id="idm140119305946592"><div class="titlepage"><div><div><h3 class="title">10.1.4. Eviction threads</h3></div></div></div><div class="para">
				By default, a single cache-wide eviction thread is used to periodically iterate through registered regions and call <code class="literal">Region.processEvictionQueues()</code> on each region. The frequency with which this thread runs can be configured using the <code class="literal">wakeUpInterval</code> attribute in the <code class="literal">eviction</code> configuration element, and defaults to 5000 milliseconds if not specified.
			</div><div class="para">
				The eviction thread can be disabled by setting <code class="literal">wakeUpInterval</code> to <code class="literal">0</code>. This can be useful if you have your own periodic maintenance thread running and would like to iterate through regions and call <code class="literal">Region.processEvictionQueues()</code> yourself.
			</div></div></div><div class="section" id="regions"><div class="titlepage"><div><div><h2 class="title">10.2. Eviction Regions</h2></div></div></div><div class="para">
			The concept of regions and the <code class="literal">Region</code> class were <a class="xref" href="#architecture.regions">Section 7.6, “Class Loading and Regions”</a> when talking about marshalling. Regions are also used to define the eviction behavior for nodes within that region. In addition to using a region-specific configuration, you can also configure default, cache-wide eviction behavior for nodes that do not fall into predefined regions or if you do not wish to define specific regions. It is important to note that when defining regions using the configuration XML file, all elements of the <code class="literal">Fqn</code> that defines the region are <code class="literal">String</code> objects.
		</div><div class="para">
			For each region, you can define eviction parameters.
		</div><div class="para">
			It's possible to define regions that overlap. In other words, one region can be defined for <code class="literal">/a/b/c</code>, and another defined for <code class="literal">/a/b/c/d</code> (which is just the <span class="emphasis"><em>d</em></span> subtree of the <code class="literal">/a/b/c</code> sub-tree). The algorithm, in order to handle scenarios like this consistently, will always choose the first region it encounters. In this way, if the algorithm needed to decide how to handle node <code class="literal">/a/b/c/d/e</code>, it would start from there and work its way up the tree until it hits the first defined region - in this case <code class="literal">/a/b/c/d</code>.
		</div><div class="section" id="idm140119308244912"><div class="titlepage"><div><div><h3 class="title">10.2.1. Resident Nodes</h3></div></div></div><div class="para">
				Nodes marked as resident (using <code class="literal">Node.setResident()</code> API) will be ignored by the eviction policies both when checking whether to trigger the eviction and when proceeding with the actual eviction of nodes. E.g. if a region is configured to have a maximum of 10 nodes, resident nodes won't be counted when deciding whether to evict nodes in that region. In addition, resident nodes will not be considered for eviction when the region's eviction threshold is reached.
			</div><div class="para">
				In order to mark a node as resident the <code class="literal">Node.setResident()</code> API should be used. By default, the newly created nodes are not resident. The <code class="literal">resident</code> attribute of a node is neither replicated, persisted nor transaction-aware.
			</div><div class="para">
				A sample use case for resident nodes would be ensuring "path" nodes don't add "noise" to an eviction policy. E.g.,:
			</div><pre class="programlisting JAVA JAVA">
...
   Map lotsOfData = generateData();
   cache.put("/a/b/c", lotsOfData);
   cache.getRoot().getChild("/a").setResident(true);
   cache.getRoot().getChild("/a/b").setResident(true);
...
</pre><div class="para">
				In this example, the nodes <code class="literal">/a</code> and <code class="literal">/a/b</code> are paths which exist solely to support the existence of node <code class="literal">/a/b/c</code> and don't hold any data themselves. As such, they are good candidates for being marked as resident. This would lead to better memory management as no eviction events would be generated when accessing <code class="literal">/a</code> and<code class="literal">/a/b</code>.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					When adding attributes to a resident node, e.g. <code class="literal">cache.put("/a", "k", "v")</code> in the above example, it would make sense to mark the nodes as non-resident again and let them be considered for eviction.
				</div></div></div></div></div><div class="section" id="idm140119312890016"><div class="titlepage"><div><div><h2 class="title">10.3. Configuring Eviction</h2></div></div></div><div class="section" id="eviction.basic_cfg"><div class="titlepage"><div><div><h3 class="title">10.3.1. Basic Configuration</h3></div></div></div><div class="para">
				The basic eviction configuration element looks like:
			</div><pre class="programlisting XML XML">
   ...
   &lt;eviction wakeUpInterval="500" eventQueueSize="100000"&gt;
      &lt;default algorithmClass="org.jboss.cache.eviction.LRUAlgorithm"&gt;
         &lt;property name="maxNodes" value="5000" /&gt;
         &lt;property name="timeToLive" value="1000" /&gt;
      &lt;/default&gt;
   &lt;/eviction&gt;
   ...
</pre><div class="para">
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">wakeUpInterval</code> - this required parameter defines how often the eviction thread runs, in milliseconds.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">eventQueueSize</code> - this optional parameter defines the size of the bounded queue which holds eviction events. If your eviction thread does not run often enough, you may find that the event queue fills up. It may then be necessary to get your eviction thread to run more frequently, or increase the size of your event queue. This configuration is just the <span class="emphasis"><em>default</em></span> event queue size, and can be overridden in specific eviction regions. If not specified, this defaults to <code class="literal">200000</code>.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">algorithmClass</code> - this is required, unless you set individual <code class="literal">algorithmClass</code> attributes on each and every region. This defines the default eviction algorithm to use if one is not defined for a region.
						</div></li><li class="listitem"><div class="para">
							Algorithm configuration attributes - these are specific to the algorithm specified in <code class="literal">algorithmClass</code>. See the section specific to the algorithm you are interested in for details.
						</div></li></ul></div>

			</div></div><div class="section" id="idm140119299362400"><div class="titlepage"><div><div><h3 class="title">10.3.2. Programmatic Configuration</h3></div></div></div><div class="para">
				Configuring eviction using the <code class="literal">Configuration</code> object entails the use of the <code class="literal">org.jboss.cache.config.EvictionConfig</code> bean, which is passed into <code class="literal">Configuration.setEvictionConfig()</code>. See the <a class="xref" href="#configuration">Chapter 3, <em>Configuration</em></a> for more on building a <code class="literal">Configuration</code> programatically.
			</div><div class="para">
				The use of simple POJO beans to represent all elements in a cache's configuration also makes it fairly easy to programatically add eviction regions after the cache is started. For example, assume we had an existing cache configured via XML with the EvictionConfig element shown above. Now at runtime we wished to add a new eviction region named "/org/jboss/fifo", using <code class="literal">LRUAlgorithm</code> but a different number of <code class="literal">maxNodes</code>:
			</div><pre class="programlisting JAVA JAVA">
   Fqn fqn = Fqn.fromString("/org/jboss/fifo");

   // Create a configuration for an LRUPolicy
   LRUAlgorithmConfig lruc = new LRUAlgorithmConfig();
   lruc.setMaxNodes(10000);

   // Create an eviction region config
   EvictionRegionConfig erc = new EvictionRegionConfig(fqn, lruc);

   // Create the region and set the config
   Region region = cache.getRegion(fqn, true);
   region.setEvictionRegionConfig(erc);
</pre></div></div><div class="section" id="eviction.shipped"><div class="titlepage"><div><div><h2 class="title">10.4. Shipped Eviction Policies</h2></div></div></div><div class="para">
			This section details the different algorithms shipped with JBoss Cache, and the various configuration parameters used for each algorithm.
		</div><div class="section" id="idm140119299353936"><div class="titlepage"><div><div><h3 class="title">10.4.1. LRUAlgorithm - Least Recently Used</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.LRUAlgorithm</code> controls both the node lifetime and age. This policy guarantees a constant order ( <code class="literal">O (1)</code> ) for adds, removals and lookups (visits). It has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">timeToLive</code> - The amount of time a node is not written to or read (in milliseconds) before the node is swept away. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">maxAge</code> - Lifespan of a node (in milliseconds) regardless of idle time before the node is swept away. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minTimeToLive</code> - the minimum amount of time a node must be allowed to live after being accessed before it is allowed to be considered for eviction. 0 denotes that this feature is disabled, which is the default value.
					</div></li></ul></div></div><div class="section" id="idm140119300018768"><div class="titlepage"><div><div><h3 class="title">10.4.2. FIFOAlgorithm - First In, First Out</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.FIFOAlgorithm</code> controls the eviction in a proper first in first out order. This policy guarantees a constant order ( <code class="literal">O (1)</code> ) for adds, removals and lookups (visits). It has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minTimeToLive</code> - the minimum amount of time a node must be allowed to live after being accessed before it is allowed to be considered for eviction. 0 denotes that this feature is disabled, which is the default value.
					</div></li></ul></div></div><div class="section" id="idm140119300012848"><div class="titlepage"><div><div><h3 class="title">10.4.3. MRUAlgorithm - Most Recently Used</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.MRUAlgorithm</code> controls the eviction in based on most recently used algorithm. The most recently used nodes will be the first to evict with this policy. This policy guarantees a constant order ( <code class="literal">O (1)</code> ) for adds, removals and lookups (visits). It has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minTimeToLive</code> - the minimum amount of time a node must be allowed to live after being accessed before it is allowed to be considered for eviction. 0 denotes that this feature is disabled, which is the default value.
					</div></li></ul></div></div><div class="section" id="idm140119299329776"><div class="titlepage"><div><div><h3 class="title">10.4.4. LFUAlgorithm - Least Frequently Used</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.LFUAlgorithm</code> controls the eviction in based on least frequently used algorithm. The least frequently used nodes will be the first to evict with this policy. Node usage starts at 1 when a node is first added. Each time it is visited, the node usage counter increments by 1. This number is used to determine which nodes are least frequently used. LFU is also a sorted eviction algorithm. The underlying EvictionQueue implementation and algorithm is sorted in ascending order of the node visits counter. This class guarantees a constant order ( <code class="literal">O (1)</code> ) for adds, removal and searches. However, when any number of nodes are added/visited to the queue for a given processing pass, a single quasilinear ( <code class="literal">O (n * log n)</code> ) operation is used to resort the queue in proper LFU order. Similarly if any nodes are removed or evicted, a single linear ( <code class="literal">O (n)</code> ) pruning operation is necessary to clean up the EvictionQueue. LFU has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minNodes</code> - This is the minimum number of nodes allowed in this region. This value determines what the eviction queue should prune down to per pass. e.g. If minNodes is 10 and the cache grows to 100 nodes, the cache is pruned down to the 10 most frequently used nodes when the eviction timer makes a pass through the eviction algorithm.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minTimeToLive</code> - the minimum amount of time a node must be allowed to live after being accessed before it is allowed to be considered for eviction. 0 denotes that this feature is disabled, which is the default value.
					</div></li></ul></div></div><div class="section" id="idm140119299320208"><div class="titlepage"><div><div><h3 class="title">10.4.5. ExpirationAlgorithm</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.ExpirationAlgorithm</code> is a policy that evicts nodes based on an absolute expiration time. The expiration time is indicated using the <code class="literal">org.jboss.cache.Node.put()</code> method, using a String key <code class="literal">expiration</code> and the absolute time as a <code class="literal">java.lang.Long</code> object, with a value indicated as milliseconds past midnight January 1st, 1970 UTC (the same relative time as provided by <code class="literal">java.lang.System.currentTimeMillis()</code> ).
			</div><div class="para">
				This policy guarantees a constant order ( <code class="literal">O (1)</code> ) for adds and removals. Internally, a sorted set (TreeSet) containing the expiration time and Fqn of the nodes is stored, which essentially functions as a heap.
			</div><div class="para">
				This policy has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">expirationKeyName</code> - This is the Node key name used in the eviction algorithm. The configuration default is <code class="literal">expiration</code> .
					</div></li><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li></ul></div><div class="para">
				The following listing shows how the expiration date is indicated and how the policy is applied:
			</div><pre class="programlisting JAVA JAVA">
   Cache cache = DefaultCacheFactory.createCache();
   Fqn fqn1 = Fqn.fromString("/node/1");
   Long future = new Long(System.currentTimeMillis() + 2000);

   // sets the expiry time for a node
   cache.getRoot().addChild(fqn1).put(ExpirationConfiguration.EXPIRATION_KEY, future);

   assertTrue(cache.getRoot().hasChild(fqn1));
   Thread.sleep(5000);

   // after 5 seconds, expiration completes
   assertFalse(cache.getRoot().hasChild(fqn1));
</pre><div class="para">
				Note that the expiration time of nodes is only checked when the region manager wakes up every <code class="literal">wakeUpIntervalSeconds</code> , so eviction may happen a few seconds later than indicated.
			</div></div><div class="section" id="idm140119299308320"><div class="titlepage"><div><div><h3 class="title">10.4.6. ElementSizeAlgorithm - Eviction based on number of key/value pairs in a node</h3></div></div></div><div class="para">
				<code class="literal">org.jboss.cache.eviction.ElementSizeAlgorithm</code> controls the eviction in based on the number of key/value pairs in the node. Nodes The most recently used nodes will be the first to evict with this policy. It has the following configuration parameters:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">maxNodes</code> - This is the maximum number of nodes allowed in this region. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">maxElementsPerNode</code> - This is the trigger number of attributes per node for the node to be selected for eviction. 0 denotes immediate expiry, -1 denotes no limit.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">minTimeToLive</code> - the minimum amount of time a node must be allowed to live after being accessed before it is allowed to be considered for eviction. 0 denotes that this feature is disabled, which is the default value.
					</div></li></ul></div></div></div></div><div xml:lang="en-US" class="chapter" id="transactions" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 11. Transactions and Concurrency</h2></div></div></div><div class="section" id="transactions.concurrent"><div class="titlepage"><div><div><h2 class="title">11.1. Concurrent Access</h2></div></div></div><div class="para">
			JBoss Cache is a thread safe caching API, and uses its own efficient mechanisms of controlling concurrent access. It uses an innovative implementation of multi-versioned concurrency control (<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" class="mimir-link-warn" title="Mimir does not include content from: en.wikipedia.org">MVCC</a>) as the default locking scheme. Versions of JBoss Cache prior to 3.x offered Optimistic and Pessimistic Locking schemes, both of which are now deprecated in favor of MVCC.
		</div><div class="section" id="transactions.locks.mvcc"><div class="titlepage"><div><div><h3 class="title">11.1.1. Multi-Version Concurrency Control (MVCC)</h3></div></div></div><div class="para">
				<a href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control" class="mimir-link-warn" title="Mimir does not include content from: en.wikipedia.org">MVCC</a> is a locking scheme commonly used by modern database implementations to control fast, safe concurrent access to shared data.
			</div><div class="section" id="mvcc.concepts"><div class="titlepage"><div><div><h4 class="title">11.1.1.1. MVCC Concepts</h4></div></div></div><div class="para">
					MVCC is designed to provide the following features for concurrent access:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Readers that don't block writers
						</div></li><li class="listitem"><div class="para">
							Writers that fail fast
						</div></li></ul></div><div class="para">
					and achieves this by using data versioning and copying for concurrent writers. The theory is that readers continue reading shared state, while writers copy the shared state, increment a version id, and write that shared state back after verifying that the version is still valid (i.e., another concurrent writer has not changed this state first).
				</div><div class="para">
					This allows readers to continue reading while not preventing writers from writing, and repeatable read semantics are maintained by allowing readers to read off the old version of the state.
				</div></div><div class="section" id="mvcc.impl"><div class="titlepage"><div><div><h4 class="title">11.1.1.2. MVCC Implementation</h4></div></div></div><div class="para">
					JBoss Cache's implementation of MVCC is based on a few features:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Readers don't acquire any locks
						</div></li><li class="listitem"><div class="para">
							Only one additional version is maintained for shared state, for a single writer
						</div></li><li class="listitem"><div class="para">
							All writes happen sequentially, to provide fail-fast semantics
						</div></li></ul></div><div class="para">
					The extremely high performance of JBoss Cache's MVCC implementation for reading threads is achieved by not requiring any synchronization or locking for readers. For each reader thread, the <code class="literal">MVCCLockingInterceptor</code> wraps state in a lightweight container object, which is placed in the thread's <code class="literal">InvocationContext</code> (or <code class="literal">TransactionContext</code> if running in a transaction). All subsequent operations on the state happens via the container object. This use of Java references allows for repeatable read semantics even if the actual state changes simultaneously.
				</div><div class="para">
					Writer threads, on the other hand, need to acquire a lock before any writing can commence. Currently, we use lock striping to improve the memory performance of the cache, and the size of the shared lock pool can be tuned using the <code class="literal">concurrencyLevel</code> attribute of the <code class="literal">locking</code> element. See the <a class="xref" href="#configuration_reference_chapter">Chapter 12, <em>Configuration References</em></a> for details. After acquiring an exclusive lock on an Fqn, the writer thread then wraps the state to be modified in a container as well, just like with reader threads, and then copies this state for writing. When copying, a reference to the original version is still maintained in the container (for rollbacks). Changes are then made to the copy and the copy is finally written to the data structure when the write completes.
				</div><div class="para">
					This way, subsequent readers see the new version while existing readers still hold a reference to the original version in their context.
				</div><div class="para">
					If a writer is unable to acquire the write lock after some time, a <code class="literal">TimeoutException</code> is thrown. This lock acquisition timeout defaults to 10000 millis and can be configured using the <code class="literal">lockAcquisitionTimeout</code> attribute of the <code class="literal">locking</code> element. See the <a class="xref" href="#configuration_reference_chapter">Chapter 12, <em>Configuration References</em></a> for details.
				</div><div class="section" id="mvcc.iso"><div class="titlepage"><div><div><h5 class="title">11.1.1.2.1. Isolation Levels</h5></div></div></div><div class="para">
						JBoss Cache 3.x supports two isolation levels: REPEATABLE_READ and READ_COMMITTED, which correspond in semantic to <a href="http://en.wikipedia.org/wiki/Isolation_level" class="mimir-link-warn" title="Mimir does not include content from: en.wikipedia.org">database-style isolation levels</a>. Previous versions of JBoss Cache supported all 5 database isolation levels, and if an unsupported isolation level is configured, it is either upgraded or downgraded to the closest supported level.
					</div><div class="para">
						REPEATABLE_READ is the default isolation level, to maintain compatibility with previous versions of JBoss Cache. READ_COMMITTED, while providing a slightly weaker isolation, has a significant performance benefit over REPEATABLE_READ.
					</div></div><div class="section" id="mvcc.writeskew"><div class="titlepage"><div><div><h5 class="title">11.1.1.2.2. Concurrent Writers and Write-Skews</h5></div></div></div><div class="para">
						Although MVCC forces writers to obtain a write lock, a phenomenon known as write skews may occur when using REPEATABLE_READ:
					</div><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/548187a709fbc97719593540020f28b1/writeskew.png" width="444" /></div><div class="para">
						This happens when concurrent transactions performing a read and then a write, based on the value that was read. Since reads involve holding on to the reference to the state in the transaction context, a subsequent write would work off that original state read, which may now be stale.
					</div><div class="para">
						The default behavior with dealing with a write skew is to throw a <code class="literal">DataVersioningException</code>, when it is detected when copying state for writing. However, in most applications, a write skew may not be an issue (for example, if the state written has no relationship to the state originally read) and should be allowed. If your application does not care about write skews, you can allow them to happen by setting the <code class="literal">writeSkewCheck</code> configuration attribute to <code class="literal">false</code>. See the <a class="xref" href="#configuration_reference_chapter">Chapter 12, <em>Configuration References</em></a> for details.
					</div><div class="para">
						Note that write skews cannot happen when using READ_COMMITTED since threads always work off committed state.
					</div></div></div><div class="section" id="mvcc.cfg"><div class="titlepage"><div><div><h4 class="title">11.1.1.3. Configuring Locking</h4></div></div></div><div class="para">
					Configuring MVCC involves using the <code class="literal">&lt;locking /&gt; </code> configuration tag, as follows:
				</div><pre class="programlisting XML XML">
   &lt;locking
      isolationLevel="REPEATABLE_READ"
      lockAcquisitionTimeout="10234"
      nodeLockingScheme="mvcc"
      writeSkewCheck="false"
      concurrencyLevel="1000" /&gt;
</pre><div class="para">
					<div class="itemizedlist"><ul><li class="listitem"><div class="para">
								<code class="literal">nodeLockingScheme</code> - the node locking scheme used. Defaults to MVCC if not provided, deprecated schemes such as <code class="literal">pessimistic</code> or <code class="literal">optimistic</code> may be used but is not encouraged.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">isolationLevel</code> - transaction isolation level. Defaults to REPEATABLE_READ if not provided.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">writeSkewCheck</code> - defaults to <code class="literal">true</code> if not provided.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">concurrencyLevel</code> - defaults to 500 if not provided.
							</div></li><li class="listitem"><div class="para">
								<code class="literal">lockAcquisitionTimeout</code> - only applies to writers when using MVCC. Defaults to 10000 if not provided.
							</div></li></ul></div>

				</div></div></div><div class="section" id="transactions.locks.dep"><div class="titlepage"><div><div><h3 class="title">11.1.2. Pessimistic and Optimistic Locking Schemes</h3></div></div></div><div class="para">
				From JBoss Cache 3.x onwards, pessimistic and optimistic locking schemes are deprecated in favor of <a class="xref" href="#transactions.locks.mvcc">Section 11.1.1, “Multi-Version Concurrency Control (MVCC)”</a>. It is recommended that existing applications move off these legacy locking schemes as support for them will eventually be dropped altogether in future releases.
			</div><div class="para">
				Documentation for legacy locking schemes are not included in this user guide, and if necessary, can be referenced in previous versions of this document, which can be found on <a href="http://www.jboss.org/jbosscache" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">the JBoss Cache website</a>.
			</div></div></div><div class="section" id="transactions.jta"><div class="titlepage"><div><div><h2 class="title">11.2. JTA Support</h2></div></div></div><div class="para">
			JBoss Cache can be configured to use and participate in <a href="http://java.sun.com/javaee/technologies/jta/" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">JTA</a> compliant transactions. Alternatively, if transaction support is disabled, it is equivalent to using autocommit in JDBC calls, where modifications are potentially replicated after every change (if replication is enabled).
		</div><div class="para">
			What JBoss Cache does on every incoming call is:
		</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
					Retrieve the current <code class="literal">javax.transaction.Transaction</code> associated with the thread
				</div></li><li class="listitem"><div class="para">
					If not already done, register a <code class="literal">javax.transaction.Synchronization</code> with the transaction manager to be notified when a transaction commits or is rolled back.
				</div></li></ol></div><div class="para">
			In order to do this, the cache has to be provided with a reference to environment's <code class="literal">javax.transaction.TransactionManager</code>. This is usually done by configuring the cache with the class name of an implementation of the <code class="literal">TransactionManagerLookup</code> interface. When the cache starts, it will create an instance of this class and invoke its <code class="literal">getTransactionManager()</code> method, which returns a reference to the <code class="literal">TransactionManager</code>.
		</div><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-JBoss_Cache_User_Guide-en-US/images/d40805abc53d186a0d0eb5377caa45ed/TransactionLookup.png" width="444" /></div><div class="para">
			JBoss Cache ships with <code class="literal">JBossTransactionManagerLookup</code> and <code class="literal">GenericTransactionManagerLookup</code>. The <code class="literal">JBossTransactionManagerLookup</code> is able to bind to a running JBoss AS instance and retrieve a <code class="literal">TransactionManager</code> while the <code class="literal">GenericTransactionManagerLookup</code> is able to bind to most popular Java EE application servers and provide the same functionality. A dummy implementation - <code class="literal">DummyTransactionManagerLookup</code> - is also provided for unit tests. Being a dummy, this is not recommended for production use a it has some severe limitations to do with concurrent transactions and recovery.
		</div><div class="para">
			An alternative to configuring a <code class="literal">TransactionManagerLookup</code> is to programatically inject a reference to the <code class="literal">TransactionManager</code> into the <code class="literal">Configuration</code> object's <code class="literal">RuntimeConfig</code> element:
		</div><pre class="programlisting JAVA JAVA">
   TransactionManager tm = getTransactionManager(); // magic method
   cache.getConfiguration().getRuntimeConfig().setTransactionManager(tm);
</pre><div class="para">
			Injecting the <code class="literal">TransactionManager</code> is the recommended approach when the <code class="literal">Configuration</code> is built by some sort of IOC container that already has a reference to the <code class="literal">TransactionManager</code>.
		</div><div class="para">
			When the transaction commits, we initiate either a one-phase or two-phase commit protocol. See <a class="xref" href="#replication.tx">Section 8.1.2.1, “Replicated Caches and Transactions”</a> for details.
		</div></div></div></div><div class="part" id="idm140119323312560"><div class="titlepage"><div><div><h1 class="title">Part III. JBoss Cache Configuration References</h1></div></div></div><div class="partintro" id="idm140119323311440"><div><!--Empty--></div><div class="para">
				This section contains technical references for easy looking up.
			</div></div><div xml:lang="en-US" class="chapter" id="configuration_reference_chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 12. Configuration References</h2></div></div></div><div class="section" id="sample_xml_file"><div class="titlepage"><div><div><h2 class="title">12.1. Sample XML Configuration File</h2></div></div></div><div class="para">
			This is what a typical XML configuration file looks like. It is recommended that you use one of the configurations shipped with the JBoss Cache distribution and tweak according to your needs rather than write one from scratch.
		</div><pre class="programlisting XML XML">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;jbosscache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="urn:jboss:jbosscache-core:config:3.1"&gt;


   &lt;!--
      isolation levels supported: READ_COMMITTED and REPEATABLE_READ
      nodeLockingSchemes: mvcc, pessimistic (deprecated), optimistic (deprecated)
   --&gt;
   &lt;locking
         isolationLevel="REPEATABLE_READ"
         lockParentForChildInsertRemove="false"
         lockAcquisitionTimeout="20000"
         nodeLockingScheme="mvcc"
         writeSkewCheck="false"
         useLockStriping="true"
         concurrencyLevel="500"/&gt;

   &lt;!--
      Used to register a transaction manager and participate in ongoing transactions.
      --&gt;
   &lt;transaction
         transactionManagerLookupClass="org.jboss.cache.transaction.GenericTransactionManagerLookup"
         syncRollbackPhase="false"
         syncCommitPhase="false"/&gt;

   &lt;!--
      Used to register JMX statistics in any available MBean server
      --&gt;
   &lt;jmxStatistics
         enabled="false"/&gt;

   &lt;!--
      If region based marshalling is used, defines whether new regions are inactive on startup.
   --&gt;
   &lt;startup
         regionsInactiveOnStartup="true"/&gt;

   &lt;!--
      Used to register JVM shutdown hooks.
      hookBehavior: DEFAULT, REGISTER, DONT_REGISTER
   --&gt;
   &lt;shutdown
         hookBehavior="DEFAULT"/&gt;

   &lt;!--
      Used to define async listener notification thread pool size
   --&gt;
   &lt;listeners
         asyncPoolSize="1"
         asyncQueueSize="100000"/&gt;

   &lt;!--
      Used to enable invocation batching and allow the use of Cache.startBatch()/endBatch() methods.
   --&gt;
   &lt;invocationBatching
         enabled="false"/&gt;

   &lt;!--
      serialization related configuration, used for replication and cache loading
   --&gt;
   &lt;serialization
         objectInputStreamPoolSize="12"
         objectOutputStreamPoolSize="14"
         version="3.0.0"
         marshallerClass="org.jboss.cache.marshall.VersionAwareMarshaller"
         useLazyDeserialization="false"
         useRegionBasedMarshalling="false"/&gt;

   &lt;!--
      This element specifies that the cache is clustered.
      modes supported: replication (r) or invalidation (i).
   --&gt;
   &lt;clustering mode="replication" clusterName="JBossCache-cluster"&gt;

      &lt;!--
         Defines whether to retrieve state on startup
      --&gt;
      &lt;stateRetrieval timeout="20000" fetchInMemoryState="false"/&gt;

      &lt;!--
         Network calls are synchronous.
      --&gt;
      &lt;sync replTimeout="20000"/&gt;
      &lt;!--
         Uncomment this for async replication.
      --&gt;
      &lt;!--&lt;async useReplQueue="true" replQueueInterval="10000" replQueueMaxElements="500" serializationExecutorPoolSize="20" serializationExecutorQueueSize="5000000"/&gt;--&gt;

      &lt;!-- Uncomment to use Buddy Replication --&gt;
      &lt;!--
      &lt;buddy enabled="true" poolName="myBuddyPoolReplicationGroup" communicationTimeout="2000"&gt;
         &lt;dataGravitation auto="true" removeOnFind="true" searchBackupTrees="true"/&gt;
         &lt;locator class="org.jboss.cache.buddyreplication.NextMemberBuddyLocator"&gt;
            &lt;properties&gt;
               numBuddies = 1
               ignoreColocatedBuddies = true
            &lt;/properties&gt;
         &lt;/locator&gt;
      &lt;/buddy&gt;
      --&gt;

      &lt;!--
         Configures the JGroups channel.  Looks up a JGroups config file on the classpath or filesystem.  udp.xml
         ships with jgroups.jar and will be picked up by the class loader.
      --&gt;
      &lt;jgroupsConfig configFile="udp.xml"&gt;
         &lt;!-- uncomment to define a JGroups stack here

         &lt;PING timeout="2000" num_initial_members="3"/&gt;
         &lt;MERGE2 max_interval="30000" min_interval="10000"/&gt;
         &lt;FD_SOCK/&gt;
         &lt;FD timeout="10000" max_tries="5" shun="true"/&gt;
         &lt;VERIFY_SUSPECT timeout="1500"/&gt;
         &lt;pbcast.NAKACK use_mcast_xmit="false" gc_lag="0"
                        retransmit_timeout="300,600,1200,2400,4800"
                        discard_delivered_msgs="true"/&gt;
         &lt;UNICAST timeout="300,600,1200,2400,3600"/&gt;
         &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000"
                        max_bytes="400000"/&gt;
         &lt;pbcast.GMS print_local_addr="true" join_timeout="5000" shun="false"
                     view_bundling="true" view_ack_collection_timeout="5000"/&gt;
         &lt;FRAG2 frag_size="60000"/&gt;
         &lt;pbcast.STREAMING_STATE_TRANSFER use_reading_thread="true"/&gt;
         &lt;pbcast.FLUSH timeout="0"/&gt;
          --&gt;
      &lt;/jgroupsConfig&gt;
   &lt;/clustering&gt;

   &lt;!--
      Eviction configuration.  WakeupInterval defines how often the eviction thread runs, in milliseconds.  0 means
      the eviction thread will never run.
   --&gt;
   &lt;eviction wakeUpInterval="500"&gt;
      &lt;default algorithmClass="org.jboss.cache.eviction.LRUAlgorithm" eventQueueSize="200000"&gt;
         &lt;property name="maxNodes" value="5000" /&gt;
         &lt;property name="timeToLive" value="1000" /&gt;
      &lt;/default&gt;
      &lt;region name="/org/jboss/data1"&gt;
         &lt;property name="timeToLive" value="2000" /&gt;
      &lt;/region&gt;
      &lt;region name="/org/jboss/data2" algorithmClass="org.jboss.cache.eviction.FIFOAlgorithm" eventQueueSize="100000"&gt;
         &lt;property name="maxNodes" value="3000" /&gt;
         &lt;property name="minTimeToLive" value="4000" /&gt;
      &lt;/region&gt;
   &lt;/eviction&gt;

   &lt;!--
      Cache loaders.

      If passivation is enabled, state is offloaded to the cache loaders ONLY when evicted.  Similarly, when the state
      is accessed again, it is removed from the cache loader and loaded into memory.

      Otherwise, state is always maintained in the cache loader as well as in memory.

      Set 'shared' to true if all instances in the cluster use the same cache loader instance, e.g., are talking to the
      same database.
   --&gt;
   &lt;loaders passivation="false" shared="false"&gt;
      &lt;preload&gt;
         &lt;node fqn="/org/jboss"/&gt;
         &lt;node fqn="/org/tempdata"/&gt;
      &lt;/preload&gt;

      &lt;!--
         we can have multiple cache loaders, which get chained
      --&gt;
      &lt;loader class="org.jboss.cache.loader.JDBCCacheLoader" async="true" fetchPersistentState="true"
              ignoreModifications="true" purgeOnStartup="true"&gt;
         &lt;properties&gt;
            cache.jdbc.table.name=jbosscache
            cache.jdbc.table.create=true
            cache.jdbc.table.drop=true
         &lt;/properties&gt;
         &lt;singletonStore enabled="true" class="org.jboss.cache.loader.SingletonStoreCacheLoader"&gt;
            &lt;properties&gt;
               pushStateWhenCoordinator=true
               pushStateWhenCoordinatorTimeout=20000
            &lt;/properties&gt;
         &lt;/singletonStore&gt;
      &lt;/loader&gt;
   &lt;/loaders&gt;

   &lt;!--
      Define custom interceptors.  All custom interceptors need to extend org.jboss.cache.interceptors.base.CommandInterceptor
   --&gt;
   &lt;!--
   &lt;customInterceptors&gt;
      &lt;interceptor position="first" 
        class="org.jboss.cache.config.parsing.custominterceptors.AaaCustomInterceptor"&gt;
         &lt;property name="attrOne" value="value1" /&gt;
         &lt;property name="attrTwo" value="value2" /&gt;
      &lt;/interceptor&gt;
      &lt;interceptor position="last" 
        class="org.jboss.cache.config.parsing.custominterceptors.BbbCustomInterceptor"/&gt;
      &lt;interceptor index="3" 
        class="org.jboss.cache.config.parsing.custominterceptors.AaaCustomInterceptor"/&gt;
      &lt;interceptor before="org.jboss.cache.interceptors.CallInterceptor"
        class="org.jboss.cache.config.parsing.custominterceptors.BbbCustomInterceptor"/&gt;
      &lt;interceptor after="org.jboss.cache.interceptors.CallInterceptor"
        class="org.jboss.cache.config.parsing.custominterceptors.AaaCustomInterceptor"/&gt;
   &lt;/customInterceptors&gt;
   --&gt;
&lt;/jbosscache&gt;


</pre><div class="section" id="idm140119306711472"><div class="titlepage"><div><div><h3 class="title">12.1.1. XML validation</h3></div></div></div><div class="para">
				Configuration XML files are validated using an XSD schema. This schema is included in <code class="literal">jbosscache-core.jar</code> and is also available online: <code class="literal">http://www.jboss.org/jbosscache/jbosscache-config-3.0.xsd</code>. Most IDEs and XML authoring tools will be able to use this schema to validate your configuration file as you write it.
			</div><div class="para">
				JBoss Cache also validates your configuration file when you start up, and will throw an exception if it encounters an invalid file. You can suppress this behavior by passing in <code class="literal">-Djbosscache.config.validate=false</code> to your JVM when you start up. Alternatively, you can point the validator to a different schema by passing in <code class="literal">-Djbosscache.config.schemaLocation=url</code>.
			</div></div></div><div class="section" id="configuration_reference"><div class="titlepage"><div><div><h2 class="title">12.2. Configuration File Quick Reference</h2></div></div></div><div class="para">
			A list of definitions of each of the XML elements attributes used above, and their bean counterparts for programmatic configuration. If the description of an attribute states that it is <span class="emphasis"><em>dynamic</em></span>, that means it can be changed after the cache is created and started.
		</div><div class="table" id="element.jbosscache"><p class="title"><strong>Table 12.1. The <code class="literal">&lt;jbosscache /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;jbosscache /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119306465152" scope="col"> The <code class="literal">&lt;jbosscache /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							This is the root element for the JBoss Cache configuration file. This is the only mandatory element in a valid JBoss Cache configuration file.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							none (is root element)
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>, <a class="xref" href="#element.customInterceptors">Table 12.37, “The <code class="literal">&lt;customInterceptors /&gt;</code> Element”</a>, <a class="xref" href="#element.eviction">Table 12.19, “The <code class="literal">&lt;eviction /&gt;</code> Element”</a>, <a class="xref" href="#element.invocationBatching">Table 12.15, “The <code class="literal">&lt;invocationBatching /&gt;</code> Element”</a>, <a class="xref" href="#element.jmxStatistics">Table 12.7, “The <code class="literal">&lt;jmxStatistics /&gt;</code> Element”</a>, <a class="xref" href="#element.listeners">Table 12.13, “The <code class="literal">&lt;listeners /&gt;</code> Element”</a>, <a class="xref" href="#element.loaders">Table 12.27, “The <code class="literal">&lt;loaders /&gt;</code> Element”</a>, <a class="xref" href="#element.locking">Table 12.3, “The <code class="literal">&lt;locking /&gt;</code> Element”</a>, <a class="xref" href="#element.serialization">Table 12.17, “The <code class="literal">&lt;serialization /&gt;</code> Element”</a>, <a class="xref" href="#element.shutdown">Table 12.11, “The <code class="literal">&lt;shutdown /&gt;</code> Element”</a>, <a class="xref" href="#element.startup">Table 12.9, “The <code class="literal">&lt;startup /&gt;</code> Element”</a>, <a class="xref" href="#element.transaction">Table 12.5, “The <code class="literal">&lt;transaction /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<span class="bold bold"><strong>Bean Equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119306465152"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.jbosscache"><p class="title"><strong>Table 12.2. <code class="literal">&lt;jbosscache /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;jbosscache /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119308013328" scope="col"> <code class="literal">&lt;jbosscache /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119308011696" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119308011216" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119308010736" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119308010256" scope="col"> Default </th><th align="left" valign="top" id="idm140119308009776" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119308013328"> <span class="bold bold"><strong>xmlns</strong></span> </td><td align="left" valign="top" headers="idm140119308013328"> - </td><td align="left" valign="top" headers="idm140119308013328"> urn:jboss:jbosscache-core:config:3.1 </td><td align="left" valign="top" headers="idm140119308013328"> urn:jboss:jbosscache-core:config:3.1 </td><td align="left" valign="top" headers="idm140119308013328"> Defines the XML namespace for all configuration entries. </td></tr><tr><td align="left" valign="top" headers="idm140119308013328"> <span class="bold bold"><strong>xmlns:xsi</strong></span> </td><td align="left" valign="top" headers="idm140119308013328"> - </td><td align="left" valign="top" headers="idm140119308013328"> http://www.w3.org/2001/XMLSchema-instance </td><td align="left" valign="top" headers="idm140119308013328"> http://www.w3.org/2001/XMLSchema-instance </td><td align="left" valign="top" headers="idm140119308013328"> Defines the XML schema instance for the configuration. </td></tr></tbody></table></div></div><div class="table" id="element.locking"><p class="title"><strong>Table 12.3. The <code class="literal">&lt;locking /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;locking /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119299285664" scope="col"> The <code class="literal">&lt;locking /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							This element specifies locking behavior on the cache.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119299285664"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119299285664"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.locking"><p class="title"><strong>Table 12.4. <code class="literal">&lt;locking /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols gt-7-rows" summary="&lt;locking /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119303289872" scope="col"> <code class="literal">&lt;locking /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119303288240" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119303287760" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119303287280" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119303286800" scope="col"> Default </th><th align="left" valign="top" id="idm140119303286320" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>isolationLevel</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> isolationLevel </td><td align="left" valign="top" headers="idm140119303289872"> READ_COMMITTED, REPEATABLE_READ </td><td align="left" valign="top" headers="idm140119303289872"> REPEATABLE_READ </td><td align="left" valign="top" headers="idm140119303289872"> The isolation level used for transactions. </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>lockParentForChildInsertRemove</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> lockParentForChildInsertRemove </td><td align="left" valign="top" headers="idm140119303289872"> true, false </td><td align="left" valign="top" headers="idm140119303289872"> false </td><td align="left" valign="top" headers="idm140119303289872"> Specifies whether parent nodes are locked when inserting or removing children. This can also be configured on a per-node basis (see <code class="literal">Node.setLockForChildInsertRemove()</code> </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>lockAcquisitionTimeout</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> lockAcquisitionTimeout (<span class="emphasis"><em>dynamic</em></span>) </td><td align="left" valign="top" headers="idm140119303289872"> Any positive long value </td><td align="left" valign="top" headers="idm140119303289872"> 10000 </td><td align="left" valign="top" headers="idm140119303289872"> Length of time, in milliseconds, that a thread will try and acquire a lock. A <code class="literal">TimeoutException</code> is usually thrown if a lock cannot be acquired in this given timeframe. Can be overridden on a per-invocation basis using <code class="literal">Option.setLockAcquisitionTimeout()</code> </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>nodeLockingScheme</strong></span> (<span class="emphasis"><em>deprecated</em></span>) </td><td align="left" valign="top" headers="idm140119303289872"> nodeLockingScheme </td><td align="left" valign="top" headers="idm140119303289872"> mvcc, pessimistic, optimistic </td><td align="left" valign="top" headers="idm140119303289872"> mvcc </td><td align="left" valign="top" headers="idm140119303289872"> Specifies the node locking scheme to be used. </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>writeSkewCheck</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> writeSkewCheck </td><td align="left" valign="top" headers="idm140119303289872"> true, false </td><td align="left" valign="top" headers="idm140119303289872"> false </td><td align="left" valign="top" headers="idm140119303289872"> Specifies whether to check for write skews. Only used if <code class="literal">nodeLockingScheme</code> is <code class="literal">mvcc</code> and <code class="literal">isolationLevel</code> is <code class="literal">REPEATABLE_READ</code>. See the <a class="xref" href="#mvcc.writeskew">Section 11.1.1.2.2, “Concurrent Writers and Write-Skews”</a> for a more detailed discussion. </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>useLockStriping</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> useLockStriping </td><td align="left" valign="top" headers="idm140119303289872"> true, false </td><td align="left" valign="top" headers="idm140119303289872"> true </td><td align="left" valign="top" headers="idm140119303289872"> Specifies whether lock striping is used. Only used if <code class="literal">nodeLockingScheme</code> is <code class="literal">mvcc</code>. Lock striping usually offers greater performance and better memory usage, although in certain cases deadlocks may occur where several Fqns map to the same shared lock. This can be mitigated by increasing your concurrency level, though the only concrete solution is to disable lock striping altogether. </td></tr><tr><td align="left" valign="top" headers="idm140119303289872"> <span class="bold bold"><strong>concurrencyLevel</strong></span> </td><td align="left" valign="top" headers="idm140119303289872"> concurrencyLevel </td><td align="left" valign="top" headers="idm140119303289872"> Any positive integer; 0 not allowed. </td><td align="left" valign="top" headers="idm140119303289872"> 500 </td><td align="left" valign="top" headers="idm140119303289872"> Specifies the number of shared locks to use for write locks acquired. Only used if <code class="literal">nodeLockingScheme</code> is <code class="literal">mvcc</code>. See the <a class="xref" href="#mvcc.impl">Section 11.1.1.2, “MVCC Implementation”</a> for a more detailed discussion. </td></tr></tbody></table></div></div><div class="table" id="element.transaction"><p class="title"><strong>Table 12.5. The <code class="literal">&lt;transaction /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;transaction /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119303246208" scope="col"> The <code class="literal">&lt;transaction /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							This element specifies transactional behavior on the cache.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119303246208"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119303246208"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.transaction"><p class="title"><strong>Table 12.6. <code class="literal">&lt;transaction /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;transaction /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311985120" scope="col"> <code class="literal">&lt;transaction /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119311983376" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119311982896" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119311982416" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119311981936" scope="col"> Default </th><th align="left" valign="top" id="idm140119311981456" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311985120"> <span class="bold bold"><strong>transactionManagerLookupClass</strong></span> </td><td align="left" valign="top" headers="idm140119311985120"> transactionManagerLookupClass </td><td align="left" valign="top" headers="idm140119311985120"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119311985120"> none </td><td align="left" valign="top" headers="idm140119311985120"> Specifies the <code class="literal">TransactionManagerLookupClass</code> implementation to use to obtain a transaction manager. If not specified (and a <code class="literal">TransactionManager</code> is not injected using <code class="literal">RuntimeConfig.setTransactionManager()</code>), the cache will not be able to participate in any transactions. </td></tr><tr><td align="left" valign="top" headers="idm140119311985120"> <span class="bold bold"><strong>syncCommitPhase</strong></span> </td><td align="left" valign="top" headers="idm140119311985120"> syncCommitPhase (<span class="emphasis"><em>dynamic</em></span>) </td><td align="left" valign="top" headers="idm140119311985120"> true, false </td><td align="left" valign="top" headers="idm140119311985120"> false </td><td align="left" valign="top" headers="idm140119311985120"> If enabled, commit messages that are broadcast around a cluster are done so synchronously. This is usually of little value since detecting a failure in broadcasting a commit means little else can be done except log a message, since some nodes in a cluster may have already committed and cannot rollback. </td></tr><tr><td align="left" valign="top" headers="idm140119311985120"> <span class="bold bold"><strong>syncRollbackPhase</strong></span> </td><td align="left" valign="top" headers="idm140119311985120"> syncRollbackPhase (<span class="emphasis"><em>dynamic</em></span>) </td><td align="left" valign="top" headers="idm140119311985120"> true, false </td><td align="left" valign="top" headers="idm140119311985120"> false </td><td align="left" valign="top" headers="idm140119311985120"> If enabled, rollback messages that are broadcast around a cluster are done so synchronously. This is usually of little value since detecting a failure in broadcasting a rollback means little else can be done except log a message, since some nodes in a cluster may have already committed and cannot rollback. </td></tr></tbody></table></div></div><div class="table" id="element.jmxStatistics"><p class="title"><strong>Table 12.7. The <code class="literal">&lt;jmxStatistics /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;jmxStatistics /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311960256" scope="col"> The <code class="literal">&lt;jmxStatistics /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							This element specifies whether cache statistics are gathered and reported via JMX.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311960256"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311960256"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.jmxStatistics"><p class="title"><strong>Table 12.8. <code class="literal">&lt;jmxStatistics /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;jmxStatistics /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311936672" scope="col"> <code class="literal">&lt;jmxStatistics /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119311934928" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119311934448" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119311933968" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119311933488" scope="col"> Default </th><th align="left" valign="top" id="idm140119311933008" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311936672"> <span class="bold bold"><strong>enabled</strong></span> </td><td align="left" valign="top" headers="idm140119311936672"> exposeManagementStatistics </td><td align="left" valign="top" headers="idm140119311936672"> true, false </td><td align="left" valign="top" headers="idm140119311936672"> true </td><td align="left" valign="top" headers="idm140119311936672"> Controls whether cache statistics are gathered and exposed via JMX. </td></tr></tbody></table></div></div><div class="table" id="element.startup"><p class="title"><strong>Table 12.9. The <code class="literal">&lt;startup /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;startup /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311921952" scope="col"> The <code class="literal">&lt;startup /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							This element specifies behavior when the cache starts up.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311921952"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311921952"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.startup"><p class="title"><strong>Table 12.10. <code class="literal">&lt;startup /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;startup /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311898384" scope="col"> <code class="literal">&lt;startup /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119311896640" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119311896160" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119311895680" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119311895200" scope="col"> Default </th><th align="left" valign="top" id="idm140119311894720" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311898384"> <span class="bold bold"><strong>regionsInactiveOnStartup</strong></span> </td><td align="left" valign="top" headers="idm140119311898384"> inactiveOnStartup </td><td align="left" valign="top" headers="idm140119311898384"> true, false </td><td align="left" valign="top" headers="idm140119311898384"> false </td><td align="left" valign="top" headers="idm140119311898384"> If <a class="xref" href="#architecture.regions">Section 7.6, “Class Loading and Regions”</a> is enabled, this attribute controls whether new regions created are inactive on startup. </td></tr></tbody></table></div></div><div class="table" id="element.shutdown"><p class="title"><strong>Table 12.11. The <code class="literal">&lt;shutdown /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;shutdown /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311883120" scope="col"> The <code class="literal">&lt;shutdown /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							This element specifies behavior when the cache shuts down.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311883120"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119311883120"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.shutdown"><p class="title"><strong>Table 12.12. <code class="literal">&lt;shutdown /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;shutdown /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119311859552" scope="col"> <code class="literal">&lt;shutdown /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119311857808" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119311857328" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119311856848" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119311856368" scope="col"> Default </th><th align="left" valign="top" id="idm140119311855888" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119311859552"> <span class="bold bold"><strong>hookBehavior</strong></span> </td><td align="left" valign="top" headers="idm140119311859552"> shutdownHookBehavior </td><td align="left" valign="top" headers="idm140119311859552"> DEFAULT, DONT_REGISTER, REGISTER </td><td align="left" valign="top" headers="idm140119311859552"> DEFAULT </td><td align="left" valign="top" headers="idm140119311859552"> This attribute determines whether the cache registers a JVM shutdown hook so that it can clean up resources if the JVM is receives a shutdown signal. By default a shutdown hook is registered if no MBean server (apart from the JDK default) is detected. REGSTER forces the cache to register a shutdown hook even if an MBean server is detected, and DONT_REGISTER forces the cache NOT to register a shutdown hook, even if no MBean server is detected. </td></tr></tbody></table></div></div><div class="table" id="element.listeners"><p class="title"><strong>Table 12.13. The <code class="literal">&lt;listeners /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;listeners /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304277216" scope="col"> The <code class="literal">&lt;listeners /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							This element specifies behavior of registered cache listeners.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304277216"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304277216"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.listeners"><p class="title"><strong>Table 12.14. <code class="literal">&lt;listeners /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;listeners /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304253648" scope="col"> <code class="literal">&lt;listeners /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119304251904" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119304251424" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119304250944" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119304250464" scope="col"> Default </th><th align="left" valign="top" id="idm140119304249984" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304253648"> <span class="bold bold"><strong>asyncPoolSize</strong></span> </td><td align="left" valign="top" headers="idm140119304253648"> listenerAsyncPoolSize </td><td align="left" valign="top" headers="idm140119304253648"> integer </td><td align="left" valign="top" headers="idm140119304253648"> 1 </td><td align="left" valign="top" headers="idm140119304253648"> The size of the thread pool used to dispatch events to cache listeners that have registered as asynchronous listeners. If this number is less than 1, all asynchronous listeners will be treated as synchronous listeners and notified synchronously. </td></tr><tr><td align="left" valign="top" headers="idm140119304253648"> <span class="bold bold"><strong>asyncQueueSize</strong></span> </td><td align="left" valign="top" headers="idm140119304253648"> listenerAsyncQueueSize </td><td align="left" valign="top" headers="idm140119304253648"> positive integer </td><td align="left" valign="top" headers="idm140119304253648"> 50000 </td><td align="left" valign="top" headers="idm140119304253648"> The size of the bounded queue used by the async listener thread pool. Only considered if <code class="literal">asyncPoolSize</code> is greater than 0. Increase this if you see a lot of threads blocking trying to add events to this queue. </td></tr></tbody></table></div></div><div class="table" id="element.invocationBatching"><p class="title"><strong>Table 12.15. The <code class="literal">&lt;invocationBatching /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;invocationBatching /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304234528" scope="col"> The <code class="literal">&lt;invocationBatching /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							This element specifies behavior of invocation batching.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304234528"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304234528"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.invocationBatching"><p class="title"><strong>Table 12.16. <code class="literal">&lt;invocationBatching /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;invocationBatching /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304210976" scope="col"> <code class="literal">&lt;invocationBatching /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119304209232" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119304208752" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119304208272" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119304207792" scope="col"> Default </th><th align="left" valign="top" id="idm140119304207312" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304210976"> <span class="bold bold"><strong>enabled</strong></span> </td><td align="left" valign="top" headers="idm140119304210976"> invocationBatchingEnabled </td><td align="left" valign="top" headers="idm140119304210976"> true, false </td><td align="left" valign="top" headers="idm140119304210976"> false </td><td align="left" valign="top" headers="idm140119304210976"> Whether invocation batching is enabled or not. See the chapter on <a class="xref" href="#batching">Chapter 4, <em>Batching API</em></a> for details. </td></tr></tbody></table></div></div><div class="table" id="element.serialization"><p class="title"><strong>Table 12.17. The <code class="literal">&lt;serialization /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;serialization /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304195632" scope="col"> The <code class="literal">&lt;serialization /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							This element specifies behavior of object serialization in JBoss Cache.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304195632"> <div class="para">

						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304195632"> <div class="para">
							<code class="literal">Configuration</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.serialization"><p class="title"><strong>Table 12.18. <code class="literal">&lt;serialization /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;serialization /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304172160" scope="col"> <code class="literal">&lt;serialization /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119304170416" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119304169936" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119304169456" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119304168976" scope="col"> Default </th><th align="left" valign="top" id="idm140119304168496" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>marshallerClass</strong></span> </td><td align="left" valign="top" headers="idm140119304172160"> marshallerClass </td><td align="left" valign="top" headers="idm140119304172160"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119304172160"> VersionAwareMarshaller </td><td align="left" valign="top" headers="idm140119304172160"> Specifies the marshaller to use when serializing and deserializing objects, either for replication or persistence. </td></tr><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>useLazyDeserialization</strong></span> </td><td align="left" valign="top" headers="idm140119304172160"> useLazyDeserialization </td><td align="left" valign="top" headers="idm140119304172160"> true, false </td><td align="left" valign="top" headers="idm140119304172160"> false </td><td align="left" valign="top" headers="idm140119304172160"> A mechanism by which serialization and deserialization of objects is deferred till the point in time in which they are used and needed. This typically means that any deserialization happens using the thread context class loader of the invocation that requires deserialization, and is an effective mechanism to provide classloader isolation. </td></tr><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>useRegionBasedMarshalling</strong></span> (<span class="emphasis"><em>deprecated</em></span>) </td><td align="left" valign="top" headers="idm140119304172160"> useRegionBasedMarshalling </td><td align="left" valign="top" headers="idm140119304172160"> true, false </td><td align="left" valign="top" headers="idm140119304172160"> false </td><td align="left" valign="top" headers="idm140119304172160"> An older mechanism by which classloader isolation was achieved, by registering classloaders on specific regions. </td></tr><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>version</strong></span> </td><td align="left" valign="top" headers="idm140119304172160"> replicationVersion </td><td align="left" valign="top" headers="idm140119304172160"> Valid JBoss Cache version string </td><td align="left" valign="top" headers="idm140119304172160"> Current version </td><td align="left" valign="top" headers="idm140119304172160"> Used by the <code class="literal">VersionAwareMarshaller</code> in determining which version stream parser to use by default when initiating communications in a cluster. Useful when you need to run a newer version of JBoss Cache in a cluster containing older versions, and can be used to perform rolling upgrades. </td></tr><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>objectInputStreamPoolSize</strong></span> </td><td align="left" valign="top" headers="idm140119304172160"> objectInputStreamPoolSize </td><td align="left" valign="top" headers="idm140119304172160"> Positive integer </td><td align="left" valign="top" headers="idm140119304172160"> 50 </td><td align="left" valign="top" headers="idm140119304172160"> Not used at the moment. </td></tr><tr><td align="left" valign="top" headers="idm140119304172160"> <span class="bold bold"><strong>objectOutputStreamPoolSize</strong></span> </td><td align="left" valign="top" headers="idm140119304172160"> objectOutputStreamPoolSize </td><td align="left" valign="top" headers="idm140119304172160"> Positive integer </td><td align="left" valign="top" headers="idm140119304172160"> 50 </td><td align="left" valign="top" headers="idm140119304172160"> Not used at the moment. </td></tr></tbody></table></div></div><div class="table" id="element.eviction"><p class="title"><strong>Table 12.19. The <code class="literal">&lt;eviction /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;eviction /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304137920" scope="col"> The <code class="literal">&lt;eviction /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							This element controls how eviction works in the cache.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<a class="xref" href="#element.default">Table 12.21, “The <code class="literal">&lt;default /&gt;</code> Element”</a>, <a class="xref" href="#element.region">Table 12.23, “The <code class="literal">&lt;region /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304137920"> <div class="para">
							<code class="literal">EvictionConfig</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.eviction"><p class="title"><strong>Table 12.20. <code class="literal">&lt;eviction /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;eviction /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304113024" scope="col"> <code class="literal">&lt;eviction /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119304111280" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119304110800" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119304110320" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119304109840" scope="col"> Default </th><th align="left" valign="top" id="idm140119304109360" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304113024"> <span class="bold bold"><strong>wakeUpInterval</strong></span> </td><td align="left" valign="top" headers="idm140119304113024"> wakeupInterval </td><td align="left" valign="top" headers="idm140119304113024"> integer </td><td align="left" valign="top" headers="idm140119304113024"> 5000 </td><td align="left" valign="top" headers="idm140119304113024"> The frequency with which the eviction thread runs, in milliseconds. If set to less than 1, the eviction thread never runs and is effectively disabled. </td></tr></tbody></table></div></div><div class="table" id="element.default"><p class="title"><strong>Table 12.21. The <code class="literal">&lt;default /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;default /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304098176" scope="col"> The <code class="literal">&lt;default /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							This element defines the default eviction region.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<a class="xref" href="#element.eviction">Table 12.19, “The <code class="literal">&lt;eviction /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<a class="xref" href="#element.property">Table 12.25, “The <code class="literal">&lt;property /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304098176"> <div class="para">
							<code class="literal">EvictionRegionConfig</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.default"><p class="title"><strong>Table 12.22. <code class="literal">&lt;default /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;default /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304073904" scope="col"> <code class="literal">&lt;default /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119304072160" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119304071680" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119304071200" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119304070720" scope="col"> Default </th><th align="left" valign="top" id="idm140119304070240" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304073904"> <span class="bold bold"><strong>algorithmClass</strong></span> </td><td align="left" valign="top" headers="idm140119304073904"> evictionAlgorithmConfig </td><td align="left" valign="top" headers="idm140119304073904"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119304073904"> none </td><td align="left" valign="top" headers="idm140119304073904"> This attribute needs to be specified if this tag is being used. Note that if being configured programmatically, the eviction algorithm's corresponding <code class="literal">EvictionAlgorithmConfig</code> file should be used instead. E.g., where you would use <code class="literal">LRUAlgorithm</code> in XML, you would use an instance of <code class="literal">LRUAlgorithmConfig</code> programmatically. </td></tr><tr><td align="left" valign="top" headers="idm140119304073904"> <span class="bold bold"><strong>actionPolicyClass</strong></span> </td><td align="left" valign="top" headers="idm140119304073904"> evictionActionPolicyClassName </td><td align="left" valign="top" headers="idm140119304073904"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119304073904"> DefaultEvictionActionPolicy </td><td align="left" valign="top" headers="idm140119304073904"> The eviction action policy class, defining what happens when a node needs to be evicted. </td></tr><tr><td align="left" valign="top" headers="idm140119304073904"> <span class="bold bold"><strong>eventQueueSize</strong></span> </td><td align="left" valign="top" headers="idm140119304073904"> eventQueueSize (<span class="emphasis"><em>dynamic</em></span> </td><td align="left" valign="top" headers="idm140119304073904"> integer </td><td align="left" valign="top" headers="idm140119304073904"> 200000 </td><td align="left" valign="top" headers="idm140119304073904"> The size of the bounded eviction event queue. </td></tr></tbody></table></div></div><div class="table" id="element.region"><p class="title"><strong>Table 12.23. The <code class="literal">&lt;region /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;region /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119304050016" scope="col"> The <code class="literal">&lt;region /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							This element defines an eviction region. Multiple instances of this tag can exist provided they have unique <code class="literal">name</code> attributes.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<a class="xref" href="#element.eviction">Table 12.19, “The <code class="literal">&lt;eviction /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<a class="xref" href="#element.property">Table 12.25, “The <code class="literal">&lt;property /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119304050016"> <div class="para">
							<code class="literal">EvictionRegionConfig</code>
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.region"><p class="title"><strong>Table 12.24. <code class="literal">&lt;region /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;region /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317206272" scope="col"> <code class="literal">&lt;region /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119317204528" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119317204048" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119317203568" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119317203088" scope="col"> Default </th><th align="left" valign="top" id="idm140119317202608" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317206272"> <span class="bold bold"><strong>name</strong></span> </td><td align="left" valign="top" headers="idm140119317206272"> regionFqn </td><td align="left" valign="top" headers="idm140119317206272"> A String that could be parsed using Fqn.fromString() </td><td align="left" valign="top" headers="idm140119317206272"> none </td><td align="left" valign="top" headers="idm140119317206272"> This should be a unique name that defines this region. See the <a class="xref" href="#regions">Section 10.2, “Eviction Regions”</a> for details of eviction regions. </td></tr><tr><td align="left" valign="top" headers="idm140119317206272"> <span class="bold bold"><strong>algorithmClass</strong></span> </td><td align="left" valign="top" headers="idm140119317206272"> evictionAlgorithmConfig </td><td align="left" valign="top" headers="idm140119317206272"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119317206272"> none </td><td align="left" valign="top" headers="idm140119317206272"> This attribute needs to be specified if this tag is being used. Note that if being configured programmatically, the eviction algorithm's corresponding <code class="literal">EvictionAlgorithmConfig</code> file should be used instead. E.g., where you would use <code class="literal">LRUAlgorithm</code> in XML, you would use an instance of <code class="literal">LRUAlgorithmConfig</code> programmatically. </td></tr><tr><td align="left" valign="top" headers="idm140119317206272"> <span class="bold bold"><strong>actionPolicyClass</strong></span> </td><td align="left" valign="top" headers="idm140119317206272"> evictionActionPolicyClassName </td><td align="left" valign="top" headers="idm140119317206272"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119317206272"> DefaultEvictionActionPolicy </td><td align="left" valign="top" headers="idm140119317206272"> The eviction action policy class, defining what happens when a node needs to be evicted. </td></tr><tr><td align="left" valign="top" headers="idm140119317206272"> <span class="bold bold"><strong>eventQueueSize</strong></span> </td><td align="left" valign="top" headers="idm140119317206272"> eventQueueSize (<span class="emphasis"><em>dynamic</em></span> </td><td align="left" valign="top" headers="idm140119317206272"> integer </td><td align="left" valign="top" headers="idm140119317206272"> 200000 </td><td align="left" valign="top" headers="idm140119317206272"> The size of the bounded eviction event queue. </td></tr></tbody></table></div></div><div class="table" id="element.property"><p class="title"><strong>Table 12.25. The <code class="literal">&lt;property /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;property /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317178080" scope="col"> The <code class="literal">&lt;property /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							A mechanism of passing in name-value properties to the enclosing configuration element.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							<a class="xref" href="#element.default">Table 12.21, “The <code class="literal">&lt;default /&gt;</code> Element”</a>, <a class="xref" href="#element.region">Table 12.23, “The <code class="literal">&lt;region /&gt;</code> Element”</a>, <a class="xref" href="#element.interceptor">Table 12.38, “The <code class="literal">&lt;interceptor /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317178080"> </td></tr><tr><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317178080"> <div class="para">
							Either direct setters or <code class="literal">setProperties()</code> enclosing bean
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.property"><p class="title"><strong>Table 12.26. <code class="literal">&lt;property /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;property /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317153664" scope="col"> <code class="literal">&lt;property /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119317151920" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119317151440" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119317150960" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119317150480" scope="col"> Default </th><th align="left" valign="top" id="idm140119317150000" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317153664"> <span class="bold bold"><strong>name</strong></span> </td><td align="left" valign="top" headers="idm140119317153664"> Either direct setters or <code class="literal">setProperties()</code> enclosing bean </td><td align="left" valign="top" headers="idm140119317153664"> String </td><td align="left" valign="top" headers="idm140119317153664"> none </td><td align="left" valign="top" headers="idm140119317153664"> Property name </td></tr><tr><td align="left" valign="top" headers="idm140119317153664"> <span class="bold bold"><strong>value</strong></span> </td><td align="left" valign="top" headers="idm140119317153664"> Either direct setters or <code class="literal">setProperties()</code> enclosing bean </td><td align="left" valign="top" headers="idm140119317153664"> String </td><td align="left" valign="top" headers="idm140119317153664"> none </td><td align="left" valign="top" headers="idm140119317153664"> Property value </td></tr></tbody></table></div></div><div class="table" id="element.loaders"><p class="title"><strong>Table 12.27. The <code class="literal">&lt;loaders /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;loaders /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317134512" scope="col"> The <code class="literal">&lt;loaders /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							Defines any cache loaders.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317134512"> <a class="xref" href="#element.preload">Table 12.29, “The <code class="literal">&lt;preload /&gt;</code> Element”</a>, <a class="xref" href="#element.loader">Table 12.32, “The <code class="literal">&lt;loader /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317134512"> <div class="para">
							CacheLoaderConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.loaders"><p class="title"><strong>Table 12.28. <code class="literal">&lt;loaders /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;loaders /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317110688" scope="col"> <code class="literal">&lt;loaders /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119317108944" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119317108464" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119317107984" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119317107504" scope="col"> Default </th><th align="left" valign="top" id="idm140119317107024" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317110688"> <span class="bold bold"><strong>passivation</strong></span> </td><td align="left" valign="top" headers="idm140119317110688"> passivation </td><td align="left" valign="top" headers="idm140119317110688"> true, false </td><td align="left" valign="top" headers="idm140119317110688"> false </td><td align="left" valign="top" headers="idm140119317110688"> If true, cache loaders are used in passivation mode. See the <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a> for a detailed discussion on this. </td></tr><tr><td align="left" valign="top" headers="idm140119317110688"> <span class="bold bold"><strong>shared</strong></span> </td><td align="left" valign="top" headers="idm140119317110688"> shared </td><td align="left" valign="top" headers="idm140119317110688"> true, false </td><td align="left" valign="top" headers="idm140119317110688"> false </td><td align="left" valign="top" headers="idm140119317110688"> If true, cache loaders are used in shared mode. See the <a class="xref" href="#cache_loaders">Chapter 9, <em>Cache Loaders</em></a> for a detailed discussion on this. </td></tr></tbody></table></div></div><div class="table" id="element.preload"><p class="title"><strong>Table 12.29. The <code class="literal">&lt;preload /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;preload /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317091152" scope="col"> The <code class="literal">&lt;preload /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							Defines preloading of Fqn subtrees when a cache starts up. This element has no attributes.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							<a class="xref" href="#element.loaders">Table 12.27, “The <code class="literal">&lt;loaders /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317091152"> <a class="xref" href="#element.node">Table 12.30, “The <code class="literal">&lt;node /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317091152"> <div class="para">
							CacheLoaderConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="element.node"><p class="title"><strong>Table 12.30. The <code class="literal">&lt;node /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;node /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317069536" scope="col"> The <code class="literal">&lt;node /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							This element defines a subtree under which all content will be preloaded from the cache loaders when the cache starts. Multiple subtrees can be preloaded, although it only makes sense to define more than one subtree if they do not overlap.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							<a class="xref" href="#element.preload">Table 12.29, “The <code class="literal">&lt;preload /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317069536"> </td></tr><tr><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317069536"> <div class="para">
							CacheLoaderConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.node"><p class="title"><strong>Table 12.31. <code class="literal">&lt;node /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;node /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317046688" scope="col"> <code class="literal">&lt;node /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119317044944" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119317044464" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119317043984" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119317043504" scope="col"> Default </th><th align="left" valign="top" id="idm140119317043024" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317046688"> <span class="bold bold"><strong>fqn</strong></span> </td><td align="left" valign="top" headers="idm140119317046688"> preload </td><td align="left" valign="top" headers="idm140119317046688"> String </td><td align="left" valign="top" headers="idm140119317046688"> none </td><td align="left" valign="top" headers="idm140119317046688"> An Fqn to preload. This should be a String that can be parsed with Fqn.fromString(). When doing this programmatically, you should create a single String containing all of the Fqns you wish to preload, separated by spaces, and pass that into <code class="literal">CacheLoaderConfig.setPreload()</code>. </td></tr></tbody></table></div></div><div class="table" id="element.loader"><p class="title"><strong>Table 12.32. The <code class="literal">&lt;loader /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;loader /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317031424" scope="col"> The <code class="literal">&lt;loader /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							This element defines a cache loader. Multiple elements may be used to create cache loader chains.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							<a class="xref" href="#element.loaders">Table 12.27, “The <code class="literal">&lt;loaders /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317031424"> <a class="xref" href="#element.properties">Table 12.34, “The <code class="literal">&lt;properties /&gt;</code> Element”</a>, <a class="xref" href="#element.singletonStore">Table 12.35, “The <code class="literal">&lt;singletonStore /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119317031424"> <div class="para">
							IndividualCacheLoaderConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.loader"><p class="title"><strong>Table 12.33. <code class="literal">&lt;loader /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;loader /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119317007472" scope="col"> <code class="literal">&lt;loader /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119317005728" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119317005248" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119317004768" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119317004288" scope="col"> Default </th><th align="left" valign="top" id="idm140119317003808" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119317007472"> <span class="bold bold"><strong>class</strong></span> </td><td align="left" valign="top" headers="idm140119317007472"> className </td><td align="left" valign="top" headers="idm140119317007472"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119317007472"> none </td><td align="left" valign="top" headers="idm140119317007472"> A cache loader implementation to use. </td></tr><tr><td align="left" valign="top" headers="idm140119317007472"> <span class="bold bold"><strong>async</strong></span> </td><td align="left" valign="top" headers="idm140119317007472"> async </td><td align="left" valign="top" headers="idm140119317007472"> true, false </td><td align="left" valign="top" headers="idm140119317007472"> false </td><td align="left" valign="top" headers="idm140119317007472"> All modifications to this cache loader happen asynchronously, on a separate thread. </td></tr><tr><td align="left" valign="top" headers="idm140119317007472"> <span class="bold bold"><strong>fetchPersistentState</strong></span> </td><td align="left" valign="top" headers="idm140119317007472"> fetchPersistentState </td><td align="left" valign="top" headers="idm140119317007472"> true, false </td><td align="left" valign="top" headers="idm140119317007472"> false </td><td align="left" valign="top" headers="idm140119317007472"> When a cache starts up, retrieve persistent state from the cache loaders in other caches in the cluster. Only <span class="emphasis"><em>one</em></span> loader element may set this to true. Also, only makes sense if the <a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a> tag is present. </td></tr><tr><td align="left" valign="top" headers="idm140119317007472"> <span class="bold bold"><strong>purgeOnStartup</strong></span> </td><td align="left" valign="top" headers="idm140119317007472"> purgeOnStartup </td><td align="left" valign="top" headers="idm140119317007472"> true, false </td><td align="left" valign="top" headers="idm140119317007472"> false </td><td align="left" valign="top" headers="idm140119317007472"> Purges this cache loader when it starts up. </td></tr></tbody></table></div></div><div class="table" id="element.properties"><p class="title"><strong>Table 12.34. The <code class="literal">&lt;properties /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;properties /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316980768" scope="col"> The <code class="literal">&lt;properties /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							This element contains a set of properties that can be read by a <code class="literal">java.util.Properties</code> instance. This tag has no attributes, and the contents of this tag will be parsed by <code class="literal">Properties.load()</code>.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							<a class="xref" href="#element.loader">Table 12.32, “The <code class="literal">&lt;loader /&gt;</code> Element”</a>, <a class="xref" href="#element.singletonStore">Table 12.35, “The <code class="literal">&lt;singletonStore /&gt;</code> Element”</a>, <a class="xref" href="#element.locator">Table 12.52, “The <code class="literal">&lt;locator /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316980768"> </td></tr><tr><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316980768"> <div class="para">
							IndividualCacheLoaderConfig.setProperties()
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="element.singletonStore"><p class="title"><strong>Table 12.35. The <code class="literal">&lt;singletonStore /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;singletonStore /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316957648" scope="col"> The <code class="literal">&lt;singletonStore /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							This element configures the enclosing cache loader as a <a class="xref" href="#sscl">Section 9.2.1, “Singleton Store Configuration”</a>.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							<a class="xref" href="#element.loader">Table 12.32, “The <code class="literal">&lt;loader /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316957648"> <a class="xref" href="#element.properties">Table 12.34, “The <code class="literal">&lt;properties /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316957648"> <div class="para">
							SingletonStoreConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.singletonStore"><p class="title"><strong>Table 12.36. <code class="literal">&lt;singletonStore /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;singletonStore /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316933840" scope="col"> <code class="literal">&lt;singletonStore /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316932096" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316931616" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316931136" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316930656" scope="col"> Default </th><th align="left" valign="top" id="idm140119316930176" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316933840"> <span class="bold bold"><strong>class</strong></span> </td><td align="left" valign="top" headers="idm140119316933840"> className </td><td align="left" valign="top" headers="idm140119316933840"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119316933840"> SingletonStoreCacheLoader </td><td align="left" valign="top" headers="idm140119316933840"> A singleton store wrapper implementation to use. </td></tr><tr><td align="left" valign="top" headers="idm140119316933840"> <span class="bold bold"><strong>enabled</strong></span> </td><td align="left" valign="top" headers="idm140119316933840"> enabled </td><td align="left" valign="top" headers="idm140119316933840"> true, false </td><td align="left" valign="top" headers="idm140119316933840"> false </td><td align="left" valign="top" headers="idm140119316933840"> If true, the singleton store cache loader is enabled. </td></tr></tbody></table></div></div><div class="table" id="element.customInterceptors"><p class="title"><strong>Table 12.37. The <code class="literal">&lt;customInterceptors /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;customInterceptors /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316915696" scope="col"> The <code class="literal">&lt;customInterceptors /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							This element allows you to define custom interceptors for the cache. This tag has no attributes.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316915696"> <a class="xref" href="#element.interceptor">Table 12.38, “The <code class="literal">&lt;interceptor /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316915696"> <div class="para">
							None. At runtime, instantiate your own interceptor and pass it in to the cache using <code class="literal">Cache.addInterceptor()</code>.
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="element.interceptor"><p class="title"><strong>Table 12.38. The <code class="literal">&lt;interceptor /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;interceptor /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316893488" scope="col"> The <code class="literal">&lt;interceptor /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							This element allows you configure a custom interceptor. This tag may appear multiple times.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							<a class="xref" href="#element.customInterceptors">Table 12.37, “The <code class="literal">&lt;customInterceptors /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316893488"> <a class="xref" href="#element.property">Table 12.25, “The <code class="literal">&lt;property /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316893488"> <div class="para">
							None. At runtime, instantiate your own interceptor and pass it in to the cache using <code class="literal">Cache.addInterceptor()</code>.
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.interceptor"><p class="title"><strong>Table 12.39. <code class="literal">&lt;interceptor /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;interceptor /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316869600" scope="col"> <code class="literal">&lt;interceptor /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316867856" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316867376" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316866896" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316866416" scope="col"> Default </th><th align="left" valign="top" id="idm140119316865936" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316869600"> <span class="bold bold"><strong>class</strong></span> </td><td align="left" valign="top" headers="idm140119316869600"> - </td><td align="left" valign="top" headers="idm140119316869600"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119316869600"> none </td><td align="left" valign="top" headers="idm140119316869600"> An implementation of <code class="literal">CommandInterceptor</code>. </td></tr><tr><td align="left" valign="top" headers="idm140119316869600"> <span class="bold bold"><strong>position</strong></span> </td><td align="left" valign="top" headers="idm140119316869600"> - </td><td align="left" valign="top" headers="idm140119316869600"> first, last </td><td align="left" valign="top" headers="idm140119316869600"> </td><td align="left" valign="top" headers="idm140119316869600"> A position at which to place this interceptor in the chain. First is the first interceptor encountered when an invocation is made on the cache, last is the last interceptor before the call is passed on to the data structure. <span class="emphasis"><em>Note that this attribute is mutually exclusive with <code class="literal">before</code>, <code class="literal">after</code> and <code class="literal">index</code>.</em></span> </td></tr><tr><td align="left" valign="top" headers="idm140119316869600"> <span class="bold bold"><strong>before</strong></span> </td><td align="left" valign="top" headers="idm140119316869600"> - </td><td align="left" valign="top" headers="idm140119316869600"> Fully qualified class name of an interceptor </td><td align="left" valign="top" headers="idm140119316869600"> </td><td align="left" valign="top" headers="idm140119316869600"> Will place the new interceptor directly before the instance of the named interceptor. <span class="emphasis"><em>Note that this attribute is mutually exclusive with <code class="literal">position</code>, <code class="literal">after</code> and <code class="literal">index</code>.</em></span> </td></tr><tr><td align="left" valign="top" headers="idm140119316869600"> <span class="bold bold"><strong>after</strong></span> </td><td align="left" valign="top" headers="idm140119316869600"> - </td><td align="left" valign="top" headers="idm140119316869600"> Fully qualified class name of an interceptor </td><td align="left" valign="top" headers="idm140119316869600"> </td><td align="left" valign="top" headers="idm140119316869600"> Will place the new interceptor directly after the instance of the named interceptor. <span class="emphasis"><em>Note that this attribute is mutually exclusive with <code class="literal">position</code>, <code class="literal">before</code> and <code class="literal">index</code>.</em></span> </td></tr><tr><td align="left" valign="top" headers="idm140119316869600"> <span class="bold bold"><strong>index</strong></span> </td><td align="left" valign="top" headers="idm140119316869600"> - </td><td align="left" valign="top" headers="idm140119316869600"> Positive integers </td><td align="left" valign="top" headers="idm140119316869600"> </td><td align="left" valign="top" headers="idm140119316869600"> A position at which to place this interceptor in the chain, with 0 being the first position. <span class="emphasis"><em>Note that this attribute is mutually exclusive with <code class="literal">position</code>, <code class="literal">before</code> and <code class="literal">after</code>.</em></span> </td></tr></tbody></table></div></div><div class="table" id="element.clustering"><p class="title"><strong>Table 12.40. The <code class="literal">&lt;clustering /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;clustering /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316832080" scope="col"> The <code class="literal">&lt;clustering /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							If this element is present, the cache is started in clustered mode. Attributes and child elements define clustering characteristics.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							<a class="xref" href="#element.jbosscache">Table 12.1, “The <code class="literal">&lt;jbosscache /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316832080"> <a class="xref" href="#element.stateRetrieval">Table 12.46, “The <code class="literal">&lt;stateRetrieval /&gt;</code> Element”</a>, <a class="xref" href="#element.sync">Table 12.42, “The <code class="literal">&lt;sync /&gt;</code> Element”</a>, <a class="xref" href="#element.async">Table 12.44, “The <code class="literal">&lt;async /&gt;</code> Element”</a>, <a class="xref" href="#element.buddy">Table 12.48, “The <code class="literal">&lt;buddy /&gt;</code> Element”</a>, <a class="xref" href="#element.jgroupsConfig">Table 12.54, “The <code class="literal">&lt;jgroupsConfig /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316832080"> <div class="para">
							Configuration
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.clustering"><p class="title"><strong>Table 12.41. <code class="literal">&lt;clustering /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;clustering /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316806224" scope="col"> <code class="literal">&lt;clustering /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316804480" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316804000" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316803520" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316803040" scope="col"> Default </th><th align="left" valign="top" id="idm140119316802560" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316806224"> <span class="bold bold"><strong>mode</strong></span> </td><td align="left" valign="top" headers="idm140119316806224"> cacheMode </td><td align="left" valign="top" headers="idm140119316806224"> replication, invalidation, r, i </td><td align="left" valign="top" headers="idm140119316806224"> replication </td><td align="left" valign="top" headers="idm140119316806224"> See the <a class="xref" href="#clustering">Chapter 8, <em>Cache Modes and Clustering</em></a> for the differences between replication and invalidation. When using the bean, synchronous and asynchronous communication is combined with clustering mode to give you the enumberation <code class="literal">Configuration.CacheMode</code>. </td></tr><tr><td align="left" valign="top" headers="idm140119316806224"> <span class="bold bold"><strong>clusterName</strong></span> </td><td align="left" valign="top" headers="idm140119316806224"> clusterName </td><td align="left" valign="top" headers="idm140119316806224"> String </td><td align="left" valign="top" headers="idm140119316806224"> JBossCache-cluster </td><td align="left" valign="top" headers="idm140119316806224"> A cluster name which is used to identify the cluster to join. </td></tr></tbody></table></div></div><div class="table" id="element.sync"><p class="title"><strong>Table 12.42. The <code class="literal">&lt;sync /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;sync /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316786560" scope="col"> The <code class="literal">&lt;sync /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							If this element is present, all communications are synchronous, in that whenever a thread sends a message sent over the wire, it blocks until it receives an acknowledgement from the recipient. This element is mutually exclusive with the <a class="xref" href="#element.async">Table 12.44, “The <code class="literal">&lt;async /&gt;</code> Element”</a> element.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316786560"> </td></tr><tr><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316786560"> <div class="para">
							Configuration.setCacheMode()
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.sync"><p class="title"><strong>Table 12.43. <code class="literal">&lt;sync /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;sync /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316763104" scope="col"> <code class="literal">&lt;sync /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316761360" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316760880" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316760400" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316759920" scope="col"> Default </th><th align="left" valign="top" id="idm140119316759440" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316763104"> <span class="bold bold"><strong>replTimeout</strong></span> </td><td align="left" valign="top" headers="idm140119316763104"> syncReplTimeout (<span class="emphasis"><em>dynamic</em></span>) </td><td align="left" valign="top" headers="idm140119316763104"> positive integer </td><td align="left" valign="top" headers="idm140119316763104"> 15000 </td><td align="left" valign="top" headers="idm140119316763104"> This is the timeout used to wait for an acknowledgement when making a remote call, after which an exception is thrown. </td></tr></tbody></table></div></div><div class="table" id="element.async"><p class="title"><strong>Table 12.44. The <code class="literal">&lt;async /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;async /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316747920" scope="col"> The <code class="literal">&lt;async /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							If this element is present, all communications are asynchronous, in that whenever a thread sends a message sent over the wire, it does not wait for an acknowledgement before returning. This element is mutually exclusive with the <a class="xref" href="#element.sync">Table 12.42, “The <code class="literal">&lt;sync /&gt;</code> Element”</a> element.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316747920"> </td></tr><tr><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316747920"> <div class="para">
							Configuration.setCacheMode()
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.async"><p class="title"><strong>Table 12.45. <code class="literal">&lt;async /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;async /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316724464" scope="col"> <code class="literal">&lt;async /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316722720" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316722240" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316721760" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316721280" scope="col"> Default </th><th align="left" valign="top" id="idm140119316720800" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316724464"> <span class="bold bold"><strong>serializationExecutorPoolSize</strong></span> </td><td align="left" valign="top" headers="idm140119316724464"> serializationExecutorPoolSize </td><td align="left" valign="top" headers="idm140119316724464"> positive integer </td><td align="left" valign="top" headers="idm140119316724464"> 25 </td><td align="left" valign="top" headers="idm140119316724464"> In addition to replication happening asynchronously, even serialization of contents for replication happens in a separate thread to allow the caller to return as quickly as possible. This setting controls the size of the serializer thread pool. Setting this to any value less than 1 means serialization does not happen asynchronously. </td></tr><tr><td align="left" valign="top" headers="idm140119316724464"> <span class="bold bold"><strong>serializationExecutorQueueSize</strong></span> </td><td align="left" valign="top" headers="idm140119316724464"> serializationExecutorQueueSize </td><td align="left" valign="top" headers="idm140119316724464"> positive integer </td><td align="left" valign="top" headers="idm140119316724464"> 50000 </td><td align="left" valign="top" headers="idm140119316724464"> This is used to define the size of the bounded queue that holds tasks for the serialization executor. This is ignored if a serialization executor is not used, such as when <code class="literal">serializationExecutorPoolSize</code> is less than 1. </td></tr><tr><td align="left" valign="top" headers="idm140119316724464"> <span class="bold bold"><strong>useReplQueue</strong></span> </td><td align="left" valign="top" headers="idm140119316724464"> useReplQueue </td><td align="left" valign="top" headers="idm140119316724464"> true, false </td><td align="left" valign="top" headers="idm140119316724464"> false </td><td align="left" valign="top" headers="idm140119316724464"> If true, this forces all async communications to be queued up and sent out periodically as a batch. </td></tr><tr><td align="left" valign="top" headers="idm140119316724464"> <span class="bold bold"><strong>replQueueInterval</strong></span> </td><td align="left" valign="top" headers="idm140119316724464"> replQueueInterval </td><td align="left" valign="top" headers="idm140119316724464"> positive integer </td><td align="left" valign="top" headers="idm140119316724464"> 5000 </td><td align="left" valign="top" headers="idm140119316724464"> If <code class="literal">useReplQueue</code> is set to true, this attribute controls how often the asynchronous thread used to flush the replication queue runs. This should be a positive integer which represents thread wakeup time in milliseconds. </td></tr><tr><td align="left" valign="top" headers="idm140119316724464"> <span class="bold bold"><strong>replQueueMaxElements</strong></span> </td><td align="left" valign="top" headers="idm140119316724464"> replQueueMaxElements </td><td align="left" valign="top" headers="idm140119316724464"> positive integer </td><td align="left" valign="top" headers="idm140119316724464"> 1000 </td><td align="left" valign="top" headers="idm140119316724464"> If <code class="literal">useReplQueue</code> is set to true, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. </td></tr></tbody></table></div></div><div class="table" id="element.stateRetrieval"><p class="title"><strong>Table 12.46. The <code class="literal">&lt;stateRetrieval /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;stateRetrieval /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316692976" scope="col"> The <code class="literal">&lt;stateRetrieval /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							This tag controls ho state is retrieved from neighboring caches when this cache instance starts.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316692976"> </td></tr><tr><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316692976"> <div class="para">
							Configuration
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.stateRetrieval"><p class="title"><strong>Table 12.47. <code class="literal">&lt;stateRetrieval /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;stateRetrieval /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316670368" scope="col"> <code class="literal">&lt;stateRetrieval /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316668624" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316668144" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316667664" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316667184" scope="col"> Default </th><th align="left" valign="top" id="idm140119316666704" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316670368"> <span class="bold bold"><strong>fetchInMemoryState</strong></span> </td><td align="left" valign="top" headers="idm140119316670368"> fetchInMemoryState </td><td align="left" valign="top" headers="idm140119316670368"> true, false </td><td align="left" valign="top" headers="idm140119316670368"> true </td><td align="left" valign="top" headers="idm140119316670368"> If true, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts "warm". </td></tr><tr><td align="left" valign="top" headers="idm140119316670368"> <span class="bold bold"><strong>timeout</strong></span> </td><td align="left" valign="top" headers="idm140119316670368"> stateRetrievalTimeout </td><td align="left" valign="top" headers="idm140119316670368"> positive integer </td><td align="left" valign="top" headers="idm140119316670368"> 10000 </td><td align="left" valign="top" headers="idm140119316670368"> This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup. </td></tr><tr><td align="left" valign="top" headers="idm140119316670368"> <span class="bold bold"><strong>nonBlocking</strong></span> </td><td align="left" valign="top" headers="idm140119316670368"> useNonBlockingStateTransfer </td><td align="left" valign="top" headers="idm140119316670368"> true, false </td><td align="left" valign="top" headers="idm140119316670368"> false </td><td align="left" valign="top" headers="idm140119316670368"> This configuration switch enables the Non-Blocking State Transfer mechanism, new in 3.1.0. Note that this requires MVCC as a node locking scheme, and that STREAMING_STATE_TRANSFER is present in the JGroups stack used. </td></tr></tbody></table></div></div><div class="table" id="element.buddy"><p class="title"><strong>Table 12.48. The <code class="literal">&lt;buddy /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;buddy /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316648048" scope="col"> The <code class="literal">&lt;buddy /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							If this tag is present, then state is not replicated across the entire cluster. Instead, buddy replication is used to select cache instances to maintain backups on. See <a class="xref" href="#br">Section 8.1.2.2, “Buddy Replication”</a> for details. Note that this is only used if the clustering mode is <code class="literal">replication</code>, and not if it is <code class="literal">invalidation</code>.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316648048"> <a class="xref" href="#element.dataGravitation">Table 12.50, “The <code class="literal">&lt;dataGravitation /&gt;</code> Element”</a>, <a class="xref" href="#element.locator">Table 12.52, “The <code class="literal">&lt;locator /&gt;</code> Element”</a>, </td></tr><tr><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316648048"> <div class="para">
							BuddyReplicationConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.buddy"><p class="title"><strong>Table 12.49. <code class="literal">&lt;buddy /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;buddy /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316622400" scope="col"> <code class="literal">&lt;buddy /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316620656" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316620176" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316619696" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316619216" scope="col"> Default </th><th align="left" valign="top" id="idm140119316618736" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316622400"> <span class="bold bold"><strong>enabled</strong></span> </td><td align="left" valign="top" headers="idm140119316622400"> enabled </td><td align="left" valign="top" headers="idm140119316622400"> true, false </td><td align="left" valign="top" headers="idm140119316622400"> false </td><td align="left" valign="top" headers="idm140119316622400"> If true, buddy replication is enabled. </td></tr><tr><td align="left" valign="top" headers="idm140119316622400"> <span class="bold bold"><strong>communicationTimeout</strong></span> </td><td align="left" valign="top" headers="idm140119316622400"> buddyCommunicationTimeout </td><td align="left" valign="top" headers="idm140119316622400"> positive integer </td><td align="left" valign="top" headers="idm140119316622400"> 10000 </td><td align="left" valign="top" headers="idm140119316622400"> This is the maximum amount of time - in milliseconds - to wait for buddy group organization communications from buddy caches. </td></tr><tr><td align="left" valign="top" headers="idm140119316622400"> <span class="bold bold"><strong>poolName</strong></span> </td><td align="left" valign="top" headers="idm140119316622400"> buddyPoolName </td><td align="left" valign="top" headers="idm140119316622400"> String </td><td align="left" valign="top" headers="idm140119316622400"> </td><td align="left" valign="top" headers="idm140119316622400"> This is used as a means to identify cache instances and provide hints to the buddy selection algorithms. More information on <a class="xref" href="#br">Section 8.1.2.2, “Buddy Replication”</a>. </td></tr></tbody></table></div></div><div class="table" id="element.dataGravitation"><p class="title"><strong>Table 12.50. The <code class="literal">&lt;dataGravitation /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;dataGravitation /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316599584" scope="col"> The <code class="literal">&lt;dataGravitation /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							This tag configures how data gravitation is conducted. See <a class="xref" href="#br">Section 8.1.2.2, “Buddy Replication”</a> for details.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							<a class="xref" href="#element.buddy">Table 12.48, “The <code class="literal">&lt;buddy /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316599584"> </td></tr><tr><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316599584"> <div class="para">
							BuddyReplicationConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.dataGravitation"><p class="title"><strong>Table 12.51. <code class="literal">&lt;dataGravitation /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;dataGravitation /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316576400" scope="col"> <code class="literal">&lt;dataGravitation /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316574656" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316574176" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316573696" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316573216" scope="col"> Default </th><th align="left" valign="top" id="idm140119316572736" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316576400"> <span class="bold bold"><strong>auto</strong></span> </td><td align="left" valign="top" headers="idm140119316576400"> autoDataGravitation </td><td align="left" valign="top" headers="idm140119316576400"> true, false </td><td align="left" valign="top" headers="idm140119316576400"> true </td><td align="left" valign="top" headers="idm140119316576400"> If true, when a get() is performed on a cache and nothing is found, a gravitation from neighboring caches is attempted. If this is false, then gravitations can only occur if the <code class="literal">Option.setForceDataGravitation()</code> option is provided. </td></tr><tr><td align="left" valign="top" headers="idm140119316576400"> <span class="bold bold"><strong>removeOnFind</strong></span> </td><td align="left" valign="top" headers="idm140119316576400"> dataGravitationRemoveOnFind </td><td align="left" valign="top" headers="idm140119316576400"> true, false </td><td align="left" valign="top" headers="idm140119316576400"> true </td><td align="left" valign="top" headers="idm140119316576400"> If true, when gravitation occurs, the instance that requests the gravitation takes ownership of the state and requests that all other instances remove the gravitated state from memory. </td></tr><tr><td align="left" valign="top" headers="idm140119316576400"> <span class="bold bold"><strong>searchBackupTrees</strong></span> </td><td align="left" valign="top" headers="idm140119316576400"> dataGravitationSearchBackupTrees </td><td align="left" valign="top" headers="idm140119316576400"> true, false </td><td align="left" valign="top" headers="idm140119316576400"> true </td><td align="left" valign="top" headers="idm140119316576400"> If true, incoming gravitation requests will cause the cache to search not just its primary data structure but its backup structure as well. </td></tr></tbody></table></div></div><div class="table" id="element.locator"><p class="title"><strong>Table 12.52. The <code class="literal">&lt;locator /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;locator /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316553520" scope="col"> The <code class="literal">&lt;locator /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							This tag provides a pluggable mechanism for providing buddy location algorithms.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							<a class="xref" href="#element.buddy">Table 12.48, “The <code class="literal">&lt;buddy /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316553520"> <a class="xref" href="#element.properties">Table 12.34, “The <code class="literal">&lt;properties /&gt;</code> Element”</a> </td></tr><tr><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316553520"> <div class="para">
							BuddyLocatorConfig
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.locator"><p class="title"><strong>Table 12.53. <code class="literal">&lt;locator /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;locator /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316530208" scope="col"> <code class="literal">&lt;locator /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316528464" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316527984" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316527504" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316527024" scope="col"> Default </th><th align="left" valign="top" id="idm140119316526544" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316530208"> <span class="bold bold"><strong>class</strong></span> </td><td align="left" valign="top" headers="idm140119316530208"> className </td><td align="left" valign="top" headers="idm140119316530208"> A valid class that is available on the classpath </td><td align="left" valign="top" headers="idm140119316530208"> NextMemberBuddyLocator </td><td align="left" valign="top" headers="idm140119316530208"> A <code class="literal">BuddyLocator</code> implementation to use when selecting buddies from the cluster. Please refer to <code class="literal">BuddyLocator</code> javadocs for details. </td></tr></tbody></table></div></div><div class="table" id="element.jgroupsConfig"><p class="title"><strong>Table 12.54. The <code class="literal">&lt;jgroupsConfig /&gt;</code> Element</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="The &lt;jgroupsConfig /&gt; Element"><colgroup><col align="left" class="name"><!--Empty--></col><col align="left" class="desc"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316514640" scope="col"> The <code class="literal">&lt;jgroupsConfig /&gt;</code> Element </th><td class="auto-generated"> </td></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							This tag provides a configuration which is used with JGroups to create a network communication channel.
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							<span class="bold bold"><strong>Parent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							<a class="xref" href="#element.clustering">Table 12.40, “The <code class="literal">&lt;clustering /&gt;</code> Element”</a>
						</div>
						 </td></tr><tr><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							<span class="bold bold"><strong>Children</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316514640"> A series of elements representing JGroups protocols (see <a href="http://www.jgroups.org/javagroupsnew/docs/ug.html" class="mimir-link-warn" title="Mimir does not include content from: www.jgroups.org">JGroups documentation</a>). Note that there are no child elements if any of the element attributes are used instead. See section on attributes. </td></tr><tr><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							<span class="bold bold"><strong>Bean equivalent</strong></span>
						</div>
						 </td><td align="left" valign="top" headers="idm140119316514640"> <div class="para">
							Configuration
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="attributes.jgroupsConfig"><p class="title"><strong>Table 12.55. <code class="literal">&lt;jgroupsConfig /&gt;</code> Attributes</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows" summary="&lt;jgroupsConfig /&gt; Attributes"><colgroup><col align="left" class="c1"><!--Empty--></col><col align="left" class="c2"><!--Empty--></col><col align="left" class="c3"><!--Empty--></col><col align="left" class="c4"><!--Empty--></col><col align="left" class="c5"><!--Empty--></col></colgroup><thead valign="top"><tr><th align="left" valign="top" id="idm140119316491136" scope="col"> <code class="literal">&lt;jgroupsConfig /&gt;</code> Attributes </th><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td><td class="auto-generated"> </td></tr><tr><th align="left" valign="top" id="idm140119316489392" scope="col"> Attribute </th><th align="left" valign="top" id="idm140119316488912" scope="col"> Bean Field </th><th align="left" valign="top" id="idm140119316488432" scope="col"> Allowed </th><th align="left" valign="top" id="idm140119316487952" scope="col"> Default </th><th align="left" valign="top" id="idm140119316487472" scope="col"> Description </th></tr></thead><tbody valign="top"><tr><td align="left" valign="top" headers="idm140119316491136"> <span class="bold bold"><strong>configFile</strong></span> </td><td align="left" valign="top" headers="idm140119316491136"> clusterConfig </td><td align="left" valign="top" headers="idm140119316491136"> A JGroups configuration file on the classpath </td><td align="left" valign="top" headers="idm140119316491136"> udp.xml </td><td align="left" valign="top" headers="idm140119316491136"> If this attribute is used, then any JGroups elements representing protocols within this tag are ignored. Instead, JGroups settings are read from the file specified. Note that this cannot be used with the <code class="literal">multiplexerStack</code> attribute. </td></tr><tr><td align="left" valign="top" headers="idm140119316491136"> <span class="bold bold"><strong>multiplexerStack</strong></span> </td><td align="left" valign="top" headers="idm140119316491136"> muxStackName </td><td align="left" valign="top" headers="idm140119316491136"> A valid multiplexer stack name that exists in the channel factory passed in to the <code class="literal">RuntimeConfig</code> </td><td align="left" valign="top" headers="idm140119316491136"> </td><td align="left" valign="top" headers="idm140119316491136"> This can only be used with the <code class="literal">RuntimeConfig</code>, where you pass in a JGroups <code class="literal">ChannelFactory</code> instance using <code class="literal">RuntimeConfig.setMuxChannelFactory()</code>. If this attribute is used, then any JGroups elements representing protocols within this tag are ignored. Instead, the JGroups channel is created using the factory passed in. Note that this cannot be used with the <code class="literal">configFile</code> attribute. </td></tr></tbody></table></div></div></div></div><div xml:lang="en-US" class="chapter" id="jmx_reference" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter 13. JMX References</h2></div></div></div><div class="section" id="jmx_reference.statistics"><div class="titlepage"><div><div><h2 class="title">13.1. JBoss Cache Statistics</h2></div></div></div><div class="para">
			There is a whole wealth of information being gathered and exposed on to JMX for monitoring the cache. Some of these are detailed below:
		</div><div class="table" id="idm140119304902640"><p class="title"><strong>Table 13.1. JBoss Cache JMX MBeans</strong></p><div class="table-contents"><table class="lt-4-cols gt-14-rows" summary="JBoss Cache JMX MBeans"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm140119304952672" scope="col"> MBean </th><th id="idm140119305300592" scope="col"> Attribute/Operation Name </th><th id="idm140119306081392" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm140119304952672"> DataContainerImpl </td><td headers="idm140119305300592"> getNumberOfAttributes() </td><td headers="idm140119306081392"> Returns the number of attributes in all nodes in the data container </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> getNumberOfNodes() </td><td headers="idm140119306081392"> Returns the number of nodes in the data container </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> printDetails() </td><td headers="idm140119306081392"> Prints details of the data container </td></tr><tr><td headers="idm140119304952672"> RPCManagerImpl </td><td headers="idm140119305300592"> localAddressString </td><td headers="idm140119306081392"> String representation of the local address </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> membersString </td><td headers="idm140119306081392"> String representation of the cluster view </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> statisticsEnabled </td><td headers="idm140119306081392"> Whether RPC statistics are being gathered </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> replicationCount </td><td headers="idm140119306081392"> Number of successful replications </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> replicationFailures </td><td headers="idm140119306081392"> Number of failed replications </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> successRatio </td><td headers="idm140119306081392"> RPC call success ratio </td></tr><tr><td headers="idm140119304952672"> RegionManagerImpl </td><td headers="idm140119305300592"> dumpRegions() </td><td headers="idm140119306081392"> Dumps a String representation of all registered regions, including eviction regions depicting their event queue sizes </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> numRegions </td><td headers="idm140119306081392"> Number of registered regions </td></tr><tr><td headers="idm140119304952672"> BuddyManager </td><td headers="idm140119305300592"> buddyGroup </td><td headers="idm140119306081392"> A String representation of the cache's buddy group </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> buddyGroupsIParticipateIn </td><td headers="idm140119306081392"> String representations of all buddy groups the cache participates in </td></tr><tr><td headers="idm140119304952672"> TransactionTable </td><td headers="idm140119305300592"> numberOfRegisteredTransactions </td><td headers="idm140119306081392"> The number of registered, ongoing transactions </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> transactionMap </td><td headers="idm140119306081392"> A String representation of all currently registered transactions mapped to internal GlobalTransaction instances </td></tr><tr><td headers="idm140119304952672"> MVCCLockManager </td><td headers="idm140119305300592"> concurrencyLevel </td><td headers="idm140119306081392"> The configured concurrency level </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> numberOfLocksAvailable </td><td headers="idm140119306081392"> Number of locks in the shared lock pool that are not used </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> numberOfLocksHeld </td><td headers="idm140119306081392"> Number of locks in the shared lock pool that are in use </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> testHashing(String fqn) </td><td headers="idm140119306081392"> Tests the spreading of locks across Fqns. For a given (String based) Fqn, this method returns the index in the lock array that it maps to. </td></tr><tr><td headers="idm140119304952672"> ActivationInterceptor </td><td headers="idm140119305300592"> Activations </td><td headers="idm140119306081392"> Number of passivated nodes that have been activated. </td></tr><tr><td headers="idm140119304952672"> CacheLoaderInterceptor </td><td headers="idm140119305300592"> CacheLoaderLoads </td><td headers="idm140119306081392"> Number of nodes loaded through a cache loader. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> CacheLoaderMisses </td><td headers="idm140119306081392"> Number of unsuccessful attempts to load a node through a cache loader. </td></tr><tr><td headers="idm140119304952672"> CacheMgmtInterceptor </td><td headers="idm140119305300592"> Hits </td><td headers="idm140119306081392"> Number of successful attribute retrievals. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> Misses </td><td headers="idm140119306081392"> Number of unsuccessful attribute retrievals. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> Stores </td><td headers="idm140119306081392"> Number of attribute store operations. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> Evictions </td><td headers="idm140119306081392"> Number of node evictions. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> NumberOfAttributes </td><td headers="idm140119306081392"> Number of attributes currently cached. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> NumberOfNodes </td><td headers="idm140119306081392"> Number of nodes currently cached. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> ElapsedTime </td><td headers="idm140119306081392"> Number of seconds that the cache has been running. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> TimeSinceReset </td><td headers="idm140119306081392"> Number of seconds since the cache statistics have been reset. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> AverageReadTime </td><td headers="idm140119306081392"> Average time in milliseconds to retrieve a cache attribute, including unsuccessful attribute retrievals. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> AverageWriteTime </td><td headers="idm140119306081392"> Average time in milliseconds to write a cache attribute. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> HitMissRatio </td><td headers="idm140119306081392"> Ratio of hits to hits and misses. A hit is a get attribute operation that results in an object being returned to the client. The retrieval may be from a cache loader if the entry isn't in the local cache. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> ReadWriteRatio </td><td headers="idm140119306081392"> Ratio of read operations to write operations. This is the ratio of cache hits and misses to cache stores. </td></tr><tr><td headers="idm140119304952672"> CacheStoreInterceptor </td><td headers="idm140119305300592"> CacheLoaderStores </td><td headers="idm140119306081392"> Number of nodes written to the cache loader. </td></tr><tr><td headers="idm140119304952672"> InvalidationInterceptor </td><td headers="idm140119305300592"> Invalidations </td><td headers="idm140119306081392"> Number of cached nodes that have been invalidated. </td></tr><tr><td headers="idm140119304952672"> PassivationInterceptor </td><td headers="idm140119305300592"> Passivations </td><td headers="idm140119306081392"> Number of cached nodes that have been passivated. </td></tr><tr><td headers="idm140119304952672"> TxInterceptor </td><td headers="idm140119305300592"> Prepares </td><td headers="idm140119306081392"> Number of transaction prepare operations performed by this interceptor. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> Commits </td><td headers="idm140119306081392"> Number of transaction commit operations performed by this interceptor. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> Rollbacks </td><td headers="idm140119306081392"> Number of transaction rollbacks operations performed by this interceptor. </td></tr><tr><td headers="idm140119304952672"> </td><td headers="idm140119305300592"> numberOfSyncsRegistered </td><td headers="idm140119306081392"> Number of synchronizations registered with the transaction manager pending completion and removal. </td></tr></tbody></table></div></div></div><div class="section" id="jmx_reference.notifications"><div class="titlepage"><div><div><h2 class="title">13.2. JMX MBean Notifications</h2></div></div></div><div class="para">
			The following table depicts the JMX notifications available for JBoss Cache as well as the cache events to which they correspond. These are the notifications that can be received through the <code class="literal">CacheJmxWrapper</code> MBean. Each notification represents a single event published by JBoss Cache and provides user data corresponding to the parameters of the event.
		</div><div class="table" id="idm140119303507936"><p class="title"><strong>Table 13.2. JBoss Cache MBean Notifications</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="JBoss Cache MBean Notifications"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm140119303506016" scope="col"> Notification Type </th><th id="idm140119303505536" scope="col"> Notification Data </th><th id="idm140119303505056" scope="col"> CacheListener Event </th></tr></thead><tbody><tr><td headers="idm140119303506016"> org.jboss.cache.CacheStarted </td><td headers="idm140119303505536"> String: cache service name </td><td headers="idm140119303505056"> @CacheStarted </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.CacheStopped </td><td headers="idm140119303505536"> String: cache service name </td><td headers="idm140119303505056"> @CacheStopped </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeCreated </td><td headers="idm140119303505536"> String: fqn, boolean: isPre, boolean: isOriginLocal </td><td headers="idm140119303505056"> @NodeCreated </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeEvicted </td><td headers="idm140119303505536"> String: fqn, boolean: isPre, boolean: isOriginLocal </td><td headers="idm140119303505056"> @NodeEvicted </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeLoaded </td><td headers="idm140119303505536"> String: fqn, boolean: isPre </td><td headers="idm140119303505056"> @NodeLoaded </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeModifed </td><td headers="idm140119303505536"> String: fqn, boolean: isPre, boolean: isOriginLocal </td><td headers="idm140119303505056"> @NodeModifed </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeRemoved </td><td headers="idm140119303505536"> String: fqn, boolean: isPre, boolean: isOriginLocal </td><td headers="idm140119303505056"> @NodeRemoved </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeVisited </td><td headers="idm140119303505536"> String: fqn, boolean: isPre </td><td headers="idm140119303505056"> @NodeVisited </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.ViewChanged </td><td headers="idm140119303505536"> String: view </td><td headers="idm140119303505056"> @ViewChanged </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeActivated </td><td headers="idm140119303505536"> String: fqn </td><td headers="idm140119303505056"> @NodeActivated </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodeMoved </td><td headers="idm140119303505536"> String: fromFqn, String: toFqn, boolean: isPre </td><td headers="idm140119303505056"> @NodeMoved </td></tr><tr><td headers="idm140119303506016"> org.jboss.cache.NodePassivated </td><td headers="idm140119303505536"> String: fqn </td><td headers="idm140119303505056"> @NodePassivated </td></tr></tbody></table></div></div></div></div></div><div><div class="legalnotice"><a id="idm140119307487280"><!--Empty--></a><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span>© 2011 Red Hat, Inc.
	</div><div class="para">
		This document is licensed by Red Hat under the <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="mimir-link-warn" title="Mimir does not include content from: creativecommons.org">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. If you distribute this document, or a modified version of it, you must provide attribution to Red Hat, Inc. and provide a link to the original. If the document is modified, all Red Hat trademarks must be removed.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat Software Collections is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></body>

        
        
    </div>
    

</div> 


                            </bdo>
                        </main>
                    </div>
                </main>
            </div>
        
            <!--#include virtual="/includes/footer/index.html" -->
        </div>
    </body>
</html>
