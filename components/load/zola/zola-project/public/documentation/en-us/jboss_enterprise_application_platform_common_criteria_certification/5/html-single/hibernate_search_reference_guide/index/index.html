<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir.min.css">
        




    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_Bwzy34i9pSdDlzGALvqVwG4fpgGp08KLMAkClGNY9M4.css" />



<link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir-doc-toc.min.css" />



        
        <!--#include virtual="/includes/head/index.html" -->

        
        <title>
Hibernate Search Reference Guide - JBoss Enterprise Application Platform Common Criteria Certification 5
</title>
        
<meta name="product" content="JBoss Enterprise Application Platform Common Criteria Certification" />
<meta name="documentation_version" content="5" />
<meta name="documentKind" content="documentation" />
<meta name="portal_content_subtype" content="title" />
<meta name="lastModifiedDate" content="2017-11-28T18:42:57.000Z" />


        
            
        
        
            
                
                
                <!-- mimir_solr_yesindex -->
                <meta name="mimir_solr_yesindex" content="true" />
            
        
    </head>

    <body class="mimir-body">

        
        

        
        <div id="page-wrap" class="page-wrap">
            <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">
                <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
                <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

                <header class="masthead" id="masthead">

                    
                    <!--#include virtual="/includes/header/index.html" -->

                    
                    
                    
                        
                    
                    
                        <div class="breadcrumbs">
                            <div id="breadcrumbs" class="container">
                                
                                <a href="/">Home</a>
                                
                                <a href="/products/">Product Documentation</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/7.2.3/">JBoss Enterprise Application Platform Common Criteria Certification</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/5/">5</a>
                                
                                
                                Hibernate Search Reference Guide
                                
                            </div>
                        </div>
                    
                </header>

                <main id="cp-main" class="portal-content-area">
                    <div id="cp-content" class="main-content">
                        
                        <main class="container mimir-docs">
                            
                            <bdo>
                                

<script type="module" src="/mimir/scripts/mimir-doc-toc.min.js"></script>






<div class="docs-grid">

    <nav id="mimir-doc-toc" class="mimir-doc-toc">
      <div class="mimir-doc-toc-inner">
          <!-- single-page -->
        
            
              <ol>
                <li>
                        
                        <a href="#">Hibernate Search Reference Guide</a>
                    </li><li>
                        <a href="#preface">
                            Preface
                        </a>
                    </li><li>
                        <a href="#getting-started">
                            1. Getting started
                        </a><ol>
                <li>
                        <a href="#idm139947798605344">
                            1.1. System Requirements
                        </a>
                    </li><li>
                        <a href="#idm139947808720416">
                            1.2. Using Maven
                        </a>
                    </li><li>
                        <a href="#idm139947796446640">
                            1.3. Configuration
                        </a>
                    </li><li>
                        <a href="#idm139947792400144">
                            1.4. Indexing
                        </a>
                    </li><li>
                        <a href="#idm139947792391680">
                            1.5. Searching
                        </a>
                    </li><li>
                        <a href="#idm139947804284384">
                            1.6. Analyzer
                        </a>
                    </li><li>
                        <a href="#idm139947804264688">
                            1.7. What's next
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-architecture">
                            2. Architecture
                        </a><ol>
                <li>
                        <a href="#idm139947802237984">
                            2.1. Overview
                        </a>
                    </li><li>
                        <a href="#idm139947798839344">
                            2.2. Back end
                        </a><ol>
                <li>
                        <a href="#idm139947804327824">
                            2.2.1. Back end types
                        </a>
                    </li><li>
                        <a href="#idm139947806232864">
                            2.2.2. Work execution
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-architecture-readerstrategy">
                            2.3. Reader strategy
                        </a><ol>
                <li>
                        <a href="#idm139947808391456">
                            2.3.1. Shared
                        </a>
                    </li><li>
                        <a href="#idm139947808386640">
                            2.3.2. Not-shared
                        </a>
                    </li><li>
                        <a href="#idm139947803412416">
                            2.3.3. Custom
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-configuration">
                            3. Configuration
                        </a><ol>
                <li>
                        <a href="#search-configuration-directory">
                            3.1. Directory configuration
                        </a>
                    </li><li>
                        <a href="#search-configuration-directory-sharding">
                            3.2. Sharding indexes
                        </a>
                    </li><li>
                        <a href="#idm139947792621168">
                            3.3. Sharing indexes (two entities into the same directory)
                        </a>
                    </li><li>
                        <a href="#idm139947796015776">
                            3.4. Worker configuration
                        </a>
                    </li><li>
                        <a href="#jms-backend">
                            3.5. JMS Master/Slave configuration
                        </a><ol>
                <li>
                        <a href="#idm139947795988352">
                            3.5.1. Slave nodes
                        </a>
                    </li><li>
                        <a href="#idm139947795983600">
                            3.5.2. Master node
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration-reader-strategy">
                            3.6. Reader strategy configuration
                        </a>
                    </li><li>
                        <a href="#search-configuration-event">
                            3.7. Enabling Hibernate Search and automatic indexing
                        </a><ol>
                <li>
                        <a href="#idm139947785237744">
                            3.7.1. Enabling Hibernate Search
                        </a>
                    </li><li>
                        <a href="#idm139947785231904">
                            3.7.2. Automatic indexing
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#lucene-indexing-performance">
                            3.8. Tuning Lucene indexing performance
                        </a>
                    </li><li>
                        <a href="#search-configuration-directory-lockfactories">
                            3.9. LockFactory configuration
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-mapping">
                            4. Mapping entities to the index structure
                        </a><ol>
                <li>
                        <a href="#search-mapping-entity">
                            4.1. Mapping an entity
                        </a><ol>
                <li>
                        <a href="#basic-mapping">
                            4.1.1. Basic mapping
                        </a>
                    </li><li>
                        <a href="#idm139947799024624">
                            4.1.2. Mapping properties multiple times
                        </a>
                    </li><li>
                        <a href="#search-mapping-associated">
                            4.1.3. Embedded and associated objects
                        </a>
                    </li><li>
                        <a href="#section-boost-annotation">
                            4.1.4. Boost factor
                        </a>
                    </li><li>
                        <a href="#idm139947799594944">
                            4.1.5. Dynamic boost factor
                        </a>
                    </li><li>
                        <a href="#analyzer">
                            4.1.6. Analyzer
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-mapping-bridge">
                            4.2. Property/Field Bridge
                        </a><ol>
                <li>
                        <a href="#idm139947791413296">
                            4.2.1. Built-in bridges
                        </a>
                    </li><li>
                        <a href="#idm139947791392400">
                            4.2.2. Custom Bridge
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#provided-id">
                            4.3. Providing your own id
                        </a><ol>
                <li>
                        <a href="#ProvidedId">
                            4.3.1. The ProvidedId annotation
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-query">
                            5. Querying
                        </a><ol>
                <li>
                        <a href="#idm139947803552080">
                            5.1. Building queries
                        </a><ol>
                <li>
                        <a href="#idm139947803550144">
                            5.1.1. Building a Lucene query
                        </a>
                    </li><li>
                        <a href="#idm139947803548496">
                            5.1.2. Building a Hibernate Search query
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139947802157712">
                            5.2. Retrieving the results
                        </a><ol>
                <li>
                        <a href="#idm139947785310960">
                            5.2.1. Performance considerations
                        </a>
                    </li><li>
                        <a href="#idm139947785302880">
                            5.2.2. Result size
                        </a>
                    </li><li>
                        <a href="#idm139947785292976">
                            5.2.3. ResultTransformer
                        </a>
                    </li><li>
                        <a href="#idm139947785287520">
                            5.2.4. Understanding results
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139947785275712">
                            5.3. Filters
                        </a>
                    </li><li>
                        <a href="#idm139947795075136">
                            5.4. Optimizing the query process
                        </a>
                    </li><li>
                        <a href="#idm139947795069936">
                            5.5. Native Lucene Queries
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-batchindex">
                            6. Manual indexing
                        </a><ol>
                <li>
                        <a href="#search-batchindex-indexing">
                            6.1. Indexing
                        </a>
                    </li><li>
                        <a href="#idm139947799639920">
                            6.2. Purging
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-optimize">
                            7. Index Optimization
                        </a><ol>
                <li>
                        <a href="#idm139947791502496">
                            7.1. Automatic optimization
                        </a>
                    </li><li>
                        <a href="#idm139947803351472">
                            7.2. Manual optimization
                        </a>
                    </li><li>
                        <a href="#idm139947804581920">
                            7.3. Adjusting optimization
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#search-lucene-native">
                            8. Advanced features
                        </a><ol>
                <li>
                        <a href="#idm139947799060880">
                            8.1. SearchFactory
                        </a>
                    </li><li>
                        <a href="#idm139947801635184">
                            8.2. Accessing a Lucene Directory
                        </a>
                    </li><li>
                        <a href="#idm139947799926752">
                            8.3. Using an IndexReader
                        </a>
                    </li><li>
                        <a href="#idm139947801840832">
                            8.4. Customizing Lucene's scoring formula
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#appe-Publican-Revision_History">
                            A. Revision History
                        </a>
                    </li><li>
                        <a href="#idm139947800265600">
                            Legal Notice
                        </a>
                    </li>
            </ol>
            
        
      </div>
    </nav>

    
    <div class="pvof-doc__wrapper" id="doc-wrapper">
        <section class="mimir-doc-title" id="mimir-doc--hibernate_search_reference_guide">
            <h1 class="title">Hibernate Search Reference Guide</h1>
        </section>
        <body><div xml:lang="en-US" class="book" id="idm139947806219696" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JBoss Enterprise Application Platform Common Criteria Certification</span> <span class="productnumber">5</span></div><div><h2 class="subtitle">for use with JBoss Enterprise Application Platform 5 Common Criteria Certification</h2></div><p class="edition">Edition 5.1.0</p><div><h3 class="corpauthor">
		<span class="inlinemediaobject"><object data="https://access.redhat.com/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Search_Reference_Guide-en-US/images/a78399a6916bd5b945caa082f6c4fa4e/title_logo.svg" type="image/svg+xml"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Search_Reference_Guide-en-US/images/20c014cff25dbc2aeb4126383228ede4/title_logo.png" alt="" /></object></span>

	</h3></div><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">Red Hat Documentation Group</span> <span class="surname"><!--Empty--></span></h3></div></div></div><div><p class="copyright">Copyright © 2011 Red Hat, Inc</p></div><div><a href="#idm139947800265600">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
			The Hibernate Search Reference Guide for JBoss Enterprise Application Platform 5.1.0.
		</div></div></div></div></div><div xml:lang="en-US" class="preface" id="preface" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div><div class="para">
		Full text search engines like Apache Lucene are very powerful technologies to add efficient free text search capabilities to applications. However, Lucene suffers several mismatches when dealing with object domain model. Amongst other things indexes have to be kept up to date and mismatches between index structure and domain model as well as query mismatches have to be avoided.
	</div><div class="para">
		Hibernate Search addresses these shortcomings - it indexes your domain model with the help of a few annotations, takes care of database/index synchronization and brings back regular managed objects from free text queries. To achieve this Hibernate Search is combining the power of <a href="http://www.hibernate.org" class="mimir-link-warn" title="Mimir does not include content from: www.hibernate.org">Hibernate</a> and <a href="http://lucene.apache.org" class="mimir-link-warn" title="Mimir does not include content from: lucene.apache.org">Apache Lucene</a>.
	</div></div><div xml:lang="en-US" class="chapter" id="getting-started" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Getting started</h1></div></div></div><div class="para">
		Welcome to Hibernate Search! The following chapter will guide you through the initial steps required to integrate Hibernate Search into an existing Hibernate enabled application. In case you are a Hibernate new timer we recommend you start <a href="http://hibernate.org/152.html" class="mimir-link-warn" title="Mimir does not include content from: hibernate.org">here</a>.
	</div><div class="section" id="idm139947798605344"><div class="titlepage"><div><div><h2 class="title">1.1. System Requirements</h2></div></div></div><div class="table" id="idm139947798924320"><p class="title"><strong>Table 1.1. System requirements</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="System requirements"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><tbody><tr><td> Java Runtime </td><td> A JDK or JRE version <span class="emphasis"><em>5</em></span> or greater. You can download a Java Runtime for Windows/Linux/Solaris <a href="http://java.sun.com/javase/downloads/" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">here</a>. </td></tr><tr><td> Hibernate Search </td><td> <code class="literal">hibernate-search.jar</code> and all runtime dependencies from the <code class="literal">lib</code> directory of the Hibernate Search distribution. Please refer to <code class="filename">README.txt </code>in the lib directory to understand which dependencies are required. </td></tr><tr><td> Hibernate Core </td><td> This instructions have been tested against Hibernate 3.3.x. You will need <code class="literal">hibernate-core.jar</code> and its transitive dependencies from the <code class="literal">lib</code> directory of the distribution. Refer to <code class="literal">README.txt</code> in the <code class="literal">lib</code> directory of the distribution to determine the minimum runtime requirements. </td></tr><tr><td> Hibernate Annotations </td><td> Even though Hibernate Search can be used without Hibernate Annotations the following instructions will use them for basic entity configuration (<span class="emphasis"><em>@Entity, @Id, @OneToMany,...</em></span>). This part of the configuration could also be expressed in xml or code. However, Hibernate Search itself has its own set of annotations (<span class="emphasis"><em>@Indexed, @DocumentId, @Field,...</em></span>) for which there exists so far no alternative configuration. The tutorial is tested against version 3.4.x of Hibernate Annotations. </td></tr></tbody></table></div></div><div class="para">
			You can download all dependencies from the Hibernate <a href="http://www.hibernate.org/6.html" class="mimir-link-warn" title="Mimir does not include content from: www.hibernate.org">download site</a>. You can also verify the dependency versions against the <a href="http://www.hibernate.org/6.html#A3" class="mimir-link-warn" title="Mimir does not include content from: www.hibernate.org">Hibernate Compatibility Matrix</a>.
		</div></div><div class="section" id="idm139947808720416"><div class="titlepage"><div><div><h2 class="title">1.2. Using Maven</h2></div></div></div><div class="para">
			Instead of managing all dependencies manually, maven users have the possibility to use the <a href="http://repository.jboss.com/maven2" class="mimir-link-warn" title="Mimir does not include content from: repository.jboss.com">JBoss maven repository</a>. Just add the JBoss repository url to the <span class="emphasis"><em>repositories</em></span> section of your <code class="filename">pom.xml</code> or <code class="filename">settings.xml</code>:
		</div><div class="example" id="idm139947808198544"><p class="title"><strong>Example 1.1. Adding the JBoss maven repository to <code class="filename">settings.xml</code></strong></p><div class="example-contents"><pre class="programlisting">
&lt;repository&gt;
  &lt;id&gt;repository.jboss.org&lt;/id&gt;
  &lt;name&gt;JBoss Maven Repository&lt;/name&gt;
  &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
  &lt;layout&gt;default&lt;/layout&gt;
&lt;/repository&gt;
</pre></div></div><div class="para">
			Then add the following dependencies to your pom.xml:
		</div><div class="example" id="idm139947808196128"><p class="title"><strong>Example 1.2. Maven dependencies for Hibernate Search</strong></p><div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;
   &lt;version&gt;3.1.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-common&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-core&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
   &lt;artifactId&gt;lucene-snowball&lt;/artifactId&gt;
   &lt;version&gt;2.4.0&lt;/version&gt;
&lt;/dependency&gt;
</pre></div></div><div class="para">
			Not all dependencies are required. Only the <span class="emphasis"><em>hibernate-search</em></span> dependeny is mandatory. This dependency, together with its required transitive dependencies, contain all required classes needed to use Hibernate Search. <span class="emphasis"><em>hibernate-annotations</em></span> is only needed if you want to use annotations to configure your domain model as we do in this tutorial. However, even if you choose not to use Hibernate Annotations you still have to use the Hibernate Search specific annotations, which are bundled with the hibernate-search jar file, to configure your Lucene index. Currently there is no XML configuration available for Hibernate Search. <span class="emphasis"><em>hibernate-entitymanager</em></span> is required if you want to use Hibernate Search in conjunction with JPA. The Solr dependencies are needed if you want to utilize Solr's analyzer framework. More about this later. And finally, the <code class="literal">lucene-snowball</code> dependency is needed if you want to utililze Lucene's snowball stemmer.
		</div></div><div class="section" id="idm139947796446640"><div class="titlepage"><div><div><h2 class="title">1.3. Configuration</h2></div></div></div><div class="para">
			Once you have downloaded and added all required dependencies to your application you have to add a couple of properties to your hibernate configuration file. If you are using Hibernate directly this can be done in <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA you can also add the properties to <code class="literal">persistence.xml</code>. The good news is that for standard use most properties offer a sensible default. An example <code class="filename">persistence.xml</code> configuration could look like this:
		</div><div class="example" id="idm139947796443328"><p class="title"><strong>Example 1.3. Basic configuration options to be added to <code class="literal"><code class="filename">hibernate.properties</code></code>, <code class="literal"><code class="filename">hibernate.cfg.xml</code></code> or <code class="filename">persistence.xml</code></strong></p><div class="example-contents"><pre class="programlisting">
...
&lt;property name="hibernate.search.default.directory_provider" 
   value="org.hibernate.search.store.FSDirectoryProvider"/&gt; 

&lt;property name="hibernate.search.default.indexBase" value="/var/lucene/indexes"/&gt; 
...
</pre></div></div><div class="para">
			First you have to tell Hibernate Search which <code class="classname">DirectoryProvider</code> to use. This can be achieved by setting the <code class="literal">hibernate.search.default.directory_provider</code> property. Apache Lucene has the notion of a <code class="literal">Directory</code> to store the index files. Hibernate Search handles the initialization and configuration of a Lucene <code class="literal">Directory</code> instance via a <code class="literal">DirectoryProvider</code>. In this tutorial we will use a subclass of <code class="literal">DirectoryProvider</code> called <code class="classname">FSDirectoryProvider</code>. This will give us the ability to physically inspect the Lucene indexes created by Hibernate Search (eg via <a href="http://www.getopt.org/luke/" class="mimir-link-warn" title="Mimir does not include content from: www.getopt.org">Luke</a>). Once you have a working configuration you can start experimenting with other directory providers (see <a class="xref" href="#search-configuration-directory">Section 3.1, “Directory configuration”</a>). Next to the directory provider you also have to specify the default root directory for all indexes via <code class="literal">hibernate.search.default.indexBase</code>.
		</div><div class="para">
			Lets assume that your application contains the Hibernate managed classes <code class="classname">example.Book</code> and <code class="classname">example.Author</code> and you want to add free text search capabilities to your application in order to search the books contained in your database.
		</div><div class="example" id="idm139947800456672"><p class="title"><strong>Example 1.4. Example entities Book and Author before adding Hibernate Search specific annotatons</strong></p><div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id; 

  private String title;  

  private String subtitle; 

  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ...
}
</pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}

</pre></div></div><div class="para">
			To achieve this you have to add a few annotations to the <code class="classname">Book</code> and <code class="classname">Author</code> class. The first annotation <code class="literal">@Indexed</code> marks <code class="classname">Book</code> as indexable. By design Hibernate Search needs to store an untokenized id in the index to ensure index unicity for a given entity. <code class="literal">@DocumentId</code> marks the property to use for this purpose and is in most cases the same as the database primary key. In fact since the 3.1.0 release of Hibernate Search <code class="literal">@DocumentId</code> is optional in the case where an <code class="classname">@Id</code> annotation exists.
		</div><div class="para">
			Next you have to mark the fields you want to make searchable. Let's start with <code class="literal">title</code> and <code class="literal">subtitle</code> and annotate both with <code class="literal">@Field</code>. The parameter <code class="literal">index=Index.TOKENIZED</code> will ensure that the text will be tokenized using the default Lucene analyzer. Usually, tokenizing means chunking a sentence into individual words and potentially excluding common words like <code class="literal">'a'</code> or '<code class="literal">the</code>'. We will talk more about analyzers a little later on. The second parameter we specify within <code class="literal">@Field</code>,<code class="literal"> store=Store.NO</code>, ensures that the actual data will not be stored in the index. Whether this data is stored in the index or not has nothing to do with the ability to search for it. From Lucene's perspective it is not necessary to keep the data once the index is created. The benefit of storing it is the ability to retrieve it via projections (<a class="xref" href="#projections">Section 5.1.2.5, “Projection”</a>).
		</div><div class="para">
			Without projections, Hibernate Search will per default execute a Lucene query in order to find the database identifiers of the entities matching the query critera and use these identifiers to retrieve managed objects from the database. The decision for or against projection has to be made on a case to case basis. The default behaviour - <code class="literal">Store.NO</code> - is recommended since it returns managed objects whereas projections only return object arrays.
		</div><div class="para">
			After this short look under the hood let's go back to annotating the <code class="classname">Book</code> class. Another annotation we have not yet discussed is <code class="literal">@DateBridge</code>. This annotation is one of the built-in field bridges in Hibernate Search. The Lucene index is purely string based. For this reason Hibernate Search must convert the data types of the indexed fields to strings and vice versa. A range of predefined bridges are provided, including the <code class="classname">DateBridge</code> which will convert a <code class="classname">java.util.Date</code> into a <code class="classname">String</code> with the specified resolution. For more details see <a class="xref" href="#search-mapping-bridge">Section 4.2, “Property/Field Bridge”</a>.
		</div><div class="para">
			This leaves us with <code class="literal">@IndexedEmbedded. </code>This annotation is used to index associated entities (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code> and <code class="literal">@Embedded</code>) as part of the owning entity. This is needed since a Lucene index document is a flat data structure which does not know anything about object relations. To ensure that the authors' name wil be searchable you have to make sure that the names are indexed as part of the book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also have to mark all fields of the associated entity you want to have included in the index with <code class="literal">@Indexed</code>. For more dedails see <a class="xref" href="#search-mapping-associated">Section 4.1.3, “Embedded and associated objects”</a>.
		</div><div class="para">
			These settings should be sufficient for now. For more details on entity mapping refer to <a class="xref" href="#search-mapping-entity">Section 4.1, “Mapping an entity”</a>.
		</div><div class="example" id="idm139947804311072"><p class="title"><strong>Example 1.5. Example entities after adding Hibernate Search annotations</strong></p><div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
<span class="bold bold"><strong>@Indexed</strong></span>
public class Book {

  @Id
  @GeneratedValue
  <span class="bold bold"><strong>@DocumentId</strong></span>
  private Integer id;
  
  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String title;
  
  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String subtitle; 

  <span class="bold bold"><strong>@IndexedEmbedded</strong></span>
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold bold"><strong> @Field(index = Index.UN_TOKENIZED, store = Store.YES) @DateBridge(resolution = Resolution.DAY)</strong></span>
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}
</pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  <span class="bold bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}
</pre></div></div></div><div class="section" id="idm139947792400144"><div class="titlepage"><div><div><h2 class="title">1.4. Indexing</h2></div></div></div><div class="para">
			Hibernate Search will transparently index every entity persisted, updated or removed through Hibernate Core. However, you have to trigger an inital indexing to populate the Lucene index with the data already present in your database. Once you have added the above properties and annotations it is time to trigger an initial batch index of your books. You can achieve this by using one of the following code snipplets (see also <a class="xref" href="#search-batchindex">Chapter 6, <em>Manual indexing</em></a>):
		</div><div class="example" id="idm139947792397936"><p class="title"><strong>Example 1.6. Using Hibernate Session to index data</strong></p><div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

List books = session.createQuery("from Book as book").list();
for (Book book : books) {
    <span class="bold bold"><strong>fullTextSession.index(book);</strong></span>
}

tx.commit(); //index is written at commit time
</pre></div></div><div class="example" id="idm139947792395712"><p class="title"><strong>Example 1.7. Using JPA to index data</strong></p><div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
em.getTransaction().begin();

List books = em.createQuery("select book from Book as book").getResultList();
for (Book book : books) {
    <span class="bold bold"><strong>fullTextEntityManager.index(book);</strong></span>
} 

em.getTransaction().commit();
em.close();


</pre></div></div><div class="para">
			After executing the above code, you should be able to see a Lucene index under <code class="literal">/var/lucene/indexes/example.Book</code>. Go ahead an inspect this index with <a href="http://www.getopt.org/luke/" class="mimir-link-warn" title="Mimir does not include content from: www.getopt.org">Luke</a>. It will help you to understand how Hibernate Search works.
		</div></div><div class="section" id="idm139947792391680"><div class="titlepage"><div><div><h2 class="title">1.5. Searching</h2></div></div></div><div class="para">
			Now it is time to execute a first search. The general approach is to create a native Lucene query and then wrap this query into a org.hibernate.Query in order to get all the functionality one is used to from the Hibernate API. The following code will prepare a query against the indexed fields, execute it and return a list of <code class="classname">Book</code>s.
		</div><div class="example" id="idm139947792389600"><p class="title"><strong>Example 1.8. Using Hibernate Session to create and execute a search</strong></p><div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();
  
tx.commit();
session.close();
</pre></div></div><div class="example" id="idm139947804286688"><p class="title"><strong>Example 1.9. Using JPA to create and execute a search</strong></p><div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();

</pre></div></div></div><div class="section" id="idm139947804284384"><div class="titlepage"><div><div><h2 class="title">1.6. Analyzer</h2></div></div></div><div class="para">
			Let's make things a little more interesting now. Assume that one of your indexed book entities has the title "Refactoring: Improving the Design of Existing Code" and you want to get hits for all of the following queries: "refactor", "refactors", "refactored" and "refactoring". In Lucene this can be achieved by choosing an analyzer class which applies word stemming during the indexing <span class="bold bold"><strong>as well as</strong></span> search process. Hibernate Search offers several ways to configure the analyzer to use (see <a class="xref" href="#analyzer">Section 4.1.6, “Analyzer”</a>):
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Setting the <code class="literal">hibernate.search.analyzer</code> property in the configuration file. The specified class will then be the default analyzer.
				</div></li><li class="listitem"><div class="para">
					Setting the <code class="literal"><code class="literal">@Analyzer</code></code> annotation at the entity level.
				</div></li><li class="listitem"><div class="para">
					Setting the <code class="literal">@<code class="literal">Analyzer</code></code> annotation at the field level.
				</div></li></ul></div><div class="para">
			When using the <code class="literal">@Analyzer</code> annotation one can either specify the fully qualified classname of the analyzer to use or one can refer to an analyzer definition defined by the <code class="literal">@AnalyzerDef</code> annotation. In the latter case the Solr analyzer framework with its factories approach is utilized. To find out more about the factory classes available you can either browse the Solr JavaDoc or read the corresponding section on the <a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" class="mimir-link-warn" title="Mimir does not include content from: wiki.apache.org">Solr Wiki.</a> Note that depending on the chosen factory class additional libraries on top of the Solr dependencies might be required. For example, the <code class="classname">PhoneticFilterFactory</code> depends on <a href="http://commons.apache.org/codec" class="mimir-link-warn" title="Mimir does not include content from: commons.apache.org">commons-codec</a>.
		</div><div class="para">
			In the example below a <code class="classname">StandardTokenizerFactory</code> is used followed by two filter factories, <code class="classname">LowerCaseFilterFactory</code> and <code class="classname">SnowballPorterFilterFactory</code>. The standard tokenizer splits words at punctuation characters and hyphens while keeping email addresses and internet hostnames intact. It is a good general purpose tokenizer. The lowercase filter lowercases the letters in each token whereas the snowball filter finally applies language specific stemming.
		</div><div class="para">
			Generally, when using the Solr framework you have to start with a tokenizer followed by an arbitrary number of filters.
		</div><div class="example" id="idm139947804270000"><p class="title"><strong>Example 1.10. Using <code class="classname">@AnalyzerDef</code> and the Solr framework to define and use an analyzer</strong></p><div class="example-contents"><pre class="programlisting">

package example;
...
@Entity
@Indexed
<span class="bold bold"><strong>@AnalyzerDef(name = "customanalyzer", tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class), filters = { @TokenFilterDef(factory = LowerCaseFilterFactory.class), @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = { @Parameter(name = "language", value = "English") }) })</strong></span>
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String title;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String subtitle; 

  @IndexedEmbedded
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold bold"><strong> </strong></span> @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}

</pre></div></div></div><div class="section" id="idm139947804264688"><div class="titlepage"><div><div><h2 class="title">1.7. What's next</h2></div></div></div><div class="para">
			The above paragraphs hopefully helped you getting an overview of Hibernate Search. Using the maven archetype plugin and the following command you can create an initial runnable maven project structure populated with the example code of this tutorial.
		</div><div class="example" id="idm139947804263168"><p class="title"><strong>Example 1.11. Using the maven achetype to create tutorial sources</strong></p><div class="example-contents"><pre class="programlisting">mvn archetype:create \ 
    -DarchetypeGroupId=org.hibernate \
    -DarchetypeArtifactId=hibernate-search-quickstart \ 
    -DarchetypeVersion=3.1.0.GA \
    -DgroupId=my.company -DartifactId=quickstart</pre></div></div><div class="para">
			Using the maven project you can execute the examples, inspect the file system based index and search and retrieve a list of managed objects. Just run <span class="emphasis"><em>mvn package</em></span> to compile the sources and run the unit tests.
		</div><div class="para">
			The next step after this tutorial is to get more familiar with the overall architecture of Hibernate Search (<a class="xref" href="#search-architecture">Chapter 2, <em>Architecture</em></a>) and explore the basic features in more detail. Two topics which were only briefly touched in this tutorial were analyzer configuration (<a class="xref" href="#analyzer">Section 4.1.6, “Analyzer”</a>) and field bridges (<a class="xref" href="#search-mapping-bridge">Section 4.2, “Property/Field Bridge”</a>), both important features required for more fine-grained indexing. More advanced topics cover clustering (<a class="xref" href="#jms-backend">Section 3.5, “JMS Master/Slave configuration”</a>) and large indexes handling (<a class="xref" href="#search-configuration-directory-sharding">Section 3.2, “Sharding indexes”</a>).
		</div></div></div><div xml:lang="en-US" class="chapter" id="search-architecture" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Architecture</h1></div></div></div><div class="section" id="idm139947802237984"><div class="titlepage"><div><div><h2 class="title">2.1. Overview</h2></div></div></div><div class="para">
			Hibernate Search consists of an indexing component and an index search component. Both are backed by Apache Lucene.
		</div><div class="para">
			Each time an entity is inserted, updated or removed in/from the database, Hibernate Search keeps track of this event (through the Hibernate event system) and schedules an index update. All the index updates are handled without you having to use the Apache Lucene APIs (see <a class="xref" href="#search-configuration-event">Section 3.7, “Enabling Hibernate Search and automatic indexing”</a>).
		</div><div class="para">
			To interact with Apache Lucene indexes, Hibernate Search has the notion of <code class="classname">DirectoryProvider</code>s. A directory provider will manage a given Lucene <code class="classname">Directory</code> type. You can configure directory providers to adjust the directory target (see <a class="xref" href="#search-configuration-directory">Section 3.1, “Directory configuration”</a>).
		</div><div class="para">
			Hibernate Search uses the Lucene index to search an entity and return a list of managed entities saving you the tedious object to Lucene document mapping. The same persistence context is shared between Hibernate and Hibernate Search. As a matter of fact, the <code class="classname">FullTextSession</code> is built on top of the Hibernate Session. so that the application code can use the unified <code class="classname">org.hibernate.Query</code> or <code class="classname">javax.persistence.Query</code> APIs exactly the way a HQL, JPA-QL or native queries would do.
		</div><div class="para">
			To be more efficient, Hibernate Search batches the write interactions with the Lucene index. There is currently two types of batching depending on the expected scope. Outside a transaction, the index update operation is executed right after the actual database operation. This scope is really a no scoping setup and no batching is performed. However, it is recommended - for both your database and Hibernate Search - to execute your operation in a transaction be it JDBC or JTA. When in a transaction, the index update operation is scheduled for the transaction commit phase and discarded in case of transaction rollback. The batching scope is the transaction. There are two immediate benefits:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Performance: Lucene indexing works better when operation are executed in batch.
				</div></li><li class="listitem"><div class="para">
					ACIDity: The work executed has the same scoping as the one executed by the database transaction and is executed if and only if the transaction is committed. This is not ACID in the strict sense of it, but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the source at any time.
				</div></li></ul></div><div class="para">
			You can think of those two scopes (no scope vs transactional) as the equivalent of the (infamous) autocommit vs transactional behavior. From a performance perspective, the <span class="emphasis"><em>in transaction</em></span> mode is recommended. The scoping choice is made transparently. Hibernate Search detects the presence of a transaction and adjust the scoping.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Hibernate Search works perfectly fine in the Hibernate/EntityManager long conversation pattern aka. atomic conversation. Also, depending on user demand, additional scoping will be considered, the pluggability mechanism being already in place.
			</div></div></div></div><div class="section" id="idm139947798839344"><div class="titlepage"><div><div><h2 class="title">2.2. Back end</h2></div></div></div><div class="para">
			Hibernate Search offers the ability to let the scoped work being processed by different back ends. Two back ends are provided out of the box for two different scenarios.
		</div><div class="section" id="idm139947804327824"><div class="titlepage"><div><div><h3 class="title">2.2.1. Back end types</h3></div></div></div><div class="section" id="idm139947796291824"><div class="titlepage"><div><div><h4 class="title">2.2.1.1. Lucene</h4></div></div></div><div class="para">
					In this mode, all index update operations applied on a given node (JVM) will be executed to the Lucene directories (through the directory providers) by the same node. This mode is typically used in non clustered environment or in clustered environments where the directory store is shared.
				</div><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Search_Reference_Guide-en-US/images/393ac85ec78b81428bcac4f721be8ce6/lucene-backend.png" align="middle" width="250" /><div class="caption"><div class="para">
						Lucene back end configuration.
					</div></div></div><div class="para">
					This mode targets non clustered applications, or clustered applications where the Directory is taking care of the locking strategy.
				</div><div class="para">
					The main advantage is simplicity and immediate visibility of the changes in Lucene queries (a requirement in some applications).
				</div></div><div class="section" id="idm139947798715168"><div class="titlepage"><div><div><h4 class="title">2.2.1.2. JMS</h4></div></div></div><div class="para">
					All index update operations applied on a given node are sent to a JMS queue. A unique reader will then process the queue and update the master index. The master index is then replicated on a regular basis to the slave copies. This is known as the master/slaves pattern. The master is the sole responsible for updating the Lucene index. The slaves can accept read as well as write operations. However, they only process the read operation on their local index copy and delegate the update operations to the master.
				</div><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Search_Reference_Guide-en-US/images/bd0e6ba6b478bba0f5f9733e44c068e9/jms-backend.png" align="middle" width="250" /><div class="caption"><div class="para">
						JMS back end configuration.
					</div></div></div><div class="para">
					This mode targets clustered environments where throughput is critical, and index update delays are affordable. Reliability is ensured by the JMS provider and by having the slaves working on a local copy of the index.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Hibernate Search is an extensible architecture. Feel free to drop ideas for other third party back ends to <code class="literal">hibernate-dev@lists.jboss.org</code>.
					</div></div></div></div></div><div class="section" id="idm139947806232864"><div class="titlepage"><div><div><h3 class="title">2.2.2. Work execution</h3></div></div></div><div class="para">
				The indexing work (done by the back end) can be executed synchronously with the transaction commit (or update operation if out of transaction), or asynchronously.
			</div><div class="section" id="idm139947806231424"><div class="titlepage"><div><div><h4 class="title">2.2.2.1. Synchronous</h4></div></div></div><div class="para">
					This is the safe mode where the back end work is executed in concert with the transaction commit. Under highly concurrent environment, this can lead to throughput limitations (due to the Apache Lucene lock mechanism) and it can increase the system response time if the backend is significantly slower than the transactional process and if a lot of IO operations are involved.
				</div></div><div class="section" id="idm139947806229616"><div class="titlepage"><div><div><h4 class="title">2.2.2.2. Asynchronous</h4></div></div></div><div class="para">
					This mode delegates the work done by the back end to a different thread. That way, throughput and response time are (to a certain extend) decorrelated from the back end performance. The drawback is that a small delay appears between the transaction commit and the index update and a small overhead is introduced to deal with thread management.
				</div><div class="para">
					It is recommended to use synchronous execution first and evaluate asynchronous execution if performance problems occur and after having set up a proper benchmark (ie not a lonely cowboy hitting the system in a completely unrealistic way).
				</div></div></div></div><div class="section" id="search-architecture-readerstrategy"><div class="titlepage"><div><div><h2 class="title">2.3. Reader strategy</h2></div></div></div><div class="para">
			When executing a query, Hibernate Search interacts with the Apache Lucene indexes through a reader strategy. chosing a reader strategy will depend on the profile of the application (frequent updates, read mostly, asynchronous index update etc). See also <a class="xref" href="#configuration-reader-strategy">Section 3.6, “Reader strategy configuration”</a>
		</div><div class="section" id="idm139947808391456"><div class="titlepage"><div><div><h3 class="title">2.3.1. Shared</h3></div></div></div><div class="para">
				With this strategy, Hibernate Search will share the same <code class="classname">IndexReader</code>, for a given Lucene index, across multiple queries and threads provided that the <code class="classname">IndexReader</code> is still up-to-date. If the <code class="classname">IndexReader</code> is not up-to-date, a new one is opened and provided. Each <code class="classname">IndexReader</code> is made of several <code class="classname">SegmentReader</code>s. This strategy only reopens segments that have been modified or created after last opening and shares the already loaded segments from the previous instance. This strategy is the default.
			</div><div class="para">
				The name of this strategy is <code class="literal">shared</code>.
			</div></div><div class="section" id="idm139947808386640"><div class="titlepage"><div><div><h3 class="title">2.3.2. Not-shared</h3></div></div></div><div class="para">
				Every time a query is executed, a Lucene <code class="classname">IndexReader</code> is opened. This strategy is not the most efficient since opening and warming up an <code class="classname">IndexReader</code> can be a relatively expensive operation.
			</div><div class="para">
				The name of this strategy is <code class="literal">not-shared</code>.
			</div></div><div class="section" id="idm139947803412416"><div class="titlepage"><div><div><h3 class="title">2.3.3. Custom</h3></div></div></div><div class="para">
				You can write your own reader strategy that suits your application needs by implementing <code class="classname">org.hibernate.search.reader.ReaderProvider</code>. The implementation must be thread safe.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="search-configuration" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Configuration</h1></div></div></div><div class="section" id="search-configuration-directory"><div class="titlepage"><div><div><h2 class="title">3.1. Directory configuration</h2></div></div></div><div class="para">
			Apache Lucene has a notion of <code class="literal">Directory</code> to store the index files. The <code class="classname">Directory</code> implementation can be customized, but Lucene comes bundled with a file system (<code class="literal">FSDirectoryProvider</code>) and an in memory (<code class="literal">RAMDirectoryProvider</code>) implementation. <code class="literal">DirectoryProvider</code>s are the Hibernate Search abstraction around a Lucene <code class="classname">Directory</code> and handle the configuration and the initialization of the underlying Lucene resources. <a class="xref" href="#directory-provider-table">Table 3.1, “List of built-in Directory Providers”</a> shows the list of the directory providers bundled with Hibernate Search.
		</div><div class="table" id="directory-provider-table"><p class="title"><strong>Table 3.1. List of built-in Directory Providers</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="List of built-in Directory Providers"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947803543424" scope="col"> Class </th><th align="center" id="idm139947798691232" scope="col"> Description </th><th align="center" id="idm139947803860528" scope="col"> Properties </th></tr></thead><tbody><tr><td headers="idm139947803543424"> org.hibernate.search.store.RAMDirectoryProvider </td><td headers="idm139947798691232"> Memory based directory, the directory will be uniquely identified (in the same deployment unit) by the <code class="literal">@Indexed.index</code> element </td><td headers="idm139947803860528"> none </td></tr><tr><td headers="idm139947803543424"> org.hibernate.search.store.FSDirectoryProvider </td><td headers="idm139947798691232"> File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt; </td><td headers="idm139947803860528"> <div class="para">
							<code class="literal">indexBase</code> : Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr><tr><td headers="idm139947803543424"> org.hibernate.search.store.FSMasterDirectoryProvider </td><td headers="idm139947798691232"> <div class="para">
							File system based directory. Like FSDirectoryProvider. It also copies the index to a source directory (aka copy directory) on a regular basis.
						</div>
						 <div class="para">
							The recommended value for the refresh period is (at least) 50% higher than the time to copy the information (default 3600 seconds - 60 minutes).
						</div>
						 <div class="para">
							Note that the copy is based on an incremental copy mechanism reducing the average copy time.
						</div>
						 <div class="para">
							DirectoryProvider typically used on the master node in a JMS back end cluster.
						</div>
						 <div class="para">
							The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
						</div>
						 </td><td headers="idm139947803860528"> <div class="para">
							<code class="literal">indexBase</code>: Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal">sourceBase</code>: Source (copy) base directory.
						</div>
						 <div class="para">
							<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
						</div>
						 <div class="para">
							<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
						</div>
						 <div class="para">
							<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr><tr><td headers="idm139947803543424"> org.hibernate.search.store.FSSlaveDirectoryProvider </td><td headers="idm139947798691232"> <div class="para">
							File system based directory. Like FSDirectoryProvider, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
						</div>
						 <div class="para">
							The recommended value for the refresh period is (at least) 50% higher than the time to copy the information (default 3600 seconds - 60 minutes).
						</div>
						 <div class="para">
							Note that the copy is based on an incremental copy mechanism reducing the average copy time.
						</div>
						 <div class="para">
							DirectoryProvider typically used on slave nodes using a JMS back end.
						</div>
						 <div class="para">
							The <code class="literal"> buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
						</div>
						 </td><td headers="idm139947803860528"> <div class="para">
							<code class="literal">indexBase</code>: Base directory
						</div>
						 <div class="para">
							<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
						</div>
						 <div class="para">
							<code class="literal">sourceBase</code>: Source (copy) base directory.
						</div>
						 <div class="para">
							<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
						</div>
						 <div class="para">
							<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
						</div>
						 <div class="para">
							<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
						</div>
						 <div class="para">
							<code class="literal"> locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories">Section 3.9, “LockFactory configuration”</a>
						</div>
						 </td></tr></tbody></table></div></div><div class="para">
			If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <code class="classname">org.hibernate.store.DirectoryProvider</code> interface.
		</div><div class="para">
			Each indexed entity is associated to a Lucene index (an index can be shared by several entities but this is not usually the case). You can configure the index through properties prefixed by <code class="constant">hibernate.search.</code><em class="replaceable">indexname</em> . Default properties inherited to all indexes can be defined using the prefix <code class="constant">hibernate.search.default.</code>
		</div><div class="para">
			To define the directory provider of a given index, you use the <code class="constant">hibernate.search.<em class="replaceable">indexname</em>.directory_provider </code>
		</div><div class="example" id="idm139947799883184"><p class="title"><strong>Example 3.1. Configuring directory providers</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider org.hibernate.search.store.RAMDirectoryProvider</pre></div></div><div class="para">
			applied on
		</div><div class="example" id="idm139947799881072"><p class="title"><strong>Example 3.2. Specifying the index name using the <code class="literal">index</code> parameter of <code class="classname">@Indexed</code></strong></p><div class="example-contents"><pre class="programlisting">@Indexed(index="Status")
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }</pre></div></div><div class="para">
			will create a file system directory in <code class="filename">/usr/lucene/indexes/Status</code> where the Status entities will be indexed, and use an in memory directory named <code class="literal">Rules</code> where Rule entities will be indexed.
		</div><div class="para">
			You can easily define common rules like the directory provider and base directory, and override those defaults later on on a per index basis.
		</div><div class="para">
			Writing your own <code class="classname">DirectoryProvider</code>, you can utilize this configuration mechanism as well.
		</div></div><div class="section" id="search-configuration-directory-sharding"><div class="titlepage"><div><div><h2 class="title">3.2. Sharding indexes</h2></div></div></div><div class="para">
			In some extreme cases involving huge indexes (in size), it is necessary to split (shard) the indexing data of a given entity type into several Lucene indexes. This solution is not recommended until you reach significant index sizes and index update times are slowing the application down. The main drawback of index sharding is that searches will end up being slower since more files have to be opened for a single search. In other words don't do it until you have problems :)
		</div><div class="para">
			Despite this strong warning, Hibernate Search allows you to index a given entity type into several sub indexes. Data is sharded into the different sub indexes thanks to an <code class="classname">IndexShardingStrategy</code>. By default, no sharding strategy is enabled, unless the number of shards is configured. To configure the number of shards use the following property
		</div><div class="example" id="idm139947792636432"><p class="title"><strong>Example 3.3. Enabling index sharding by specifying nbr_of_shards for a specific index</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5</pre></div></div><div class="para">
			This will use 5 different shards.
		</div><div class="para">
			The default sharding strategy, when shards are set up, splits the data according to the hash value of the id string representation (generated by the Field Bridge). This ensures a fairly balanced sharding. You can replace the strategy by implementing <code class="literal">IndexShardingStrategy</code> and by setting the following property
		</div><div class="example" id="idm139947792633360"><p class="title"><strong>Example 3.4. Specifying a custom sharding strategy</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation</pre></div></div><div class="para">
			Each shard has an independent directory provider configuration as described in <a class="xref" href="#search-configuration-directory">Section 3.1, “Directory configuration”</a>. The DirectoryProvider default name for the previous example are <code class="literal">&lt;indexName&gt;.0</code> to <code class="literal">&lt;indexName&gt;.4</code>. In other words, each shard has the name of it's owning index followed by <code class="constant">.</code> (dot) and its index number.
		</div><div class="example" id="idm139947792629632"><p class="title"><strong>Example 3.5. Configuring the sharding configuration for an example entity <code class="classname">Animal</code></strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase /usr/lucene/indexes

hibernate.search.Animal.sharding_strategy.nbr_of_shards 5
hibernate.search.Animal.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.Animal.0.indexName Animal00
hibernate.search.Animal.3.indexBase /usr/lucene/sharded
hibernate.search.Animal.3.indexName Animal03</pre></div></div><div class="para">
			This configuration uses the default id string hashing strategy and shards the Animal index into 5 subindexes. All subindexes are <code class="classname">FSDirectoryProvider</code> instances and the directory where each subindex is stored is as followed:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					for subindex 0: /usr/lucene/indexes/Animal00 (shared indexBase but overridden indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 1: /usr/lucene/indexes/Animal.1 (shared indexBase, default indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 2: /usr/lucene/indexes/Animal.2 (shared indexBase, default indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 3: /usr/lucene/shared/Animal03 (overridden indexBase, overridden indexName)
				</div></li><li class="listitem"><div class="para">
					for subindex 4: /usr/lucene/indexes/Animal.4 (shared indexBase, default indexName)
				</div></li></ul></div></div><div class="section" id="idm139947792621168"><div class="titlepage"><div><div><h2 class="title">3.3. Sharing indexes (two entities into the same directory)</h2></div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				This is only presented here so that you know the option is available. There is really not much benefit in sharing indexes.
			</div></div></div><div class="para">
			It is technically possible to store the information of more than one entity into a single Lucene index. There are two ways to accomplish this:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Configuring the underlying directory providers to point to the same physical index directory. In practice, you set the property <code class="literal">hibernate.search.[fully qualified entity name].indexName</code> to the same value. As an example let’s use the same index (directory) for the <code class="classname">Furniture</code> and <code class="classname">Animal</code> entity. We just set <code class="literal">indexName</code> for both entities to for example “Animal”. Both entities will then be stored in the Animal directory
				</div><div class="para">
					
<pre class="programlisting"><code class="code">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Aninal hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Aninal</code></pre>

				</div></li><li class="listitem"><div class="para">
					Setting the <code class="code">@Indexed</code> annotation’s <code class="methodname">index</code> attribute of the entities you want to merge to the same value. If we again wanted all <code class="classname">Furniture</code> instances to be indexed in the <code class="classname">Animal</code> index along with all instances of <code class="classname">Animal</code> we would specify <code class="code">@Indexed(index=”Animal”)</code> on both <code class="classname">Animal</code> and <code class="classname">Furniture</code> classes.
				</div></li></ul></div></div><div class="section" id="idm139947796015776"><div class="titlepage"><div><div><h2 class="title">3.4. Worker configuration</h2></div></div></div><div class="para">
			It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. The work can be executed to the Lucene directory or sent to a JMS queue for later processing. When processed to the Lucene directory, the work can be processed synchronously or asynchronously to the transaction commit.
		</div><div class="para">
			You can define the worker configuration using the following properties
		</div><div class="table" id="idm139947796013744"><p class="title"><strong>Table 3.2. worker configuration</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="worker configuration"><colgroup><col align="center"><!--Empty--></col><col><!--Empty--></col></colgroup><tbody><tr><td align="center"> Property </td><td> Description </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.backend</code> </td><td> Out of the box support for the Apache Lucene back end and the JMS back end. Default to <code class="literal">lucene</code>. Supports also <code class="literal">jms</code>. </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.execution</code> </td><td> Supports synchronous and asynchrounous execution. Default to <code class="literal"> <code class="literal">sync</code> </code>. Supports also <code class="literal">async</code>. </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.thread_pool.size</code> </td><td> Defines the number of threads in the pool. useful only for asynchrounous execution. Default to 1. </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.buffer_queue.max</code> </td><td> Defines the maximal number of work queue if the thread poll is starved. Useful only for asynchrounous execution. Default to infinite. If the limit is reached, the work is done by the main thread. </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.jndi.*</code> </td><td> Defines the JNDI properties to initiate the InitialContext (if needed). JNDI is only used by the JMS back end. </td></tr><tr><td align="center"> <code class="literal"> hibernate.search.worker.jms.connection_factory</code> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<code class="literal">/ConnectionFactory</code> by default in JBoss AS) </td></tr><tr><td align="center"> <code class="literal">hibernate.search.worker.jms.queue</code> </td><td> Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages. </td></tr></tbody></table></div></div></div><div class="section" id="jms-backend"><div class="titlepage"><div><div><h2 class="title">3.5. JMS Master/Slave configuration</h2></div></div></div><div class="para">
			This section describes in greater detail how to configure the Master / Slaves Hibernate Search architecture.
		</div><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Search_Reference_Guide-en-US/images/bd0e6ba6b478bba0f5f9733e44c068e9/jms-backend.png" align="middle" width="250" /><div class="caption"><div class="para">
				JMS Master/Slave architecture overview.
			</div></div></div><div class="section" id="idm139947795988352"><div class="titlepage"><div><div><h3 class="title">3.5.1. Slave nodes</h3></div></div></div><div class="para">
				Every index update operation is sent to a JMS queue. Index quering operations are executed on a local index copy.
			</div><div class="example" id="idm139947795986960"><p class="title"><strong>Example 3.6. JMS Slave configuration</strong></p><div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSSlaveDirectoryProvider

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.worker.execution = async
# hibernate.search.worker.thread_pool.size = 2
# hibernate.search.worker.buffer_queue.max = 50</pre></div></div><div class="para">
				A file system local copy is recommended for faster search results.
			</div><div class="para">
				The refresh period should be higher than the expected time copy.
			</div></div><div class="section" id="idm139947795983600"><div class="titlepage"><div><div><h3 class="title">3.5.2. Master node</h3></div></div></div><div class="para">
				Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis.
			</div><div class="example" id="idm139947795982208"><p class="title"><strong>Example 3.7. JMS Master configuration</strong></p><div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSMasterDirectoryProvider

## Backend configuration
#Backend is the default lucene one</pre></div></div><div class="para">
				The refresh period should be higher than the expected time copy.
			</div><div class="para">
				In addition to the Hibernate Search framework configuration, a Message Driven Bean should be written and set up to process the index works queue through JMS.
			</div><div class="example" id="idm139947795979216"><p class="title"><strong>Example 3.8. Message Driven Bean processing the indexing queue</strong></p><div class="example-contents"><pre class="programlisting">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController implements MessageListener {
    @PersistenceContext EntityManager em;
    
    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session) 
    }
}</pre></div></div><div class="para">
				This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a JavaEE 5 MDB. This implementation is given as an example and, while most likely be more complex, can be adjusted to make use of non Java EE Message Driven Beans. For more information about the <code class="methodname">getSession()</code> and <code class="methodname">cleanSessionIfNeeded()</code>, please check <code class="classname">AbstractJMSHibernateSearchController</code>'s javadoc.
			</div></div></div><div class="section" id="configuration-reader-strategy"><div class="titlepage"><div><div><h2 class="title">3.6. Reader strategy configuration</h2></div></div></div><div class="para">
			The different reader strategies are described in <a class="xref" href="#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>. Out of the box strategies are:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">shared</code>: share index readers across several queries. This strategy is the most efficient.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">not-shared</code>: create an index reader for each individual query
				</div></li></ul></div><div class="para">
			The default reader strategy is <code class="literal">shared</code>. This can be adjusted:
		</div><pre class="programlisting">hibernate.search.reader.strategy = not-shared</pre><div class="para">
			Adding this property switches to the <code class="literal">not-shared</code> strategy.
		</div><div class="para">
			Or if you have a custom reader strategy:
		</div><pre class="programlisting">hibernate.search.reader.strategy = my.corp.myapp.CustomReaderProvider</pre><div class="para">
			where <code class="classname">my.corp.myapp.CustomReaderProvider</code> is the custom strategy implementation.
		</div></div><div class="section" id="search-configuration-event"><div class="titlepage"><div><div><h2 class="title">3.7. Enabling Hibernate Search and automatic indexing</h2></div></div></div><div class="section" id="idm139947785237744"><div class="titlepage"><div><div><h3 class="title">3.7.1. Enabling Hibernate Search</h3></div></div></div><div class="para">
				Hibernate Search is enabled out of the box when using Hibernate Annotations or Hibernate EntityManager. If, for some reason you need to disable it, set <code class="literal">hibernate.search.autoregister_listeners</code> to false. Note that there is no performance penalty when the listeners are enabled even though no entities are indexed.
			</div><div class="para">
				To enable Hibernate Search in Hibernate Core (ie. if you don't use Hibernate Annotations), add the <code class="literal">FullTextIndexEventListener</code> for the following six Hibernate events.
			</div><div class="example" id="idm139947785234800"><p class="title"><strong>Example 3.9. Explicitly enabling Hibernate Search by configuring the <code class="classname">FullTextIndexEventListener</code></strong></p><div class="example-contents"><pre class="programlisting">&lt;hibernate-configuration&gt;
     &lt;session-factory&gt;
        ...
        &lt;event type="post-update"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-insert"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-delete"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-recreate"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-remove"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-update"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre></div></div></div><div class="section" id="idm139947785231904"><div class="titlepage"><div><div><h3 class="title">3.7.2. Automatic indexing</h3></div></div></div><div class="para">
				By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search updates the according Lucene index. It is sometimes desirable to disable that features if either your index is read-only or if index updates are done in a batch way (see <a class="xref" href="#search-batchindex">Chapter 6, <em>Manual indexing</em></a>).
			</div><div class="para">
				To disable event based indexing, set
			</div><pre class="programlisting">hibernate.search.indexing_strategy manual</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					In most case, the JMS backend provides the best of both world, a lightweight event based system keeps track of all changes in the system, and the heavyweight indexing process is done by a separate process or machine.
				</div></div></div></div></div><div class="section" id="lucene-indexing-performance"><div class="titlepage"><div><div><h2 class="title">3.8. Tuning Lucene indexing performance</h2></div></div></div><div class="para">
			Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code> and <code class="literal">maxBufferedDocs</code>. You can specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard.
		</div><div class="para">
			There are two sets of parameters allowing for different performance settings depending on the use case. During indexing operations triggered by database modifications, the parameters are grouped by the <code class="literal">transaction</code> keyword: 
<pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.transaction.&lt;parameter_name&gt;</pre>
			 When indexing occurs via <code class="literal">FullTextSession.index()</code> (see <a class="xref" href="#search-batchindex">Chapter 6, <em>Manual indexing</em></a>), the used properties are those grouped under the <code class="literal">batch</code> keyword: 
<pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.&lt;parameter_name&gt;</pre>

		</div><div class="para">
			Unless the corresponding <code class="literal">.batch</code> property is explicitly set, the value will default to the <code class="literal">.transaction</code> property. If no value is set for a <code class="literal">.batch</code> value in a specific shard configuration, Hibernate Search will look at the index section, then at the default section and after that it will look for a <code class="literal">.transaction</code> in the same order: 
<pre class="programlisting">hibernate.search.Animals.2.indexwriter.transaction.max_merge_docs 10
hibernate.search.Animals.2.indexwriter.transaction.merge_factor 20
hibernate.search.default.indexwriter.batch.max_merge_docs 100</pre>
			 This configuration will result in these settings applied to the second shard of Animals index:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">transaction.max_merge_docs</code> = 10
				</div></li><li class="listitem"><div class="para">
					<code class="literal">batch.max_merge_docs</code> = 100
				</div></li><li class="listitem"><div class="para">
					<code class="literal">transaction.merge_factor</code> = 20
				</div></li><li class="listitem"><div class="para">
					<code class="literal">batch.merge_factor</code> = 20
				</div></li></ul></div><div class="para">
			All other values will use the defaults defined in Lucene.
		</div><div class="para">
			The default for all values is to leave them at Lucene's own default, so the listed values in the following table actually depend on the version of Lucene you are using; values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performances, please refer to the Lucene documentation.
		</div><div class="table" id="idm139947785209072"><p class="title"><strong>Table 3.3. List of indexing performance and behavior properties</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="List of indexing performance and behavior properties"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947785207152" scope="col"> Property </th><th align="center" id="idm139947785206480" scope="col"> Description </th><th align="center" id="idm139947785205808" scope="col"> Default Value </th></tr></thead><tbody><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_delete_terms</code> </td><td headers="idm139947785206480"> <div class="para">
							Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
						</div>
						 </td><td headers="idm139947785205808"> Disabled (flushes by RAM usage) </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_docs</code> </td><td headers="idm139947785206480"> <div class="para">
							Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
						</div>
						 </td><td headers="idm139947785205808"> Disabled (flushes by RAM usage) </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_field_length</code> </td><td headers="idm139947785206480"> <div class="para">
							The maximum number of terms that will be indexed for a single field. This limits the amount of memory required for indexing so that very large data will not crash the indexing process by running out of memory. This setting refers to the number of running terms, not to the number of different terms.
						</div>
						 <div class="para">
							This silently truncates large documents, excluding from the index all terms that occur further in the document. If you know your source documents are large, be sure to set this value high enough to accomodate the expected size. If you set it to Integer.MAX_VALUE, then the only limit is your memory, but you should anticipate an OutOfMemoryError.
						</div>
						 <div class="para">
							If setting this value in <code class="literal">batch</code> differently than in <code class="literal">transaction</code> you may get different data (and results) in your index depending on the indexing mode.
						</div>
						 </td><td headers="idm139947785205808"> 10000 </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_merge_docs</code> </td><td headers="idm139947785206480"> <div class="para">
							Defines the largest number of documents allowed in a segment. Larger values are best for batched indexing and speedier searches. Small values are best for transaction indexing.
						</div>
						 </td><td headers="idm139947785205808"> Unlimited (Integer.MAX_VALUE) </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].merge_factor</code> </td><td headers="idm139947785206480"> <div class="para">
							Controls segment merge frequency and size.
						</div>
						 <div class="para">
							Determines how often segment indices are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indices are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indices are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indices that are interactively maintained. The value must no be lower than 2.
						</div>
						 </td><td headers="idm139947785205808"> 10 </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].ram_buffer_size</code> </td><td headers="idm139947785206480"> <div class="para">
							Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
						</div>
						 <div class="para">
							Generally for faster indexing performance it's best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
						</div>
						 </td><td headers="idm139947785205808"> 16 MB </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].term_index_interval</code> </td><td headers="idm139947785206480"> <div class="para">
							Expert: Set the interval between indexed terms.
						</div>
						 <div class="para">
							Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
						</div>
						 </td><td headers="idm139947785205808"> 128 </td></tr><tr><td headers="idm139947785207152"> <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].use_compound_file</code> </td><td headers="idm139947785206480"> The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large. 
						<div class="para">

						</div>
						 <div class="para">
							Boolean parameter, use "<code class="literal">true</code>" or "<code class="literal">false</code>". The default value for this option is <code class="literal">true</code>.
						</div>
						 </td><td headers="idm139947785205808"> true </td></tr></tbody></table></div></div></div><div class="section" id="search-configuration-directory-lockfactories"><div class="titlepage"><div><div><h2 class="title">3.9. LockFactory configuration</h2></div></div></div><div class="para">
			Lucene Directories have default locking strategies which work well for most cases, but it's possible to specify for each index managed by Hibernate Search which LockingFactory you want to use.
		</div><div class="para">
			Some of these locking strategies require a filesystem level lock and may be used even on RAM based indexes, but this is not recommended and of no practical use.
		</div><div class="para">
			To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to one of <code class="literal">simple</code>, <code class="literal">native</code>, <code class="literal">single</code> or <code class="literal">none</code>, or set it to the fully qualified name of an implementation of <code class="literal">org.hibernate.search.store.LockFactoryFactory</code>; Implementing this interface you can provide a custom <code class="literal">org.apache.lucene.store.LockFactory</code>.
		</div><div class="table" id="search-configuration-directory-lockfactories-table"><p class="title"><strong>Table 3.4. List of available LockFactory implementations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="List of available LockFactory implementations"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947785163488" scope="col"> name </th><th align="center" id="idm139947785162704" scope="col"> Class </th><th align="center" id="idm139947785161920" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139947785163488"> simple </td><td headers="idm139947785162704"> org.apache.lucene.store.SimpleFSLockFactory </td><td headers="idm139947785161920"> <div class="para">
							Safe implementation based on Java's File API, it marks the usage of the index by creating a marker file.
						</div>
						 <div class="para">
							If for some reason you had to kill your application, you will need to remove this file before restarting it.
						</div>
						 <div class="para">
							This is the default implementation for <code class="literal">FSDirectoryProvider</code>,<code class="literal">FSMasterDirectoryProvider</code> and <code class="literal">FSSlaveDirectoryProvider</code>.
						</div>
						 </td></tr><tr><td headers="idm139947785163488"> native </td><td headers="idm139947785162704"> org.apache.lucene.store.NativeFSLockFactory </td><td headers="idm139947785161920"> <div class="para">
							As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if your application crashes the locks will be cleaned up.
						</div>
						 <div class="para">
							This implementation has known problems on NFS.
						</div>
						 </td></tr><tr><td headers="idm139947785163488"> single </td><td headers="idm139947785162704"> org.apache.lucene.store.SingleInstanceLockFactory </td><td headers="idm139947785161920"> <div class="para">
							This LockFactory doesn't use a file marker but is a Java object lock held in memory; therefore it's possible to use it only when you are sure the index is not going to be shared by any other process.
						</div>
						 <div class="para">
							This is the default implementation for <code class="literal">RAMDirectoryProvider</code>.
						</div>
						 </td></tr><tr><td headers="idm139947785163488"> none </td><td headers="idm139947785162704"> org.apache.lucene.store.NoLockFactory </td><td headers="idm139947785161920"> <div class="para">
							All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means.
						</div>
						 </td></tr></tbody></table></div></div><div class="para">
			Configuration example:
		</div><pre class="programlisting">hibernate.search.default.locking_strategy simple
hibernate.search.Animals.locking_strategy native
hibernate.search.Books.locking_strategy org.custom.components.MyLockingFactory</pre></div></div><div xml:lang="en-US" class="chapter" id="search-mapping" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Mapping entities to the index structure</h1></div></div></div><div class="para">
		All the metadata information needed to index entities is described through annotations. There is no need for xml mapping files. In fact there is currently no xml configuration option available (see <a href="http://opensource.atlassian.com/projects/hibernate/browse/HSEARCH-210" class="mimir-link-warn" title="Mimir does not include content from: opensource.atlassian.com">HSEARCH-210</a>). You can still use Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific configuration has to be expressed via annotations.
	</div><div class="section" id="search-mapping-entity"><div class="titlepage"><div><div><h2 class="title">4.1. Mapping an entity</h2></div></div></div><div class="section" id="basic-mapping"><div class="titlepage"><div><div><h3 class="title">4.1.1. Basic mapping</h3></div></div></div><div class="para">
				First, we must declare a persistent class as indexable. This is done by annotating the class with <code class="literal">@Indexed</code> (all entities not annotated with <code class="literal">@Indexed</code> will be ignored by the indexing process):
			</div><div class="example" id="idm139947801994640"><p class="title"><strong>Example 4.1. Making a class indexable using the <code class="classname">@Indexed</code> annotation</strong></p><div class="example-contents"><pre class="programlisting">@Entity
<span class="bold bold"><strong>@Indexed(index="indexes/essays")</strong></span>
public class Essay {
    ...
}</pre></div></div><div class="para">
				The <code class="literal">index</code> attribute tells Hibernate what the Lucene directory name is (usually a directory on your file system). It is recommended to define a base directory for all Lucene indexes using the <code class="literal">hibernate.search.default.indexBase</code> property in your configuration file. Alternatively you can specify a base directory per indexed entity by specifying <code class="literal">hibernate.search.&lt;index&gt;.indexBase, </code>where <code class="literal">&lt;index&gt;</code> is the fully qualified classname of the indexed entity. Each entity instance will be represented by a Lucene <code class="classname">Document</code> inside the given index (aka Directory).
			</div><div class="para">
				For each property (or attribute) of your entity, you have the ability to describe how it will be indexed. The default (no annotation present) means that the property is ignored by the indexing process. <code class="literal">@Field</code> does declare a property as indexed. When indexing an element to a Lucene document you can specify how it is indexed:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">name</code> : describe under which name, the property should be stored in the Lucene Document. The default value is the property name (following the JavaBeans convention)
					</div></li><li class="listitem"><div class="para">
						<code class="literal">store</code> : describe whether or not the property is stored in the Lucene index. You can store the value <code class="literal">Store.YES</code> (comsuming more space in the index but allowing projection, see <a class="xref" href="#projections">Section 5.1.2.5, “Projection”</a> for more information), store it in a compressed way <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or avoid any storage <code class="literal">Store.NO</code> (this is the default value). When a property is stored, you can retrieve its original value from the Lucene Document. This is not related to whether the element is indexed or not.
					</div></li><li class="listitem"><div class="para">
						index: describe how the element is indexed and the type of information store. The different values are <code class="literal">Index.NO</code> (no indexing, ie cannot be found by a query), <code class="literal">Index.TOKENIZED</code> (use an analyzer to process the property), <code class="literal">Index.UN_TOKENISED</code> (no analyzer pre processing), <code class="literal">Index.NO_NORM</code> (do not store the normalization data). The default value is <code class="literal">TOKENIZED</code>.
					</div></li><li class="listitem"><div class="para">
						termVector: describes collections of term-frequency pairs. This attribute enables term vectors being stored during indexing so they are available within documents. The default value is TermVector.NO.
					</div><div class="para">
						The different values of this attribute are:
					</div><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947804187488" scope="col"> Value </th><th align="center" id="idm139947804186816" scope="col"> Definition </th></tr></thead><tbody><tr><td align="left" headers="idm139947804187488"> TermVector.YES </td><td align="left" headers="idm139947804186816"> Store the term vectors of each document. This produces two synchronized arrays, one contains document terms and the other contains the term's frequency. </td></tr><tr><td align="left" headers="idm139947804187488"> TermVector.NO </td><td align="left" headers="idm139947804186816"> Do not store term vectors. </td></tr><tr><td align="left" headers="idm139947804187488"> TermVector.WITH_OFFSETS </td><td align="left" headers="idm139947804186816"> Store the term vector and token offset information. This is the same as TermVector.YES plus it contains the starting and ending offset position information for the terms. </td></tr><tr><td align="left" headers="idm139947804187488"> TermVector.WITH_POSITIONS </td><td align="left" headers="idm139947804186816"> Store the term vector and token position information. This is the same as TermVector.YES plus it contains the ordinal positions of each occurrence of a term in a document. </td></tr><tr><td align="left" headers="idm139947804187488"> TermVector.WITH_POSITIONS_OFFSETS </td><td align="left" headers="idm139947804186816"> Store the term vector, token position and offset information. This is a combination of the YES, WITH_OFFSETS and WITH_POSITIONS. </td></tr></tbody></table></div></li></ul></div><div class="para">
				Whether or not you want to store the original data in the index depends on how you wish to use the index query result. For a regular Hibernate Search usage storing is not necessary. However you might want to store some fields to subsequently project them (see <a class="xref" href="#projections">Section 5.1.2.5, “Projection”</a> for more information).
			</div><div class="para">
				Whether or not you want to tokenize a property depends on whether you wish to search the element as is, or by the words it contains. It make sense to tokenize a text field, but probably not a date field.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Note that fields used for sorting must not be tokenized.
				</div></div></div><div class="para">
				Finally, the id property of an entity is a special property used by Hibernate Search to ensure index unicity of a given entity. By design, an id has to be stored and must not be tokenized. To mark a property as index id, use the <code class="literal">@DocumentId</code> annotation. If you are using Hibernate Annotations and you have specified @Id you can omit @DocumentId. The chosen entity id will also be used as document id.
			</div><div class="example" id="example-annotated-entity"><p class="title"><strong>Example 4.2. Adding <code class="classname">@DocumentId</code> ad <code class="classname">@Field</code> annotations to an indexed entity</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...

    @Id
    <span class="bold bold"><strong>@DocumentId</strong></span>
    public Long getId() { return id; }

    <span class="bold bold"><strong>@Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    <span class="bold bold"><strong>@Field(index=Index.TOKENIZED)</strong></span>
    public String getText() { return text; }
}</pre></div></div><div class="para">
				<a class="xref" href="#example-annotated-entity">Example 4.2, “Adding <code class="classname">@DocumentId</code> ad <code class="classname">@Field</code> annotations to an indexed entity”</a> define an index with three fields: <code class="literal">id</code> , <code class="literal">Abstract</code> and <code class="literal">text</code> . Note that by default the field name is decapitalized, following the JavaBean specification
			</div></div><div class="section" id="idm139947799024624"><div class="titlepage"><div><div><h3 class="title">4.1.2. Mapping properties multiple times</h3></div></div></div><div class="para">
				Sometimes one has to map a property multiple times per index, with slightly different indexing strategies. For example, sorting a query by field requires the field to be <code class="literal">UN_TOKENIZED</code>. If one wants to search by words in this property and still sort it, one need to index it twice - once tokenized and once untokenized. @Fields allows to achieve this goal.
			</div><div class="example" id="example-fields-annotation"><p class="title"><strong>Example 4.3. Using @Fields to map a property multiple times</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index = "Book" )
public class Book {
    <span class="bold bold"><strong>@Fields( {</strong></span>
            @Field(index = Index.TOKENIZED),
            @Field(name = "summary_forSort", index = Index.UN_TOKENIZED, store = Store.YES)
            <span class="bold bold"><strong>} )</strong></span>
    public String getSummary() {
        return summary;
    }

    ...
}</pre></div></div><div class="para">
				In <a class="xref" href="#example-fields-annotation">Example 4.3, “Using @Fields to map a property multiple times”</a>, the field <code class="literal">summary</code> is indexed twice; once as <code class="literal">summary</code> in a tokenized way, and once as <code class="literal">summary_forSort</code> in an untokenized way. @Field supports 2 attributes useful when @Fields is used:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						analyzer: defines a @Analyzer annotation per field rather than per property
					</div></li><li class="listitem"><div class="para">
						bridge: defines a @FieldBridge annotation per field rather than per property
					</div></li></ul></div><div class="para">
				See below for more information about analyzers and field bridges.
			</div></div><div class="section" id="search-mapping-associated"><div class="titlepage"><div><div><h3 class="title">4.1.3. Embedded and associated objects</h3></div></div></div><div class="para">
				Associated objects as well as embedded objects can be indexed as part of the root entity index. This is ueful if you expect to search a given entity based on properties of associated objects. In the following example the aim is to return places where the associated city is Atlanta (In the Lucene query parser language, it would translate into <code class="code">address.city:Atlanta</code>).
			</div><div class="example" id="idm139947785989952"><p class="title"><strong>Example 4.4. Using @IndexedEmbedded to index associations</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre></div></div><div class="para">
				In this example, the place fields will be indexed in the <code class="literal">Place</code> index. The <code class="literal">Place</code> index documents will also contain the fields <code class="literal">address.id</code>, <code class="literal">address.street</code>, and <code class="literal">address.city</code> which you will be able to query. This is enabled by the <code class="literal">@IndexedEmbedded</code> annotation.
			</div><div class="para">
				Be careful. Because the data is denormalized in the Lucene index when using the <code class="classname">@IndexedEmbedded</code> technique, Hibernate Search needs to be aware of any change in the <code class="classname">Place</code> object and any change in the <code class="classname">Address</code> object to keep the index up to date. To make sure the <code class="literal"> <code class="classname">Place</code> </code> Lucene document is updated when it's <code class="classname">Address</code> changes, you need to mark the other side of the birirectional relationship with <code class="classname">@ContainedIn</code>.
			</div><div class="para">
				<code class="literal">@ContainedIn</code> is only useful on associations pointing to entities as opposed to embedded (collection of) objects.
			</div><div class="para">
				Let's make our example a bit more complex:
			</div><div class="example" id="idm139947802412672"><p class="title"><strong>Example 4.5. Nested usage of <code class="classname">@IndexedEmbedded</code> and <code class="classname">@ContainedIn</code></strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold bold"><strong>@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</strong></span>
    private Owner ownedBy;

    <span class="bold bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field(index = Index.TOKENIZED)
    private String name;
   ...
}</pre></div></div><div class="para">
				Any <code class="literal">@*ToMany, @*ToOne</code> and <code class="literal">@Embedded</code> attribute can be annotated with <code class="literal">@IndexedEmbedded</code>. The attributes of the associated class will then be added to the main entity index. In the previous example, the index will contain the following fields
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						id
					</div></li><li class="listitem"><div class="para">
						name
					</div></li><li class="listitem"><div class="para">
						address.street
					</div></li><li class="listitem"><div class="para">
						address.city
					</div></li><li class="listitem"><div class="para">
						addess.ownedBy_name
					</div></li></ul></div><div class="para">
				The default prefix is <code class="literal">propertyName.</code>, following the traditional object navigation convention. You can override it using the <code class="literal">prefix</code> attribute as it is shown on the <code class="literal">ownedBy</code> property.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The prefix cannot be set to the empty string.
				</div></div></div><div class="para">
				The<code class="literal"> depth</code> property is necessary when the object graph contains a cyclic dependency of classes (not instances). For example, if <code class="classname">Owner</code> points to <code class="classname">Place</code>. Hibernate Search will stop including Indexed embedded atttributes after reaching the expected depth (or the object graph boundaries are reached). A class having a self reference is an example of cyclic dependency. In our example, because <code class="literal">depth</code> is set to 1, any <code class="literal">@IndexedEmbedded</code> attribute in Owner (if any) will be ignored.
			</div><div class="para">
				Using <code class="literal">@IndexedEmbedded</code> for object associations allows you to express queries such as:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Return places where name contains JBoss and where address city is Atlanta. In Lucene query this would be
					</div><pre class="programlisting">+name:jboss +address.city:atlanta</pre></li><li class="listitem"><div class="para">
						Return places where name contains JBoss and where owner's name contain Joe. In Lucene query this would be
					</div><pre class="programlisting">+name:jboss +address.orderBy_name:joe</pre></li></ul></div><div class="para">
				In a way it mimics the relational join operation in a more efficient way (at the cost of data duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join operation is simply non-existent. It might help to keep the relational model normalized while benefiting from the full text index speed and feature richness.
			</div><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						An associated object can itself (but does not have to) be <code class="literal">@Indexed</code>
					</div></div></div>

			</div><div class="para">
				When @IndexedEmbedded points to an entity, the association has to be directional and the other side has to be annotated <code class="literal">@ContainedIn</code> (as seen in the previous example). If not, Hibernate Search has no way to update the root index when the associated entity is updated (in our example, a <code class="literal">Place</code> index document has to be updated when the associated <code class="classname">Address</code> instance is updated).
			</div><div class="para">
				Sometimes, the object type annotated by <code class="classname">@IndexedEmbedded</code> is not the object type targeted by Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of their implementation. For this reason you can override the object type targeted by Hibernate Search using the <code class="methodname">targetElement</code> parameter.
			</div><div class="example" id="idm139947799609744"><p class="title"><strong>Example 4.6. Using the <code class="literal">targetElement</code> property of <code class="classname">@IndexedEmbedded</code></strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field(index= Index.TOKENIZED)
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <span class="bold bold"><strong>targetElement = Owner.class</strong></span>)
    @Target(Owner.class)
    private Person ownedBy;


    ...
}

@Embeddable
public class Owner implements Person { ... }</pre></div></div></div><div class="section" id="section-boost-annotation"><div class="titlepage"><div><div><h3 class="title">4.1.4. Boost factor</h3></div></div></div><div class="para">
				Lucene has the notion of <span class="emphasis"><em>boost factor</em></span>. It's a way to give more weight to a field or to an indexed element over others during the indexation process. You can use <code class="literal">@Boost</code> at the @Field, method or class level.
			</div><div class="example" id="idm139947799603744"><p class="title"><strong>Example 4.7. Using different ways of increasing the weight of an indexed element using a boost factor</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
<span class="bold bold"><strong>@Boost(1.7f)</strong></span>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES, boost=<span class="bold bold"><strong>@Boost(2f)</strong></span>)
    <span class="bold bold"><strong>@Boost(1.5f)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    @Field(index=Index.TOKENIZED, boost=<span class="bold bold"><strong>@Boost(1.2f)</strong></span>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}</pre></div></div><div class="para">
				In our example, <code class="classname">Essay</code>'s probability to reach the top of the search list will be multiplied by 1.7. The <code class="methodname">summary</code> field will be 3.0 (2 * 1.5 - <code class="methodname">@Field.boost</code> and <code class="classname">@Boost</code> on a property are cumulative) more important than the <code class="methodname">isbn</code> field. The <code class="methodname">text</code> field will be 1.2 times more important than the <code class="methodname">isbn</code> field. Note that this explanation in strictest terms is actually wrong, but it is simple and close enough to reality for all practical purposes. Please check the Lucene documentation or the excellent <em class="citetitle">Lucene In Action </em> from Otis Gospodnetic and Erik Hatcher.
			</div></div><div class="section" id="idm139947799594944"><div class="titlepage"><div><div><h3 class="title">4.1.5. Dynamic boost factor</h3></div></div></div><div class="para">
				The <code class="literal">@Boost </code>annotation used in <a class="xref" href="#section-boost-annotation">Section 4.1.4, “Boost factor”</a> defines a static boost factor which is is independent of the state of of the indexed entity at runtime. However, there are usecases in which the boost factor may depends on the actual state of the entity. In this case you can use the <code class="literal">@DynamicBoost </code>annotation together with an accompanying custom <code class="classname">BoostStrategy</code>. 
				<div class="example" id="example-dynamic-boosting"><p class="title"><strong>Example 4.8. Dynamic boost example</strong></p><div class="example-contents"><pre class="programlisting">public enum PersonType {
         NORMAL,
         VIP
     }
     
     @Entity
     @Indexed
     @DynamicBoost(impl = VIPBoostStrategy.class)
     public class Person {
         private PersonType type;  
        
         // ....
     }
     
     public class VIPBoostStrategy implements BoostStrategy {
         public float defineBoost(Object value) {
             Person person = ( Person ) value;
             if ( person.getType().equals( PersonType.VIP ) ) {
                 return 2.0f;
             }
             else {
                 return 1.0f;
             }
         }
     }</pre></div></div>
				 In <a class="xref" href="#example-dynamic-boosting">Example 4.8, “Dynamic boost example”</a> a dynamic boost is defined on class level specifying <code class="classname">VIPBoostStrategy</code> as implementation of the <code class="classname">BoostStrategy</code> interface to be used at indexing time. You can place the <code class="literal">@DynamicBoost</code> either at class or field level. Depending on the placement of the annotation either the whole entity is passed to the <code class="methodname">defineBoost</code> method or just the annotated field/property value. It's up to you to cast the passed object to the correct type. In the example all indexed values of a VIP person would be double as important as the values of a normal person. 
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The specified <code class="classname">BoostStrategy</code> implementation must define a public no-arg constructor.
					</div></div></div>
				 Of course you can mix and match <code class="literal">@Boost</code> and <code class="literal">@DynamicBoost</code> annotations in your entity. All defined boost factors are cummulative as described in <a class="xref" href="#section-boost-annotation">Section 4.1.4, “Boost factor”</a>.
			</div></div><div class="section" id="analyzer"><div class="titlepage"><div><div><h3 class="title">4.1.6. Analyzer</h3></div></div></div><div class="para">
				The default analyzer class used to index tokenized fields is configurable through the <code class="literal">hibernate.search.analyzer</code> property. The default value for this property is <code class="classname">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.
			</div><div class="para">
				You can also define the analyzer class per entity, property and even per @Field (useful when multiple fields are indexed from a single property).
			</div><div class="example" id="idm139947799579824"><p class="title"><strong>Example 4.9. Different ways of specifying an analyzer</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold bold"><strong>@Analyzer(impl = EntityAnalyzer.class)</strong></span>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field(index = Index.TOKENIZED)
    private String name;

    @Field(index = Index.TOKENIZED)
    <span class="bold bold"><strong>@Analyzer(impl = PropertyAnalyzer.class)</strong></span>
    private String summary;

    @Field(index = Index.TOKENIZED, <span class="emphasis"><em><span class="bold bold"><strong>analyzer = @Analyzer(impl = FieldAnalyzer.class</strong></span>)</em></span>
    private String body;

    ...
}</pre></div></div><div class="para">
				In this example, <code class="classname">EntityAnalyzer</code> is used to index all tokenized properties (eg. <code class="literal">name</code>), except <code class="literal">summary</code> and <code class="literal">body</code> which are indexed with <code class="classname">PropertyAnalyzer</code> and <code class="classname">FieldAnalyzer</code> respectively.
			</div><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
					Mixing different analyzers in the same entity is most of the time a bad practice. It makes query building more complex and results less predictable (for the novice), especially if you are using a QueryParser (which uses the same analyzer for the whole query). As a rule of thumb, for any given field the same analyzer should be used for indexing and querying.
				</div></div></div><div class="section" id="idm139947799571376"><div class="titlepage"><div><div><h4 class="title">4.1.6.1. Analyzer definitions</h4></div></div></div><div class="para">
					Analyzers can become quite complex to deal with for which reason Hibernate Search introduces the notion of analyzer definitions. An analyzer definition can be reused by many <code class="classname">@Analyzer</code> declarations. An analyzer definition is composed of:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							a name: the unique string used to refer to the definition
						</div></li><li class="listitem"><div class="para">
							a tokenizer: responsible for tokenizing the input stream into individual words
						</div></li><li class="listitem"><div class="para">
							a list of filters: each filter is responsible to remove, modify or sometimes even add words into the stream provided by the tokenizer
						</div></li></ul></div><div class="para">
					This separation of tasks - a tokenizer followed by a list of filters - allows for easy reuse of each individual component and let you build your customized analyzer in a very flexible way (just like lego). Generally speaking the <code class="classname">Tokenizer</code> starts the analysis process by turning the character input into tokens which are then further processed by the <code class="classname">TokenFilter</code>s. Hibernate Search supports this infrastructure by utilizing the Solr analyzer framework. Make sure to add<code class="filename"> solr-core.jar and </code><code class="filename">solr-common.jar</code> to your classpath to use analyzer definitions. In case you also want to utilizing a snowball stemmer also include the <code class="filename">lucene-snowball.jar.</code> Other Solr analyzers might depend on more libraries. For example, the <code class="classname">PhoneticFilterFactory</code> depends on <a href="http://commons.apache.org/codec" class="mimir-link-warn" title="Mimir does not include content from: commons.apache.org">commons-codec</a>. Your distribution of Hibernate Search provides these dependecies in its <code class="filename">lib</code> directory.
				</div><div class="example" id="idm139947791483120"><p class="title"><strong>Example 4.10. <code class="classname">@AnalyzerDef</code> and the Solr framework</strong></p><div class="example-contents"><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
        filters = {
                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
                @TokenFilterDef(factory = LowerCaseFilterFactory.class),
                @TokenFilterDef(factory = StopFilterFactory.class, params = {
                    @Parameter(name="words", value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
                    @Parameter(name="ignoreCase", value="true")
                })
})
public class Team {
    ...
}</pre></div></div><div class="para">
					A tokenizer is defined by its factory which is responsible for building the tokenizer and using the optional list of parameters. This example use the standard tokenizer. A filter is defined by its factory which is responsible for creating the filter instance using the optional parameters. In our example, the StopFilter filter is built reading the dedicated words property file and is expected to ignore case. The list of parameters is dependent on the tokenizer or filter factory.
				</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
						Filters are applied in the order they are defined in the <code class="classname">@AnalyzerDef</code> annotation. Make sure to think twice about this order.
					</div></div></div><div class="para">
					Once defined, an analyzer definition can be reused by an <code class="classname">@Analyzer</code> declaration using the definition name rather than declaring an implementation class.
				</div><div class="example" id="idm139947791477200"><p class="title"><strong>Example 4.11. Referencing an analyzer by name</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field <span class="bold bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
    private String description;
}</pre></div></div><div class="para">
					Analyzer instances declared by <code class="classname">@AnalyzerDef</code> are available by their name in the <code class="classname">SearchFactory</code>.
				</div><pre class="programlisting">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><div class="para">
					This is quite useful wen building queries. Fields in queries should be analyzed with the same analyzer used to index the field so that they speak a common "language": the same tokens are reused between the query and the indexing process. This rule has some exceptions but is true most of the time. Respect it unless you know what you are doing.
				</div></div><div class="section" id="idm139947791472048"><div class="titlepage"><div><div><h4 class="title">4.1.6.2. Available analyzers</h4></div></div></div><div class="para">
					Solr and Lucene come with a lot of useful default tokenizers and filters. You can find a complete list of tokenizer factories and filter factories at <a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" class="mimir-link-warn" title="Mimir does not include content from: wiki.apache.org">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>. Let check a few of them.
				</div><div class="table" id="idm139947791469776"><p class="title"><strong>Table 4.1. Some of the tokenizers avalable</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Some of the tokenizers avalable"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947791467744" scope="col"> Factory </th><th align="center" id="idm139947791466960" scope="col"> Description </th><th align="center" id="idm139947791466176" scope="col"> parameters </th></tr></thead><tbody><tr><td headers="idm139947791467744"> StandardTokenizerFactory </td><td headers="idm139947791466960"> Use the Lucene StandardTokenizer </td><td headers="idm139947791466176"> none </td></tr><tr><td headers="idm139947791467744"> HTMLStripStandardTokenizerFactory </td><td headers="idm139947791466960"> Remove HTML tags, keep the text and pass it to a StandardTokenizer </td><td headers="idm139947791466176"> none </td></tr></tbody></table></div></div><div class="table" id="idm139947791460480"><p class="title"><strong>Table 4.2. Some of the filters avalable</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Some of the filters avalable"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947791458448" scope="col"> Factory </th><th align="center" id="idm139947791457664" scope="col"> Description </th><th align="center" id="idm139947791456880" scope="col"> parameters </th></tr></thead><tbody><tr><td headers="idm139947791458448"> StandardFilterFactory </td><td headers="idm139947791457664"> Remove dots from acronyms and 's from words </td><td headers="idm139947791456880"> none </td></tr><tr><td headers="idm139947791458448"> LowerCaseFilterFactory </td><td headers="idm139947791457664"> Lowercase words </td><td headers="idm139947791456880"> none </td></tr><tr><td headers="idm139947791458448"> StopFilterFactory </td><td headers="idm139947791457664"> remove words (tokens) matching a list of stop words </td><td headers="idm139947791456880"> <div class="para">
									<code class="literal">words</code>: points to a resource file containing the stop words
								</div>
								 <div class="para">
									ignoreCase: true if <code class="literal">case</code> should be ignore when comparing stop words, <code class="literal">false</code> otherwise
								</div>
								 </td></tr><tr><td headers="idm139947791458448"> SnowballPorterFilterFactory </td><td headers="idm139947791457664"> Reduces a word to it's root in a given language. (eg. protect, protects, protection share the same root). Using such a filter allows searches matching related words. </td><td headers="idm139947791456880"> <div class="para">
									<code class="literal">language</code>: Danish, Dutch, English, Finnish, French, German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish
								</div>
								 and a few more </td></tr><tr><td headers="idm139947791458448"> ISOLatin1AccentFilterFactory </td><td headers="idm139947791457664"> remove accents for languages like French </td><td headers="idm139947791456880"> none </td></tr></tbody></table></div></div><div class="para">
					We recommend to check all the implementations of <code class="classname">org.apache.solr.analysis.TokenizerFactory</code> and <code class="classname">org.apache.solr.analysis.TokenFilterFactory</code> in your IDE to see the implementations available.
				</div></div><div class="section" id="idm139947791440544"><div class="titlepage"><div><div><h4 class="title">4.1.6.3. Analyzer discriminator (experimental)</h4></div></div></div><div class="para">
					So far all the introduced ways to specify an analyzer were static. However, there are usecases where it is useful to select an analyzer depending on the current state of the entity to be indexed, for example in multilingual application. For an <code class="classname">BlogEntry</code> class for example the analyzer could depend on the language property of the entry. Depending on this property the correct language specific stemmer should be chosen to index the actual text.
				</div><div class="para">
					To enable this dynamic analyzer selection Hibernate Search introduces the <code class="classname">AnalyzerDiscriminator</code> annotation. The following example demonstrates the usage of this annotation:
				</div><div class="para">
					<div class="example" id="idm139947791437184"><p class="title"><strong>Example 4.12. Usage of @AnalyzerDiscriminator in order to select an analyzer depending on the entity state</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre><pre class="programlisting">public class LanguageDiscriminator implements Discriminator {

    public String getAnanyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;
    }
}</pre></div></div>
					 The prerequisite for using <code class="classname">@AnalyzerDiscriminator</code> is that all analyzers which are going to be used are predefined via <code class="classname">@AnalyzerDef</code> definitions. If this is the case one can place the <code class="classname">@AnalyzerDiscriminator</code> annotation either on the class or on a specific property of the entity for which to dynamically select an analyzer. Via the <code class="literal">impl</code> parameter of the <code class="classname">AnalyzerDiscriminator</code> you specify a concrete implementation of the <code class="classname">Discriminator</code> interface. It is up to you to provide an implementation for this interface. The only method you have to implement is <code class="classname">getAnanyzerDefinitionName()</code> which gets called for each field added to the Lucene document. The entity which is getting indexed is also passed to the interface method. The <code class="literal">value</code> parameter is only set if the <code class="classname">AnalyzerDiscriminator</code> is placed on property level instead of class level. In this case the value represents the current value of this property.
				</div><div class="para">
					An implemention of the <code class="classname">Discriminator</code> interface has to return the name of an existing analyzer definition if the analyzer should be set dynamically or <code class="classname">null</code> if the default analyzer should not be overridden. The given example assumes that the language paramter is either 'de' or 'en' which matches the specified names in the <code class="classname">@AnalyzerDef</code>s.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The <code class="classname">@AnalyzerDiscriminator</code> is currently still experimental and the API might still change. We are hoping for some feedback from the community about the usefulness and usability of this feature.
					</div></div></div></div><div class="section" id="analyzer-retrievinganalyzer"><div class="titlepage"><div><div><h4 class="title">4.1.6.4. Retrieving an analyzer</h4></div></div></div><div class="para">
					During indexing time, Hibernate Search is using analyzers under the hood for you. In some situations, retrieving analyzers can be handy. If your domain model makes use of multiple analyzers (maybe to benefit from stemming, use phonetic approximation and so on), you need to make sure to use the same analyzers when you build your query.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						This rule can be broken but you need a good reason for it. If you are unsure, use the same analyzers.
					</div></div></div><div class="para">
					You can retrieve the scoped analyzer for a given entity used at indexing time by Hibernate Search. A scoped analyzer is an analyzer which applies the right analyzers depending on the field indexed: multiple analyzers can be defined on a given entity each one working on an individual field, a scoped analyzer unify all these analyzers into a context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is very easy.
				</div><div class="example" id="idm139947791421168"><p class="title"><strong>Example 4.13. Using the scoped analyzer when building a full-text query</strong></p><div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</pre></div></div><div class="para">
					In the example above, the song title is indexed in two fields: the standard analyzer is used in the field <code class="literal">title</code> and a stemming analyzer is used in the field <code class="literal">title_stemmed</code>. By using the analyzer provided by the search factory, the query uses the appropriate analyzer depending on the field targeted.
				</div><div class="para">
					If your query targets more that one query and you wish to use your standard analyzer, make sure to describe it using an analyzer definition. You can retrieve analyzers by their definition name using <code class="code">searchFactory.getAnalyzer(String)</code>.
				</div></div></div></div><div class="section" id="search-mapping-bridge"><div class="titlepage"><div><div><h2 class="title">4.2. Property/Field Bridge</h2></div></div></div><div class="para">
			In Lucene all index fields have to be represented as Strings. For this reason all entity properties annotated with <code class="literal">@Field</code> have to be indexed in a String form. For most of your properties, Hibernate Search does the translation job for you thanks to a built-in set of bridges. In some cases, though you need a more fine grain control over the translation process.
		</div><div class="section" id="idm139947791413296"><div class="titlepage"><div><div><h3 class="title">4.2.1. Built-in bridges</h3></div></div></div><div class="para">
				Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its full text representation.
			</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">null</span></dt><dd><div class="para">
							null elements are not indexed. Lucene does not support null elements and this does not make much sense either.
						</div></dd><dt><span class="term">java.lang.String</span></dt><dd><div class="para">
							String are indexed as is
						</div></dd><dt><span class="term">short, Short, integer, Integer, long, Long, float, Float, double, Double, BigInteger, BigDecimal</span></dt><dd><div class="para">
							Numbers are converted in their String representation. Note that numbers cannot be compared by Lucene (ie used in ranged queries) out of the box: they have to be padded 
							<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
									Using a Range query is debatable and has drawbacks, an alternative approach is to use a Filter query which will filter the result query to the appropriate range.
								</div><div class="para">
									Hibernate Search will support a padding mechanism
								</div></div></div>

						</div></dd><dt><span class="term">java.util.Date</span></dt><dd><div class="para">
							Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You shouldn't really bother with the internal format. What is important is that when using a DateRange Query, you should know that the dates have to be expressed in GMT time.
						</div><div class="para">
							Usually, storing the date up to the milisecond is not necessary. <code class="literal">@DateBridge</code> defines the appropriate resolution you are willing to store in the index ( <code class="literal"> <code class="literal">@DateBridge(resolution=Resolution.DAY)</code> </code> ). The date pattern will then be truncated accordingly.
						</div><pre class="programlisting">@Entity 
@Indexed
public class Meeting {
    @Field(index=Index.UN_TOKENIZED)
    <span class="bold bold"><strong>@DateBridge(resolution=Resolution.MINUTE)</strong></span>
    private Date date;
    ...</pre><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
								A Date whose resolution is lower than <code class="literal">MILLISECOND</code> cannot be a <code class="literal">@DocumentId</code>
							</div></div></div></dd><dt><span class="term">java.net.URI, java.net.URL</span></dt><dd><div class="para">
							URI and URL are converted to their string representation
						</div></dd><dt><span class="term">java.lang.Class</span></dt><dd><div class="para">
							Class are converted to their fully qualified class name. The thread context classloader is used when the class is rehydrated
						</div></dd></dl></div></div><div class="section" id="idm139947791392400"><div class="titlepage"><div><div><h3 class="title">4.2.2. Custom Bridge</h3></div></div></div><div class="para">
				Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the String representation used by the bridge does not meet your requirements. The following paragraphs describe several solutions to this problem.
			</div><div class="section" id="idm139947791390880"><div class="titlepage"><div><div><h4 class="title">4.2.2.1. StringBridge</h4></div></div></div><div class="para">
					The simplest custom solution is to give Hibernate Search an implementation of your expected <span class="emphasis"><em> <code class="classname">Object</code> </em></span>to <code class="classname">String</code> bridge. To do so you need to implements the <code class="literal">org.hibernate.search.bridge.StringBridge</code> interface. All implementations have to be thread-safe as they are used concurrently.
				</div><div class="example" id="idm139947791387584"><p class="title"><strong>Example 4.14. Implementing your own <code class="classname">StringBridge</code></strong></p><div class="example-contents"><pre class="programlisting">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements <span class="bold bold"><strong>StringBridge</strong></span> {

    private int PADDING = 5;

    <span class="bold bold"><strong>public String objectToString(Object object)</strong></span> {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</pre></div></div><div class="para">
					Then any property or field can use this bridge thanks to the <code class="literal">@FieldBridge</code> annotation
				</div><pre class="programlisting"><span class="bold bold"><strong>@FieldBridge(impl = PaddedIntegerBridge.class)</strong></span>
private Integer length;</pre><div class="para">
					Parameters can be passed to the Bridge implementation making it more flexible. The Bridge implementation implements a <code class="classname">ParameterizedBridge</code> interface, and the parameters are passed through the <code class="literal">@FieldBridge</code> annotation.
				</div><div class="example" id="idm139947791380160"><p class="title"><strong>Example 4.15. Passing parameters to your bridge implementation</strong></p><div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements StringBridge, <span class="bold bold"><strong>ParameterizedBridge</strong></span> {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    <span class="bold bold"><strong>public void setParameterValues(Map parameters)</strong></span> {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             <span class="bold bold"><strong>params = @Parameter(name="padding", value="10")</strong></span>
            )
private Integer length;</pre></div></div><div class="para">
					The <code class="classname">ParameterizedBridge</code> interface can be implemented by <code class="classname">StringBridge</code> , <code class="classname">TwoWayStringBridge</code> , <code class="classname">FieldBridge</code> implementations.
				</div><div class="para">
					All implementations have to be thread-safe, but the parameters are set during initialization and no special care is required at this stage.
				</div><div class="para">
					If you expect to use your bridge implementation on an id property (ie annotated with <code class="literal">@DocumentId</code> ), you need to use a slightly extended version of <code class="literal">StringBridge</code> named <code class="classname">TwoWayStringBridge</code>. Hibernate Search needs to read the string representation of the identifier and generate the object out of it. There is not difference in the way the <code class="literal">@FieldBridge</code> annotation is used.
				</div><div class="example" id="idm139947791370144"><p class="title"><strong>Example 4.16. Implementing a TwoWayStringBridge which can for example be used for id properties</strong></p><div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    <span class="bold bold"><strong>public Object stringToObject(String stringValue)</strong></span> {
        return new Integer(stringValue);
    }
}


//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10") 
private Integer id;
</pre></div></div><div class="para">
					It is critically important for the two-way process to be idempotent (ie object = stringToObject( objectToString( object ) ) ).
				</div></div><div class="section" id="idm139947791366160"><div class="titlepage"><div><div><h4 class="title">4.2.2.2. FieldBridge</h4></div></div></div><div class="para">
					Some usecases require more than a simple object to string translation when mapping a property to a Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a <code class="classname">FieldBridge</code>. This interface gives you a property value and let you map it the way you want in your Lucene <code class="classname">Document</code>.The interface is very similar in its concept to the Hibernate<code class="classname"> UserType</code>'s.
				</div><div class="para">
					You can for example store a given property in two different document fields:
				</div><div class="example" id="idm139947791362672"><p class="title"><strong>Example 4.17. Implementing the FieldBridge interface in order to a given property into multiple document fields</strong></p><div class="example-contents"><pre class="programlisting">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * 
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    <span class="bold bold"><strong>public void set(String name, Object value, Document document, LuceneOptions luceneOptions)</strong></span> {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
  
        // set year
        Field field = new Field(name + ".year", String.valueOf(year),
            luceneOptions.getStore(), luceneOptions.getIndex(),
            luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
  
        // set month and pad it if needed
        field = new Field(name + ".month", month &lt; 10 ? "0" : ""
            + String.valueOf(month), luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
  
        // set day and pad it if needed
        field = new Field(name + ".day", day &lt; 10 ? "0" : ""
            + String.valueOf(day), luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
    }
}

//property
<span class="bold bold"><strong>@FieldBridge(impl = DateSplitBridge.class)</strong></span>
private Date date;</pre></div></div></div><div class="section" id="idm139947791357872"><div class="titlepage"><div><div><h4 class="title">4.2.2.3. ClassBridge</h4></div></div></div><div class="para">
					It is sometimes useful to combine more than one property of a given entity and index this combination in a specific way into the Lucene index. The <code class="classname">@ClassBridge</code> and <code class="classname">@ClassBridge</code> annotations can be defined at the class level (as opposed to the property level). In this case the custom field bridge implementation receives the entity instance as the value parameter instead of a particular property. Though not shown in this example, <code class="classname">@ClassBridge</code> supports the <code class="methodname">termVector</code> attribute discussed in section <a class="xref" href="#basic-mapping">Section 4.1.1, “Basic mapping”</a>.
				</div><div class="example" id="idm139947791353696"><p class="title"><strong>Example 4.18. Implementing a class bridge</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold bold"><strong>@ClassBridge</strong></span>(name="branchnetwork",
             index=Index.TOKENIZED,
             store=Store.YES,
             impl = <span class="bold bold"><strong>CatFieldsClassBridge.class</strong></span>,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees;
    ...
}


public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    <span class="bold bold"><strong>public void set(String name, Object value, Document document, LuceneOptions luceneOptions)</strong></span> {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</pre></div></div><div class="para">
					In this example, the particular <code class="classname">CatFieldsClassBridge</code> is applied to the <code class="literal">department</code> instance, the field bridge then concatenate both branch and network and index the concatenation.
				</div></div></div></div><div class="section" id="provided-id"><div class="titlepage"><div><div><h2 class="title">4.3. Providing your own id</h2></div></div></div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				This part of the documentation is a work in progress.
			</div></div></div><div class="para">
			You can provide your own id for Hibernate Search if you are extending the internals. You will have to generate a unique value so it can be given to Lucene to be indexed. This will have to be given to Hibernate Search when you create an org.hibernate.search.Work object - the document id is required in the constructor.
		</div><div class="section" id="ProvidedId"><div class="titlepage"><div><div><h3 class="title">4.3.1. The ProvidedId annotation</h3></div></div></div><div class="para">
				Unlike conventional Hibernate Search API and @DocumentId, this annotation is used on the class and not a field. You also can provide your own bridge implementation when you put in this annotation by calling the bridge() which is on @ProvidedId. Also, if you annotate a class with @ProvidedId, your subclasses will also get the annotation - but it is not done by using the java.lang.annotations.@Inherited. Be sure however, to <span class="emphasis"><em>not</em></span> use this annotation with @DocumentId as your system will break.
			</div><div class="example" id="idm139947791340384"><p class="title"><strong>Example 4.19. Providing your own id</strong></p><div class="example-contents"><pre class="programlisting">@ProvidedId (bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</pre></div></div></div></div></div><div xml:lang="en-US" class="chapter" id="search-query" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Querying</h1></div></div></div><div class="para">
		The second most important capability of Hibernate Search is the ability to execute a Lucene query and retrieve entities managed by an Hibernate session, providing the power of Lucene without leaving the Hibernate paradigm, and giving another dimension to the Hibernate classic search mechanisms (HQL, Criteria query, native SQL query). Preparing and executing a query consists of four simple steps:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				Creating a <code class="classname">FullTextSession</code>
			</div></li><li class="listitem"><div class="para">
				Creating a Lucene query
			</div></li><li class="listitem"><div class="para">
				Wrapping the Lucene query using a <code class="classname">org.hibernate.Query</code>
			</div></li><li class="listitem"><div class="para">
				Executing the search by calling for example <code class="methodname">list()</code> or <code class="methodname">scroll()</code>
			</div></li></ul></div><div class="para">
		To access the querying facilities, you have to use an <code class="classname">FullTextSession</code> . This Search specfic session wraps a regular <code class="classname">org.hibernate.Session</code> to provide query and indexing capabilities.
	</div><div class="example" id="idm139947796384992"><p class="title"><strong>Example 5.1. Creating a FullTextSession</strong></p><div class="example-contents"><pre class="programlisting">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);</pre></div></div><div class="para">
		The actual search facility is built on native Lucene queries which the following example illustrates.
	</div><div class="example" id="idm139947800298000"><p class="title"><strong>Example 5.2. Creating a Lucene query</strong></p><div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold bold"><strong>org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery ); </strong></span>
List result = fullTextQuery.list(); //return a list of managed objects</pre></div></div><div class="para">
		The Hibernate query built on top of the Lucene query is a regular <code class="literal">org.hibernate.Query</code>, which means you are in the same paradigm as the other Hibernate query facilities (HQL, Native or Criteria). The regular <code class="literal">list()</code> , <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code> and <code class="literal">scroll()</code> methods can be used.
	</div><div class="para">
		In case you are using the Java Persistence APIs of Hibernate (aka EJB 3.0 Persistence), the same extensions exist:
	</div><div class="example" id="idm139947800843008"><p class="title"><strong>Example 5.3. Creating a Search query using the JPA API</strong></p><div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold bold"><strong>javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );</strong></span>

List result = fullTextQuery.getResultList(); //return a list of managed objects</pre></div></div><div class="para">
		The following examples we will use the Hibernate APIs but the same example can be easily rewritten with the Java Persistence API by just adjusting the way the <code class="classname">FullTextQuery</code> is retrieved.
	</div><div class="section" id="idm139947803552080"><div class="titlepage"><div><div><h2 class="title">5.1. Building queries</h2></div></div></div><div class="para">
			Hibernate Search queries are built on top of Lucene queries which gives you total freedom on the type of Lucene query you want to execute. However, once built, Hibernate Search wraps further query processing using <code class="classname">org.hibernate.Query</code> as your primary query manipulation API.
		</div><div class="section" id="idm139947803550144"><div class="titlepage"><div><div><h3 class="title">5.1.1. Building a Lucene query</h3></div></div></div><div class="para">
				It is out of the scope of this documentation on how to exactly build a Lucene query. Please refer to the online Lucene documentation or get hold of a copy of either Lucene In Action or Hibernate Search in Action.
			</div></div><div class="section" id="idm139947803548496"><div class="titlepage"><div><div><h3 class="title">5.1.2. Building a Hibernate Search query</h3></div></div></div><div class="section" id="idm139947803547728"><div class="titlepage"><div><div><h4 class="title">5.1.2.1. Generality</h4></div></div></div><div class="para">
					Once the Lucene query is built, it needs to be wrapped into an Hibernate Query.
				</div><div class="example" id="idm139947803546480"><p class="title"><strong>Example 5.4. Wrapping a Lucene query into a Hibernate Query</strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre></div></div><div class="para">
					If not specified otherwise, the query will be executed against all indexed entities, potentially returning all types of indexed classes. It is advised, from a performance point of view, to restrict the returned types:
				</div><div class="example" id="idm139947802465376"><p class="title"><strong>Example 5.5. Filtering the search result by entity type</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
// or
fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre></div></div><div class="para">
					The first example returns only matching <code class="classname">Customer</code>s, the second returns matching <code class="classname">Actor</code>s and <code class="classname">Item</code>s. The type restriction is fully polymorphic which means that if there are two indexed subclasses <code class="classname">Salesman</code> and <code class="classname">Customer</code> of the baseclass <code class="classname">Person</code>, it is possible to just specify <code class="classname">Person.class</code> in order to filter on result types.
				</div></div><div class="section" id="idm139947802459936"><div class="titlepage"><div><div><h4 class="title">5.1.2.2. Pagination</h4></div></div></div><div class="para">
					Out of performace reasons it is recommended to restrict the number of returned objects per query. In fact is a very common use case anyway that the user navigates from one page to an other. The way to define pagination is exactly the way you would define pagination in a plain HQL or Criteria query.
				</div><div class="example" id="idm139947802458368"><p class="title"><strong>Example 5.6. Defining pagination for a search query</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						It is still possible to get the total number of matching elements regardless of the pagination via <code class="methodname">fulltextQuery.</code><code class="methodname">getResultSize()</code>
					</div></div></div></div><div class="section" id="idm139947802811760"><div class="titlepage"><div><div><h4 class="title">5.1.2.3. Sorting</h4></div></div></div><div class="para">
					Apache Lucene provides a very flexible and powerful way to sort results. While the default sorting (by relevance) is appropriate most of the time, it can be interesting to sort by one or several other properties. In order to do so set the Lucene Sort object to apply a Lucene sorting strategy.
				</div><div class="example" id="idm139947802810192"><p class="title"><strong>Example 5.7. Specifying a Lucene <code class="classname">Sort</code> in order to sort the results</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(new SortField("title"));
<span class="bold bold"><strong>query.setSort(sort);</strong></span>
List results = query.list();</pre></div></div><div class="para">
					One can notice the <code class="classname">FullTextQuery</code> interface which is a sub interface of <code class="classname">org.hibernate.Query</code>. Be aware that fields used for sorting must not be tokenized.
				</div></div><div class="section" id="idm139947804621696"><div class="titlepage"><div><div><h4 class="title">5.1.2.4. Fetching strategy</h4></div></div></div><div class="para">
					When you restrict the return types to one class, Hibernate Search loads the objects using a single query. It also respects the static fetching strategy defined in your domain model.
				</div><div class="para">
					It is often useful, however, to refine the fetching strategy for a specific use case.
				</div><div class="example" id="idm139947804619792"><p class="title"><strong>Example 5.8. Specifying <code class="classname">FetchMode</code> on a query</strong></p><div class="example-contents"><pre class="programlisting">Criteria criteria = s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre></div></div><div class="para">
					In this example, the query will return all Books matching the luceneQuery. The authors collection will be loaded from the same query using an SQL outer join.
				</div><div class="para">
					When defining a criteria query, it is not needed to restrict the entity types returned while creating the Hibernate Search query from the full text session: the type is guessed from the criteria query itself. Only fetch mode can be adjusted, refrain from applying any other restriction.
				</div><div class="para">
					One cannot use <code class="methodname">setCriteriaQuery</code> if more than one entity type is expected to be returned.
				</div></div><div class="section" id="projections"><div class="titlepage"><div><div><h4 class="title">5.1.2.5. Projection</h4></div></div></div><div class="para">
					For some use cases, returning the domain object (graph) is overkill. Only a small subset of the properties is necessary. Hibernate Search allows you to return a subset of properties:
				</div><div class="example" id="idm139947804613248"><p class="title"><strong>Example 5.9. Using projection instead of returning the full domain object</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold bold"><strong>setProjection( "id", "summary", "body", "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
  Integer id = (Integer) firstResult[0];
  String summary = (String) firstResult[1];
  String body = (String) firstResult[2];
  String authorName = (String) firstResult[3];</pre></div></div><div class="para">
					Hibernate Search extracts the properties from the Lucene index and convert them back to their object representation, returning a list of <code class="classname">Object[]</code>. Projections avoid a potential database round trip (useful if the query response time is critical), but has some constraints:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							the properties projected must be stored in the index (<code class="literal">@Field(store=Store.YES)</code>), which increase the index size
						</div></li><li class="listitem"><div class="para">
							the properties projected must use a <code class="literal">FieldBridge</code> implementing <code class="classname">org.hibernate.search.bridge.TwoWayFieldBridge</code> or <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version. All Hibernate Search built-in types are two-way.
						</div></li><li class="listitem"><div class="para">
							you can only project simple properties of the indexed entity or its embedded associations. This means you cannot project a whole embedded entity.
						</div></li><li class="listitem"><div class="para">
							projection does not work on collections or maps which are indexed via <code class="classname">@IndexedEmbedded</code>
						</div></li></ul></div><div class="para">
					Projection is useful for another kind of usecases. Lucene provides some metadata informations to the user about the results. By using some special placeholders, the projection mechanism can retrieve them:
				</div><div class="example" id="idm139947802168848"><p class="title"><strong>Example 5.10. Using projection in order to retrieve meta data</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold bold"><strong>setProjection( FullTextQuery.SCORE, FullTextQuery.THIS, "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
  float score = (Float) firstResult[0];
  Book book = (Book) firstResult[1];
  String authorName = (String) firstResult[2];</pre></div></div><div class="para">
					You can mix and match regular fields and special placeholders. Here is the list of available placeholders:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							FullTextQuery.THIS: returns the intialized and managed entity (as a non projected query would have done).
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.DOCUMENT: returns the Lucene Document related to the object projected.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.OBJECT_CLASS: returns the class of the indexded entity.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.SCORE: returns the document score in the query. Scores are handy to compare one result against an other for a given query but are useless when comparing the result of different queries.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.ID: the id property value of the projected object.
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.DOCUMENT_ID: the Lucene document id. Careful, Lucene document id can change overtime between two different IndexReader opening (this feature is experimental).
						</div></li><li class="listitem"><div class="para">
							FullTextQuery.EXPLANATION: returns the Lucene Explanation object for the matching object/document in the given query. Do not use if you retrieve a lot of data. Running explanation typically is as costly as running the whole Lucene query per matching element. Make sure you use projection!
						</div></li></ul></div></div></div></div><div class="section" id="idm139947802157712"><div class="titlepage"><div><div><h2 class="title">5.2. Retrieving the results</h2></div></div></div><div class="para">
			Once the Hibernate Search query is built, executing it is in no way different than executing a HQL or Criteria query. The same paradigm and object semantic applies. All the common operations are available: <code class="methodname">list()</code>, <code class="methodname">uniqueResult()</code>, <code class="methodname">iterate()</code>, <code class="methodname">scroll()</code>.
		</div><div class="section" id="idm139947785310960"><div class="titlepage"><div><div><h3 class="title">5.2.1. Performance considerations</h3></div></div></div><div class="para">
				If you expect a reasonable number of results (for example using pagination) and expect to work on all of them, <code class="methodname">list()</code> or <code class="methodname">uniqueResult()</code> are recommended. <code class="methodname">list()</code> work best if the entity <code class="literal">batch-size</code> is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the pagination) when using <code class="methodname">list()</code> , <code class="methodname">uniqueResult()</code> and <code class="methodname">iterate()</code>.
			</div><div class="para">
				If you wish to minimize Lucene document loading, <code class="methodname">scroll()</code> is more appropriate. Don't forget to close the <code class="classname">ScrollableResults</code> object when you're done, since it keeps Lucene resources. If you expect to use <code class="methodname">scroll,</code> but wish to load objects in batch, you can use <code class="methodname">query.setFetchSize()</code>. When an object is accessed, and if not already loaded, Hibernate Search will load the next <code class="literal">fetchSize</code> objects in one pass.
			</div><div class="para">
				Pagination is a preferred method over scrolling though.
			</div></div><div class="section" id="idm139947785302880"><div class="titlepage"><div><div><h3 class="title">5.2.2. Result size</h3></div></div></div><div class="para">
				It is sometime useful to know the total number of matching documents:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						for the Google-like feature 1-10 of about 888,000,000
					</div></li><li class="listitem"><div class="para">
						to implement a fast pagination navigation
					</div></li><li class="listitem"><div class="para">
						to implement a multi step search engine (adding approximation if the restricted query return no or not enough results)
					</div></li></ul></div><div class="para">
				Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you to retrieve the total number of matching documents regardless of the pagination parameters. Even more interesting, you can retrieve the number of matching elements without triggering a single object load.
			</div><div class="example" id="idm139947785297360"><p class="title"><strong>Example 5.11. Determining the result size of a query</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
assert 3245 == <span class="bold bold"><strong>query.getResultSize()</strong></span>; //return the number of matching books without loading a single one

org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResults(10);
List results = query.list();
assert 3245 == <span class="bold bold"><strong>query.getResultSize()</strong></span>; //return the total number of matching books regardless of pagination</pre></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Like Google, the number of results is approximative if the index is not fully up-to-date with the database (asynchronous cluster for example).
				</div></div></div></div><div class="section" id="idm139947785292976"><div class="titlepage"><div><div><h3 class="title">5.2.3. ResultTransformer</h3></div></div></div><div class="para">
				Especially when using projection, the data structure returned by a query (an object array in this case), is not always matching the application needs. It is possible to apply a <code class="classname">ResultTransformer</code> operation post query to match the targeted data structure:
			</div><div class="example" id="idm139947785291008"><p class="title"><strong>Example 5.12. Using ResultTransformer in conjuncton with projections</strong></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

<span class="bold bold"><strong>query.setResultTransformer( new AliasToBeanResultTransformer( BookView.class ) );</strong></span>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre></div></div><div class="para">
				Examples of <code class="classname">ResultTransformer</code> implementations can be found in the Hibernate Core codebase.
			</div></div><div class="section" id="idm139947785287520"><div class="titlepage"><div><div><h3 class="title">5.2.4. Understanding results</h3></div></div></div><div class="para">
				You will find yourself sometimes puzzled by a result showing up in a query or a result not showing up in a query. Luke is a great tool to understand those mysteries. However, Hibernate Search also gives you access to the Lucene <code class="classname">Explanation</code> object for a given result (in a given query). This class is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of an object. You have two ways to access the Explanation object for a given result:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Use the <code class="methodname">fullTextQuery.explain(int)</code> method
					</div></li><li class="listitem"><div class="para">
						Use projection
					</div></li></ul></div><div class="para">
				The first approach takes a document id as a parameter and return the Explanation object. The document id can be retrieved using projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code> constant.
			</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
					The Document id has nothing to do with the entity id. Do not mess up these two notions.
				</div></div></div><div class="para">
				The second approach let's you project the <code class="classname">Explanation</code> object using the <code class="literal">FullTextQuery.EXPLANATION</code> constant.
			</div><div class="example" id="idm139947785279120"><p class="title"><strong>Example 5.13. Retrieving the Lucene Explanation object using projection</strong></p><div class="example-contents"><pre class="programlisting">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( FullTextQuery.DOCUMENT_ID, <span class="bold bold"><strong>FullTextQuery.EXPLANATION</strong></span>, FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    System.out.println( e.toString() );
}</pre></div></div><div class="para">
				Be careful, building the explanation object is quite expensive, it is roughly as expensive as running the Lucene query again. Don't do it if you don't need the object
			</div></div></div><div class="section" id="idm139947785275712"><div class="titlepage"><div><div><h2 class="title">5.3. Filters</h2></div></div></div><div class="para">
			Apache Lucene has a powerful feature that allows to filter query results according to a custom filtering process. This is a very powerful way to apply additional data restrictions, especially since filters can be cached and reused. Some interesting usecases are:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					security
				</div></li><li class="listitem"><div class="para">
					temporal data (eg. view only last month's data)
				</div></li><li class="listitem"><div class="para">
					population filter (eg. search limited to a given category)
				</div></li><li class="listitem"><div class="para">
					and many more
				</div></li></ul></div><div class="para">
			Hibernate Search pushes the concept further by introducing the notion of parameterizable named filters which are transparently cached. For people familiar with the notion of Hibernate Core filters, the API is very similar:
		</div><div class="example" id="idm139947785269104"><p class="title"><strong>Example 5.14. Enabling fulltext filters for a given query</strong></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre></div></div><div class="para">
			In this example we enabled two filters on top of the query. You can enable (or disable) as many filters as you like.
		</div><div class="para">
			Declaring filters is done through the <code class="classname">@FullTextFilterDef</code> annotation. This annotation can be on any <code class="literal">@Indexed</code> entity regardless of the query the filter is later applied to. This implies that filter definitions are global and their names must be unique. A <code class="classname">SearchException</code> is thrown in case two different <code class="classname">@FullTextFilterDef</code> annotations with the same name are defined. Each named filter has to specify its actual filter implementation.
		</div><div class="example" id="idm139947785264320"><p class="title"><strong>Example 5.15. Defining and implementing a Filter</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDefs( {
    <span class="bold bold"><strong>@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</strong></span>, 
    <span class="bold bold"><strong>@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</strong></span> 
})
public class Driver { ... }</pre><pre class="programlisting">public class BestDriversFilter extends <span class="bold bold"><strong>org.apache.lucene.search.Filter</strong></span> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre></div></div><div class="para">
			<code class="classname">BestDriversFilter</code> is an example of a simple Lucene filter which reduces the result set to drivers whose score is 5. In this example the specified filter implements the <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a no-arg constructor.
		</div><div class="para">
			If your Filter creation requires additional steps or if the filter you want to use does not have a no-arg constructor, you can use the factory pattern:
		</div><div class="example" id="idm139947785258080"><p class="title"><strong>Example 5.16. Creating a filter using the factory pattern</strong></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <span class="bold bold"><strong>@Factory</strong></span>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre></div></div><div class="para">
			Hibernate Search will look for a <code class="literal">@Factory</code> annotated method and use it to build the filter instance. The factory must have a no-arg constructor. For people familiar with JBoss Seam, this is similar to the component factory pattern, but the annotation is different!
		</div><div class="para">
			Named filters come in handy where parameters have to be passed to the filter. For example a security filter might want to know which security level you want to apply:
		</div><div class="example" id="idm139947785253840"><p class="title"><strong>Example 5.17. Passing parameters to a defined filter</strong></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security")<span class="bold bold"><strong>.setParameter( "level", 5 )</strong></span>;</pre></div></div><div class="para">
			Each parameter name should have an associated setter on either the filter or filter factory of the targeted named filter definition.
		</div><div class="example" id="idm139947785251088"><p class="title"><strong>Example 5.18. Using paramters in the actual filter implementation</strong></p><div class="example-contents"><pre class="programlisting">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <span class="bold bold"><strong>public void setLevel(Integer level)</strong></span> {
        this.level = level;
    }

    <span class="bold bold"><strong>@Key public FilterKey getKey()</strong></span> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre></div></div><div class="para">
			Note the method annotated <code class="classname">@Key</code> returning a <code class="classname">FilterKey</code> object. The returned object has a special contract: the key object must implement <code class="methodname">equals()</code> / <code class="methodname">hashcode()</code> so that 2 keys are equal if and only if the given <code class="classname">Filter</code> types are the same and the set of parameters are the same. In other words, 2 filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism.
		</div><div class="para">
			<code class="classname">@Key</code> methods are needed only if:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					you enabled the filter caching system (enabled by default)
				</div></li><li class="listitem"><div class="para">
					your filter has parameters
				</div></li></ul></div><div class="para">
			In most cases, using the <code class="literal">StandardFilterKey</code> implementation will be good enough. It delegates the <code class="methodname">equals()</code> / <code class="methodname">hashcode()</code> implementation to each of the parameters equals and hashcode methods.
		</div><div class="para">
			As mentioned before the defined filters are per default cached and the cache uses a combination of hard and soft references to allow disposal of memory when needed. The hard reference cache keeps track of the most recently used filters and transforms the ones least used to <code class="classname">SoftReferences</code> when needed. Once the limit of the hard reference cache is reached addtional filters are cached as <code class="classname">SoftReferences</code>. To adjust the size of the hard reference cache, use <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advance use of filter caching, you can implement your own <code class="classname">FilterCachingStrategy</code>. The classname is defined by <code class="literal">hibernate.search.filter.cache_strategy</code>.
		</div><div class="para">
			This filter caching mechanism should not be confused with caching the actual filter results. In Lucene it is common practice to wrap filters using the <code class="classname">IndexReader</code> around a <code class="classname">CachingWrapperFilter.</code> The wrapper will cache the <code class="classname">DocIdSet</code> returned from the <code class="methodname">getDocIdSet(IndexReader reader)</code> method to avoid expensive recomputation. It is important to mention that the computed <code class="classname">DocIdSet</code> is only cachable for the same <code class="classname">IndexReader</code> instance, because the reader effectively represents the state of the index at the moment it was opened. The document list cannot change within an opened <code class="classname">IndexReader</code>. A different/new<code class="classname"> IndexReader</code> instance, however, works potentially on a different set of <code class="classname">Document</code>s (either from a different index or simply because the index has changed), hence the cached <code class="classname">DocIdSet</code> has to be recomputed.
		</div><div class="para">
			Hibernate Search also helps with this aspect of caching. Per default the <code class="literal">cache</code> flag of <code class="classname">@FullTextFilterDef </code>is set to <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will automatically cache the filter instance as well as wrap the specified filter around a Hibernate specific implementation of <code class="classname">CachingWrapperFilter</code> (<code class="classname">org.hibernate.search.filter.CachingWrapperFilter</code>). In contrast to Lucene's version of this class <code class="classname">SoftReference</code>s are used together with a hard reference count (see dicussion about filter cache). The hard reference count can be adjusted using <code class="literal">hibernate.search.filter.cache_docidresults.size</code> (defaults to 5). The wrapping behaviour can be controlled using the <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three differerent values for this parameter:
		</div><div class="para">
			<div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col align="center"><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947795087664" scope="col"> Value </th><th align="center" id="idm139947795086992" scope="col"> Definition </th></tr></thead><tbody><tr><td align="left" headers="idm139947795087664"> FilterCacheModeType.NONE </td><td align="left" headers="idm139947795086992"> No filter instance and no result is cached by Hibernate Search. For every filter call, a new filter instance is created. This setting might be useful for rapidly changing data sets or heavily memory constrained environments. </td></tr><tr><td align="left" headers="idm139947795087664"> FilterCacheModeType.INSTANCE_ONLY </td><td align="left" headers="idm139947795086992"> The filter instance is cached and reused across concurrent <code class="methodname">Filter.getDocIdSet()</code> calls. <code class="classname">DocIdSet</code> results are not cached. This setting is useful when a filter uses its own specific caching mechanism or the filter results change dynamically due to application specific events making <code class="classname">DocIdSet</code> caching in both cases unnecessary. </td></tr><tr><td align="left" headers="idm139947795087664"> FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS </td><td align="left" headers="idm139947795086992"> Both the filter instance and the <code class="classname">DocIdSet</code> results are cached. This is the default value. </td></tr></tbody></table></div>
			 Last but not least - why should filters be cached? There are two areas where filter caching shines:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					the system does not update the targeted entity index often (in other words, the IndexReader is reused a lot)
				</div></li><li class="listitem"><div class="para">
					the Filter's DocIdSet is expensive to compute (compared to the time spent to execute the query)
				</div></li></ul></div></div><div class="section" id="idm139947795075136"><div class="titlepage"><div><div><h2 class="title">5.4. Optimizing the query process</h2></div></div></div><div class="para">
			Query performance depends on several criteria:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					the Lucene query itself: read the literature on this subject
				</div></li><li class="listitem"><div class="para">
					the number of object loaded: use pagination (always ;-) ) or index projection (if needed)
				</div></li><li class="listitem"><div class="para">
					the way Hibernate Search interacts with the Lucene readers: defines the appropriate <a class="xref" href="#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>.
				</div></li></ul></div></div><div class="section" id="idm139947795069936"><div class="titlepage"><div><div><h2 class="title">5.5. Native Lucene Queries</h2></div></div></div><div class="para">
			If you wish to use some specific features of Lucene, you can always run Lucene specific queries. Check <a class="xref" href="#search-lucene-native">Chapter 8, <em>Advanced features</em></a> for more informations.
		</div></div></div><div xml:lang="en-US" class="chapter" id="search-batchindex" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Manual indexing</h1></div></div></div><div class="section" id="search-batchindex-indexing"><div class="titlepage"><div><div><h2 class="title">6.1. Indexing</h2></div></div></div><div class="para">
			It is sometimes useful to index an entity even if this entity is not inserted or updated to the database. This is for example the case when you want to build your index for the first time. <code class="classname">FullTextSession</code>.<code class="methodname">index()</code> allows you to do so.
		</div><div class="example" id="idm139947801019136"><p class="title"><strong>Example 6.1. Indexing an entity via <code class="methodname">FullTextSession.index()</code></strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <span class="bold bold"><strong>fullTextSession.index(customer);</strong></span>
}
tx.commit(); //index are written at commit time</pre></div></div><div class="para">
			For maximum efficiency, Hibernate Search batches index operations and executes them at commit time. If you expect to index a lot of data, however, you need to be careful about memory consumption since all documents are kept in a queue until the transaction commit. You can potentially face an <code class="classname">OutOfMemoryException</code>. To avoid this exception, you can use <code class="methodname">fullTextSession.flushToIndexes()</code>. Every time <code class="methodname">fullTextSession.flushToIndexes()</code> is called (or if the transaction is committed), the batch queue is processed (freeing memory) applying all index changes. Be aware that once flushed changes cannot be rolled back.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				<code class="literal">hibernate.search.worker.batch_size</code> has been deprecated in favor of this explicit API which provides better control
			</div></div></div><div class="para">
			Other parameters which also can affect indexing time and memory consumption are:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</code>
				</div></li></ul></div><div class="para">
			These parameters are Lucene specific and Hibernate Search is just passing these parameters through - see <a class="xref" href="#lucene-indexing-performance">Section 3.8, “Tuning Lucene indexing performance”</a> for more details.
		</div><div class="example" id="idm139947799642608"><p class="title"><strong>Example 6.2. Efficiently indexing a given class (useful for index (re)initialization)</strong></p><div class="example-contents"><pre class="programlisting">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //clear since the queue is processed
    }
}
transaction.commit();</pre></div></div><div class="para">
			Try to use a batch size that guarantees that your application will not run out of memory.
		</div></div><div class="section" id="idm139947799639920"><div class="titlepage"><div><div><h2 class="title">6.2. Purging</h2></div></div></div><div class="para">
			It is equally possible to remove an entity or all entities of a given type from a Lucene index without the need to physically remove them from the database. This operation is named purging and is also done through the <code class="classname">FullTextSession</code>.
		</div><div class="example" id="idm139947801279360"><p class="title"><strong>Example 6.3. Purging a specific instance of an entity from the index</strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <span class="bold bold"><strong>fullTextSession.purge( Customer.class, customer.getId() );</strong></span>
}
tx.commit(); //index are written at commit time</pre></div></div><div class="para">
			Purging will remove the entity with the given id from the Lucene index but will not touch the database.
		</div><div class="para">
			If you need to remove all entities of a given type, you can use the <code class="methodname">purgeAll</code> method. This operation remove all entities of the type passed as a parameter as well as all its subtypes.
		</div><div class="example" id="idm139947801275776"><p class="title"><strong>Example 6.4. Purging all instances of an entity from the index</strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<span class="bold bold"><strong>fullTextSession.purgeAll( Customer.class );</strong></span>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index are written at commit time</pre></div></div><div class="para">
			It is recommended to optimize the index after such an operation.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Methods <code class="methodname">index</code>, <code class="methodname">purge</code> and <code class="methodname">purgeAll</code> are available on <code class="classname">FullTextEntityManager</code> as well.
			</div></div></div></div></div><div xml:lang="en-US" class="chapter" id="search-optimize" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Index Optimization</h1></div></div></div><div class="para">
		From time to time, the Lucene index needs to be optimized. The process is essentially a defragmentation. Until an optimization is triggered Lucene only marks deleted documents as such, no physical deletions are applied. During the optimization process the deletions will be applied which also effects the number of files in the Lucene Directory.
	</div><div class="para">
		Optimising the Lucene index speeds up searches but has no effect on the indexation (update) performance. During an optimization, searches can be performed, but will most likely be slowed down. All index updates will be stopped. It is recommended to schedule optimization:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				on an idle system or when the searches are less frequent
			</div></li><li class="listitem"><div class="para">
				after a lot of index modifications
			</div></li></ul></div><div class="section" id="idm139947791502496"><div class="titlepage"><div><div><h2 class="title">7.1. Automatic optimization</h2></div></div></div><div class="para">
			Hibernate Search can automatically optimize an index after:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					a certain amount of operations (insertion, deletion)
				</div></li><li class="listitem"><div class="para">
					or a certain amout of transactions
				</div></li></ul></div><div class="para">
			The configuration for automatic index optimization can be defined on a global level or per index:
		</div><div class="example" id="idm139947798462656"><p class="title"><strong>Example 7.1. Defining automatic optimization parameters</strong></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div></div><div class="para">
			An optimization will be triggered to the <code class="literal">Animal</code> index as soon as either:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					the number of additions and deletions reaches 1000
				</div></li><li class="listitem"><div class="para">
					the number of transactions reaches 50 (<code class="constant">hibernate.search.Animal.optimizer.transaction_limit.max</code> having priority over <code class="constant">hibernate.search.default.optimizer.transaction_limit.max</code>)
				</div></li></ul></div><div class="para">
			If none of these parameters are defined, no optimization is processed automatically.
		</div></div><div class="section" id="idm139947803351472"><div class="titlepage"><div><div><h2 class="title">7.2. Manual optimization</h2></div></div></div><div class="para">
			You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the <code class="classname">SearchFactory</code>:
		</div><div class="example" id="idm139947799336752"><p class="title"><strong>Example 7.2. Programmatic index optimization</strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</pre></div></div><div class="para">
			The first example optimizes the Lucene index holding <code class="classname">Order</code>s; the second, optimizes all indexes.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				<code class="literal">searchFactory.optimize()</code> has no effect on a JMS backend. You must apply the optimize operation on the Master node.
			</div></div></div></div><div class="section" id="idm139947804581920"><div class="titlepage"><div><div><h2 class="title">7.3. Adjusting optimization</h2></div></div></div><div class="para">
			Apache Lucene has a few parameters to influence how optimization is performed. Hibernate Search exposes those parameters.
		</div><div class="para">
			Further index optimisation parameters include: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</code>
					</div></li><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</code>
					</div></li><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</code>
					</div></li><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</code>
					</div></li><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</code>
					</div></li><li class="listitem"><div class="para">
						<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</code>
					</div></li></ul></div>
			 See <a class="xref" href="#lucene-indexing-performance">Section 3.8, “Tuning Lucene indexing performance”</a> for more details.
		</div></div></div><div xml:lang="en-US" class="chapter" id="search-lucene-native" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Advanced features</h1></div></div></div><div class="section" id="idm139947799060880"><div class="titlepage"><div><div><h2 class="title">8.1. SearchFactory</h2></div></div></div><div class="para">
			The <code class="classname">SearchFactory</code> object keeps track of the underlying Lucene resources for Hibernate Search, it's also a convenient way to access Lucene natively. The <code class="classname">SearchFactory</code> can be accessed from a <code class="classname">FullTextSession</code>:
		</div><div class="example" id="idm139947799283152"><p class="title"><strong>Example 8.1. Accessing the <code class="classname">SearchFactory</code></strong></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre></div></div></div><div class="section" id="idm139947801635184"><div class="titlepage"><div><div><h2 class="title">8.2. Accessing a Lucene Directory</h2></div></div></div><div class="para">
			You can always access the Lucene directories through plain Lucene, the Directory structure is in no way different with or without Hibernate Search. However there are some more convenient ways to access a given Directory. The <code class="classname">SearchFactory</code> keeps track of the <code class="classname">DirectoryProvider</code>s per indexed class. One directory provider can be shared amongst several indexed classes if the classes share the same underlying index directory. While usually not the case, a given entity can have several <code class="classname">DirectoryProvider</code>s if the index is sharded (see <a class="xref" href="#search-configuration-directory-sharding">Section 3.2, “Sharding indexes”</a>).
		</div><div class="example" id="idm139947802783136"><p class="title"><strong>Example 8.2. Accessing the Lucene <code class="classname">Directory</code></strong></p><div class="example-contents"><pre class="programlisting">DirectoryProvider[] provider = searchFactory.getDirectoryProviders(Order.class);
org.apache.lucene.store.Directory directory = provider[0].getDirectory();</pre></div></div><div class="para">
			In this example, directory points to the lucene index storing <code class="classname">Order</code>s information. Note that the obtained Lucene directory must not be closed (this is Hibernate Search responsibility).
		</div></div><div class="section" id="idm139947799926752"><div class="titlepage"><div><div><h2 class="title">8.3. Using an IndexReader</h2></div></div></div><div class="para">
			Queries in Lucene are executed on an <code class="literal">IndexReader</code>. Hibernate Search caches all index readers to maximize performance. Your code can access this cached resources, but you have to follow some "good citizen" rules.
		</div><div class="example" id="idm139947804194944"><p class="title"><strong>Example 8.3. Accesing an <code class="classname">IndexReader</code></strong></p><div class="example-contents"><pre class="programlisting">DirectoryProvider orderProvider = searchFactory.getDirectoryProviders(Order.class)[0];
DirectoryProvider clientProvider = searchFactory.getDirectoryProviders(Client.class)[0];

ReaderProvider readerProvider = searchFactory.getReaderProvider();
IndexReader reader = readerProvider.openReader(orderProvider, clientProvider);

try {
    //do read-only operations on the reader
}
finally {
    readerProvider.closeReader(reader);
}</pre></div></div><div class="para">
			The ReaderProvider (described in <a class="xref" href="#search-architecture-readerstrategy">Section 2.3, “Reader strategy”</a>), will open an IndexReader on top of the index(es) referenced by the directory providers. Because this <code class="classname">IndexReader</code> is shared amongst several clients, you must adhere to the following rules:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Never call indexReader.close(), but always call readerProvider.closeReader(reader), preferably in a finally block.
				</div></li><li class="listitem"><div class="para">
					Don't use this <code class="classname">IndexReader</code> for modification operations (you would get an exception). If you want to use a read/write index reader, open one from the Lucene Directory object.
				</div></li></ul></div><div class="para">
			Aside from those rules, you can use the IndexReader freely, especially to do native queries. Using the shared <code class="literal">IndexReader</code>s will make most queries more efficient.
		</div></div><div class="section" id="idm139947801840832"><div class="titlepage"><div><div><h2 class="title">8.4. Customizing Lucene's scoring formula</h2></div></div></div><div class="para">
			Lucene allows the user to customize its scoring formula by extending <code class="classname">org.apache.lucene.search.Similarity</code>. The abstract methods defined in this class match the factors of the follownig formula calculating the score of query q for document d:
		</div><div class="para">
			<span class="bold bold"><strong>score(q,d) = coord(q,d) · queryNorm(q) · ∑<sub>t in q</sub> ( tf(t in d) · idf(t)<sup>2</sup> · t.getBoost() · norm(t,d) )</strong></span>
		</div><div class="para">
			<div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm139947801834816" scope="col"> Factor </th><th align="center" id="idm139947801146416" scope="col"> Description </th></tr></thead><tbody><tr><td align="left" headers="idm139947801834816"> tf(t ind) </td><td align="left" headers="idm139947801146416"> Term frequency factor for the term (t) in the document (d). </td></tr><tr><td align="left" headers="idm139947801834816"> idf(t) </td><td align="left" headers="idm139947801146416"> Inverse document frequency of the term. </td></tr><tr><td align="left" headers="idm139947801834816"> coord(q,d) </td><td align="left" headers="idm139947801146416"> Score factor based on how many of the query terms are found in the specified document. </td></tr><tr><td align="left" headers="idm139947801834816"> queryNorm(q) </td><td align="left" headers="idm139947801146416"> Normalizing factor used to make scores between queries comparable. </td></tr><tr><td align="left" headers="idm139947801834816"> t.getBoost() </td><td align="left" headers="idm139947801146416"> Field boost. </td></tr><tr><td align="left" headers="idm139947801834816"> norm(t,d) </td><td align="left" headers="idm139947801146416"> Encapsulates a few (indexing time) boost and length factors. </td></tr></tbody></table></div>
			 It is beyond the scope of this manual to explain this formula in more detail. Please refer to <code class="classname">Similarity</code>'s Javadocs for more information.
		</div><div class="para">
			Hibernate Search provides two ways to modify Lucene's similarity calculation. First you can set the default similarity by specifying the fully specified classname of your <code class="classname">Similarity</code> implementation using the property <code class="constant">hibernate.search.similarity</code>. The default value is <code class="classname">org.apache.lucene.search.DefaultSimilarity</code>. Additionally you can override the default similarity on class level using the <code class="literal">@Similarity</code> annotation. 
<pre class="programlisting">@Entity
@Indexed
<span class="bold bold"><strong>@Similarity(impl = DummySimilarity.class)</strong></span>
public class Book {
   ...
}</pre>
			 As an exmaple, let's assume it is not important how often a term appears in a document. Documents with a single occurrence of the term should be scored the same as documents with multiple occurrences. In this case your custom implementation of the method <code class="methodname">tf(float freq)</code> should return 1.0.
		</div></div></div><div xml:lang="en-US" class="appendix" id="appe-Publican-Revision_History" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Appendix A. Revision History</h1></div></div></div><div class="para"><p><!--Empty--></p>
		<div class="revhistory"><table summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 5.1.0-110.33.400</td><td align="left">2013-10-31</td><td align="left"><span class="author"><span class="firstname">Rüdiger</span> <span class="surname">Landmann</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Rebuild with publican 4.0.0</td></tr></table>

				</td></tr><tr><td align="left">Revision 5.1.0-110.33</td><td align="left">July 24 2012</td><td align="left"><span class="author"><span class="firstname">Ruediger</span> <span class="surname">Landmann</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Rebuild for Publican 3.0</td></tr></table>

				</td></tr><tr><td align="left">Revision 5.1-0</td><td align="left">Wed Sep 15 2010</td><td align="left"><span class="author"><span class="firstname">Laura</span> <span class="surname">Bailey</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Changed version number in line with new versioning requirements.</td></tr><tr><td>Revised for JBoss Enterprise Application Platform 5.1.0.GA.</td></tr></table>

				</td></tr></table></div>

	</div></div><div><div class="legalnotice"><a id="idm139947800265600"><!--Empty--></a><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span>© 2011 Red Hat, Inc.
	</div><div class="para">
		This document is licensed by Red Hat under the <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="mimir-link-warn" title="Mimir does not include content from: creativecommons.org">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. If you distribute this document, or a modified version of it, you must provide attribution to Red Hat, Inc. and provide a link to the original. If the document is modified, all Red Hat trademarks must be removed.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat Software Collections is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></body>

        
        
    </div>
    

</div> 


                            </bdo>
                        </main>
                    </div>
                </main>
            </div>
        
            <!--#include virtual="/includes/footer/index.html" -->
        </div>
    </body>
</html>
