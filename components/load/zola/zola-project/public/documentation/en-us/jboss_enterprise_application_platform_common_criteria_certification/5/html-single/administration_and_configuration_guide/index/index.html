<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir.min.css">
        




    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_Bwzy34i9pSdDlzGALvqVwG4fpgGp08KLMAkClGNY9M4.css" />



<link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir-doc-toc.min.css" />



        
        <!--#include virtual="/includes/head/index.html" -->

        
        <title>
Administration And Configuration Guide - JBoss Enterprise Application Platform Common Criteria Certification 5
</title>
        
<meta name="product" content="JBoss Enterprise Application Platform Common Criteria Certification" />
<meta name="documentation_version" content="5" />
<meta name="documentKind" content="documentation" />
<meta name="portal_content_subtype" content="title" />
<meta name="lastModifiedDate" content="2017-11-28T18:42:55.000Z" />


        
            
        
        
            
                
                
                <!-- mimir_solr_yesindex -->
                <meta name="mimir_solr_yesindex" content="true" />
            
        
    </head>

    <body class="mimir-body">

        
        

        
        <div id="page-wrap" class="page-wrap">
            <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">
                <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
                <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

                <header class="masthead" id="masthead">

                    
                    <!--#include virtual="/includes/header/index.html" -->

                    
                    
                    
                        
                    
                    
                        <div class="breadcrumbs">
                            <div id="breadcrumbs" class="container">
                                
                                <a href="/">Home</a>
                                
                                <a href="/products/">Product Documentation</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/7.2.3/">JBoss Enterprise Application Platform Common Criteria Certification</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/5/">5</a>
                                
                                
                                Administration And Configuration Guide
                                
                            </div>
                        </div>
                    
                </header>

                <main id="cp-main" class="portal-content-area">
                    <div id="cp-content" class="main-content">
                        
                        <main class="container mimir-docs">
                            
                            <bdo>
                                

<script type="module" src="/mimir/scripts/mimir-doc-toc.min.js"></script>






<div class="docs-grid">

    <nav id="mimir-doc-toc" class="mimir-doc-toc">
      <div class="mimir-doc-toc-inner">
          <!-- single-page -->
        
            
              <ol>
                <li>
                        
                        <a href="#">Administration And Configuration Guide</a>
                    </li><li>
                        <a href="#What_this_Book_Covers">
                            What this Book Covers
                        </a>
                    </li><li>
                        <a href="#JBoss_Enterprise_Application_Platform_5_Introduction">
                            1. Introduction
                        </a><ol>
                <li>
                        <a href="#JBossAS_Use_Cases">
                            1.1. JBoss Enterprise Application Platform Use Cases
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#JBoss_AS_Infrastructure">
                            I. JBoss Enterprise Application Platform Infrastructure
                        </a><ol>
                <li>
                        <a href="#JBoss_Enterprise_Application_Platform_5_Architecture">
                            2. JBoss Enterprise Application Platform 5 architecture
                        </a><ol>
                <li>
                        <a href="#Architecture_Server_Bootstrap">
                            2.1. The JBoss Enterprise Application Platform Bootstrap
                        </a>
                    </li><li>
                        <a href="#Architecture_Hotdeployment">
                            2.2. Hot Deployment
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Application_Configuration">
                            II. JBoss Enterprise Application Platform 5 Configuration
                        </a><ol>
                <li>
                        <a href="#idm139946658924176">
                            3. Logging
                        </a><ol>
                <li>
                        <a href="#logging-defaults">
                            3.1. Logging Defaults
                        </a>
                    </li><li>
                        <a href="#logging-component-specific">
                            3.2. Component-Specific Logging
                        </a><ol>
                <li>
                        <a href="#idm139946674369536">
                            3.2.1. SQL Logging with Hibernate
                        </a>
                    </li><li>
                        <a href="#idm139946673512368">
                            3.2.2. Transaction Service Logging
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Deployment">
                            4. Deployment
                        </a><ol>
                <li>
                        <a href="#Deployable_Application_Types">
                            4.1. Deployable Application Types
                        </a>
                    </li><li>
                        <a href="#Standard_Server_Profiles">
                            4.2. Standard Server Profiles
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#microcontainer">
                            5. Microcontainer
                        </a>
                    </li><li>
                        <a href="#Naming_on_JBoss">
                            6. The JNDI Naming Service
                        </a><ol>
                <li>
                        <a href="#Naming_on_JBoss-An_Overview_of_JNDI">
                            6.1. An Overview of JNDI
                        </a><ol>
                <li>
                        <a href="#An_Overview_of_JNDI-Names">
                            6.1.1. Names
                        </a>
                    </li><li>
                        <a href="#An_Overview_of_JNDI-Contexts">
                            6.1.2. Contexts
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Naming_on_JBoss-The_JBossNS_Architecture">
                            6.2. The JBoss Naming Service Architecture
                        </a>
                    </li><li>
                        <a href="#Naming_on_JBoss-The_Naming_InitialContext_Factories">
                            6.3. The Naming InitialContext Factories
                        </a><ol>
                <li>
                        <a href="#The_Naming_InitialContext_Factories-The_standard_naming_context_factory">
                            6.3.1. The standard naming context factory
                        </a>
                    </li><li>
                        <a href="#The_Naming_InitialContext_Factories-The_org.jboss.naming.NamingContextFactory">
                            6.3.2. The org.jboss.naming.NamingContextFactory
                        </a>
                    </li><li>
                        <a href="#The_Naming_InitialContext_Factories-Naming_Discovery_in_Clustered_Environments">
                            6.3.3. Naming Discovery in Clustered Environments
                        </a>
                    </li><li>
                        <a href="#The_Naming_InitialContext_Factories-The_HTTP_InitialContext_Factory_Implementation">
                            6.3.4. The HTTP InitialContext Factory Implementation
                        </a>
                    </li><li>
                        <a href="#The_Naming_InitialContext_Factories-The_Login_InitialContext_Factory_Implementation">
                            6.3.5. The Login InitialContext Factory Implementation
                        </a>
                    </li><li>
                        <a href="#The_Naming_InitialContext_Factories-The_ORBInitialContextFactory">
                            6.3.6. The ORBInitialContextFactory
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Naming_on_JBoss-JNDI_over_HTTP">
                            6.4. JNDI over HTTP
                        </a><ol>
                <li>
                        <a href="#JNDI_over_HTTP-Accessing_JNDI_over_HTTP">
                            6.4.1. Accessing JNDI over HTTP
                        </a>
                    </li><li>
                        <a href="#JNDI_over_HTTP-Accessing_JNDI_over_HTTPS">
                            6.4.2. Accessing JNDI over HTTPS
                        </a>
                    </li><li>
                        <a href="#JNDI_over_HTTP-Securing_Access_to_JNDI_over_HTTP">
                            6.4.3. Securing Access to JNDI over HTTP
                        </a>
                    </li><li>
                        <a href="#JNDI_over_HTTP-Securing_Access_to_JNDI_with_a_Read_Only_Unsecured_Context">
                            6.4.4. Securing Access to JNDI with a Read-Only Unsecured Context
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Naming_on_JBoss-Additional_Naming_MBeans">
                            6.5. Additional Naming MBeans
                        </a><ol>
                <li>
                        <a href="#Additional_Naming_MBeans-JNDI_Binding_Manager">
                            6.5.1. JNDI Binding Manager
                        </a>
                    </li><li>
                        <a href="#Additional_Naming_MBeans-The_org.jboss.naming.NamingAlias_MBean">
                            6.5.2. The org.jboss.naming.NamingAlias MBean
                        </a>
                    </li><li>
                        <a href="#Additional_Naming_MBeans-org.jboss.naming.ExternalContext_MBean">
                            6.5.3. org.jboss.naming.ExternalContext MBean
                        </a>
                    </li><li>
                        <a href="#Additional_Naming_MBeans-The_org.jboss.naming.JNDIView_MBean">
                            6.5.4. The org.jboss.naming.JNDIView MBean
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Naming_on_JBoss-J2EE_and_JNDI___The_Application_Component_Environment">
                            6.6. J2EE and JNDI - The Application Component Environment
                        </a><ol>
                <li>
                        <a href="#J2EE_and_JNDI___The_Application_Component_Environment-ENC_Usage_Conventions">
                            6.6.1. ENC Usage Conventions
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Web_Services">
                            7. Web Services
                        </a><ol>
                <li>
                        <a href="#idm139946657805040">
                            7.1. The need for web services
                        </a>
                    </li><li>
                        <a href="#idm139946675865312">
                            7.2. What web services are not
                        </a>
                    </li><li>
                        <a href="#idm139946675181408">
                            7.3. Document/Literal
                        </a>
                    </li><li>
                        <a href="#idm139946670816320">
                            7.4. Document/Literal (Bare)
                        </a>
                    </li><li>
                        <a href="#idm139946670812064">
                            7.5. Document/Literal (Wrapped)
                        </a>
                    </li><li>
                        <a href="#idm139946676330672">
                            7.6. RPC/Literal
                        </a>
                    </li><li>
                        <a href="#idm139946675910736">
                            7.7. RPC/Encoded
                        </a>
                    </li><li>
                        <a href="#idm139946675902384">
                            7.8. Web Service Endpoints 
                        </a>
                    </li><li>
                        <a href="#idm139946675900592">
                            7.9. Plain old Java Object (POJO)
                        </a>
                    </li><li>
                        <a href="#idm139946675898272">
                            7.10. The endpoint as a web application
                        </a>
                    </li><li>
                        <a href="#idm139946658540096">
                            7.11. Packaging the endpoint
                        </a>
                    </li><li>
                        <a href="#idm139946658535872">
                            7.12. Accessing the generated WSDL
                        </a>
                    </li><li>
                        <a href="#idm139946658532688">
                            7.13. EJB3 Stateless Session Bean (SLSB)
                        </a>
                    </li><li>
                        <a href="#idm139946670492080">
                            7.14. Endpoint Provider
                        </a>
                    </li><li>
                        <a href="#idm139946670486288">
                            7.15. WebServiceContext
                        </a>
                    </li><li>
                        <a href="#idm139946670482528">
                            7.16. Web Service Clients
                        </a><ol>
                <li>
                        <a href="#idm139946670481728">
                            7.16.1. Service
                        </a>
                    </li><li>
                        <a href="#idm139946669653088">
                            7.16.2. Dynamic Proxy
                        </a>
                    </li><li>
                        <a href="#idm139946669643872">
                            7.16.3. WebServiceRef
                        </a>
                    </li><li>
                        <a href="#idm139946669624176">
                            7.16.4. Dispatch
                        </a>
                    </li><li>
                        <a href="#idm139946669615712">
                            7.16.5. Asynchronous Invocations
                        </a>
                    </li><li>
                        <a href="#idm139946676576512">
                            7.16.6. Oneway Invocations
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676573216">
                            7.17. Common API
                        </a><ol>
                <li>
                        <a href="#idm139946676570608">
                            7.17.1. Handler Framework
                        </a>
                    </li><li>
                        <a href="#idm139946676554592">
                            7.17.2. Message Context
                        </a>
                    </li><li>
                        <a href="#idm139946676545536">
                            7.17.3. Fault Handling
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676539632">
                            7.18. DataBinding
                        </a><ol>
                <li>
                        <a href="#idm139946676538832">
                            7.18.1. Using JAXB with non annotated classes
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676531040">
                            7.19. Attachments
                        </a><ol>
                <li>
                        <a href="#idm139946676529536">
                            7.19.1. MTOM/XOP
                        </a>
                    </li><li>
                        <a href="#idm139946676496080">
                            7.19.2. SwaRef
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676481632">
                            7.20. Tools
                        </a><ol>
                <li>
                        <a href="#idm139946676454448">
                            7.20.1. Bottom-Up (Using wsprovide)
                        </a>
                    </li><li>
                        <a href="#idm139946676433600">
                            7.20.2. Top-Down (Using wsconsume)
                        </a>
                    </li><li>
                        <a href="#idm139946658069872">
                            7.20.3. Client Side
                        </a>
                    </li><li>
                        <a href="#idm139946658045696">
                            7.20.4. Command-line & Ant Task Reference
                        </a>
                    </li><li>
                        <a href="#idm139946658039248">
                            7.20.5. JAX-WS binding customization
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946658032640">
                            7.21. Web Service Extensions
                        </a><ol>
                <li>
                        <a href="#idm139946658031840">
                            7.21.1. WS-Addressing
                        </a>
                    </li><li>
                        <a href="#idm139946658007248">
                            7.21.2. WS-Security
                        </a>
                    </li><li>
                        <a href="#sect-XML_Registries">
                            7.21.3. XML Registries
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676661968">
                            7.22. JBossWS Extensions
                        </a><ol>
                <li>
                        <a href="#idm139946676660640">
                            7.22.1. Proprietary Annotations
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946676649184">
                            7.23. Web Services Appendix
                        </a>
                    </li><li>
                        <a href="#idm139946676642944">
                            7.24. References
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#jboss_aop">
                            8. JBoss AOP
                        </a><ol>
                <li>
                        <a href="#idm139946675763376">
                            8.1. Some key terms
                        </a>
                    </li><li>
                        <a href="#idm139946670376432">
                            8.2. Creating Aspects in JBoss AOP
                        </a>
                    </li><li>
                        <a href="#idm139946670527168">
                            8.3. Applying Aspects in JBoss AOP
                        </a>
                    </li><li>
                        <a href="#idm139946670514592">
                            8.4. Packaging AOP Applications
                        </a>
                    </li><li>
                        <a href="#idm139946675025616">
                            8.5. The JBoss AspectManager Service
                        </a>
                    </li><li>
                        <a href="#running-as-sun-jdk">
                            8.6. Loadtime transformation in the JBoss Enterprise Application Platform Using Sun JDK
                        </a>
                    </li><li>
                        <a href="#idm139946672797888">
                            8.7. JRockit
                        </a>
                    </li><li>
                        <a href="#idm139946672783088">
                            8.8. Improving Loadtime Performance in the JBoss Enterprise Application Platform Environment
                        </a>
                    </li><li>
                        <a href="#idm139946672781072">
                            8.9. Scoping the AOP to the classloader
                        </a><ol>
                <li>
                        <a href="#idm139946672779104">
                            8.9.1. Deploying as part of a scoped classloader
                        </a>
                    </li><li>
                        <a href="#idm139946672774880">
                            8.9.2. Attaching to a scoped deployment
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transaction">
                            9. Transaction Management
                        </a><ol>
                <li>
                        <a href="#idm139946670209024">
                            9.1. Overview
                        </a>
                    </li><li>
                        <a href="#idm139946661043088">
                            9.2. Configuration Essentials
                        </a>
                    </li><li>
                        <a href="#idm139946662456960">
                            9.3. Transactional Resources
                        </a>
                    </li><li>
                        <a href="#lrco-overview">
                            9.4. Last Resource Commit Optimization (LRCO)
                        </a>
                    </li><li>
                        <a href="#transaction-timeout">
                            9.5. Transaction Timeout Handling
                        </a>
                    </li><li>
                        <a href="#idm139946671357312">
                            9.6. Recovery Configuration
                        </a>
                    </li><li>
                        <a href="#idm139946671352320">
                            9.7. Transaction Service FAQ
                        </a>
                    </li><li>
                        <a href="#using-jts">
                            9.8. Using the JTS Module
                        </a>
                    </li><li>
                        <a href="#using-xts">
                            9.9. Using the XTS Module
                        </a>
                    </li><li>
                        <a href="#idm139946658594528">
                            9.10. Transaction Management Console
                        </a>
                    </li><li>
                        <a href="#idm139946658591888">
                            9.11. Experimental Components
                        </a>
                    </li><li>
                        <a href="#transactions-source-code">
                            9.12. Source Code and Upgrading
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#remoting">
                            10. Remoting
                        </a><ol>
                <li>
                        <a href="#idm139946673791408">
                            10.1. Background
                        </a>
                    </li><li>
                        <a href="#idm139946675082736">
                            10.2. JBoss Remoting Configuration
                        </a><ol>
                <li>
                        <a href="#idm139946657585792">
                            10.2.1. MBeans
                        </a>
                    </li><li>
                        <a href="#idm139946673541712">
                            10.2.2. POJOs
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946673024352">
                            10.3. Multihomed servers
                        </a>
                    </li><li>
                        <a href="#idm139946676295024">
                            10.4. Address translation
                        </a>
                    </li><li>
                        <a href="#idm139946676292912">
                            10.5. Where are they now?
                        </a>
                    </li><li>
                        <a href="#idm139946674865808">
                            10.6. Further information.
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#messaging">
                            11. JBoss Messaging
                        </a>
                    </li><li>
                        <a href="#alternative_DBs">
                            12. Use Alternative Databases with JBoss Enterprise Application Platform
                        </a><ol>
                <li>
                        <a href="#idm139946658783584">
                            12.1. How to Use Alternative Databases
                        </a>
                    </li><li>
                        <a href="#idm139946669709536">
                            12.2. Install JDBC Drivers
                        </a><ol>
                <li>
                        <a href="#idm139946674515936">
                            12.2.1. Special Notes on Sybase
                        </a>
                    </li><li>
                        <a href="#Configuring_JDBC_DataSources">
                            12.2.2. Configuring JDBC DataSources
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946657843328">
                            12.3. Common Database-Related Tasks
                        </a><ol>
                <li>
                        <a href="#idm139946657842560">
                            12.3.1. Security and Pooling
                        </a>
                    </li><li>
                        <a href="#idm139946657838672">
                            12.3.2. Change Database for the JMS Services
                        </a>
                    </li><li>
                        <a href="#idm139946658987536">
                            12.3.3. Support Foreign Keys in CMP Services
                        </a>
                    </li><li>
                        <a href="#idm139946671576016">
                            12.3.4. Specify Database Dialect for Java Persistence API
                        </a>
                    </li><li>
                        <a href="#idm139946671557472">
                            12.3.5. Change Other JBoss Enterprise Application Platform Services to use the External Database
                        </a>
                    </li><li>
                        <a href="#idm139946671524064">
                            12.3.6. A Special Note About Oracle Databases
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#datasource-config">
                            13. Datasource Configuration
                        </a><ol>
                <li>
                        <a href="#idm139946675010288">
                            13.1. Types of Datasources
                        </a>
                    </li><li>
                        <a href="#idm139946669942112">
                            13.2. Datasource Parameters
                        </a>
                    </li><li>
                        <a href="#idm139946671454688">
                            13.3. Datasource Examples
                        </a><ol>
                <li>
                        <a href="#idm139946671452960">
                            13.3.1. Generic Datasource Example
                        </a>
                    </li><li>
                        <a href="#idm139946671446224">
                            13.3.2. Configuring a DataSource for Remote Usage
                        </a>
                    </li><li>
                        <a href="#idm139946671438112">
                            13.3.3. Configuring a Datasource to Use Login Modules
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#pooling">
                            14. Pooling
                        </a><ol>
                <li>
                        <a href="#idm139946657624080">
                            14.1. Strategy
                        </a>
                    </li><li>
                        <a href="#idm139946679272992">
                            14.2. Transaction stickness
                        </a>
                    </li><li>
                        <a href="#idm139946679269344">
                            14.3. Workaround for Oracle
                        </a>
                    </li><li>
                        <a href="#idm139946679267696">
                            14.4. Pool Access
                        </a>
                    </li><li>
                        <a href="#idm139946669740496">
                            14.5. Pool Filling
                        </a>
                    </li><li>
                        <a href="#idm139946669734928">
                            14.6. Idle Connections
                        </a>
                    </li><li>
                        <a href="#idm139946676612128">
                            14.7. Dead connections
                        </a><ol>
                <li>
                        <a href="#idm139946676610336">
                            14.7.1. Valid connection checking
                        </a>
                    </li><li>
                        <a href="#idm139946676607296">
                            14.7.2. Errors during SQL queries
                        </a>
                    </li><li>
                        <a href="#idm139946676604656">
                            14.7.3. Changing/Closing/Flushing the pool
                        </a>
                    </li><li>
                        <a href="#idm139946676600720">
                            14.7.4. Other pooling
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#faq">
                            15. Frequently Asked Questions
                        </a><ol>
                <li>
                        <a href="#idm139946673368592">
                            15.1. I have problems with Oracle XA?
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Clustering">
                            III. Clustering Guide
                        </a><ol>
                <li>
                        <a href="#clustering-intro.chapt">
                            16. Introduction and Quick Start
                        </a><ol>
                <li>
                        <a href="#clustering-quickstart">
                            16.1. Quick Start Guide
                        </a><ol>
                <li>
                        <a href="#clustering-quickstart-setup">
                            16.1.1. Initial Preparation
                        </a>
                    </li><li>
                        <a href="#clustering-quickstart-launching">
                            16.1.2. Launching a JBoss Enterprise Application Platform Cluster
                        </a>
                    </li><li>
                        <a href="#clustering-quickstart-http">
                            16.1.3. Web Application Clustering Quick Start
                        </a>
                    </li><li>
                        <a href="#clustering-quickstart-ejbsessions">
                            16.1.4. EJB Session Bean Clustering Quick Start
                        </a>
                    </li><li>
                        <a href="#clustering-quickstart-ejb3entities">
                            16.1.5. Entity Clustering Quick Start
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#cluster.concepts.chapt">
                            17. Clustering Concepts
                        </a><ol>
                <li>
                        <a href="#clustering-concepts-def">
                            17.1. Cluster Definition
                        </a>
                    </li><li>
                        <a href="#clustering-concepts-arch">
                            17.2. Service Architectures
                        </a><ol>
                <li>
                        <a href="#clustering-concepts-arch-proxy">
                            17.2.1. Client-side interceptor architecture
                        </a>
                    </li><li>
                        <a href="#clustering-concepts-arch-balancer">
                            17.2.2. External Load Balancer Architecture
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-concepts-balancepolicy">
                            17.3. Load Balancing Policies
                        </a><ol>
                <li>
                        <a href="#clustering-concepts-balancepolicy-30">
                            17.3.1. Client-side interceptor architecture
                        </a>
                    </li><li>
                        <a href="#idm139946676066848">
                            17.3.2. External load balancer architecture
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-blocks.chapt">
                            18. Clustering Building Blocks
                        </a><ol>
                <li>
                        <a href="#clustering-blocks-jgroups">
                            18.1. Group Communication with JGroups
                        </a><ol>
                <li>
                        <a href="#clustering-blocks-jgroups-channelfactory">
                            18.1.1. The Channel Factory Service
                        </a>
                    </li><li>
                        <a href="#clustering-blocks-jgroups-sharedtransport">
                            18.1.2. The JGroups Shared Transport
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-blocks-jbc">
                            18.2. Distributed Caching with JBoss Cache
                        </a><ol>
                <li>
                        <a href="#clustering-blocks-jbc-cachemanager">
                            18.2.1. The JBoss Enterprise Application Platform CacheManager Service
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-hapartition">
                            18.3. The HAPartition Service
                        </a><ol>
                <li>
                        <a href="#clustering-hapartition-drm">
                            18.3.1. DistributedReplicantManager Service
                        </a>
                    </li><li>
                        <a href="#clustering-hapartition-distributedstate">
                            18.3.2. DistributedState Service
                        </a>
                    </li><li>
                        <a href="#clustering-hapartition-customsvcs">
                            18.3.3. Custom Use of HAPartition
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-jndi">
                            19. Clustered JNDI Services
                        </a><ol>
                <li>
                        <a href="#clustering-jndi-how">
                            19.1. How it works
                        </a>
                    </li><li>
                        <a href="#clustering-jndi-client">
                            19.2. Client configuration
                        </a><ol>
                <li>
                        <a href="#idm139946660078864">
                            19.2.1. For clients running inside the Enterprise Application Platform
                        </a>
                    </li><li>
                        <a href="#idm139946658372224">
                            19.2.2. For clients running outside the Enterprise Application Platform
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-jndi-jboss">
                            19.3. JBoss configuration
                        </a><ol>
                <li>
                        <a href="#idm139946672662160">
                            19.3.1. Adding a Second HA-JNDI Service
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-session">
                            20. Clustered Session EJBs
                        </a><ol>
                <li>
                        <a href="#clustering-session-slsb30">
                            20.1. Stateless Session Bean in EJB 3.0
                        </a>
                    </li><li>
                        <a href="#clustering-session-sfsb30">
                            20.2. Stateful Session Beans in EJB 3.0
                        </a><ol>
                <li>
                        <a href="#idm139946658802864">
                            20.2.1. The EJB application configuration
                        </a>
                    </li><li>
                        <a href="#idm139946660186224">
                            20.2.2. Optimize state replication
                        </a>
                    </li><li>
                        <a href="#sfsb-jbc-cachemanager">
                            20.2.3. CacheManager service configuration
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-session-slsb21">
                            20.3. Stateless Session Bean in EJB 2.x
                        </a>
                    </li><li>
                        <a href="#clustering-session-sfsb21">
                            20.4. Stateful Session Bean in EJB 2.x
                        </a><ol>
                <li>
                        <a href="#idm139946659161504">
                            20.4.1. The EJB application configuration
                        </a>
                    </li><li>
                        <a href="#idm139946659154416">
                            20.4.2. Optimize state replication
                        </a>
                    </li><li>
                        <a href="#idm139946659150224">
                            20.4.3. The HASessionStateService configuration
                        </a>
                    </li><li>
                        <a href="#idm139946659137632">
                            20.4.4. Handling Cluster Restart
                        </a>
                    </li><li>
                        <a href="#idm139946659132528">
                            20.4.5. JNDI Lookup Process
                        </a>
                    </li><li>
                        <a href="#idm139946659125600">
                            20.4.6. SingleRetryInterceptor
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-entity">
                            21. Clustered Entity EJBs
                        </a><ol>
                <li>
                        <a href="#clustering-entity-30">
                            21.1. Entity Bean in EJB 3.0
                        </a><ol>
                <li>
                        <a href="#clustering-entity-30-cache">
                            21.1.1. Configure the distributed cache
                        </a>
                    </li><li>
                        <a href="#clustering-entity-30-bean">
                            21.1.2. Configure the entity beans for cache
                        </a>
                    </li><li>
                        <a href="#idm139946659112368">
                            21.1.3. Query result caching
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-entity-21">
                            21.2. Entity Bean in EJB 2.x
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-http">
                            22. HTTP Services
                        </a><ol>
                <li>
                        <a href="#clustering-http-modjk">
                            22.1. Configuring load balancing using Apache and mod_jk
                        </a><ol>
                <li>
                        <a href="#clustering-http-download">
                            22.1.1. Download the software
                        </a>
                    </li><li>
                        <a href="#idm139946669955264">
                            22.1.2. Configure Apache to load mod_jk
                        </a>
                    </li><li>
                        <a href="#clustering-http-nodes">
                            22.1.3. Configure worker nodes in mod_jk
                        </a>
                    </li><li>
                        <a href="#clustering-http-jboss">
                            22.1.4. Configuring JBoss to work with mod_jk
                        </a>
                    </li><li>
                        <a href="#idm139946653946384">
                            22.1.5. Configuring the NSAPI connector on Solaris
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-http-state">
                            22.2. Configuring HTTP session state replication
                        </a><ol>
                <li>
                        <a href="#clustering-http-app">
                            22.2.1. Enabling session replication in your application
                        </a>
                    </li><li>
                        <a href="#clustering-http-passivation">
                            22.2.2. HttpSession Passivation and Activation
                        </a>
                    </li><li>
                        <a href="#clustering-http-state-cacheconfig">
                            22.2.3. Configuring the JBoss Cache instance used for session state replication
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-http-field">
                            22.3. Using FIELD-level replication
                        </a>
                    </li><li>
                        <a href="#clustering-http-sso">
                            22.4. Using Clustered Single Sign-on (SSO)
                        </a><ol>
                <li>
                        <a href="#clustering-sso-configuration">
                            22.4.1. Configuration
                        </a>
                    </li><li>
                        <a href="#clustering-sso-behavior">
                            22.4.2. SSO Behavior
                        </a>
                    </li><li>
                        <a href="#clustering-sso-limitations">
                            22.4.3. Limitations
                        </a>
                    </li><li>
                        <a href="#clustering-sso-cookie-domain">
                            22.4.4. Configuring the Cookie Domain
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-jms">
                            23. JBoss Messaging Clustering Notes
                        </a>
                    </li><li>
                        <a href="#deployment.chapt">
                            24. Clustered Deployment Options
                        </a><ol>
                <li>
                        <a href="#idm139946669877856">
                            24.1. Clustered Singleton Services
                        </a><ol>
                <li>
                        <a href="#idm139946673051152">
                            24.1.1. HASingleton Deployment Options
                        </a>
                    </li><li>
                        <a href="#idm139946658563936">
                            24.1.2. Determining the master node
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#clustering-intro-farm">
                            24.2. Farming Deployment
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#jgroups.chapt">
                            25. JGroups Services
                        </a><ol>
                <li>
                        <a href="#jgroups-configuration">
                            25.1. Configuring a JGroups Channel's Protocol Stack
                        </a><ol>
                <li>
                        <a href="#idm139946673209664">
                            25.1.1. Common Configuration Properties
                        </a>
                    </li><li>
                        <a href="#jgroups-transport">
                            25.1.2. Transport Protocols
                        </a>
                    </li><li>
                        <a href="#jgroups-discovery">
                            25.1.3. Discovery Protocols
                        </a>
                    </li><li>
                        <a href="#jgroups-fd">
                            25.1.4. Failure Detection Protocols
                        </a>
                    </li><li>
                        <a href="#jgroups-reliable">
                            25.1.5. Reliable Delivery Protocols
                        </a>
                    </li><li>
                        <a href="#jgroups-other-gms">
                            25.1.6. Group Membership (GMS)
                        </a>
                    </li><li>
                        <a href="#jgroups-other-fc">
                            25.1.7. Flow Control (FC)
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946652629312">
                            25.2. Fragmentation (FRAG2)
                        </a>
                    </li><li>
                        <a href="#jgroups-other-st">
                            25.3. State Transfer
                        </a>
                    </li><li>
                        <a href="#jgroups-other-gc">
                            25.4. Distributed Garbage Collection (STABLE)
                        </a>
                    </li><li>
                        <a href="#jgroups-other-merge">
                            25.5. Merging (MERGE2)
                        </a>
                    </li><li>
                        <a href="#jgroups-other">
                            25.6. Other Configuration Issues
                        </a><ol>
                <li>
                        <a href="#idm139946653403472">
                            25.6.1. Binding JGroups Channels to a Particular Interface
                        </a>
                    </li><li>
                        <a href="#clustering-jgroups-isolation">
                            25.6.2. Isolating JGroups Channels
                        </a>
                    </li><li>
                        <a href="#idm139946653022736">
                            25.6.3. JGroups Troubleshooting
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#jbosscache.chapt">
                            26. JBoss Cache Configuration and Deployment
                        </a><ol>
                <li>
                        <a href="#jbosscache-configuration">
                            26.1. Key JBoss Cache Configuration Options
                        </a><ol>
                <li>
                        <a href="#jbosscache-configuration-cachemanager">
                            26.1.1. Editing the CacheManager Configuration
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-cachemode">
                            26.1.2. Cache Mode
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-transactions">
                            26.1.3. Transaction Handling
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-concurrency">
                            26.1.4. Concurrent Access
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-jgroups">
                            26.1.5. JGroups Integration
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-eviction">
                            26.1.6. Eviction
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-cacheloaders">
                            26.1.7. Cache Loaders
                        </a>
                    </li><li>
                        <a href="#jbosscache-configuration-buddyrepl">
                            26.1.8. Buddy Replication
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#jbosscache-custom-deployment">
                            26.2. Deploying Your Own JBoss Cache Instance
                        </a><ol>
                <li>
                        <a href="#jbosscache-custom-deployment-cachemgr">
                            26.2.1. Deployment Via the CacheManager Service
                        </a>
                    </li><li>
                        <a href="#jbosscache-custom-deployment-service.xml">
                            26.2.2. Deployment Via a -service.xml File
                        </a>
                    </li><li>
                        <a href="#jbosscache-custom-deployment-beans.xml">
                            26.2.3. Deployment Via a -jboss-beans.xml File
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#Appendices">
                            IV. Appendices
                        </a><ol>
                <li>
                        <a href="#appendix-db-specific-datasources">
                            A. Vendor-Specific Datasource Definitions
                        </a><ol>
                <li>
                        <a href="#idm139946673620080">
                            A.1. Deployer Location and Naming
                        </a>
                    </li><li>
                        <a href="#idm139946670367776">
                            A.2. DB2
                        </a>
                    </li><li>
                        <a href="#idm139946670954992">
                            A.3. Oracle
                        </a><ol>
                <li>
                        <a href="#idm139946671041904">
                            A.3.1. Changes in Oracle 10g JDBC Driver
                        </a>
                    </li><li>
                        <a href="#idm139946671039600">
                            A.3.2. Type Mapping for Oracle 10g
                        </a>
                    </li><li>
                        <a href="#idm139946671036080">
                            A.3.3. Retrieving the Underlying Oracle Connection Object
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946671032464">
                            A.4. Sybase
                        </a>
                    </li><li>
                        <a href="#idm139946671323536">
                            A.5. Microsoft SQL Server
                        </a><ol>
                <li>
                        <a href="#idm139946671307216">
                            A.5.1. Microsoft JDBC Drivers
                        </a>
                    </li><li>
                        <a href="#idm139946671293680">
                            A.5.2. JSQL Drivers
                        </a>
                    </li><li>
                        <a href="#idm139946671289744">
                            A.5.3. jTDS JDBC Driver
                        </a>
                    </li><li>
                        <a href="#idm139946671279184">
                            A.5.4. "Invalid object name 'JMS_SUBSCRIPTIONS' Exception
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946671271728">
                            A.6. MySQL Datasource
                        </a><ol>
                <li>
                        <a href="#idm139946671270928">
                            A.6.1. Installing the Driver
                        </a>
                    </li><li>
                        <a href="#idm139946671260560">
                            A.6.2. MySQL Local-TX Datasource
                        </a>
                    </li><li>
                        <a href="#idm139946654639280">
                            A.6.3. MySQL Using a Named Pipe
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946654634992">
                            A.7. PostgreSQL
                        </a>
                    </li><li>
                        <a href="#idm139946654627376">
                            A.8. Ingres
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#logging-appendix">
                            B. Logging Information and Recipes
                        </a><ol>
                <li>
                        <a href="#idm139946676123056">
                            B.1. Log Level Descriptions
                        </a>
                    </li><li>
                        <a href="#idm139946670963344">
                            B.2. Separate Log Files Per Application
                        </a>
                    </li><li>
                        <a href="#idm139946670904576">
                            B.3. Redirecting Category Output
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm139946671941360">
                            Legal Notice
                        </a>
                    </li>
            </ol>
            
        
      </div>
    </nav>

    
    <div class="pvof-doc__wrapper" id="doc-wrapper">
        <section class="mimir-doc-title" id="mimir-doc--administration_and_configuration_guide">
            <h1 class="title">Administration And Configuration Guide</h1>
        </section>
        <body><div xml:lang="en-US" class="book" id="idm139946668755376" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JBoss Enterprise Application Platform Common Criteria Certification</span> <span class="productnumber">5</span></div><div><h2 class="subtitle">for JBoss Enterprise Application Platform 5 Common Criteria Certification</h2></div><p class="edition">Edition 5.1.0</p><div><h3 class="corpauthor">
		<span class="inlinemediaobject"><object data="https://access.redhat.com/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/a78399a6916bd5b945caa082f6c4fa4e/title_logo.svg" type="image/svg+xml"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/20c014cff25dbc2aeb4126383228ede4/title_logo.png" alt="" /></object></span>

	</h3></div><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">JBoss</span> <span class="surname">Community</span></h3></div><div class="editor"><h4 class="editedby">Edited by</h4><h3 class="editor"><span class="firstname">JBoss</span> <span class="surname">Community</span></h3></div><div class="editor"><h4 class="editedby">Edited by</h4><h3 class="editor"><span class="firstname">Red Hat</span> <span class="surname">Documentation Group</span></h3></div></div></div><div><p class="copyright">Copyright  2010 Red Hat, Inc</p></div><div><a href="#idm139946671941360">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
			This book is a guide to the administration and configuration of JBoss Enterprise Application Platform 5.1.0.
		</div></div></div></div></div><div xml:lang="en-US" class="preface" id="What_this_Book_Covers" lang="en-US"><div class="titlepage"><div><div><h1 class="title">What this Book Covers</h1></div></div></div><div class="para">
		The primary focus of this book is the presentation of the standard JBoss Enterprise Application Platform 5.0 architecture components from both the perspective of their configuration and architecture. As a user of a standard JBoss distribution you will be given an understanding of how to configure the standard components. This book is not an introduction to JavaEE or how to use JavaEE in applications. It focuses on the internal details of the JBoss server architecture and how our implementation of a given JavaEE container can be configured and extended.
	</div><div class="para">
		As a JBoss developer, you will be given a good understanding of the architecture and integration of the standard components to enable you to extend or replace the standard components for your infrastructure needs. We also show you how to obtain the JBoss source code, along with how to build and debug the JBoss server.
	</div></div><div xml:lang="en-US" class="chapter" id="JBoss_Enterprise_Application_Platform_5_Introduction" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter1.Introduction</h1></div></div></div><div class="para">
		<a id="idm139946671956400" class="indexterm"><!--Empty--></a> JBoss Enterprise Application Platform 5 is built on top of the new JBoss Microcontainer. The JBoss Microcontainer is a lightweight container that supports direct deployment, configuration and lifecycle of plain old Java objects (POJOs). <a id="idm139946665800112" class="indexterm"><!--Empty--></a> The JBoss Microcontainer project is standalone and replaces the JBoss JMX Microkernel used in the 4.x JBoss Enterprise Application Platforms. 
	</div><div class="para">
		The JBoss Microcontainer integrates nicely with the JBoss Aspect Oriented Programming framework (JBoss AOP). JBoss AOP is discussed in <a class="xref" href="#jboss_aop">Chapter8, <em>JBoss AOP</em></a> Support for JMX in JBoss Enterprise Application Platform 5 remains strong and MBean services written against the old Microkernel are expected to work.
	</div><div class="para">
		A sample Java EE 5 application that can be run on top of JBoss Enterprise Application Platform 5.0.0.GA and above which demonstrates many interesting technologies is the Seam Booking Application available with this distribution. This example application makes use of the following technologies running on JBoss Enterprise Application Platform 5:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				EJB3
			</div></li><li class="listitem"><div class="para">
				Stateful Session Beans
			</div></li><li class="listitem"><div class="para">
				Stateless Session Beans
			</div></li><li class="listitem"><div class="para">
				JPA (w/ Hibernate validation)
			</div></li><li class="listitem"><div class="para">
				JSF
			</div></li><li class="listitem"><div class="para">
				Facelets
			</div></li><li class="listitem"><div class="para">
				Ajax4JSF
			</div></li><li class="listitem"><div class="para">
				Seam
			</div></li></ul></div><div class="para">
		Many key features of JBoss Enterprise Application Platform 5 are provided by integrating standalone JBoss projects which include:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				JBoss EJB3 included with JBoss Enterprise Application Platform 5 provides the implementation of the latest revision of the Enterprise Java Beans (EJB) specification. EJB 3.0 is a deep overhaul and simplification of the EJB specification. EJB 3.0's goals are to simplify development, facilitate a test driven approach, and focus more on writing plain old java objects (POJOs) rather than coding against complex EJB APIs.
			</div></li><li class="listitem"><div class="para">
				JBoss Messaging is a high performance JMS provider included in JBoss Enterprise Application Platform 5 as the default messaging provider. It is also the backbone of the JBoss ESB infrastructure. JBoss Messaging is a complete rewrite of JBossMQ, which is the default JMS provider for JBoss Enterprise Application Platform 4.2.
			</div></li><li class="listitem"><div class="para">
				JBoss Cache comes in two flavors: a traditional tree-structured node-based cache, and a PojoCache, an in-memory, transactional, and replicated cache system that allows users to operate on simple POJOs transparently without active user management of either replication or persistency aspects.
			</div></li><li class="listitem"><div class="para">
				JBossWS 3.x is the web services stack for JBoss Enterprise Application Platform 5 providing Java EE compatible web services, JAXWS-2.x.
			</div></li><li class="listitem"><div class="para">
				JBoss Transactions is the default transaction manager for JBoss Enterprise Application Platform 5. JBoss Transactions is founded on industry proven technology and 18 year history as a leader in distributed transactions, and is one of the most interoperable implementations available.
			</div></li><li class="listitem"><div class="para">
				JBoss Web is the Web container in JBoss Enterprise Application Platform 5, an implementation based on Apache Tomcat that includes the Apache Portable Runtime (APR) and Tomcat native technologies to achieve scalability and performance characteristics that match and exceed the Apache Http server.
			</div></li></ul></div><div class="section" id="JBossAS_Use_Cases"><div class="titlepage"><div><div><h2 class="title">1.1.JBoss Enterprise Application Platform Use Cases</h2></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					99% of web applications involving a database
				</div></li><li class="listitem"><div class="para">
					Mission critical web applications likely to be clustered.
				</div></li><li class="listitem"><div class="para">
					Simple web applications with JSPs/Servlets upgrades to JBoss Enterprise Application Platform with Tomcat Embedded.
				</div></li><li class="listitem"><div class="para">
					Intermediate web applications with JSPs/Servlets using a web framework such as Struts, Java Server Faces, Cocoon, Tapestry, Spring, Expresso, Avalon, Turbine.
				</div></li><li class="listitem"><div class="para">
					Complex web applications with JSPs/Servlets, SEAM, Enterprise Java Beans (EJB), Java Messaging (JMS), caching etc.
				</div></li><li class="listitem"><div class="para">
					Cross application middleware (JMS, Corba, JMX etc).
				</div></li></ul></div></div></div><div class="part" id="JBoss_AS_Infrastructure"><div class="titlepage"><div><div><h1 class="title">PartI.JBoss Enterprise Application Platform Infrastructure</h1></div></div></div><div xml:lang="en-US" class="chapter" id="JBoss_Enterprise_Application_Platform_5_Architecture" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter2.JBoss Enterprise Application Platform 5 architecture</h2></div></div></div><div class="para">
		<a id="idm139946674910832" class="indexterm"><!--Empty--></a> The following diagram illustrates an overview of the JBoss Enterprise Application Server and its components. 
		<span class="inlinemediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/4f79cda30ce3e4b27bc6ba61abcf174c/jboss-as-components.png" width="444" /></span>

	</div><div class="para">
		The directory structure of JBoss Enterprise Application Platform 5 resembles that of the 4.x series with some notable differences:
	</div><pre class="screen">
-jboss-as - the path to your JBoss Enterprise Application Server.
		|-- bin - contains start scripts and run.jar
		|-- client - client jars 
		|-- common/lib - static jars shared across server profile
		|-- docs - schemas/dtds, examples
		|-- lib - core bootstrap jars
		| lib/endorsed - added to the server JVM java.endorsed.dirs path
		`-- server - server profile directories. See Section 3.2 
                     for details of the server profiles included in this release.
</pre><pre class="screen">
-seam - the path to JBoss SEAM application framework 
		|-- bootstrap
		|-- build
		|-- examples - examples demonstrating uses of SEAM's features
		|-- extras
		|-- lib - library directory
		|-- seam-gen - command-line utility used to generate simple skeletal SEAM code to get your project started
		|-- ui -
</pre><pre class="screen">
-resteasy - RESTEasy - a portable implementation of JSR-311 JAX-RS Specification
		|-- embedded-lib
		|-- lib
		|-- resteasy-jaxrs.war
</pre><div class="section" id="Architecture_Server_Bootstrap"><div class="titlepage"><div><div><h2 class="title">2.1.The JBoss Enterprise Application Platform Bootstrap</h2></div></div></div><a id="idm139946672412624" class="indexterm"><!--Empty--></a><div class="para">
			The JBoss Enterprise Application Platform 5 bootstrap is similar to the JBoss Enterprise Application Platform 4.x versions in that the org.jboss.Main entry point loads an org.jboss.system.server.Server implementation. In JBoss Enterprise Application Platform 4.x this was a JMX based microkernel. In JBoss Enterprise Application Platform 5 this is a JBoss Microcontainer.
		</div><a id="idm139946674813008" class="indexterm"><!--Empty--></a><div class="para">
			The default JBoss Enterprise Application Platform 5 <code class="classname">org.jboss.system.server.Server implementation</code> is <code class="classname">org.jboss.bootstrap.microcontainer.ServerImpl</code>. This implementation is an extension of the kernel basic bootstrap that boots the MC from the bootstrap beans declared in <code class="filename">{jboss.server.config.url}/bootstrap.xml</code> descriptors using a <code class="classname">BasicXMLDeployer</code>. In addition, the <code class="classname">ServerImpl</code> registers install callbacks for any beans that implement the <code class="classname">org.jboss.bootstrap.spi.Bootstrap</code> interface. The <code class="filename">bootstrap/profile*.xml</code> configurations include a <code class="classname">ProfileServiceBootstrap</code> bean that implements the Bootstrap interface.
		</div><a id="idm139946662337536" class="indexterm"><!--Empty--></a><div class="para">
			The <code class="classname">org.jboss.system.server.profileservice.ProfileServiceBootstrap</code> is an implementation of the <code class="classname">org.jboss.bootstrap.spi.Bootstrap</code> interface that loads the deployments associated with the current profile. The <span class="emphasis"><em>{profile-name}</em></span> is the name of the profile being loaded and corresponds to the <code class="code">server -c</code> command line argument. The default <span class="emphasis"><em>{profile-name}</em></span> is <span class="emphasis"><em>default</em></span>. The deployers, deploy
		</div></div><div class="section" id="Architecture_Hotdeployment"><div class="titlepage"><div><div><h2 class="title">2.2.Hot Deployment</h2></div></div></div><a id="idm139946669761696" class="indexterm"><!--Empty--></a><div class="para">
			Hot deployment in JBoss Enterprise Application Platform 5 is controlled by the <code class="classname">Profile</code> implementations associated with the <code class="classname">ProfileService</code>. The <code class="classname">HDScanner</code> bean deployed via the <code class="filename">deploy/hdscanner-jboss-beans.xml</code> MC deployment, queries the profile service for changes in application directory contents and redeploys updated content, undeploys removed content, and adds new deployment content to the current profile via the <code class="classname">ProfileService</code>.
		</div><a id="idm139946669757280" class="indexterm"><!--Empty--></a><div class="para">
			Disabling hot deployment is achieved by removing the <code class="filename">hdscanner-jboss-beans.xml</code> file from deployment.
		</div></div></div></div><div class="part" id="Application_Configuration"><div class="titlepage"><div><div><h1 class="title">PartII.JBoss Enterprise Application Platform 5 Configuration</h1></div></div></div><div xml:lang="en-US" class="chapter" id="idm139946658924176" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter3.Logging</h2></div></div></div><div class="para">
		Logging is the most important tool to troubleshoot errors and monitor the status of the components of the Platform. <span class="application"><strong>log4j</strong></span> provides a familiar, flexible framework, familiar to Java developers.
	</div><div class="para">
		<a class="xref" href="#logging-defaults">Section3.1, Logging Defaults</a> contains information about customizing the default logging behavior for the Platform. See <a class="xref" href="#logging-component-specific">Section3.2, Component-Specific Logging</a> for additional customization. <a class="xref" href="#logging-appendix">AppendixB, <em>Logging Information and Recipes</em></a> provides some logging <em class="wordasword">recipes</em>, which you can customize to your needs.
	</div><div class="section" id="logging-defaults"><div class="titlepage"><div><div><h2 class="title">3.1.Logging Defaults</h2></div></div></div><div class="para">
			The <span class="application"><strong>log4j</strong></span> configuration is loaded from the <code class="filename"><em class="replaceable">JBOSS_HOME</em>/server/<em class="replaceable">PROFILE</em>/conf/jboss-log4j.xml</code> deployment descriptor. <span class="application"><strong>log4j</strong></span> uses <em class="firstterm">appenders</em> to control its logging behavior. An appender is a directive for where to log information, and how to do it. The <code class="filename">jboss-log4j.xml</code> file contains many sample appenders, including FILE, CONSOLE, and SMTP.
		</div><div class="table" id="idm139946670447312"><p class="title"><strong>Table3.1.Common <span class="application">log4j</span> Configuration Directives</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Common log4j Configuration Directives"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946674502272" scope="col"> Configuration Option </th><th id="idm139946661048928" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946674502272"> <div class="para">
							<code class="option">appender</code>
						</div>
						 </td><td headers="idm139946661048928"> <div class="para">
							The main appender. Gives the name and the implementing class.
						</div>
						 </td></tr><tr><td headers="idm139946674502272"> <div class="para">
							<code class="option">errorHandler</code>
						</div>
						 </td><td headers="idm139946661048928"> <div class="para">
							Delegates an external class to handle exceptions passed to the logger, especially if the appender cannot write the log for some reason.
						</div>
						 </td></tr><tr><td headers="idm139946674502272"> <div class="para">
							<code class="option">param</code>
						</div>
						 </td><td headers="idm139946661048928"> <div class="para">
							Options specific to the type of appender. In this instance, the &lt;param&gt; is the name of the file that stores the logs for the FILE appender.
						</div>
						 </td></tr><tr><td headers="idm139946674502272"> <div class="para">
							<code class="option">layout</code><code class="option"><!--Empty--></code>
						</div>
						 </td><td headers="idm139946661048928"> <div class="para">
							Controls the logging format. Tweak this to work with your log-parsing software of choice.
						</div>
						 </td></tr></tbody></table></div></div><div class="example" id="idm139946671876512"><p class="title"><strong>Example3.1.Sample Appender</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;appender name="FILE" class="org.jboss.logging.appender.DailyRollingFileAppender"&gt;
  &lt;errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"/&gt;
  &lt;param name="File" value="${jboss.server.log.dir}/server.log"/&gt;
  &lt;param name="Append" value="true"/&gt;
  &lt;!-- In AS 5.0.x the server log threshold was set by a system property.
		 In 5.1 and later, the system property sets the priority on the root
		 logger (see &lt;root/&gt; below)
		 &lt;param name="Threshold" value="${jboss.server.log.threshold}"/&gt; --&gt;
 
  &lt;!-- Rollover at midnight each day --&gt;
  &lt;param name="DatePattern" value="'.'yyyy-MM-dd"/&gt;
  &lt;layout class="org.apache.log4j.PatternLayout"&gt;
	 &lt;!-- The default pattern: Date Priority [Category] (Thread) Message\n --&gt;
	 &lt;param name="ConversionPattern" value="%d %-5p [%c] (%t) %m%n"/&gt;
  &lt;/layout&gt;
&lt;/appender&gt;</pre></div></div><div class="para">
			For more information on configuring <span class="application"><strong>log4j</strong></span>, see <a href="http://logging.apache.org/log4j/1.2/" class="mimir-link-warn" title="Mimir does not include content from: logging.apache.org">http://logging.apache.org/log4j/1.2/</a>.
		</div></div><div class="section" id="logging-component-specific"><div class="titlepage"><div><div><h2 class="title">3.2.Component-Specific Logging</h2></div></div></div><div class="para">
			Some Platform components have extra logging options available, or extra mechanisms for customizing logging.
		</div><div class="section" id="idm139946674369536"><div class="titlepage"><div><div><h3 class="title">3.2.1.SQL Logging with Hibernate</h3></div></div></div><div class="para">
				Hibernate has two ways to enable logging of SQL statements. These statements are most useful during the testing and debugging phases of application development.
			</div><div class="para">
				The first way is to explicitly enable it in your code.
			</div><pre class="programlisting language-java JAVA JAVA">SessionFactory sf = new Configuration()
	 .setProperty("hibernate.show_sql", "true")
	 // ...
	 .buildSessionFactory();</pre><div class="para">
				Alternately, you can configure Hibernate to send all SQL messages to <span class="application"><strong>log4j</strong></span>, using a specific facility:
			</div><pre class="screen">
log4j.logger.org.hibernate.SQL=DEBUG, SQL_APPENDER
log4j.additivity.org.hibernate.SQL=false
</pre><div class="para">
				The <code class="option">additivity</code> option controls whether these log messages are propagated upward to parent handlers, and is a matter of preference.
			</div></div><div class="section" id="idm139946673512368"><div class="titlepage"><div><div><h3 class="title">3.2.2.Transaction Service Logging</h3></div></div></div><div class="para">
				The TransactionManagerService included with the Enterprise Platform handles logging differently than the stand-alone Transaction Service. Specifically, it overrides the value of the <span class="property">com.arjuna.common.util.logger property</span> given in the <code class="filename">jbossjta-properties.xml</code> file, forcing use of the <span class="application"><strong>log4j_releveler</strong></span> logger. All <code class="literal">INFO</code> level messages in the transaction code behave as <code class="literal">DEBUG</code> messages. Therefore, these messages are only present in log files if the filter level is <code class="literal">DEBUG</code>. All other log messages behave as normal.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="Deployment" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter4.Deployment</h2></div></div></div><div class="para">
		Deploying applications on JBoss Enterprise Application Platform is achieved by copying the application into the <code class="filename">$JBOSS_HOME/server/default/deploy</code> directory. You can replace <span class="emphasis"><em>default</em></span> with different server profiles such as <span class="emphasis"><em>all</em></span> or <span class="emphasis"><em>minimal</em></span> (profiles are covered later in this guide). The JBoss Enterprise Application Platform constantly scans the deploy directory to pick up new applications or any changes to existing applications. This enables <span class="emphasis"><em>hot deployment</em></span> of applications on the fly, while JBoss Enterprise Application Platform is still running.
	</div><div class="section" id="Deployable_Application_Types"><div class="titlepage"><div><div><h2 class="title">4.1.Deployable Application Types</h2></div></div></div><div class="para">
			With JBoss Enterprise Application Platform 4.x, a deployer existed to handle a specified deployment type and that was the only deployer that would process the deployment. In JBoss Enterprise Application Platform 5, multiple deployers transform the metadata associated with a deployment until its processed by a deployer that creates a runtime component from the metadata. Deployment has to contain a descriptor that causes the component metadata to be added to the deployment. The types of deployments for which deployers exists by default in the JBoss Enterprise Application Platform include:
		</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">WAR</span></dt><dd><a id="idm139946669539424" class="indexterm"><!--Empty--></a><a id="idm139946670771040" class="indexterm"><!--Empty--></a><div class="para">
						The WAR application archive (e.g., myapp.war) packages Java EE web applications in a JAR file. It contains servlet classes, view pages, libraries, and deployment descriptors in WEB-INF such as web.xml, faces-config.xml, and jboss-web.xml etc..
					</div></dd><dt><span class="term">EAR</span></dt><dd><a id="idm139946674964032" class="indexterm"><!--Empty--></a><a id="idm139946673300848" class="indexterm"><!--Empty--></a><div class="para">
						The EAR application archive (e.g., myapp.ear) packages a Java EE enterprise application in a JAR file. It typically contains a WAR file for the web module, JAR files for EJB modules, as well as META-INF deployment descriptors such as application.xml and jboss-app.xml etc.
					</div></dd><dt><span class="term">JBoss Microcontainer</span></dt><dd><a id="idm139946662358336" class="indexterm"><!--Empty--></a><div class="para">
						The JBoss Microcontainer (MC) beans archive (typical suffixes include, .beans, .deployer) packages a POJO deployment in a JAR file with a <code class="filename">META-INF/jboss-beans.xml</code> descriptor. This format is commonly used by the JBoss Enterprise Application Platform component deployers.
					</div><div class="para">
						You can deploy <code class="filename">*-jboss-beans.xml</code> files with MC beans definitions. If you have the approriate JAR files available in the deploy or lib directories, the MC beans can be deployed using such a standalone XML file.
					</div></dd><dt><span class="term">SAR</span></dt><dd><a id="idm139946670777760" class="indexterm"><!--Empty--></a><a id="idm139946674433984" class="indexterm"><!--Empty--></a><div class="para">
						The SAR application archive (e.g., myservice.sar) packages a JBoss service in a JAR file. It is mostly used by JBoss Enterprise Application Platform internal services that have not been updated to support MC beans style deployments.
					</div><div class="para">
						You can deploy <code class="filename">*-service.xml</code> files with MBean service definitions. If you have the appropriate JAR files available in the deploy or lib directories, the MBeans specified in the XML files will be started. This is the way you deploy many JBoss Enterprise Application Platform internal services that have not been updated to support POJO style deployment, such as the JMS queues.
					</div><div class="para">
						You can also deploy JAR files containing EJBs or other service objects directly in JBoss Enterprise Application Platform. The list of suffixes that are recognized as JAR files is specified in the <code class="filename">conf/bootstrap/deployers.xml</code> JARStructure bean constructor set.
					</div></dd><dt><span class="term">DataSource</span></dt><dd><a id="idm139946674428336" class="indexterm"><!--Empty--></a><div class="para">
						The <code class="filename">*-ds.xml</code> file defines connections to external databases. The data source can then be reused by all applications and services in JBoss Enterprise Application Platform via the internal JNDI.
					</div></dd></dl></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><a id="idm139946674151888" class="indexterm"><!--Empty--></a><div class="para">
				The WAR, EAR, MC beans and SAR deployment packages are really just JAR files with special XML deployment descriptors in directories like META-INF and WEB-INF. JBoss Enterprise Application Platform allows you to deploy those archives as expanded directories instead of JAR files. That allows you to make changes to web pages etc on the fly without re-deploying the entire application. If you do need to re-deploy the exploded directory without re-start the server, you can just <code class="code">touch</code> the deployment descriptors (e.g., the <code class="filename">WEB-INF/web.xml</code> in a WAR and the <code class="filename">META-INF/application.xml</code> in an EAR) to update their timestamps.
			</div></div></div></div><div class="section" id="Standard_Server_Profiles"><div class="titlepage"><div><div><h2 class="title">4.2.Standard Server Profiles</h2></div></div></div><a id="idm139946674147200" class="indexterm"><!--Empty--></a><a id="idm139946674366464" class="indexterm"><!--Empty--></a><div class="para">
			The JBoss Enterprise Application Platform ships with six server profiles. You can choose which configuration to start by passing the <code class="code">-c</code> parameter to the server startup script. For instance, the <code class="code">run.sh -c all</code> command starts the server in the <span class="emphasis"><em>all</em></span> profile.
		</div><div class="para">
			Each profile is contained in a directory named <code class="filename"><em class="replaceable">install_directory</em>/server/<em class="replaceable">[profile name]</em>/</code>. You can look into each server profile's directory to see the services, applications, and libraries included in the profile.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The exact contents of the <code class="filename">server/<em class="replaceable">[profile name]</em></code> directory depends on the profile service implementation and is subject to change as the management layer and embedded server evolve.
			</div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">all</span></dt><dd><a id="idm139946675622640" class="indexterm"><!--Empty--></a><div class="para">
						Default profile loaded when <code class="command">run.sh</code> is executed without the <em class="parameter"><code>-c</code></em> parameter. The profile provides clustering support and other enterprise extensions.
					</div></dd><dt><span class="term">production</span></dt><dd><a id="idm139946675618736" class="indexterm"><!--Empty--></a><div class="para">
						The <span class="emphasis"><em>production</em></span> profile is based on the <code class="literal">all</code> profile and provides configuration optimized for production environments.
					</div></dd><dt><span class="term">minimal</span></dt><dd><a id="idm139946675614800" class="indexterm"><!--Empty--></a><div class="para">
						Starts the core server container without any of the enterprise services. Use the <code class="literal">minimal</code> profile as a base to build a customized version of JBoss Enterprise Application Platform that only contains the services you need.
					</div></dd><dt><span class="term">default</span></dt><dd><a id="idm139946675611184" class="indexterm"><!--Empty--></a><div class="para">
						The <code class="literal">default</code> profile is the mostly common used profile for application developers. It supports the standard Java EE 5.0 programming APIs (e.g., Annotations, JPA, and EJB3).
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							The <code class="literal">default</code> profile is a misnomer; it is not loaded automatically if you do not specify a profile at start up. The <code class="literal">all</code> profile is loaded when you do not specify a profile at startup.
						</div></div></div></dd><dt><span class="term">standard</span></dt><dd><a id="idm139946679069232" class="indexterm"><!--Empty--></a><div class="para">
						The <span class="emphasis"><em>standard</em></span> profile is the profile that has been tested for Java EE compliance. The major differences with the existing configurations is that call-by-value and deployment isolation are enabled by default, along with support for <code class="filename">rmiiiop</code> and <code class="filename">juddi</code> (taken from the <span class="emphasis"><em>all</em></span> config).
					</div></dd><dt><span class="term">web</span></dt><dd><a id="idm139946679064064" class="indexterm"><!--Empty--></a><div class="para">
						The <span class="emphasis"><em>web</em></span> profile is an experimental, lightweight configuration created around JBoss Web that will follow the developments of the Java EE 6 web profile. Except for the <code class="filename">servlet/jsp</code> container, it provides support for JTA/JCA and JPA. It also limits itself to allowing access to the server only through the http port. Please note that this configuration is not Java EE certified and will most likely change in the following releases.
					</div></dd></dl></div><div class="para">
			The detailed services and APIs supported in each of those profiles will be discussed throughout.
		</div></div></div><div xml:lang="en-US" class="chapter" id="microcontainer" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter5.Microcontainer</h2></div></div></div><div class="para">
		JBoss Enterprise Application Platform 5.0 uses the Microcontainer to integrate enterprise services together with a Servlet/JSP container, EJB container, deployers and management utilities in order to provide a standard Java EE environment. If you need additional services, you can deploy these on top of Java EE to provide the functionality you need. Likewise any services that you do not need can be removed by changing the configuration. You can even use the Microcontainer to do this in other environments such as Tomcat and GlassFish by plugging in different classloading models during the service deployment phase.
	</div><div class="para">
		Since JBoss Microcontainer is very lightweight and deals with POJOs, it can also be used to deploy services into a Java ME runtime environment. This opens up new possibilities for mobile applications that can now take advantage of enterprise services without requiring a full JEE application server. As with other lightweight containers, JBoss Microcontainer uses dependency injection to wire individual POJOs together to create services. Configuration is performed using either annotations or XML depending on where the information is best located. Unit testing is made extremely simple thanks to a helper class that extends JUnit to setup the test environment, allowing you to access POJOs and services from your test methods using just a few lines of code.
	</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			For detailed information regarding the Microcontainer architecture, refer to the Microcontainer User Guide hosted on <a href="http://docs.redhat.com/docs/en-US/index.html" class="mimir-link-warn" title="This content is not included in Mimir.">docs.redhat.com</a>.
		</div></div></div></div><div xml:lang="en-US" class="chapter" id="Naming_on_JBoss" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter6.The JNDI Naming Service</h2></div></div></div><div class="para">
		The naming service plays a key role in enterprise Java applications, providing the core infrastructure that is used to locate objects or services in an application server. It is also the mechanism that clients external to the application server use to locate services inside the application server. Application code, whether it is internal or external to the JBoss Enterprise Application Platform instance, needs only know that it needs to talk to the a message queue named <code class="literal">queue/IncomingOrders</code> and need not worry about any of the queue's configuration details.
	</div><div class="para">
		In a clustered environment, naming services are even more valuable. A client of a service must be able to look up a <code class="literal">ProductCatalog</code> session bean from the cluster without needing to know which machine it resides on. Whether it is a large clustered service, a local resource or an application component that is needed, the JNDI naming service provides the glue that lets code find the objects in the system by name.
	</div><div class="section" id="Naming_on_JBoss-An_Overview_of_JNDI"><div class="titlepage"><div><div><h2 class="title">6.1.An Overview of JNDI</h2></div></div></div><div class="para">
			JNDI is a standard Java API that is bundled with the Java Development Kit. JNDI provides a common interface to a variety of existing naming services: DNS, LDAP, Active Directory, RMI registry, COS registry, NIS, and file systems. The JNDI API is divided logically into a client API that is used to access naming services, and a service provider interface (SPI) that allows the user to create JNDI implementations for naming services.
		</div><div class="para">
			The SPI layer is an abstraction that naming service providers must implement to enable the core JNDI classes to expose the naming service using the common JNDI client interface. An implementation of JNDI for a naming service is referred to as a <em class="firstterm">JNDI provider</em>. JBoss naming is an example JNDI implementation, based on the SPI classes. Note that the JNDI SPI is not needed by J2EE component developers.
		</div><div class="para">
			The main JNDI API package is the <code class="literal">javax.naming</code> package. It contains five interfaces, 10 classes, and several exceptions. There is one key class, <code class="classname">InitialContext</code>, and two key interfaces, <code class="classname">Context</code> and <code class="classname">Name</code>
		</div><div class="section" id="An_Overview_of_JNDI-Names"><div class="titlepage"><div><div><h3 class="title">6.1.1.Names</h3></div></div></div><div class="para">
				The notion of a name is of fundamental importance in JNDI. The naming system determines the syntax that the name must follow. The syntax of the naming system allows the user to parse string representations of names into its components. A name is used with a naming system to locate objects. In the simplest sense, a naming system is just a collection of objects with unique names. To locate an object in a naming system you provide a name to the naming system, and the naming system returns the object store under the name.
			</div><div class="para">
				As an example, consider the Unix file system's naming convention. Each file is named from its path relative to the root of the file system, with each component in the path separated by the forward slash character ("<code class="literal">/</code>"). The file's path is ordered from left to right. The pathname <code class="filename">/usr/jboss/readme.txt</code>, for example, names a file <code class="filename">readme.txt</code> in the directory <code class="filename">jboss</code>, under the directory <code class="filename">usr</code>, located in the root of the file system. JBoss Enterprise Application Platform naming uses a Unix-style namespace as its naming convention.
			</div><div class="para">
				The <code class="classname">javax.naming.Name</code> interface represents a generic name as an ordered sequence of components. It can be a composite name (one that spans multiple namespaces), or a compound name (one that is used within a single hierarchical naming system). The components of a name are numbered. The indexes of a name with N components range from 0 up to, but not including, N. The most significant component is at index 0. An empty name has no components.
			</div><div class="para">
				A composite name is a sequence of component names that span multiple namespaces. An example of a composite name would be the hostname and file combination commonly used with Unix commands like <code class="literal">scp</code>. For example, the following command copies <code class="filename">localfile.txt</code> to the file <code class="filename">remotefile.txt</code> in the <code class="filename">tmp</code> directory on host <code class="literal">ahost.someorg.org</code>:
			</div><pre class="programlisting">scp localfile.txt ahost.someorg.org:/tmp/remotefile.txt</pre><div class="para">
				A compound name is derived from a hierarchical namespace. Each component in a compound name is an atomic name, meaning a string that cannot be parsed into smaller components. A file pathname in the Unix file system is an example of a compound name. <code class="literal">ahost.someorg.org:/tmp/remotefile.txt</code> is a composite name that spans the DNS and Unix file system namespaces. The components of the composite name are <code class="literal">ahost.someorg.org</code> and <code class="filename">/tmp/remotefile.txt</code>. A component is a string name from the namespace of a naming system. If the component comes from a hierarchical namespace, that component can be further parsed into its atomic parts by using the <code class="literal">javax.naming.CompoundName</code> class. The JNDI API provides the <code class="literal">javax.naming.CompositeName</code> class as the implementation of the <code class="literal">Name</code> interface for composite names.
			</div></div><div class="section" id="An_Overview_of_JNDI-Contexts"><div class="titlepage"><div><div><h3 class="title">6.1.2.Contexts</h3></div></div></div><div class="para">
				The <code class="classname">javax.naming.Context</code> interface is the primary interface for interacting with a naming service. The <code class="classname">Context</code> interface represents a set of name-to-object bindings. Every context has an associated naming convention that determines how the context parses string names into <code class="classname">javax.naming.Name</code> instances. To create a name-to-object binding you invoke the bind method of a <code class="classname">Context</code> and specify a name and an object as arguments. The object can later be retrieved using its name using the <code class="classname">Context</code> lookup method. A <code class="classname">Context</code> will typically provide operations for binding a name to an object, unbinding a name, and obtaining a listing of all name-to-object bindings. The object you bind into a <code class="classname">Context</code> can itself be of type <code class="literal">Context</code>. The <code class="classname">Context</code> object that is bound is referred to as a subcontext of the <code class="classname">Context</code> on which the bind method was invoked.
			</div><div class="para">
				As an example, consider a file directory with a pathname <code class="filename">/usr</code>, which is a context in the Unix file system. A file directory named relative to another file directory is a subcontext (commonly referred to as a subdirectory). A file directory with a pathname <code class="filename">/usr/jboss</code> names a <code class="literal">jboss</code> context that is a subcontext of <code class="literal">usr</code>. In another example, a DNS domain, such as <code class="literal">org</code>, is a context. A DNS domain named relative to another DNS domain is another example of a subcontext. In the DNS domain <code class="literal">jboss.org</code>, the DNS domain <code class="literal">jboss</code> is a subcontext of <code class="literal">org</code> because DNS names are parsed right to left.
			</div><div class="section" id="Contexts-Obtaining_a_Context_using_InitialContext"><div class="titlepage"><div><div><h4 class="title">6.1.2.1.Obtaining a Context using InitialContext</h4></div></div></div><div class="para">
					All naming service operations are performed on some implementation of the <code class="classname">Context</code> interface. Therefore, you need a way to obtain a <code class="classname">Context</code> for the naming service you are interested in using. The <code class="literal">javax.naming.IntialContext</code> class implements the <code class="classname">Context</code> interface, and provides the starting point for interacting with a naming service.
				</div><div class="para">
					When you create an <code class="classname">InitialContext</code>, it is initialized with properties from the environment. JNDI determines each property's value by merging the values from the following two sources, in order.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							The first occurrence of the property from the constructor's environment parameter and (for appropriate properties) the applet parameters and system properties.
						</div></li><li class="listitem"><div class="para">
							All <code class="filename">jndi.properties</code> resource files found on the classpath.
						</div></li></ul></div><div class="para">
					For each property found in both of these two sources, the property's value is determined as follows. If the property is one of the standard JNDI properties that specify a list of JNDI factories, all of the values are concatenated into a single colon-separated list. For other properties, only the first value found is used. The preferred method of specifying the JNDI environment properties is through a <code class="filename">jndi.properties</code> file, which allows your code to externalize the JNDI provider specific information so that changing JNDI providers will not require changes to your code or recompilation.
				</div><div class="para">
					The <code class="classname">Context</code> implementation used internally by the <code class="classname">InitialContext</code> class is determined at runtime. The default policy uses the environment property <code class="varname">java.naming.factory.initial</code>, which contains the class name of the <code class="classname">javax.naming.spi.InitialContextFactory</code> implementation. You obtain the name of the <code class="classname">InitialContextFactory</code> class from the naming service provider you are using.
				</div><div class="para">
					<a class="xref" href="#Obtaining_a_Context_using_InitialContext-A_sample_jndi.properties_file">Example6.1, A sample jndi.properties file</a> gives a sample <code class="filename">jndi.properties</code> file a client application would use to connect to a JBossNS service running on the local host at port 1099. The client application would need to have the <code class="filename">jndi.properties</code> file available on the application classpath. These are the properties that the JBossNS JNDI implementation requires. Other JNDI providers will have different properties and values.
				</div><div class="example" id="Obtaining_a_Context_using_InitialContext-A_sample_jndi.properties_file"><p class="title"><strong>Example6.1.A sample jndi.properties file</strong></p><div class="example-contents"><pre class="programlisting">### JBossNS properties
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=jnp://localhost:1099
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces
</pre></div></div></div></div></div><div class="section" id="Naming_on_JBoss-The_JBossNS_Architecture"><div class="titlepage"><div><div><h2 class="title">6.2.The JBoss Naming Service Architecture</h2></div></div></div><div class="para">
			The JBoss Naming Service (JBossNS) architecture is a Java socket/RMI based implementation of the <code class="classname">javax.naming.Context</code> interface. It is a client/server implementation that can be accessed remotely. The implementation is optimized so that access from within the same VM in which the JBossNS server is running does not involve sockets. Same VM access occurs through an object reference available as a global singleton. <a class="xref" href="#The_JBossNS_Architecture-Key_components_in_the_JBossNS_architecture.">Figure6.1, Key components in the JBoss Naming Service architecture.</a> illustrates some of the key classes in the JBossNS implementation and their relationships.
		</div><div class="figure" id="The_JBossNS_Architecture-Key_components_in_the_JBossNS_architecture."><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/3389a9558687274b36e5d25d458ca637/Chap3-8.jpg" align="middle" width="444" alt="Key components in the JBoss Naming Service architecture." /></div></div><p class="title"><strong>Figure6.1.Key components in the JBoss Naming Service architecture.</strong></p></div><div class="para">
			We will start with the <code class="literal">NamingService</code> MBean. The <code class="literal">NamingService</code> MBean provides the JNDI naming service. This is a key service used pervasively by the J2EE technology components. The configurable attributes for the <code class="literal">NamingService</code> are as follows.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>Port</strong></span>: The jnp protocol listening port for the <code class="literal">NamingService</code>. If not specified default is 1099, the same as the RMI registry default port.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>RmiPort</strong></span>: The RMI port on which the RMI Naming implementation will be exported. If not specified the default is 0 which means use any available port.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>BindAddress</strong></span>: The specific address the <code class="literal">NamingService</code> listens on. This can be used on a multi-homed host for a <code class="literal">java.net.ServerSocket</code> that will only accept connect requests on one of its addresses.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>RmiBindAddress</strong></span>: The specific address the RMI server portion of the <code class="literal">NamingService</code> listens on. This can be used on a multi-homed host for a <code class="literal">java.net.ServerSocket</code> that will only accept connect requests on one of its addresses. If this is not specified and the <code class="literal">BindAddress</code> is, the <code class="literal">RmiBindAddress</code> defaults to the <code class="literal">BindAddress</code> value.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>Backlog</strong></span>: The maximum queue length for incoming connection indications (a request to connect) is set to the <code class="literal">backlog</code> parameter. If a connection indication arrives when the queue is full, the connection is refused.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>ClientSocketFactory</strong></span>: An optional custom <code class="literal">java.rmi.server.RMIClientSocketFactory</code> implementation class name. If not specified the default <code class="literal">RMIClientSocketFactory</code> is used.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>ServerSocketFactory</strong></span>: An optional custom <code class="literal">java.rmi.server.RMIServerSocketFactory</code> implementation class name. If not specified the default <code class="literal">RMIServerSocketFactory</code> is used.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>JNPServerSocketFactory</strong></span>: An optional custom <code class="literal">javax.net.ServerSocketFactory</code> implementation class name. This is the factory for the <code class="literal">ServerSocket</code> used to bootstrap the download of the JBoss Naming Service <code class="literal">Naming</code> interface. If not specified the <code class="literal">javax.net.ServerSocketFactory.getDefault()</code> method value is used.
				</div></li></ul></div><div class="para">
			The <code class="literal">NamingService</code> also creates the <code class="literal">java:comp</code> context such that access to this context is isolated based on the context class loader of the thread that accesses the <code class="literal">java:comp</code> context. This provides the application component private ENC that is required by the J2EE specs. This segregation is accomplished by binding a <code class="literal">javax.naming.Reference</code> to a context that uses the <code class="literal">org.jboss.naming.ENCFactory</code> as its <code class="literal">javax.naming.ObjectFactory</code>. When a client performs a lookup of <code class="literal">java:comp</code>, or any subcontext, the <code class="literal">ENCFactory</code> checks the thread context <code class="literal">ClassLoader</code>, and performs a lookup into a map using the <code class="literal">ClassLoader</code> as the key.
		</div><div class="para">
			If a context instance does not exist for the class loader instance, one is created and associated with that class loader in the <code class="literal">ENCFactory</code> map. Thus, correct isolation of an application component's ENC relies on each component receiving a unique <code class="literal">ClassLoader</code> that is associated with the component threads of execution.
		</div><div class="para">
			The <code class="literal">NamingService</code> delegates its functionality to an <code class="literal">org.jnp.server.Main</code> MBean. The reason for the duplicate MBeans is because JBoss Naming Service started out as a stand-alone JNDI implementation, and can still be run as such. The <code class="literal">NamingService</code> MBean embeds the <code class="literal">Main</code> instance into the JBoss server so that usage of JNDI with the same VM as the JBoss server does not incur any socket overhead. The configurable attributes of the NamingService are really the configurable attributes of the JBoss Naming Service <code class="literal">Main</code> MBean. The setting of any attributes on the <code class="literal">NamingService</code> MBean simply set the corresponding attributes on the <code class="literal">Main</code> MBean the <code class="literal">NamingService</code> contains. When the <code class="literal">NamingService</code> is started, it starts the contained <code class="literal">Main</code> MBean to activate the JNDI naming service.
		</div><div class="para">
			In addition, the <code class="literal">NamingService</code> exposes the <code class="literal">Naming</code> interface operations through a JMX detyped invoke operation. This allows the naming service to be accessed via JMX adaptors for arbitrary protocols. We will look at an example of how HTTP can be used to access the naming service using the invoke operation later in this chapter.
		</div><div class="para">
			When the <code class="literal">Main</code> MBean is started, it performs the following tasks:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Instantiates an <code class="literal">org.jnp.naming.NamingService</code> instance and sets this as the local VM server instance. This is used by any <code class="literal">org.jnp.interfaces.NamingContext</code> instances that are created within the JBoss server VM to avoid RMI calls over TCP/IP.
				</div></li><li class="listitem"><div class="para">
					Exports the <code class="literal">NamingServer</code> instance's <code class="literal">org.jnp.naming.interfaces.Naming</code> RMI interface using the configured <code class="literal">RmiPort</code>, <code class="literal">ClientSocketFactory</code>, <code class="literal">ServerSocketFactory</code> attributes.
				</div></li><li class="listitem"><div class="para">
					Creates a socket that listens on the interface given by the <code class="literal">BindAddress</code> and <code class="literal">Port</code> attributes.
				</div></li><li class="listitem"><div class="para">
					Spawns a thread to accept connections on the socket.
				</div></li></ul></div></div><div class="section" id="Naming_on_JBoss-The_Naming_InitialContext_Factories"><div class="titlepage"><div><div><h2 class="title">6.3.The Naming InitialContext Factories</h2></div></div></div><div class="para">
			The JBoss JNDI provider currently supports several different <code class="literal">InitialContext</code> factory implementations.
		</div><div class="section" id="The_Naming_InitialContext_Factories-The_standard_naming_context_factory"><div class="titlepage"><div><div><h3 class="title">6.3.1.The standard naming context factory</h3></div></div></div><div class="para">
				The most commonly used factory is the <code class="literal">org.jnp.interfaces.NamingContextFactory</code> implementation. Its properties include:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.initial</strong></span>: The name of the environment property for specifying the initial context factory to use. The value of the property should be the fully qualified class name of the factory class that will create an initial context. If it is not specified, a <code class="literal">javax.naming.NoInitialContextException</code> will be thrown when an <code class="literal">InitialContext</code> object is created.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.provider.url</strong></span>: The name of the environment property for specifying the location of the JBoss JNDI service provider the client will use. The <code class="literal">NamingContextFactory</code> class uses this information to know which JBossNS server to connect to. The value of the property should be a URL string. For JBossNS the URL format is <code class="literal">jnp://host:port/[jndi_path]</code>. The <code class="literal">jnp:</code> portion of the URL is the protocol and refers to the socket/RMI based protocol used by JBoss. The <code class="literal">jndi_path</code> portion of the URL is an optional JNDI name relative to the root context, for example, <code class="literal">apps</code> or <code class="literal">apps/tmp</code>. Everything but the host component is optional. The following examples are equivalent because the default port value is 1099.
					</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
								<code class="literal">jnp://www.jboss.org:1099/</code>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">www.jboss.org:1099</code>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">www.jboss.org</code>
							</div></li></ul></div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.url.pkgs</strong></span>: The name of the environment property for specifying the list of package prefixes to use when loading in URL context factories. The value of the property should be a colon-separated list of package prefixes for the class name of the factory class that will create a URL context factory. For the JBoss JNDI provider this must be <code class="literal">org.jboss.naming:org.jnp.interfaces</code>. This property is essential for locating the <code class="literal">jnp:</code> and <code class="literal">java:</code> URL context factories of the JBoss JNDI provider.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.socketFactory</strong></span>: The fully qualified class name of the <code class="literal">javax.net.SocketFactory</code> implementation to use to create the bootstrap socket. The default value is <code class="literal">org.jnp.interfaces.TimedSocketFactory</code>. The <code class="literal">TimedSocketFactory</code> is a simple <code class="literal">SocketFactory</code> implementation that supports the specification of a connection and read timeout. These two properties are specified by:
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.timeout</strong></span>: The connection timeout in milliseconds. The default value is 0 which means the connection will block until the VM TCP/IP layer times out.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.sotimeout</strong></span>: The connected socket read timeout in milliseconds. The default value is 0 which means reads will block. This is the value passed to the <code class="literal">Socket.setSoTimeout</code> on the newly connected socket.
					</div></li></ul></div><div class="para">
				When a client creates an <code class="literal">InitialContext</code> with these JBossNS properties available, the <code class="literal">org.jnp.interfaces.NamingContextFactory</code> object is used to create the <code class="literal">Context</code> instance that will be used in subsequent operations. The <code class="literal">NamingContextFactory</code> is the JBossNS implementation of the <code class="literal">javax.naming.spi.InitialContextFactory</code> interface. When the <code class="literal">NamingContextFactory</code> class is asked to create a <code class="literal">Context</code>, it creates an <code class="literal">org.jnp.interfaces.NamingContext</code> instance with the <code class="literal">InitialContext</code> environment and name of the context in the global JNDI namespace. It is the <code class="literal">NamingContext</code> instance that actually performs the task of connecting to the JBossNS server, and implements the <code class="literal">Context</code> interface. The <code class="literal">Context.PROVIDER_URL</code> information from the environment indicates from which server to obtain a <code class="literal">NamingServer</code> RMI reference.
			</div><div class="para">
				The association of the <code class="literal">NamingContext</code> instance to a <code class="literal">NamingServer</code> instance is done in a lazy fashion on the first <code class="literal">Context</code> operation that is performed. When a <code class="literal">Context</code> operation is performed and the <code class="literal">NamingContext</code> has no <code class="literal">NamingServer</code> associated with it, it looks to see if its environment properties define a <code class="literal">Context.PROVIDER_URL</code>. A <code class="literal">Context.PROVIDER_URL</code> defines the host and port of the JBossNS server the <code class="literal">Context</code> is to use. If there is a provider URL, the <code class="literal">NamingContext</code> first checks to see if a <code class="literal">Naming</code> instance keyed by the host and port pair has already been created by checking a <code class="literal">NamingContext</code> class static map. It simply uses the existing <code class="literal">Naming</code> instance if one for the host port pair has already been obtained. If no <code class="literal">Naming</code> instance has been created for the given host and port, the <code class="literal">NamingContext</code> connects to the host and port using a <code class="literal">java.net.Socket</code>, and retrieves a <code class="literal">Naming</code> RMI stub from the server by reading a <code class="literal">java.rmi.MarshalledObject</code> from the socket and invoking its get method. The newly obtained Naming instance is cached in the <code class="literal">NamingContext</code> server map under the host and port pair. If no provider URL was specified in the JNDI environment associated with the context, the <code class="literal">NamingContext</code> simply uses the in VM Naming instance set by the <code class="literal">Main</code> MBean.
			</div><div class="para">
				The <code class="literal">NamingContext</code> implementation of the <code class="literal">Context</code> interface delegates all operations to the <code class="literal">Naming</code> instance associated with the <code class="literal">NamingContext</code>. The <code class="literal">NamingServer</code> class that implements the <code class="literal">Naming</code> interface uses a <code class="literal">java.util.Hashtable</code> as the <code class="literal">Context</code> store. There is one unique <code class="literal">NamingServer</code> instance for each distinct JNDI Name for a given JBossNS server. There are zero or more transient <code class="literal">NamingContext</code> instances active at any given moment that refers to a <code class="literal">NamingServer</code> instance. The purpose of the <code class="literal">NamingContext</code> is to act as a <code class="literal">Context</code> to the <code class="literal">Naming</code> interface adaptor that manages translation of the JNDI names passed to the <code class="literal">NamingContext</code> . Because a JNDI name can be relative or a URL, it needs to be converted into an absolute name in the context of the JBossNS server to which it refers. This translation is a key function of the <code class="literal">NamingContext</code>.
			</div></div><div class="section" id="The_Naming_InitialContext_Factories-The_org.jboss.naming.NamingContextFactory"><div class="titlepage"><div><div><h3 class="title">6.3.2.The org.jboss.naming.NamingContextFactory</h3></div></div></div><div class="para">
				This version of the <code class="literal">InitialContextFactory</code> implementation is a simple extension of the jnp version which differs from the jnp version in that it stores the last configuration passed to its <code class="literal">InitialContextFactory.getInitialContext(Hashtable env)</code> method in a public thread local variable. This is used by EJB handles and other JNDI sensitive objects like the <code class="literal">UserTransaction</code> factory to keep track of the JNDI context that was in effect when they were created. If you want this environment to be bound to the object even after its serialized across vm boundaries, then you should the <code class="literal">org.jboss.naming.NamingContextFactory</code>. If you want the environment that is defined in the current VM <code class="literal">jndi.properties</code> or system properties, then you should use the <code class="literal">org.jnp.interfaces.NamingContextFactory</code> version.
			</div></div><div class="section" id="The_Naming_InitialContext_Factories-Naming_Discovery_in_Clustered_Environments"><div class="titlepage"><div><div><h3 class="title">6.3.3.Naming Discovery in Clustered Environments</h3></div></div></div><div class="para">
				When running in a clustered JBoss environment, you can choose not to specify a <code class="literal">Context.PROVIDER_URL</code> value and let the client query the network for available naming services. This only works with JBoss servers running with the <code class="literal">all</code> configuration, or an equivalent configuration that has <code class="literal">org.jboss.ha.framework.server.ClusterPartition</code> and <code class="literal">org.jboss.ha.jndi.HANamingService</code> services deployed. The discovery process consists of sending a multicast request packet to the discovery address/port and waiting for any node to respond. The response is a HA-RMI version of the <code class="literal">Naming</code> interface. The following <code class="literal">InitialContext</code> properties affect the discovery configuration:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.partitionName</strong></span>: The cluster partition name discovery should be restricted to. If you are running in an environment with multiple clusters, you may want to restrict the naming discovery to a particular cluster. There is no default value, meaning that any cluster response will be accepted.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.discoveryGroup</strong></span>: The multicast IP/address to which the discovery query is sent. The default is 230.0.0.4.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.discoveryPort</strong></span>: The port to which the discovery query is sent. The default is 1102.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.discoveryTimeout</strong></span>: The time in milliseconds to wait for a discovery query response. The default value is 5000 (5 seconds).
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jnp.disableDiscovery</strong></span>: A flag indicating if the discovery process should be avoided. Discovery occurs when either no <code class="literal">Context.PROVIDER_URL</code> is specified, or no valid naming service could be located among the URLs specified. If the <code class="literal">jnp.disableDiscovery</code> flag is true, then discovery will not be attempted.
					</div></li></ul></div></div><div class="section" id="The_Naming_InitialContext_Factories-The_HTTP_InitialContext_Factory_Implementation"><div class="titlepage"><div><div><h3 class="title">6.3.4.The HTTP InitialContext Factory Implementation</h3></div></div></div><div class="para">
				The JNDI naming service can be accessed over HTTP. From a JNDI client's perspective this is a transparent change as they continue to use the JNDI <code class="literal">Context</code> interface. Operations through the <code class="literal">Context</code> interface are translated into HTTP posts to a servlet that passes the request to the NamingService using its JMX invoke operation. Advantages of using HTTP as the access protocol include better access through firewalls and proxies setup to allow HTTP, as well as the ability to secure access to the JNDI service using standard servlet role based security.
			</div><div class="para">
				To access JNDI over HTTP you use the <code class="literal">org.jboss.naming.HttpNamingContextFactory</code> as the factory implementation. The complete set of support <code class="literal">InitialContext</code> environment properties for this factory are:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.initial</strong></span>: The name of the environment property for specifying the initial context factory, which must be <code class="literal">org.jboss.naming.HttpNamingContextFactory</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.provider.url</strong></span> (or <code class="literal">Context.PROVIDER_URL</code>): This must be set to the HTTP URL of the JNDI factory. The full HTTP URL would be the public URL of the JBoss servlet container plus <code class="literal">/invoker/JNDIFactory</code>. Examples include:
					</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
								<code class="literal">http://www.jboss.org:8080/invoker/JNDIFactory</code>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">http://www.jboss.org/invoker/JNDIFactory</code>
							</div></li><li class="listitem"><div class="para">
								<code class="literal">https://www.jboss.org/invoker/JNDIFactory</code>
							</div></li></ul></div><div class="para">
						The first example accesses the servlet using the port 8080. The second uses the standard HTTP port 80, and the third uses an SSL encrypted connection to the standard HTTPS port 443.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.url.pkgs</strong></span>: For all JBoss JNDI provider this must be <code class="literal">org.jboss.naming:org.jnp.interfaces</code>. This property is essential for locating the <code class="literal">jnp:</code> and <code class="literal">java:</code> URL context factories of the JBoss JNDI provider.
					</div></li></ul></div><div class="para">
				The JNDI <code class="literal">Context</code> implementation returned by the <code class="literal">HttpNamingContextFactory</code> is a proxy that delegates invocations made on it to a bridge servlet which forwards the invocation to the <code class="literal">NamingService</code> through the JMX bus and marshalls the reply back over HTTP. The proxy needs to know what the URL of the bridge servlet is in order to operate. This value may have been bound on the server side if the JBoss web server has a well known public interface. If the JBoss web server is sitting behind one or more firewalls or proxies, the proxy cannot know what URL is required. In this case, the proxy will be associated with a system property value that must be set in the client VM. For more information on the operation of JNDI over HTTP see <a class="xref" href="#JNDI_over_HTTP-Accessing_JNDI_over_HTTP">Section6.4.1, Accessing JNDI over HTTP</a>.
			</div></div><div class="section" id="The_Naming_InitialContext_Factories-The_Login_InitialContext_Factory_Implementation"><div class="titlepage"><div><div><h3 class="title">6.3.5.The Login InitialContext Factory Implementation</h3></div></div></div><div class="para">
				JAAS is the preferred method for authenticating a remote client to JBoss. However, for simplicity and to ease the migration from other application server environment that do not use JAAS, JBoss allows you the security credentials to be passed through the <code class="literal">InitialContext</code>. JAAS is still used under the covers, but there is no manifest use of the JAAS interfaces in the client application.
			</div><div class="para">
				The factory class that provides this capability is the <code class="literal">org.jboss.security.jndi.LoginInitialContextFactory</code>. The complete set of support <code class="literal">InitialContext</code> environment properties for this factory are:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.initial</strong></span>: The name of the environment property for specifying the initial context factory, which must be <code class="literal">org.jboss.security.jndi.LoginInitialContextFactory</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.provider.url</strong></span>: This must be set to a <code class="literal">NamingContextFactory</code> provider URL. The <code class="literal">LoginIntialContext</code> is really just a wrapper around the <code class="literal">NamingContextFactory</code> that adds a JAAS login to the existing <code class="literal">NamingContextFactory</code> behavior.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.factory.url.pkgs</strong></span>: For all JBoss JNDI provider this must be <code class="literal">org.jboss.naming:org.jnp.interfaces</code>. This property is essential for locating the <code class="literal">jnp:</code> and <code class="literal">java:</code> URL context factories of the JBoss JNDI provider.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.security.principal</strong></span> (or <code class="literal">Context.SECURITY_PRINCIPAL</code>): The principal to authenticate. This may be either a <code class="literal">java.security.Principal</code> implementation or a string representing the name of a principal.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.security.credentials</strong></span> (or <code class="literal">Context.SECURITY_CREDENTIALS</code>), The credentials that should be used to authenticate the principal, e.g., password, session key, etc.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>java.naming.security.protocol</strong></span>: (<code class="literal">Context.SECURITY_PROTOCOL</code>) This gives the name of the JAAS login module to use for the authentication of the principal and credentials.
					</div></li></ul></div></div><div class="section" id="The_Naming_InitialContext_Factories-The_ORBInitialContextFactory"><div class="titlepage"><div><div><h3 class="title">6.3.6.The ORBInitialContextFactory</h3></div></div></div><div class="para">
				When using Sun's CosNaming it is necessary to use a different naming context factory from the default. CosNaming looks for the ORB in JNDI instead of using the the ORB configured in <code class="literal">deploy/iiop-service.xml?</code>. It is necessary to set the global context factory to <code class="literal">org.jboss.iiop.naming.ORBInitialContextFactory</code>, which sets the ORB to JBoss's ORB. This is done in the <code class="literal">conf/jndi.properties</code> file:
			</div><pre class="programlisting">
# DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING
#
java.naming.factory.initial=org.jboss.iiop.naming.ORBInitialContextFactory
java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces

</pre><div class="para">
				It is also necessary to use <code class="literal">ORBInitialContextFactory</code> when using CosNaming in an application client.
			</div></div></div><div class="section" id="Naming_on_JBoss-JNDI_over_HTTP"><div class="titlepage"><div><div><h2 class="title">6.4.JNDI over HTTP</h2></div></div></div><div class="para">
			In addition to the legacy RMI/JRMP with a socket bootstrap protocol, JBoss provides support for accessing its JNDI naming service over HTTP.
		</div><div class="section" id="JNDI_over_HTTP-Accessing_JNDI_over_HTTP"><div class="titlepage"><div><div><h3 class="title">6.4.1.Accessing JNDI over HTTP</h3></div></div></div><div class="para">
				This capability is provided by <code class="literal">http-invoker.sar</code>. The structure of the <code class="literal">http-invoker.sar</code> is:
			</div><pre class="programlisting"><span class="bold bold"><strong>http-invoker.sar</strong></span>
+- META-INF/jboss-service.xml
+- invoker.war
| +- WEB-INF/jboss-web.xml
| +- WEB-INF/classes/org/jboss/invocation/http/servlet/InvokerServlet.class
| +- WEB-INF/classes/org/jboss/invocation/http/servlet/NamingFactoryServlet.class
| +- WEB-INF/classes/org/jboss/invocation/http/servlet/ReadOnlyAccessFilter.class
| +- WEB-INF/classes/roles.properties
| +- WEB-INF/classes/users.properties
| +- WEB-INF/web.xml
| +- META-INF/MANIFEST.MF
+- META-INF/MANIFEST.MF
</pre><div class="para">
				The <code class="literal">jboss-service.xml</code> descriptor defines the <code class="literal">HttpInvoker</code> and <code class="literal">HttpInvokerHA</code> MBeans. These services handle the routing of methods invocations that are sent via HTTP to the appropriate target MBean on the JMX bus.
			</div><div class="para">
				The <code class="literal">http-invoker.war</code> web application contains servlets that handle the details of the HTTP transport. The <code class="literal">NamingFactoryServlet</code> handles creation requests for the JBoss JNDI naming service <code class="literal">javax.naming.Context</code> implementation. The <code class="literal">InvokerServlet</code> handles invocations made by RMI/HTTP clients. The <code class="literal">ReadOnlyAccessFilter</code> allows one to secure the JNDI naming service while making a single JNDI context available for read-only access by unauthenticated clients.
			</div><div class="figure" id="Accessing_JNDI_over_HTTP-The_HTTP_invoker_proxyserver_structure_for_a_JNDI_Context"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/db1a9822d3e49db93c60213a49436792/Chap3-9.jpg" align="middle" width="444" alt="The HTTP invoker proxy/server structure for a JNDI Context" /></div></div><p class="title"><strong>Figure6.2.The HTTP invoker proxy/server structure for a JNDI Context</strong></p></div><div class="para">
				Before looking at the configurations let's look at the operation of the <code class="literal">http-invoker</code> services. <a class="xref" href="#Accessing_JNDI_over_HTTP-The_HTTP_invoker_proxyserver_structure_for_a_JNDI_Context">Figure6.2, The HTTP invoker proxy/server structure for a JNDI Context</a> shows a logical view of the structure of a JBoss JNDI proxy and its relationship to the JBoss server side components of the <code class="literal">http-invoker</code>. The proxy is obtained from the <code class="literal">NamingFactoryServlet</code> using an <code class="literal">InitialContext</code> with the <code class="literal">Context.INITIAL_CONTEXT_FACTORY</code> property set to <code class="literal">org.jboss.naming.HttpNamingContextFactory</code>, and the <code class="literal">Context.PROVIDER_URL</code> property set to the HTTP URL of the <code class="literal">NamingFactoryServlet</code>. The resulting proxy is embedded in an <code class="literal">org.jnp.interfaces.NamingContext</code> instance that provides the <code class="literal">Context</code> interface implementation.
			</div><div class="para">
				The proxy is an instance of <code class="literal">org.jboss.invocation.http.interfaces.HttpInvokerProxy</code>, and implements the <code class="literal">org.jnp.interfaces.Naming</code> interface. Internally the <code class="literal">HttpInvokerProxy</code> contains an invoker that marshalls the <code class="literal">Naming</code> interface method invocations to the <code class="literal">InvokerServlet</code> via HTTP posts. The <code class="literal">InvokerServlet</code> translates these posts into JMX invocations to the <code class="literal">NamingService</code>, and returns the invocation response back to the proxy in the HTTP post response.
			</div><div class="para">
				There are several configuration values that need to be set to tie all of these components together and <a class="xref" href="#Accessing_JNDI_over_HTTP-The_relationship_between_configuration_files_and_JNDIHTTP_component">Figure6.3, The relationship between configuration files and JNDI/HTTP component</a> illustrates the relationship between configuration files and the corresponding components.
			</div><div class="figure" id="Accessing_JNDI_over_HTTP-The_relationship_between_configuration_files_and_JNDIHTTP_component"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/292077854ade34e62e16663f84a6123b/Chap3-10.jpg" align="middle" alt="The relationship between configuration files and JNDI/HTTP component" /></div></div><p class="title"><strong>Figure6.3.The relationship between configuration files and JNDI/HTTP component</strong></p></div><div class="para">
				The <code class="literal">http-invoker.sar/META-INF/jboss-service.xml</code> descriptor defines the <code class="literal">HttpProxyFactory</code> that creates the <code class="literal">HttpInvokerProxy</code> for the <code class="literal">NamingService</code>. The attributes that need to be configured for the <code class="literal">HttpProxyFactory</code> include:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>InvokerName</strong></span>: The JMX <code class="literal">ObjectName</code> of the <code class="literal">NamingService</code> defined in the <code class="literal">conf/jboss-service.xml</code> descriptor. The standard setting used in the JBoss distributions is <code class="literal">jboss:service=Naming</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>InvokerURL</strong></span> or <span class="bold bold"><strong>InvokerURLPrefix</strong></span> + InvokerURLSuffix + <span class="bold bold"><strong>UseHostName</strong></span>. You can specify the full HTTP URL to the <code class="literal">InvokerServlet</code> using the <code class="literal">InvokerURL</code> attribute, or you can specify the hostname independent parts of the URL and have the <code class="literal">HttpProxyFactory</code> fill them in. An example <code class="literal">InvokerURL</code> value would be <code class="literal">http://jbosshost1.dot.com:8080/invoker/JMXInvokerServlet</code>. This can be broken down into: 
						<div class="itemizedlist"><ul><li class="listitem"><div class="para">
									<span class="bold bold"><strong>InvokerURLPrefix</strong></span>: the URL prefix prior to the hostname. Typically this will be <code class="literal">http://</code> or <code class="literal">https://</code> if SSL is to be used.
								</div></li><li class="listitem"><div class="para">
									<span class="bold bold"><strong>InvokerURLSuffix</strong></span>: the URL suffix after the hostname. This will include the port number of the web server as well as the deployed path to the <code class="literal">InvokerServlet</code>. For the example <code class="literal">InvokerURL</code> value the <code class="literal">InvokerURLSuffix</code> would be <code class="literal">:8080/invoker/JMXInvokerServlet</code> without the quotes. The port number is determined by the web container service settings. The path to the <code class="literal">InvokerServlet</code> is specified in the <code class="literal">http-invoker.sar/invoker.war/WEB-INF/web.xml</code> descriptor.
								</div></li><li class="listitem"><div class="para">
									<span class="bold bold"><strong>UseHostName</strong></span>: a flag indicating if the hostname should be used in place of the host IP address when building the hostname portion of the full <code class="literal">InvokerURL</code>. If true, <code class="methodname">InetAddress.getLocalHost().getHostName</code> method will be used. Otherwise, the <code class="methodname">InetAddress.getLocalHost().getHostAddress()</code> method is used.
								</div></li></ul></div>

					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>ExportedInterface</strong></span>: The <code class="literal">org.jnp.interfaces.Naming</code> interface the proxy will expose to clients. The actual client of this proxy is the JBoss JNDI implementation <code class="literal">NamingContext</code> class, which JNDI client obtain from <code class="literal">InitialContext</code> lookups when using the JBoss JNDI provider.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>JndiName</strong></span>: The name in JNDI under which the proxy is bound. This needs to be set to a blank/empty string to indicate the interface should not be bound into JNDI. We can't use the JNDI to bootstrap itself. This is the role of the <code class="literal">NamingFactoryServlet</code>.
					</div></li></ul></div><div class="para">
				The <code class="literal">http-invoker.sar/invoker.war/WEB-INF/web.xml</code> descriptor defines the mappings of the <code class="literal">NamingFactoryServlet</code> and <code class="literal">InvokerServlet</code> along with their initialization parameters. The configuration of the <code class="literal">NamingFactoryServlet</code> relevant to JNDI/HTTP is the <code class="literal">JNDIFactory</code> entry which defines:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						A <code class="literal">namingProxyMBean</code> initialization parameter that maps to the <code class="literal">HttpProxyFactory</code> MBean name. This is used by the <code class="literal">NamingFactoryServlet</code> to obtain the <code class="literal">Naming</code> proxy which it will return in response to HTTP posts. For the default <code class="literal">http-invoker.sar/META-INF/jboss-service.xml</code> settings the name <code class="literal">jboss:service=invoker,type=http,target=Naming</code>.
					</div></li><li class="listitem"><div class="para">
						A proxy initialization parameter that defines the name of the <code class="literal">namingProxyMBean</code> attribute to query for the Naming proxy value. This defaults to an attribute name of <code class="literal">Proxy</code>.
					</div></li><li class="listitem"><div class="para">
						The servlet mapping for the <code class="literal">JNDIFactory</code> configuration. The default setting for the unsecured mapping is <code class="literal">/JNDIFactory/*</code>. This is relative to the context root of the <code class="literal">http-invoker.sar/invoker.war</code>, which by default is the WAR name minus the <code class="literal">.war</code> suffix.
					</div></li></ul></div><div class="para">
				The configuration of the <code class="literal">InvokerServlet</code> relevant to JNDI/HTTP is the <code class="literal">JMXInvokerServlet</code> which defines:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The servlet mapping of the <code class="literal">InvokerServlet</code>. The default setting for the unsecured mapping is <code class="literal">/JMXInvokerServlet/*</code>. This is relative to the context root of the <code class="literal">http-invoker.sar/invoker.war</code>, which by default is the WAR name minus the <code class="literal">.war</code> suffix.
					</div></li></ul></div></div><div class="section" id="JNDI_over_HTTP-Accessing_JNDI_over_HTTPS"><div class="titlepage"><div><div><h3 class="title">6.4.2.Accessing JNDI over HTTPS</h3></div></div></div><div class="para">
				To be able to access JNDI over HTTP/SSL you need to enable an SSL connector on the web container. The details of this are covered in the Integrating Servlet Containers for Tomcat. We will demonstrate the use of HTTPS with a simple example client that uses an HTTPS URL as the JNDI provider URL. We will provide an SSL connector configuration for the example, so unless you are interested in the details of the SSL connector setup, the example is self contained.
			</div><div class="para">
				We also provide a configuration of the <code class="literal">HttpProxyFactory</code> setup to use an HTTPS URL. The following example shows the section of the <code class="literal">http-invoker.sar</code><code class="literal">jboss-service.xml</code> descriptor that the example installs to provide this configuration. All that has changed relative to the standard HTTP configuration are the <code class="literal">InvokerURLPrefix</code> and <code class="literal">InvokerURLSuffix</code> attributes, which setup an HTTPS URL using the 8443 port.
			</div><pre class="programlisting">&lt;!-- Expose the Naming service interface via HTTPS --&gt;
&lt;mbean code="org.jboss.invocation.http.server.HttpProxyFactory" 
       name="jboss:service=invoker,type=https,target=Naming"&gt;
    &lt;!-- The Naming service we are proxying --&gt;
    &lt;attribute name="InvokerName"&gt;jboss:service=Naming&lt;/attribute&gt;
    &lt;!-- Compose the invoker URL from the cluster node address --&gt;
    &lt;attribute name="InvokerURLPrefix"&gt;https://&lt;/attribute&gt;
    &lt;attribute name="InvokerURLSuffix"&gt;:8443/invoker/JMXInvokerServlet 
&lt;/attribute&gt;
    &lt;attribute name="UseHostName"&gt;true&lt;/attribute&gt;
    &lt;attribute name="ExportedInterface"&gt;org.jnp.interfaces.Naming 
&lt;/attribute&gt;
    &lt;attribute name="JndiName"/&gt;
    &lt;attribute name="ClientInterceptors"&gt;
        &lt;interceptors&gt;
            &lt;interceptor&gt;org.jboss.proxy.ClientMethodInterceptor 
&lt;/interceptor&gt;
            &lt;interceptor&gt;org.jboss.proxy.SecurityInterceptor
&lt;/interceptor&gt;
            &lt;interceptor&gt;org.jboss.naming.interceptors.ExceptionInterceptor 
&lt;/interceptor&gt;
            &lt;interceptor&gt;org.jboss.invocation.InvokerInterceptor 
&lt;/interceptor&gt;
        &lt;/interceptors&gt;
    &lt;/attribute&gt;
&lt;/mbean&gt;
</pre><div class="para">
				At a minimum, a JNDI client using HTTPS requires setting up a HTTPS URL protocol handler. We will be using the Java Secure Socket Extension (JSSE) for HTTPS. The JSSE documentation does a good job of describing what is necessary to use HTTPS, and the following steps were needed to configure the example client shown in <a class="xref" href="#Accessing_JNDI_over_HTTPS-A_JNDI_client_that_uses_HTTPS_as_the_transport">Example6.2, A JNDI client that uses HTTPS as the transport</a>:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						A protocol handler for HTTPS URLs must be made available to Java. The JSSE release includes an HTTPS handler in the <code class="literal">com.sun.net.ssl.internal.www.protocol</code> package. To enable the use of HTTPS URLs you include this package in the standard URL protocol handler search property, <code class="literal">java.protocol.handler.pkgs</code>. We set the <code class="literal">java.protocol.handler.pkgs</code> property in the Ant script.
					</div></li><li class="listitem"><div class="para">
						The JSSE security provider must be installed in order for SSL to work. This can be done either by installing the JSSE jars as an extension package, or programatically. We use the programatic approach in the example since this is less intrusive. Line 18 of the <code class="literal">ExClient</code> code demonstrates how this is done.
					</div></li><li class="listitem"><div class="para">
						The JNDI provider URL must use HTTPS as the protocol. Lines 24-25 of the <code class="literal">ExClient</code> code specify an HTTP/SSL connection to the localhost on port 8443. The hostname and port are defined by the web container SSL connector.
					</div></li><li class="listitem"><div class="para">
						The validation of the HTTPS URL hostname against the server certificate must be disabled. By default, the JSSE HTTPS protocol handler employs a strict validation of the hostname portion of the HTTPS URL against the common name of the server certificate. This is the same check done by web browsers when you connect to secured web site. We are using a self-signed server certificate that uses a common name of "<code class="literal">Chapter 8 SSL Example</code>" rather than a particular hostname, and this is likely to be common in development environments or intranets. The JBoss <code class="literal">HttpInvokerProxy</code> will override the default hostname checking if a <code class="literal">org.jboss.security.ignoreHttpsHost</code> system property exists and has a value of true. We set the <code class="literal">org.jboss.security.ignoreHttpsHost</code> property to true in the Ant script.
					</div></li></ul></div><div class="example" id="Accessing_JNDI_over_HTTPS-A_JNDI_client_that_uses_HTTPS_as_the_transport"><p class="title"><strong>Example6.2.A JNDI client that uses HTTPS as the transport</strong></p><div class="example-contents"><pre class="programlisting">package org.jboss.chap3.ex1;

import java.security.Security;
import java.util.Properties;
import javax.naming.Context;
import javax.naming.InitialContext;
                    
public class ExClient
{
    public static void main(String args[]) throws Exception
    {
        Properties env = new Properties();
        env.setProperty(Context.INITIAL_CONTEXT_FACTORY,
                        "org.jboss.naming.HttpNamingContextFactory");
        env.setProperty(Context.PROVIDER_URL,
                        "https://localhost:8443/invoker/JNDIFactorySSL");

        Context ctx = new InitialContext(env);
        System.out.println("Created InitialContext, env=" + env);

        Object data = ctx.lookup("jmx/invoker/RMIAdaptor");
        System.out.println("lookup(jmx/invoker/RMIAdaptor): " + data);
    }
}
</pre></div></div><div class="para">
				To test the client, first build the chapter 3 example to create the <code class="literal">chap3</code> configuration fileset.
			</div><pre class="programlisting">[examples]$ ant -Dchap=naming config</pre><div class="para">
				Next, start the JBoss server using the <code class="literal">naming</code> configuration fileset:
			</div><pre class="programlisting">[bin]$ sh run.sh -c naming</pre><div class="para">
				And finally, run the <code class="literal">ExClient</code> using:
			</div><pre class="programlisting">[examples]$ ant -Dchap=naming -Dex=1 run-example
...
run-example1:

[java] Created InitialContext, env={java.naming. \ 
provider.url=https://localhost:8443/invoker/JNDIFactorySSL, java.naming. \
factory.initial=org.jboss.naming.HttpNamingContextFactory}
     [java] lookup(jmx/invoker/RMIAdaptor): org.jboss.invocation.jrmp. \
     interfaces.JRMPInvokerP
roxy@cac3fa
</pre></div><div class="section" id="JNDI_over_HTTP-Securing_Access_to_JNDI_over_HTTP"><div class="titlepage"><div><div><h3 class="title">6.4.3.Securing Access to JNDI over HTTP</h3></div></div></div><div class="para">
				One benefit to accessing JNDI over HTTP is that it is easy to secure access to the JNDI <code class="literal">InitialContext</code> factory as well as the naming operations using standard web declarative security. This is possible because the server side handling of the JNDI/HTTP transport is implemented with two servlets. These servlets are included in the <code class="literal">http-invoker.sar/invoker.war</code> directory found in the <code class="literal">default</code> and <code class="literal">all</code> configuration deploy directories as shown previously. To enable secured access to JNDI you need to edit the <code class="literal">invoker.war/WEB-INF/web.xml</code> descriptor and remove all unsecured servlet mappings. For example, the <code class="literal">web.xml</code> descriptor shown in <a class="xref" href="#Securing_Access_to_JNDI_over_HTTP-An_example_web.xml_descriptor_for_secured_access_to_the_JNDI_servlets">Example6.3, An example web.xml descriptor for secured access to the JNDI servlets</a> only allows access to the <code class="literal">invoker.war</code> servlets if the user has been authenticated and has a role of <code class="literal">HttpInvoker</code>.
			</div><div class="example" id="Securing_Access_to_JNDI_over_HTTP-An_example_web.xml_descriptor_for_secured_access_to_the_JNDI_servlets"><p class="title"><strong>Example6.3.An example web.xml descriptor for secured access to the JNDI servlets</strong></p><div class="example-contents"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE web-app PUBLIC
          "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
          "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;
&lt;web-app&gt;
    &lt;!-- ### Servlets --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;JMXInvokerServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.invocation.http.servlet.InvokerServlet
        &lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;  &lt;servlet&gt;
        &lt;servlet-name&gt;JNDIFactory&lt;/servlet-name&gt;
        &lt;servlet-class&gt;
            org.jboss.invocation.http.servlet.NamingFactoryServlet
        &lt;/servlet-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;namingProxyMBean&lt;/param-name&gt;
            &lt;param-value&gt;jboss:service=invoker,type=http,target=Naming&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;proxyAttribute&lt;/param-name&gt;
            &lt;param-value&gt;Proxy&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
    &lt;/servlet&gt; 
    &lt;!-- ### Servlet Mappings --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;JNDIFactory&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/restricted/JNDIFactory/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;JMXInvokerServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/restricted/JMXInvokerServlet/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;  &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;HttpInvokers&lt;/web-resource-name&gt;
            &lt;description&gt;An example security config that only allows users with
                the role HttpInvoker to access the HTTP invoker servlets &lt;/description&gt;
            &lt;url-pattern&gt;/restricted/*&lt;/url-pattern&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;HttpInvoker&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;
    &lt;login-config&gt;
        &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
        &lt;realm-name&gt;JBoss HTTP Invoker&lt;/realm-name&gt;
    &lt;/login-config&gt;  &lt;security-role&gt;
        &lt;role-name&gt;HttpInvoker&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/web-app&gt;
</pre></div></div><div class="para">
				The <code class="literal">web.xml</code> descriptor only defines which sevlets are secured, and which roles are allowed to access the secured servlets. You must additionally define the security domain that will handle the authentication and authorization for the war. This is done through the <code class="literal">jboss-web.xml</code> descriptor, and an example that uses the <code class="literal">http-invoker</code> security domain is given below.
			</div><pre class="programlisting">&lt;jboss-web&gt;
    &lt;security-domain&gt;java:/jaas/http-invoker&lt;/security-domain&gt;
&lt;/jboss-web&gt;
</pre><div class="para">
				The <code class="literal">security-domain</code> element defines the name of the security domain that will be used for the JAAS login module configuration used for authentication and authorization. 
			</div></div><div class="section" id="JNDI_over_HTTP-Securing_Access_to_JNDI_with_a_Read_Only_Unsecured_Context"><div class="titlepage"><div><div><h3 class="title">6.4.4.Securing Access to JNDI with a Read-Only Unsecured Context</h3></div></div></div><div class="para">
				Another feature available for the JNDI/HTTP naming service is the ability to define a context that can be accessed by unauthenticated users in read-only mode. This can be important for services used by the authentication layer. For example, the <code class="literal">SRPLoginModule</code> needs to lookup the SRP server interface used to perform authentication. The rest of this section explains how read-only works in JBoss Enterprise Application Platform.
			</div><div class="para">
				First, the <code class="literal">ReadOnlyJNDIFactory</code> is declared in <code class="literal">invoker.sar/WEB-INF/web.xml</code>. It will be mapped to <code class="literal">/invoker/ReadOnlyJNDIFactory</code>.
			</div><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;ReadOnlyJNDIFactory&lt;/servlet-name&gt;
    &lt;description&gt;A servlet that exposes the JBoss JNDI Naming service stub
          through http, but only for a single read-only context. The return content 
          is serialized MarshalledValue containing the org.jnp.interfaces.Naming 
          stub.
    &lt;/description&gt;
    &lt;servlet-class&gt;org.jboss.invocation.http.servlet.NamingFactoryServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;namingProxyMBean&lt;/param-name&gt;
        &lt;param-value&gt;<span class="bold bold"><strong>jboss:service=invoker,type=http,target=Naming,readonly=true</strong></span>&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;proxyAttribute&lt;/param-name&gt;
        &lt;param-value&gt;Proxy&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;!-- ... --&gt;
                        
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ReadOnlyJNDIFactory&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/ReadOnlyJNDIFactory/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</pre><div class="para">
				The factory only provides a JNDI stub which needs to be connected to an invoker. Here the invoker is <code class="literal">jboss:service=invoker,type=http,target=Naming,readonly=true</code>. This invoker is declared in the <code class="filename">http-invoker.sar/META-INF/jboss-service.xml</code> file.
			</div><pre class="programlisting">   &lt;mbean code="org.jboss.invocation.http.server.HttpProxyFactory"
      name="jboss:service=invoker,type=http,target=Naming,readonly=true"&gt;
      &lt;attribute name="InvokerName"&gt;jboss:service=Naming&lt;/attribute&gt;
      &lt;attribute name="InvokerURLPrefix"&gt;http://&lt;/attribute&gt;
      &lt;attribute name="InvokerURLSuffix"&gt;:8080<span class="bold bold"><strong>/invoker/readonly/JMXInvokerServlet</strong></span>&lt;/attribute&gt;
      &lt;attribute name="UseHostName"&gt;true&lt;/attribute&gt;
      &lt;attribute name="ExportedInterface"&gt;org.jnp.interfaces.Naming&lt;/attribute&gt;
      &lt;attribute name="JndiName"&gt;&lt;/attribute&gt;
      &lt;attribute name="ClientInterceptors"&gt;
          &lt;interceptors&gt;
             &lt;interceptor&gt;org.jboss.proxy.ClientMethodInterceptor&lt;/interceptor&gt;
             &lt;interceptor&gt;org.jboss.proxy.SecurityInterceptor&lt;/interceptor&gt;
             &lt;interceptor&gt;org.jboss.naming.interceptors.ExceptionInterceptor&lt;/interceptor&gt;
             &lt;interceptor&gt;org.jboss.invocation.InvokerInterceptor&lt;/interceptor&gt;
          &lt;/interceptors&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;
</pre><div class="para">
				The proxy on the client side needs to talk back to a specific invoker servlet on the server side. The configuration here has the actual invocations going to <code class="literal">/invoker/readonly/JMXInvokerServlet</code>. This is actually the standard <code class="literal">JMXInvokerServlet</code> with a read-only filter attached.
			</div><pre class="programlisting">    &lt;filter&gt;
        &lt;filter-name&gt;ReadOnlyAccessFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.jboss.invocation.http.servlet.ReadOnlyAccessFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;readOnlyContext&lt;/param-name&gt;
            &lt;param-value&gt;<span class="bold bold"><strong>readonly</strong></span>&lt;/param-value&gt;
            &lt;description&gt;The top level JNDI context the filter will enforce
                read-only access on. If specified only Context.lookup operations
                will be allowed on this context. Another other operations or
                lookups on any other context will fail. Do not associate this
                filter with the JMXInvokerServlets if you want unrestricted
                access. &lt;/description&gt;
        &lt;/init-param&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;invokerName&lt;/param-name&gt;
            &lt;param-value&gt;jboss:service=Naming&lt;/param-value&gt;
            &lt;description&gt;The JMX ObjectName of the naming service mbean &lt;/description&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;ReadOnlyAccessFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/readonly/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;

    &lt;!-- ... --&gt;
    &lt;!-- A mapping for the JMXInvokerServlet that only allows invocations 
            of lookups under a read-only context. This is enforced by the
            ReadOnlyAccessFilter 
            --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;JMXInvokerServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/readonly/JMXInvokerServlet/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</pre><div class="para">
				The <code class="literal">readOnlyContext</code> parameter is set to <code class="literal">readonly</code> which means that when you access JBoss through the <code class="literal">ReadOnlyJNDIFactory</code>, you will only be able to access data in the <code class="literal">readonly</code> context. Here is a code fragment that illustrates the usage:
			</div><pre class="programlisting">Properties env = new Properties();
env.setProperty(Context.INITIAL_CONTEXT_FACTORY, 
                "org.jboss.naming.HttpNamingContextFactory");
env.setProperty(Context.PROVIDER_URL, 
                "http://localhost:8080/invoker/ReadOnlyJNDIFactory");

Context ctx2 = new InitialContext(env);
Object data = ctx2.lookup("readonly/data");
</pre><div class="para">
				Attempts to look up any objects outside of the readonly context will fail. Note that JBoss doesn't ship with any data in the <code class="literal">readonly</code> context, so the readonly context won't be bound usable unless you create it.
			</div></div></div><div class="section" id="Naming_on_JBoss-Additional_Naming_MBeans"><div class="titlepage"><div><div><h2 class="title">6.5.Additional Naming MBeans</h2></div></div></div><div class="para">
			In addition to the <code class="literal">NamingService</code> MBean that configures an embedded JBossNS server within JBoss, there are several additional MBean services related to naming that ship with JBoss. They are <code class="literal">JndiBindingServiceMgr</code>, <code class="literal">NamingAlias</code>, <code class="literal">ExternalContext</code>, and <code class="literal">JNDIView</code>.
		</div><div class="section" id="Additional_Naming_MBeans-JNDI_Binding_Manager"><div class="titlepage"><div><div><h3 class="title">6.5.1.JNDI Binding Manager</h3></div></div></div><div class="para">
				The JNDI binding manager service allows you to quickly bind objects into JNDI for use by application code. The MBean class for the binding service is <code class="literal">org.jboss.naming.JNDIBindingServiceMgr</code>. It has a single attribute, <code class="literal">BindingsConfig</code>, which accepts an XML document that conforms to the <code class="literal">jndi-binding-service_1_0.xsd</code> schema. The content of the <code class="literal">BindingsConfig</code> attribute is unmarshalled using the JBossXB framework. The following is an MBean definition that shows the most basic form usage of the JNDI binding manager service.
			</div><pre class="programlisting">&lt;mbean code="org.jboss.naming.JNDIBindingServiceMgr" 
       name="jboss.tests:name=example1"&gt;
    &lt;attribute name="BindingsConfig" serialDataType="jbxb"&gt;
        &lt;jndi:bindings xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" 
                       xmlns:jndi="urn:jboss:jndi-binding-service:1.0"
                       xs:schemaLocation="urn:jboss:jndi-binding-service  \
		       resource:jndi-binding-service_1_0.xsd"&gt; 
            &lt;jndi:binding name="bindexample/message"&gt;
                &lt;jndi:value trim="true"&gt;
                    Hello, JNDI!
                &lt;/jndi:value&gt;
            &lt;/jndi:binding&gt;
        &lt;/jndi:bindings&gt;
    &lt;/attribute&gt;
&lt;/mbean&gt;
</pre><div class="para">
				This binds the text string "<code class="literal">Hello, JNDI!</code>" under the JNDI name <code class="literal">bindexample/message</code>. An application would look up the value just as it would for any other JNDI value. The <code class="literal">trim</code> attribute specifies that leading and trailing whitespace should be ignored. The use of the attribute here is purely for illustrative purposes as the default value is true.
			</div><pre class="programlisting">InitialContext ctx  = new InitialContext();
String         text = (String) ctx.lookup("bindexample/message");
</pre><div class="para">
				String values themselves are not that interesting. If a JavaBeans property editor is available, the desired class name can be specified using the <code class="literal">type</code> attribute
			</div><pre class="programlisting">&lt;jndi:binding name="urls/jboss-home"&gt;
    &lt;jndi:value type="java.net.URL"&gt;http://www.jboss.org&lt;/jndi:value&gt;
&lt;/jndi:binding&gt;
</pre><div class="para">
				The <code class="literal">editor</code> attribute can be used to specify a particular property editor to use.
			</div><pre class="programlisting">&lt;jndi:binding name="hosts/localhost"&gt;
    &lt;jndi:value editor="org.jboss.util.propertyeditor.InetAddressEditor"&gt; 
        127.0.0.1 
    &lt;/jndi:value&gt;
&lt;/jndi:binding&gt;
</pre><div class="para">
				For more complicated structures, any JBossXB-ready schema may be used. The following example shows how a <code class="literal">java.util.Properties</code> object would be mapped.
			</div><pre class="programlisting">&lt;jndi:binding name="maps/testProps"&gt;
    &lt;java:properties xmlns:java="urn:jboss:java-properties" 
                     xmlns:xs="http://www.w3.org/2001/XMLSchema-instance"
                     xs:schemaLocation="urn:jboss:java-properties \
		     resource:java-properties_1_0.xsd"&gt;
        &lt;java:property&gt;
            &lt;java:key&gt;key1&lt;/java:key&gt;
            &lt;java:value&gt;value1&lt;/java:value&gt;
        &lt;/java:property&gt;
        &lt;java:property&gt;
            &lt;java:key&gt;key2&lt;/java:key&gt;
            &lt;java:value&gt;value2&lt;/java:value&gt;
        &lt;/java:property&gt;
    &lt;/java:properties&gt;
&lt;/jndi:binding&gt;
</pre></div><div class="section" id="Additional_Naming_MBeans-The_org.jboss.naming.NamingAlias_MBean"><div class="titlepage"><div><div><h3 class="title">6.5.2.The org.jboss.naming.NamingAlias MBean</h3></div></div></div><div class="para">
				The <code class="literal">NamingAlias</code> MBean is a simple utility service that allows you to create an alias in the form of a JNDI <code class="literal">javax.naming.LinkRef</code> from one JNDI name to another. This is similar to a symbolic link in the Unix file system. To an alias you add a configuration of the <code class="literal">NamingAlias</code> MBean to the <code class="literal">jboss-service.xml</code> configuration file. The configurable attributes of the <code class="literal">NamingAlias</code> service are as follows:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>FromName</strong></span>: The location where the <code class="literal">LinkRef</code> is bound under JNDI.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>ToName</strong></span>: The to name of the alias. This is the target name to which the <code class="literal">LinkRef</code> refers. The name is a URL, or a name to be resolved relative to the <code class="literal">InitialContext</code>, or if the first character of the name is a dot (<code class="literal">.</code>), the name is relative to the context in which the link is bound.
					</div></li></ul></div><div class="para">
				The following example provides a mapping of the JNDI name <code class="literal">QueueConnectionFactory</code> to the name <code class="literal">ConnectionFactory</code>.
			</div><pre class="programlisting">&lt;mbean code="org.jboss.naming.NamingAlias" 
       name="jboss.mq:service=NamingAlias,fromName=QueueConnectionFactory"&gt;
    &lt;attribute name="ToName"&gt;ConnectionFactory&lt;/attribute&gt;
    &lt;attribute name="FromName"&gt;QueueConnectionFactory&lt;/attribute&gt;
&lt;/mbean&gt;
</pre></div><div class="section" id="Additional_Naming_MBeans-org.jboss.naming.ExternalContext_MBean"><div class="titlepage"><div><div><h3 class="title">6.5.3.org.jboss.naming.ExternalContext MBean</h3></div></div></div><div class="para">
				The <code class="literal">ExternalContext</code> MBean allows you to federate external JNDI contexts into the JBoss server JNDI namespace. The term external refers to any naming service external to the JBossNS naming service running inside of the JBoss server VM. You can incorporate LDAP servers, file systems, DNS servers, and so on, even if the JNDI provider root context is not serializable. The federation can be made available to remote clients if the naming service supports remote access.
			</div><div class="para">
				To incorporate an external JNDI naming service, you have to add a configuration of the <code class="literal">ExternalContext</code> MBean service to the <code class="literal">jboss-service.xml</code> configuration file. The configurable attributes of the <code class="literal">ExternalContext</code> service are as follows:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>JndiName</strong></span>: The JNDI name under which the external context is to be bound.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>RemoteAccess</strong></span>: A boolean flag indicating if the external <code class="literal">InitialContext</code> should be bound using a <code class="literal">Serializable</code> form that allows a remote client to create the external <code class="literal">InitialContext</code> . When a remote client looks up the external context via the JBoss JNDI <code class="literal">InitialContext</code>, they effectively create an instance of the external <code class="literal">InitialContext</code> using the same env properties passed to the <code class="literal">ExternalContext</code> MBean. This will only work if the client can do a <code class="literal">new InitialContext(env)</code> remotely. This requires that the <code class="literal">Context.PROVIDER_URL</code> value of env is resolvable in the remote VM that is accessing the context. This should work for the LDAP example. For the file system example this most likely won't work unless the file system path refers to a common network path. If this property is not given it defaults to false.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>CacheContext</strong></span>: The <code class="literal">cacheContext</code> flag. When set to true, the external <code class="literal">Context</code> is only created when the MBean is started and then stored as an in memory object until the MBean is stopped. If cacheContext is set to false, the external <code class="literal">Context</code> is created on each lookup using the MBean properties and InitialContext class. When the uncached <code class="literal">Context</code> is looked up by a client, the client should invoke <code class="literal">close()</code> on the Context to prevent resource leaks.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>InitialContext</strong></span>: The fully qualified class name of the <code class="literal">InitialContext</code> implementation to use. Must be one of: <code class="literal">javax.naming.InitialContext</code>, <code class="literal">javax.naming.directory.InitialDirContext</code> or <code class="literal">javax.naming.ldap.InitialLdapContext</code>. In the case of the <code class="literal">InitialLdapContext</code> a null <code class="literal">Controls</code> array is used. The default is <code class="literal">javax.naming.InitialContex</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Properties</strong></span>: The <code class="literal">Properties</code> attribute contains the JNDI properties for the external <code class="literal">InitialContext</code>. The input should be the text equivalent to what would go into a <code class="literal">jndi.properties</code> file.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>PropertiesURL</strong></span>: This set the <code class="literal">jndi.properties</code> information for the external <code class="literal">InitialContext</code> from an external properties file. This is either a URL, string or a classpath resource name. Examples are as follows:
					</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
								file:///config/myldap.properties
							</div></li><li class="listitem"><div class="para">
								http://config.mycompany.com/myldap.properties
							</div></li><li class="listitem"><div class="para">
								/conf/myldap.properties
							</div></li><li class="listitem"><div class="para">
								myldap.properties
							</div></li></ul></div></li></ul></div><div class="para">
				The MBean definition below shows a binding to an external LDAP context into the JBoss JNDI namespace under the name <code class="literal">external/ldap/jboss</code>.
			</div><pre class="programlisting">&lt;!-- Bind a remote LDAP server --&gt;
&lt;mbean code="org.jboss.naming.ExternalContext" 
       name="jboss.jndi:service=ExternalContext,jndiName=external/ldap/jboss"&gt;
    &lt;attribute name="JndiName"&gt;external/ldap/jboss&lt;/attribute&gt;
    &lt;attribute name="Properties"&gt;
        java.naming.factory.initial=com.sun.jndi.ldap.LdapCtxFactory
        java.naming.provider.url=ldap://ldaphost.jboss.org:389/o=jboss.org
        java.naming.security.principal=cn=Directory Manager
        java.naming.security.authentication=simple
        java.naming.security.credentials=secret
    &lt;/attribute&gt;
    &lt;attribute name="InitialContext"&gt; javax.naming.ldap.InitialLdapContext &lt;/attribute&gt;
    &lt;attribute name="RemoteAccess"&gt;true&lt;/attribute&gt;
&lt;/mbean&gt;
</pre><div class="para">
				With this configuration, you can access the external LDAP context located at <code class="literal">ldap://ldaphost.jboss.org:389/o=jboss.org</code> from within the JBoss VM using the following code fragment:
			</div><pre class="programlisting">InitialContext iniCtx = new InitialContext();
LdapContext ldapCtx = iniCtx.lookup("external/ldap/jboss");
</pre><div class="para">
				Using the same code fragment outside of the JBoss server VM will work in this case because the <code class="literal">RemoteAccess</code> property was set to true. If it were set to false, it would not work because the remote client would receive a <code class="literal">Reference</code> object with an <code class="literal">ObjectFactory</code> that would not be able to recreate the external <code class="literal">InitialContext</code>
			</div><pre class="programlisting">&lt;!-- Bind the /usr/local file system directory  --&gt;
&lt;mbean code="org.jboss.naming.ExternalContext" 
       name="jboss.jndi:service=ExternalContext,jndiName=external/fs/usr/local"&gt;
    &lt;attribute name="JndiName"&gt;external/fs/usr/local&lt;/attribute&gt;
    &lt;attribute name="Properties"&gt;
        java.naming.factory.initial=com.sun.jndi.fscontext.RefFSContextFactory
        java.naming.provider.url=file:///usr/local
    &lt;/attribute&gt;
    &lt;attribute name="InitialContext"&gt;javax.naming.IntialContext&lt;/attribute&gt;
&lt;/mbean&gt;
</pre><div class="para">
				This configuration describes binding a local file system directory <code class="literal">/usr/local</code> into the JBoss JNDI namespace under the name <code class="literal">external/fs/usr/local</code>.
			</div><div class="para">
				With this configuration, you can access the external file system context located at <code class="literal">file:///usr/local</code> from within the JBoss VM using the following code fragment:
			</div><pre class="programlisting">InitialContext iniCtx = new InitialContext();
                Context ldapCtx = iniCtx.lookup("external/fs/usr/local");
</pre></div><div class="section" id="Additional_Naming_MBeans-The_org.jboss.naming.JNDIView_MBean"><div class="titlepage"><div><div><h3 class="title">6.5.4.The org.jboss.naming.JNDIView MBean</h3></div></div></div><div class="para">
				The JNDIView MBean allows the user to view the JNDI namespace tree as it exists in the JBoss server using the JMX agent view interface. To view the JBoss JNDI namespace using the JNDIView MBean, you connect to the JMX Agent View using the http interface. The default settings put this at <code class="literal">http://localhost:8080/jmx-console/</code>. On this page you will see a section that lists the registered MBeans sorted by domain. It should look something like that shown in <a class="xref" href="#The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_configured_JBoss_MBeans">Figure6.4, The JMX Console view of the configured JBoss MBeans</a>.
			</div><div class="figure" id="The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_configured_JBoss_MBeans"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/e609e082c124cc92dbca321bfdb65507/jndiview-1.jpg" align="middle" width="444" alt="The JMX Console view of the configured JBoss MBeans" /></div></div><p class="title"><strong>Figure6.4.The JMX Console view of the configured JBoss MBeans</strong></p></div><div class="para">
				Selecting the JNDIView link takes you to the JNDIView MBean view, which will have a list of the JNDIView MBean operations. This view should look similar to that shown in <a class="xref" href="#The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_JNDIView_MBean">Figure6.5, The JMX Console view of the JNDIView MBean</a>.
			</div><div class="figure" id="The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_JNDIView_MBean"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/2742c64ae28f87b53388af1315d7ac91/jndiview-2.jpg" align="middle" width="444" alt="The JMX Console view of the JNDIView MBean" /></div></div><p class="title"><strong>Figure6.5.The JMX Console view of the JNDIView MBean</strong></p></div><div class="para">
				The list operation dumps out the JBoss server JNDI namespace as an HTML page using a simple text view. As an example, invoking the list operation produces the view shown in <a class="xref" href="#The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_JNDIView_list_operation_output">Figure6.6, The JMX Console view of the JNDIView list operation output</a>.
			</div><div class="figure" id="The_org.jboss.naming.JNDIView_MBean-The_JMX_Console_view_of_the_JNDIView_list_operation_output"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/19b9b70c708e2e0eb86adb650a80a514/jndiview-3.jpg" align="middle" width="444" alt="The JMX Console view of the JNDIView list operation output" /></div></div><p class="title"><strong>Figure6.6.The JMX Console view of the JNDIView list operation output</strong></p></div></div></div><div class="section" id="Naming_on_JBoss-J2EE_and_JNDI___The_Application_Component_Environment"><div class="titlepage"><div><div><h2 class="title">6.6.J2EE and JNDI - The Application Component Environment</h2></div></div></div><div class="para">
			JNDI is a fundamental aspect of the J2EE specifications. One key usage is the isolation of J2EE component code from the environment in which the code is deployed. Use of the application component's environment allows the application component to be customized without the need to access or change the application component's source code. The application component environment is referred to as the ENC, the enterprise naming context. It is the responsibility of the application component container to make an ENC available to the container components in the form of JNDI Context. The ENC is utilized by the participants involved in the life cycle of a J2EE component in the following ways.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Application component business logic should be coded to access information from its ENC. The component provider uses the standard deployment descriptor for the component to specify the required ENC entries. The entries are declarations of the information and resources the component requires at runtime.
				</div></li><li class="listitem"><div class="para">
					The container provides tools that allow a deployer of a component to map the ENC references made by the component developer to the deployment environment entity that satisfies the reference.
				</div></li><li class="listitem"><div class="para">
					The component deployer utilizes the container tools to ready a component for final deployment.
				</div></li><li class="listitem"><div class="para">
					The component container uses the deployment package information to build the complete component ENC at runtime
				</div></li></ul></div><div class="para">
			The complete specification regarding the use of JNDI in the J2EE platform can be found in section 5 of the J2EE 1.4 specification.
		</div><div class="para">
			An application component instance locates the ENC using the JNDI API. An application component instance creates a <code class="literal">javax.naming.InitialContext</code> object by using the no argument constructor and then looks up the naming environment under the name <code class="literal">java:comp/env</code>. The application component's environment entries are stored directly in the ENC, or in its subcontexts. <a class="xref" href="#J2EE_and_JNDI___The_Application_Component_Environment-ENC_access_sample_code">Example6.4, ENC access sample code</a> illustrates the prototypical lines of code a component uses to access its ENC.
		</div><div class="example" id="J2EE_and_JNDI___The_Application_Component_Environment-ENC_access_sample_code"><p class="title"><strong>Example6.4.ENC access sample code</strong></p><div class="example-contents"><pre class="programlisting">// Obtain the application component's ENC
Context iniCtx = new InitialContext();
Context compEnv = (Context) iniCtx.lookup("java:comp/env");
</pre></div></div><div class="para">
			An application component environment is a local environment that is accessible only by the component when the application server container thread of control is interacting with the application component. This means that an EJB <code class="literal">Bean1</code> cannot access the ENC elements of EJB <code class="literal">Bean2</code>, and vice versa. Similarly, Web application <code class="literal">Web1</code> cannot access the ENC elements of Web application <code class="literal">Web2</code> or <code class="literal">Bean1</code> or <code class="literal">Bean2</code> for that matter. Also, arbitrary client code, whether it is executing inside of the application server VM or externally cannot access a component's <code class="literal">java:comp</code> JNDI context. The purpose of the ENC is to provide an isolated, read-only namespace that the application component can rely on regardless of the type of environment in which the component is deployed. The ENC must be isolated from other components because each component defines its own ENC content. Components <code class="literal">A</code> and <code class="literal">B</code>, for example, may define the same name to refer to different objects. For example, EJB <code class="literal">Bean1</code> may define an environment entry <code class="literal">java:comp/env/red</code> to refer to the hexadecimal value for the RGB color for red, while Web application <code class="literal">Web1</code> may bind the same name to the deployment environment language locale representation of red.
		</div><div class="para">
			There are three commonly used levels of naming scope in JBoss: names under <code class="literal">java:comp</code>, names under <code class="literal">java:</code>, and any other name. As discussed, the <code class="literal">java:comp</code> context and its subcontexts are only available to the application component associated with that particular context. Subcontexts and object bindings directly under <code class="literal">java:</code> are only visible within the JBoss server virtual machine and not to remote clients. Any other context or object binding is available to remote clients, provided the context or object supports serialization. You'll see how the isolation of these naming scopes is achieved in the <a class="xref" href="#Naming_on_JBoss-The_JBossNS_Architecture">Section6.2, The JBoss Naming Service Architecture</a>.
		</div><div class="para">
			An example of where the restricting a binding to the <code class="literal">java:</code> context is useful would be a <code class="literal">javax.sql.DataSource</code> connection factory that can only be used inside of the JBoss server where the associated database pool resides. On the other hand, an EJB home interface would be bound to a globally visible name that should accessible by remote client.
		</div><div class="section" id="J2EE_and_JNDI___The_Application_Component_Environment-ENC_Usage_Conventions"><div class="titlepage"><div><div><h3 class="title">6.6.1.ENC Usage Conventions</h3></div></div></div><div class="para">
				JNDI is used as the API for externalizing a great deal of information from an application component. The JNDI name that the application component uses to access the information is declared in the standard <code class="literal">ejb-jar.xml</code> deployment descriptor for EJB components, and the standard <code class="literal">web.xml</code> deployment descriptor for Web components. Several different types of information may be stored in and retrieved from JNDI including:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Environment entries as declared by the <code class="literal">env-entry</code> elements
					</div></li><li class="listitem"><div class="para">
						EJB references as declared by <code class="literal">ejb-ref</code> and <code class="literal">ejb-local-ref</code> elements.
					</div></li><li class="listitem"><div class="para">
						Resource manager connection factory references as declared by the <code class="literal">resource-ref</code> elements
					</div></li><li class="listitem"><div class="para">
						Resource environment references as declared by the <code class="literal">resource-env-ref</code> elements
					</div></li></ul></div><div class="para">
				Each type of deployment descriptor element has a JNDI usage convention with regard to the name of the JNDI context under which the information is bound. Also, in addition to the standard deploymentdescriptor element, there is a JBoss server specific deployment descriptor element that maps the JNDI name as used by the application component to the deployment environment JNDI name.
			</div><div class="section" id="ENC_Usage_Conventions-Environment_Entries"><div class="titlepage"><div><div><h4 class="title">6.6.1.1.Environment Entries</h4></div></div></div><div class="para">
					Environment entries are the simplest form of information stored in a component ENC, and are similar to operating system environment variables like those found on Unix or Windows. Environment entries are a name-to-value binding that allows a component to externalize a value and refer to the value using a name.
				</div><div class="para">
					An environment entry is declared using an <code class="literal">env-entry</code> element in the standard deployment descriptors. The <code class="literal">env-entry</code> element contains the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>description</strong></span> element that provides a description of the entry
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>env-entry-name</strong></span> element giving the name of the entry relative to <code class="literal">java:comp/env</code>
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>env-entry-type</strong></span> element giving the Java type of the entry value that must be one of: 
							<div class="itemizedlist"><ul><li class="listitem"><div class="para">
										<code class="literal">java.lang.Byte</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Boolean</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Character</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Double</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Float</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Integer</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Long</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.Short</code>
									</div></li><li class="listitem"><div class="para">
										<code class="literal">java.lang.String</code>
									</div></li></ul></div>

						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>env-entry-value</strong></span> element giving the value of entry as a string
						</div></li></ul></div><div class="para">
					An example of an <code class="literal">env-entry</code> fragment from an <code class="literal">ejb-jar.xml</code> deployment descriptor is given in <a class="xref" href="#Environment_Entries-An_example_ejb_jar.xml_env_entry_fragment">Example6.5, An example ejb-jar.xml env-entry fragment</a>. There is no JBoss specific deployment descriptor element because an <code class="literal">env-entry</code> is a complete name and value specification. <a class="xref" href="#Environment_Entries-ENC_env_entry_access_code_fragment">Example6.6, ENC env-entry access code fragment</a> shows a sample code fragment for accessing the <code class="literal">maxExemptions</code> and <code class="literal">taxRate</code> and <code class="literal">env-entry</code> values declared in the deployment descriptor.
				</div><div class="example" id="Environment_Entries-An_example_ejb_jar.xml_env_entry_fragment"><p class="title"><strong>Example6.5.An example ejb-jar.xml env-entry fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;!-- ... --&gt;
&lt;session&gt;
    &lt;ejb-name&gt;ASessionBean&lt;/ejb-name&gt;
    &lt;!-- ... --&gt;
    &lt;env-entry&gt;
        &lt;description&gt;The maximum number of tax exemptions allowed &lt;/description&gt;
        &lt;env-entry-name&gt;maxExemptions&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Integer&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;15&lt;/env-entry-value&gt;
    &lt;/env-entry&gt;
    &lt;env-entry&gt;
        &lt;description&gt;The tax rate &lt;/description&gt;
        &lt;env-entry-name&gt;taxRate&lt;/env-entry-name&gt;
        &lt;env-entry-type&gt;java.lang.Float&lt;/env-entry-type&gt;
        &lt;env-entry-value&gt;0.23&lt;/env-entry-value&gt;
    &lt;/env-entry&gt;
&lt;/session&gt;
&lt;!-- ... --&gt;
</pre></div></div><div class="example" id="Environment_Entries-ENC_env_entry_access_code_fragment"><p class="title"><strong>Example6.6.ENC env-entry access code fragment</strong></p><div class="example-contents"><pre class="programlisting">InitialContext iniCtx = new InitialContext();
Context envCtx = (Context) iniCtx.lookup("java:comp/env");
Integer maxExemptions = (Integer) envCtx.lookup("maxExemptions");
Float taxRate = (Float) envCtx.lookup("taxRate");
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-EJB_References"><div class="titlepage"><div><div><h4 class="title">6.6.1.2.EJB References</h4></div></div></div><div class="para">
					It is common for EJBs and Web components to interact with other EJBs. Because the JNDI name under which an EJB home interface is bound is a deployment time decision, there needs to be a way for a component developer to declare a reference to an EJB that will be linked by the deployer. EJB references satisfy this requirement.
				</div><div class="para">
					An EJB reference is a link in an application component naming environment that points to a deployed EJB home interface. The name used by the application component is a logical link that isolates the component from the actual name of the EJB home in the deployment environment. The J2EE specification recommends that all references to enterprise beans be organized in the <code class="literal">java:comp/env/ejb</code> context of the application component's environment.
				</div><div class="para">
					An EJB reference is declared using an <code class="literal">ejb-ref</code> element in the deployment descriptor. Each <code class="literal">ejb-ref</code> element describes the interface requirements that the referencing application component has for the referenced enterprise bean. The <code class="literal">ejb-ref</code> element contains the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>description</strong></span> element that provides the purpose of the reference.
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-ref-name</strong></span> element that specifies the name of the reference relative to the <code class="literal">java:comp/env</code> context. To place the reference under the recommended <code class="literal">java:comp/env/ejb</code> context, use an <code class="literal">ejb/link-name</code> form for the <code class="literal">ejb-ref-name</code> value.
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-ref-type</strong></span> element that specifies the type of the EJB. This must be either <code class="literal">Entity</code> or <code class="literal">Session</code>.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>home</strong></span> element that gives the fully qualified class name of the EJB home interface.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>remote</strong></span> element that gives the fully qualified class name of the EJB remote interface.
						</div></li><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>ejb-link</strong></span> element that links the reference to another enterprise bean in the same EJB JAR or in the same J2EE application unit. The <code class="literal">ejb-link</code> value is the <code class="literal">ejb-name</code> of the referenced bean. If there are multiple enterprise beans with the same <code class="literal">ejb-name</code>, the value uses the path name specifying the location of the <code class="literal">ejb-jar</code> file that contains the referenced component. The path name is relative to the referencing <code class="literal">ejb-jar</code> file. The Application Assembler appends the <code class="literal">ejb-name</code> of the referenced bean to the path name separated by <code class="literal">#</code>. This allows multiple beans with the same name to be uniquely identified.
						</div></li></ul></div><div class="para">
					An EJB reference is scoped to the application component whose declaration contains the <code class="literal">ejb-ref</code> element. This means that the EJB reference is not accessible from other application components at runtime, and that other application components may define <code class="literal">ejb-ref</code> elements with the same <code class="literal">ejb-ref-name</code> without causing a name conflict. <a class="xref" href="#EJB_References-An_example_ejb_jar.xml_ejb_ref_descriptor_fragment">Example6.7, An example ejb-jar.xml ejb-ref descriptor fragment</a> provides an <code class="literal">ejb-jar.xml</code> fragment that illustrates the use of the <code class="literal">ejb-ref</code> element. A code sample that illustrates accessing the <code class="literal">ShoppingCartHome</code> reference declared in <a class="xref" href="#EJB_References-An_example_ejb_jar.xml_ejb_ref_descriptor_fragment">Example6.7, An example ejb-jar.xml ejb-ref descriptor fragment</a> is given in <a class="xref" href="#EJB_References-ENC_ejb_ref_access_code_fragment">Example6.8, ENC ejb-ref access code fragment</a>.
				</div><div class="example" id="EJB_References-An_example_ejb_jar.xml_ejb_ref_descriptor_fragment"><p class="title"><strong>Example6.7.An example ejb-jar.xml ejb-ref descriptor fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;!-- ... --&gt;
&lt;session&gt;
    &lt;ejb-name&gt;ShoppingCartBean&lt;/ejb-name&gt;
    &lt;!-- ...--&gt;
&lt;/session&gt;

&lt;session&gt;
    &lt;ejb-name&gt;ProductBeanUser&lt;/ejb-name&gt;
    &lt;!--...--&gt;
    &lt;ejb-ref&gt;
        &lt;description&gt;This is a reference to the store products entity &lt;/description&gt;
        &lt;ejb-ref-name&gt;ejb/ProductHome&lt;/ejb-ref-name&gt;
        &lt;ejb-ref-type&gt;Entity&lt;/ejb-ref-type&gt;
        &lt;home&gt;org.jboss.store.ejb.ProductHome&lt;/home&gt;
        &lt;remote&gt; org.jboss.store.ejb.Product&lt;/remote&gt;
    &lt;/ejb-ref&gt;

&lt;/session&gt;

&lt;session&gt;
    &lt;ejb-ref&gt;
        &lt;ejb-name&gt;ShoppingCartUser&lt;/ejb-name&gt;
        &lt;!--...--&gt;
        &lt;ejb-ref-name&gt;ejb/ShoppingCartHome&lt;/ejb-ref-name&gt;
        &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
        &lt;home&gt;org.jboss.store.ejb.ShoppingCartHome&lt;/home&gt;
        &lt;remote&gt; org.jboss.store.ejb.ShoppingCart&lt;/remote&gt;
        &lt;ejb-link&gt;ShoppingCartBean&lt;/ejb-link&gt;
    &lt;/ejb-ref&gt;
&lt;/session&gt;

&lt;entity&gt;
    &lt;description&gt;The Product entity bean &lt;/description&gt;
    &lt;ejb-name&gt;ProductBean&lt;/ejb-name&gt;
    &lt;!--...--&gt;
&lt;/entity&gt;

&lt;!--...--&gt;
</pre></div></div><div class="example" id="EJB_References-ENC_ejb_ref_access_code_fragment"><p class="title"><strong>Example6.8.ENC ejb-ref access code fragment</strong></p><div class="example-contents"><pre class="programlisting">InitialContext iniCtx = new InitialContext();
Context ejbCtx = (Context) iniCtx.lookup("java:comp/env/ejb");
ShoppingCartHome home = (ShoppingCartHome) ejbCtx.lookup("ShoppingCartHome");
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-EJB_References_with_jboss.xml_and_jboss_web.xml"><div class="titlepage"><div><div><h4 class="title">6.6.1.3.EJB References with <code class="literal">jboss.xml</code> and <code class="literal">jboss-web.xml</code></h4></div></div></div><div class="para">
					The JBoss specific <code class="literal">jboss.xml</code> EJB deployment descriptor affects EJB references in two ways. First, the <code class="literal">jndi-name</code> child element of the <code class="literal">session</code> and <code class="literal">entity</code> elements allows the user to specify the deployment JNDI name for the EJB home interface. In the absence of a <code class="literal">jboss.xml</code> specification of the <code class="literal">jndi-name</code> for an EJB, the home interface is bound under the <code class="literal">ejb-jar.xml</code><code class="literal">ejb-name</code> value. For example, the session EJB with the <code class="literal">ejb-name</code> of <code class="literal">ShoppingCartBean</code> in <a class="xref" href="#EJB_References-An_example_ejb_jar.xml_ejb_ref_descriptor_fragment">Example6.7, An example ejb-jar.xml ejb-ref descriptor fragment</a> would have its home interface bound under the JNDI name <code class="literal">ShoppingCartBean</code> in the absence of a <code class="literal">jboss.xml</code><code class="literal">jndi-name</code> specification.
				</div><div class="para">
					The second use of the <code class="literal">jboss.xml</code> descriptor with respect to <code class="literal">ejb-ref</code>s is the setting of the destination to which a component's ENC <code class="literal">ejb-ref</code> refers. The <code class="literal">ejb-link</code> element cannot be used to refer to EJBs in another enterprise application. If your <code class="literal">ejb-ref</code> needs to access an external EJB, you can specify the JNDI name of the deployed EJB home using the <code class="literal">jboss.xml</code><code class="literal">ejb-ref/jndi-name</code> element.
				</div><div class="para">
					The <code class="literal">jboss-web.xml</code> descriptor is used only to set the destination to which a Web application ENC <code class="literal">ejb-ref</code> refers. The content model for the JBoss <code class="literal">ejb-ref</code> is as follows:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-ref-name</strong></span> element that corresponds to the <span class="bold bold"><strong>ejb-ref-name</strong></span> element in the <span class="bold bold"><strong>ejb-jar.xml</strong></span> or <span class="bold bold"><strong>web.xml</strong></span> standard descriptor
						</div></li><li class="listitem"><div class="para">
							A <code class="literal">jndi-name</code> element that specifies the JNDI name of the EJB home interface in the deployment environment
						</div></li></ul></div><div class="para">
					<a class="xref" href="#EJB_References_with_jboss.xml_and_jboss_web.xml-An_example_jboss.xml_ejb_ref_fragment">Example6.9, An example jboss.xml ejb-ref fragment</a> provides an example <code class="literal">jboss.xml</code> descriptor fragment that illustrates the following usage points:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							The <code class="literal">ProductBeanUser</code><code class="literal">ejb-ref</code> link destination is set to the deployment name of <code class="literal">jboss/store/ProductHome</code>
						</div></li><li class="listitem"><div class="para">
							The deployment JNDI name of the <code class="literal">ProductBean</code> is set to <code class="literal">jboss/store/ProductHome</code>
						</div></li></ul></div><div class="example" id="EJB_References_with_jboss.xml_and_jboss_web.xml-An_example_jboss.xml_ejb_ref_fragment"><p class="title"><strong>Example6.9.An example jboss.xml ejb-ref fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;!-- ... --&gt;
&lt;session&gt;
    &lt;ejb-name&gt;ProductBeanUser&lt;/ejb-name&gt;
    &lt;ejb-ref&gt;
        &lt;ejb-ref-name&gt;ejb/ProductHome&lt;/ejb-ref-name&gt;
        &lt;jndi-name&gt;<span class="bold bold"><strong>jboss/store/ProductHome</strong></span>&lt;/jndi-name&gt;
    &lt;/ejb-ref&gt;
&lt;/session&gt;
                        
&lt;entity&gt;
    &lt;ejb-name&gt;ProductBean&lt;/ejb-name&gt;
    &lt;jndi-name&gt;<span class="bold bold"><strong>jboss/store/ProductHome</strong></span>&lt;/jndi-name&gt;
     &lt;!-- ... --&gt;
&lt;/entity&gt;
&lt;!-- ... --&gt;
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-EJB_Local_References"><div class="titlepage"><div><div><h4 class="title">6.6.1.4.EJB Local References</h4></div></div></div><div class="para">
					EJB 2.0 added local interfaces that do not use RMI call by value semantics. These interfaces use a call by reference semantic and therefore do not incur any RMI serialization overhead. An EJB local reference is a link in an application component naming environment that points to a deployed EJB local home interface. The name used by the application component is a logical link that isolates the component from the actual name of the EJB local home in the deployment environment. The J2EE specification recommends that all references to enterprise beans be organized in the <code class="literal">java:comp/env/ejb</code> context of the application component's environment.
				</div><div class="para">
					An EJB local reference is declared using an <code class="literal">ejb-local-ref</code> element in the deployment descriptor. Each <code class="literal">ejb-local-ref</code> element describes the interface requirements that the referencing application component has for the referenced enterprise bean. The <code class="literal">ejb-local-ref</code> element contains the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>description</strong></span> element that provides the purpose of the reference.
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-ref-name</strong></span> element that specifies the name of the reference relative to the <code class="literal">java:comp/env</code> context. To place the reference under the recommended <code class="literal">java:comp/env/ejb</code> context, use an <code class="literal">ejb/link-name</code> form for the <code class="literal">ejb-ref-name</code> value.
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-ref-type</strong></span> element that specifies the type of the EJB. This must be either <code class="literal">Entity</code> or <code class="literal">Session</code>.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>local-home</strong></span> element that gives the fully qualified class name of the EJB local home interface.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>local</strong></span> element that gives the fully qualified class name of the EJB local interface.
						</div></li><li class="listitem"><div class="para">
							An <span class="bold bold"><strong>ejb-link</strong></span> element that links the reference to another enterprise bean in the <code class="literal">ejb-jar</code> file or in the same J2EE application unit. The <code class="literal">ejb-link</code> value is the <code class="literal">ejb-name</code> of the referenced bean. If there are multiple enterprise beans with the same <code class="literal">ejb-name</code>, the value uses the path name specifying the location of the <code class="literal">ejb-jar</code> file that contains the referenced component. The path name is relative to the referencing <code class="literal">ejb-jar</code> file. The Application Assembler appends the <code class="literal">ejb-name</code> of the referenced bean to the path name separated by <code class="literal">#</code>. This allows multiple beans with the same name to be uniquely identified. An <code class="literal">ejb-link</code> element must be specified in JBoss to match the local reference to the corresponding EJB.
						</div></li></ul></div><div class="para">
					An EJB local reference is scoped to the application component whose declaration contains the <code class="literal">ejb-local-ref</code> element. This means that the EJB local reference is not accessible from other application components at runtime, and that other application components may define <code class="literal">ejb-local-ref</code> elements with the same <code class="literal">ejb-ref-name</code> without causing a name conflict. <a class="xref" href="#EJB_Local_References-An_example_ejb_jar.xml_ejb_local_ref_descriptor_fragment">Example6.10, An example ejb-jar.xml ejb-local-ref descriptor fragment</a> provides an <code class="literal">ejb-jar.xml</code> fragment that illustrates the use of the <code class="literal">ejb-local-ref</code> element. A code sample that illustrates accessing the <code class="literal">ProbeLocalHome</code> reference declared in <a class="xref" href="#EJB_Local_References-An_example_ejb_jar.xml_ejb_local_ref_descriptor_fragment">Example6.10, An example ejb-jar.xml ejb-local-ref descriptor fragment</a> is given in <a class="xref" href="#EJB_Local_References-ENC_ejb_local_ref_access_code_fragment">Example6.11, ENC ejb-local-ref access code fragment</a>.
				</div><div class="example" id="EJB_Local_References-An_example_ejb_jar.xml_ejb_local_ref_descriptor_fragment"><p class="title"><strong>Example6.10.An example ejb-jar.xml ejb-local-ref descriptor fragment</strong></p><div class="example-contents"><pre class="programlisting">    &lt;!-- ... --&gt;
    &lt;session&gt;
        &lt;ejb-name&gt;Probe&lt;/ejb-name&gt;
        &lt;home&gt;org.jboss.test.perf.interfaces.ProbeHome&lt;/home&gt;
        &lt;remote&gt;org.jboss.test.perf.interfaces.Probe&lt;/remote&gt;
        &lt;local-home&gt;org.jboss.test.perf.interfaces.ProbeLocalHome&lt;/local-home&gt;
        &lt;local&gt;org.jboss.test.perf.interfaces.ProbeLocal&lt;/local&gt;
        &lt;ejb-class&gt;org.jboss.test.perf.ejb.ProbeBean&lt;/ejb-class&gt;
        &lt;session-type&gt;Stateless&lt;/session-type&gt;
        &lt;transaction-type&gt;Bean&lt;/transaction-type&gt;
    &lt;/session&gt;
    &lt;session&gt;
        &lt;ejb-name&gt;PerfTestSession&lt;/ejb-name&gt;
        &lt;home&gt;org.jboss.test.perf.interfaces.PerfTestSessionHome&lt;/home&gt;
        &lt;remote&gt;org.jboss.test.perf.interfaces.PerfTestSession&lt;/remote&gt;
        &lt;ejb-class&gt;org.jboss.test.perf.ejb.PerfTestSessionBean&lt;/ejb-class&gt;
        &lt;session-type&gt;Stateless&lt;/session-type&gt;
        &lt;transaction-type&gt;Container&lt;/transaction-type&gt;
        &lt;ejb-ref&gt;
            &lt;ejb-ref-name&gt;ejb/ProbeHome&lt;/ejb-ref-name&gt;
            &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
            &lt;home&gt;org.jboss.test.perf.interfaces.SessionHome&lt;/home&gt;
            &lt;remote&gt;org.jboss.test.perf.interfaces.Session&lt;/remote&gt;
            &lt;ejb-link&gt;Probe&lt;/ejb-link&gt;
        &lt;/ejb-ref&gt;
        &lt;ejb-local-ref&gt;
            &lt;ejb-ref-name&gt;ejb/ProbeLocalHome&lt;/ejb-ref-name&gt;
            &lt;ejb-ref-type&gt;Session&lt;/ejb-ref-type&gt;
            &lt;local-home&gt;org.jboss.test.perf.interfaces.ProbeLocalHome&lt;/local-home&gt;
            &lt;local&gt;org.jboss.test.perf.interfaces.ProbeLocal&lt;/local&gt;
            &lt;ejb-link&gt;Probe&lt;/ejb-link&gt;
        &lt;/ejb-local-ref&gt;
    &lt;/session&gt;
    &lt;!-- ... --&gt;
</pre></div></div><div class="example" id="EJB_Local_References-ENC_ejb_local_ref_access_code_fragment"><p class="title"><strong>Example6.11.ENC ejb-local-ref access code fragment</strong></p><div class="example-contents"><pre class="programlisting">InitialContext iniCtx = new InitialContext();
Context ejbCtx = (Context) iniCtx.lookup("java:comp/env/ejb");
ProbeLocalHome home = (ProbeLocalHome) ejbCtx.lookup("ProbeLocalHome");
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-Resource_Manager_Connection_Factory_References"><div class="titlepage"><div><div><h4 class="title">6.6.1.5.Resource Manager Connection Factory References</h4></div></div></div><div class="para">
					Resource manager connection factory references allow application component code to refer to resource factories using logical names called resource manager connection factory references. Resource manager connection factory references are defined by the <code class="literal">resource-ref</code> elements in the standard deployment descriptors. The <code class="literal">Deployer</code> binds the resource manager connection factory references to the actual resource manager connection factories that exist in the target operational environment using the <code class="literal">jboss.xml</code> and <code class="literal">jboss-web.xml</code> descriptors.
				</div><div class="para">
					Each <code class="literal">resource-ref</code> element describes a single resource manager connection factory reference. The <code class="literal">resource-ref</code> element consists of the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>description</strong></span> element that provides the purpose of the reference.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>res-ref-name</strong></span> element that specifies the name of the reference relative to the <code class="literal">java:comp/env</code> context. The resource type based naming convention for which subcontext to place the <code class="literal">res-ref-name</code> into is discussed in the next paragraph.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>res-type</strong></span> element that specifies the fully qualified class name of the resource manager connection factory.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>res-auth</strong></span> element that indicates whether the application component code performs resource signon programmatically, or whether the container signs on to the resource based on the principal mapping information supplied by the Deployer. It must be one of <code class="literal">Application</code> or <code class="literal">Container</code>.
						</div></li><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>res-sharing-scope</strong></span> element. This currently is not supported by JBoss.
						</div></li></ul></div><div class="para">
					The J2EE specification recommends that all resource manager connection factory references be organized in the subcontexts of the application component's environment, using a different subcontext for each resource manager type. The recommended resource manager type to subcontext name is as follows:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							JDBC <code class="literal">DataSource</code> references should be declared in the <code class="literal">java:comp/env/jdbc</code> subcontext.
						</div></li><li class="listitem"><div class="para">
							JMS connection factories should be declared in the <code class="literal">java:comp/env/jms</code> subcontext.
						</div></li><li class="listitem"><div class="para">
							JavaMail connection factories should be declared in the <code class="literal">java:comp/env/mail</code> subcontext.
						</div></li><li class="listitem"><div class="para">
							URL connection factories should be declared in the <code class="literal">java:comp/env/url</code> subcontext.
						</div></li></ul></div><div class="para">
					<a class="xref" href="#Resource_Manager_Connection_Factory_References-A_web.xml_resource_ref_descriptor_fragment">Example6.12, A web.xml resource-ref descriptor fragment</a> shows an example <code class="literal">web.xml</code> descriptor fragment that illustrates the <code class="literal">resource-ref</code> element usage. <a class="xref" href="#Resource_Manager_Connection_Factory_References-ENC_resource_ref_access_sample_code_fragment">Example6.13, ENC resource-ref access sample code fragment</a> provides a code fragment that an application component would use to access the <code class="literal">DefaultMail</code> resource declared by the <code class="literal">resource-ref</code>.
				</div><div class="example" id="Resource_Manager_Connection_Factory_References-A_web.xml_resource_ref_descriptor_fragment"><p class="title"><strong>Example6.12.A web.xml resource-ref descriptor fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;web&gt;
    &lt;!-- ... --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;AServlet&lt;/servlet-name&gt;
        &lt;!-- ... --&gt;
    &lt;/servlet&gt;
    &lt;!-- ... --&gt;
    &lt;!-- JDBC DataSources (java:comp/env/jdbc) --&gt;
    &lt;resource-ref&gt;
        &lt;description&gt;The default DS&lt;/description&gt;
        &lt;res-ref-name&gt;jdbc/DefaultDS&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
        &lt;res-auth&gt;Container&lt;/res-auth&gt;
    &lt;/resource-ref&gt;
    &lt;!-- JavaMail Connection Factories (java:comp/env/mail) --&gt;
    &lt;resource-ref&gt;
        &lt;description&gt;Default Mail&lt;/description&gt;
        &lt;res-ref-name&gt;mail/DefaultMail&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.mail.Session&lt;/res-type&gt;
        &lt;res-auth&gt;Container&lt;/res-auth&gt;
    &lt;/resource-ref&gt;
    &lt;!-- JMS Connection Factories (java:comp/env/jms) --&gt;
    &lt;resource-ref&gt;
        &lt;description&gt;Default QueueFactory&lt;/description&gt;
        &lt;res-ref-name&gt;jms/QueueFactory&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.jms.QueueConnectionFactory&lt;/res-type&gt;
        &lt;res-auth&gt;Container&lt;/res-auth&gt;
    &lt;/resource-ref&gt; 
&lt;web&gt;
</pre></div></div><div class="example" id="Resource_Manager_Connection_Factory_References-ENC_resource_ref_access_sample_code_fragment"><p class="title"><strong>Example6.13.ENC resource-ref access sample code fragment</strong></p><div class="example-contents"><pre class="programlisting">Context initCtx = new InitialContext();
javax.mail.Session s = (javax.mail.Session)
initCtx.lookup("java:comp/env/mail/DefaultMail");
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-Resource_Manager_Connection_Factory_References_with_jboss.xml_and_jboss_web.xml"><div class="titlepage"><div><div><h4 class="title">6.6.1.6.Resource Manager Connection Factory References with jboss.xml and jboss-web.xml</h4></div></div></div><div class="para">
					The purpose of the JBoss <code class="literal">jboss.xml</code> EJB deployment descriptor and <code class="literal">jboss-web.xml</code> Web application deployment descriptor is to provide the link from the logical name defined by the <code class="literal">res-ref-name</code> element to the JNDI name of the resource factory as deployed in JBoss. This is accomplished by providing a <code class="literal">resource-ref</code> element in the <code class="literal">jboss.xml</code> or <code class="literal">jboss-web.xml</code> descriptor. The JBoss <code class="literal">resource-ref</code> element consists of the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>res-ref-name</strong></span> element that must match the <code class="literal">res-ref-name</code> of a corresponding <code class="literal">resource-ref</code> element from the <code class="literal">ejb-jar.xml</code> or <code class="literal">web.xml</code> standard descriptors
						</div></li><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>res-type</strong></span> element that specifies the fully qualified class name of the resource manager connection factory
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>jndi-name</strong></span> element that specifies the JNDI name of the resource factory as deployed in JBoss
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>res-url</strong></span> element that specifies the URL string in the case of a <code class="literal">resource-ref</code> of type <code class="literal">java.net.URL</code>
						</div></li></ul></div><div class="para">
					<a class="xref" href="#Resource_Manager_Connection_Factory_References_with_jboss.xml_and_jboss_web.xml-A_sample_jboss_web.xml_resource_ref_descriptor_fragment">Example6.14, A sample jboss-web.xml resource-ref descriptor fragment</a> provides a sample <code class="literal">jboss-web.xml</code> descriptor fragment that shows sample mappings of the <code class="literal">resource-ref</code> elements given in <a class="xref" href="#Resource_Manager_Connection_Factory_References-A_web.xml_resource_ref_descriptor_fragment">Example6.12, A web.xml resource-ref descriptor fragment</a>.
				</div><div class="example" id="Resource_Manager_Connection_Factory_References_with_jboss.xml_and_jboss_web.xml-A_sample_jboss_web.xml_resource_ref_descriptor_fragment"><p class="title"><strong>Example6.14.A sample jboss-web.xml resource-ref descriptor fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;jboss-web&gt;
    &lt;!-- ... --&gt;
    &lt;resource-ref&gt;
        &lt;res-ref-name&gt;jdbc/DefaultDS&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
        &lt;jndi-name&gt;java:/DefaultDS&lt;/jndi-name&gt;
    &lt;/resource-ref&gt;
    &lt;resource-ref&gt;
        &lt;res-ref-name&gt;mail/DefaultMail&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.mail.Session&lt;/res-type&gt;
        &lt;jndi-name&gt;java:/Mail&lt;/jndi-name&gt;
    &lt;/resource-ref&gt;
    &lt;resource-ref&gt;
        &lt;res-ref-name&gt;jms/QueueFactory&lt;/res-ref-name&gt;
        &lt;res-type&gt;javax.jms.QueueConnectionFactory&lt;/res-type&gt;
        &lt;jndi-name&gt;QueueConnectionFactory&lt;/jndi-name&gt;
    &lt;/resource-ref&gt;
    &lt;!-- ... --&gt;
&lt;/jboss-web&gt;
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-Resource_Environment_References"><div class="titlepage"><div><div><h4 class="title">6.6.1.7.Resource Environment References</h4></div></div></div><div class="para">
					Resource environment references are elements that refer to administered objects that are associated with a resource (for example, JMS destinations) using logical names. Resource environment references are defined by the <code class="literal">resource-env-ref</code> elements in the standard deployment descriptors. The <code class="literal">Deployer</code> binds the resource environment references to the actual administered objects location in the target operational environment using the <code class="literal">jboss.xml</code> and <code class="literal">jboss-web.xml</code> descriptors.
				</div><div class="para">
					Each <code class="literal">resource-env-ref</code> element describes the requirements that the referencing application component has for the referenced administered object. The <code class="literal">resource-env-ref</code> element consists of the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							An optional <span class="bold bold"><strong>description</strong></span> element that provides the purpose of the reference.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>resource-env-ref-name</strong></span> element that specifies the name of the reference relative to the <code class="literal">java:comp/env</code> context. Convention places the name in a subcontext that corresponds to the associated resource factory type. For example, a JMS queue reference named <code class="literal">MyQueue</code> should have a <code class="literal">resource-env-ref-name</code> of <code class="literal">jms/MyQueue</code>.
						</div></li><li class="listitem"><div class="para">
							A <span class="bold bold"><strong>resource-env-ref-type</strong></span> element that specifies the fully qualified class name of the referenced object. For example, in the case of a JMS queue, the value would be <code class="literal">javax.jms.Queue</code>.
						</div></li></ul></div><div class="para">
					<a class="xref" href="#Resource_Environment_References-An_example_ejb_jar.xml_resource_env_ref_fragment">Example6.15, An example ejb-jar.xml resource-env-ref fragment</a> provides an example <code class="literal">resource-ref-env</code> element declaration by a session bean. <a class="xref" href="#Resource_Environment_References-ENC_resource_env_ref_access_code_fragment">Example6.16, ENC resource-env-ref access code fragment</a> gives a code fragment that illustrates how to look up the <code class="literal">StockInfo</code> queue declared by the <code class="literal">resource-env-ref</code>.
				</div><div class="example" id="Resource_Environment_References-An_example_ejb_jar.xml_resource_env_ref_fragment"><p class="title"><strong>Example6.15.An example ejb-jar.xml resource-env-ref fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;session&gt;
    &lt;ejb-name&gt;MyBean&lt;/ejb-name&gt;
    &lt;!-- ... --&gt;
    &lt;resource-env-ref&gt;
        &lt;description&gt;This is a reference to a JMS queue used in the
            processing of Stock info
        &lt;/description&gt;
        &lt;resource-env-ref-name&gt;jms/StockInfo&lt;/resource-env-ref-name&gt;
        &lt;resource-env-ref-type&gt;javax.jms.Queue&lt;/resource-env-ref-type&gt;
    &lt;/resource-env-ref&gt;
    &lt;!-- ... --&gt;
&lt;/session&gt;
</pre></div></div><div class="example" id="Resource_Environment_References-ENC_resource_env_ref_access_code_fragment"><p class="title"><strong>Example6.16.ENC resource-env-ref access code fragment</strong></p><div class="example-contents"><pre class="programlisting">InitialContext iniCtx = new InitialContext();
javax.jms.Queue q = (javax.jms.Queue)
envCtx.lookup("java:comp/env/jms/StockInfo");
</pre></div></div></div><div class="section" id="ENC_Usage_Conventions-Resource_Environment_References_and_jboss.xml_jboss_web.xml"><div class="titlepage"><div><div><h4 class="title">6.6.1.8.Resource Environment References and jboss.xml, jboss-web.xml</h4></div></div></div><div class="para">
					The purpose of the JBoss <code class="literal">jboss.xml</code> EJB deployment descriptor and <code class="literal">jboss-web.xml</code> Web application deployment descriptor is to provide the link from the logical name defined by the <code class="literal">resource-env-ref-name</code> element to the JNDI name of the administered object deployed in JBoss. This is accomplished by providing a <code class="literal">resource-env-ref</code> element in the <code class="literal">jboss.xml</code> or <code class="literal">jboss-web.xml</code> descriptor. The JBoss <code class="literal">resource-env-ref</code> element consists of the following child elements:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							A <code class="literal">resource-env-ref-name</code> element that must match the <code class="literal">resource-env-ref-name</code> of a corresponding <code class="literal">resource-env-ref</code> element from the <code class="literal">ejb-jar.xml</code> or <code class="literal">web.xml</code> standard descriptors
						</div></li><li class="listitem"><div class="para">
							A <code class="literal">jndi-name</code> element that specifies the JNDI name of the resource as deployed in JBoss
						</div></li></ul></div><div class="para">
					<a class="xref" href="#Resource_Environment_References_and_jboss.xml_jboss_web.xml-A_sample_jboss.xml_resource_env_ref_descriptor_fragment">Example6.17, A sample jboss.xml resource-env-ref descriptor fragment</a> provides a sample <code class="literal">jboss.xml</code> descriptor fragment that shows a sample mapping for the <code class="literal">StockInfo</code><code class="literal">resource-env-ref</code>.
				</div><div class="example" id="Resource_Environment_References_and_jboss.xml_jboss_web.xml-A_sample_jboss.xml_resource_env_ref_descriptor_fragment"><p class="title"><strong>Example6.17.A sample jboss.xml resource-env-ref descriptor fragment</strong></p><div class="example-contents"><pre class="programlisting">&lt;session&gt;
    &lt;ejb-name&gt;MyBean&lt;/ejb-name&gt;
    &lt;!-- ... --&gt;
    &lt;resource-env-ref&gt;
        &lt;resource-env-ref-name&gt;jms/StockInfo&lt;/resource-env-ref-name&gt;
        &lt;jndi-name&gt;queue/StockInfoQueue&lt;/jndi-name&gt;
    &lt;/resource-env-ref&gt;
    &lt;!-- ... --&gt;
&lt;/session&gt;
</pre></div></div></div></div></div></div><div xml:lang="en-US" class="chapter" id="Web_Services" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter7.Web Services</h2></div></div></div><div class="para">
		<a id="idm139946674076096" class="indexterm"><!--Empty--></a> <a id="idm139946675518208" class="indexterm"><!--Empty--></a> <a id="idm139946670801728" class="indexterm"><!--Empty--></a> Web services are a key contributing factor in the way Web commerce is conducted today. Web services enable applications to communicate by sending small and large chunks of data to each other.
	</div><div class="para">
		A web service is essentially a software application that supports interaction of applications over a computer network or the world wide web. Web services usually interact through XML documents that map to an object, computer program, business process or database. To communicate, an application sends a message in XML document format to a web service which sends this message to the respective programs. Responses may be received based on requirements, the web service receives and then sends them in XML document format to the required program or applications. Web services can be used in many ways, examples include supply chain information management and business integration.
	</div><div class="para">
		JBossWS is a web service framework included as part of the JBoss Enterprise Application Platform. It implements the JAX-WS specification that defines a programming model and run-time architecture for implementing web services in Java, targeted at the Java Platform, Enterprise Edition 5 (Java EE 5). Even though JAX-RPC is still supported (the web service specification for J2EE 1.4), JBossWS does put a clear focus on JAX-WS.
	</div><div class="para">
		<div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				JAX-RPC is not supported for JBoss Web Services CXF Stack.
			</div></div></div>

	</div><div class="section" id="idm139946657805040"><div class="titlepage"><div><div><h2 class="title">7.1.The need for web services</h2></div></div></div><div class="para">
			Enterprise systems communication may benefit from a wise adoption of web service technologies. Focusing attention on well designed contracts allows developers to establish an abstract view of their service capabilities. Considering the standardized way contracts are written, this definitely helps communication with third-party systems and eventually supports business-to-business integration; everything is clear and standardized in the contract the provider and consumer agree on. This also reduces the dependencies between implementations allowing other consumers to easily use the provided service without major changes.
		</div><div class="para">
			Other benefits exist for enterprise systems that incorporate web service technologies for internal heterogenous subsystems communication as web service interoperability boosts service reuse and composition. Web services eliminates the need to rewrite whole functionalities because they were developed by another enterprise department using a different software language.
		</div></div><div class="section" id="idm139946675865312"><div class="titlepage"><div><div><h2 class="title">7.2.What web services are not</h2></div></div></div><div class="para">
			Web services are not the solution for every software system communication.
		</div><div class="para">
			Nowadays they are meant to be used for loosely-coupled coarse-grained communication, message (document) exchange. Recent times has seen many specifications (WS-*) discussed and finally approved to establish standardized ws-related advanced aspects, including reliable messaging, message-level security and cross-service transactions. Web service specifications also include the notion of registries to collect service contract references, to easily discover service implementations.
		</div><div class="para">
			This all means that the web services technology platform suits complex enterprise communication and is not simply the latest way of doing remote procedure calls.
		</div></div><div class="section" id="idm139946675181408"><div class="titlepage"><div><div><h2 class="title">7.3.Document/Literal</h2></div></div></div><div class="para">
			With document style web services two business partners agree on the exchange of complex business documents that are well defined in XML schema. For example, one party sends a document describing a purchase order, the other responds (immediately or later) with a document that describes the status of the purchase order. The payload of the SOAP message is an XML document that can be validated against XML schema. The document is defined by the style attribute on the SOAP binding.
		</div><pre class="programlisting XML XML">&lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;
   &lt;soap:binding style='document' transport='http://schemas.xmlsoap.org/soap/http'/&gt;
   &lt;operation name='concat'&gt;
      &lt;soap:operation soapAction=''/&gt;
      &lt;input&gt;
         &lt;soap:body use='literal'/&gt;
      &lt;/input&gt;
      &lt;output&gt;
         &lt;soap:body use='literal'/&gt;
      &lt;/output&gt;
   &lt;/operation&gt;
&lt;/binding&gt;
</pre><div class="para">
			With document style web services the payload of every message is defined by a complex type in XML schema.
		</div><pre class="programlisting XML XML">&lt;complexType name='concatType'&gt;
   &lt;sequence&gt;
      &lt;element name='String_1' nillable='true' type='string'/&gt;
      &lt;element name='long_1' type='long'/&gt;
   &lt;/sequence&gt;
&lt;/complexType&gt;
&lt;element name='concat' type='tns:concatType'/&gt;</pre><div class="para">
			Therefore, message parts must refer to an element from the schema.
		</div><pre class="programlisting XML XML">&lt;message name='EndpointInterface_concat'&gt;
   &lt;part name='parameters' element='tns:concat'/&gt;
&lt;/message&gt;</pre><div class="para">
			The following message definition is invalid.
		</div><pre class="programlisting XML XML">&lt;message name='EndpointInterface_concat'&gt;
   &lt;part name='parameters' type='tns:concatType'/&gt;
&lt;/message&gt;</pre></div><div class="section" id="idm139946670816320"><div class="titlepage"><div><div><h2 class="title">7.4.Document/Literal (Bare)</h2></div></div></div><div class="para">
			Bare is an implementation detail from the Java domain. Neither in the abstract contract (for instance, wsdl+schema) nor at the SOAP message level is a bare endpoint recognizable. A bare endpoint or client uses a Java bean that represents the entire document payload.
		</div><pre class="programlisting JAVA JAVA">@WebService
@SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)
public class DocBareServiceImpl
{
   @WebMethod
   public SubmitBareResponse submitPO(SubmitBareRequest poRequest)
   {
      ...
   }
}</pre><div class="para">
			The trick is that the Java beans representing the payload contain JAXB annotations that define how the payload is represented on the wire.
		</div><pre class="programlisting JAVA JAVA">@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "SubmitBareRequest", namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/", propOrder = { "product" })
@XmlRootElement(namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/", name = "SubmitPO")
public class SubmitBareRequest
{
   @XmlElement(namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/",  required = true)
   private String product;

   ...
}</pre></div><div class="section" id="idm139946670812064"><div class="titlepage"><div><div><h2 class="title">7.5.Document/Literal (Wrapped)</h2></div></div></div><div class="para">
			Wrapped is an implementation detail from the Java domain. Neither in the abstract contract (for instance, wsdl+schema) nor at the SOAP message level is a wrapped endpoint recognizable. A wrapped endpoint or client uses the individual document payload properties. Wrapped is the default and does not have to be declared explicitly.
		</div><pre class="programlisting JAVA JAVA">@WebService
public class DocWrappedServiceImpl
{
   @WebMethod
   @RequestWrapper (className="org.somepackage.SubmitPO")
   @ResponseWrapper (className="org.somepackage.SubmitPOResponse")
   public String submitPO(String product, int quantity)
   {
   ...
   }
}</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				With JBossWS the request and response wrapper annotations are not required, they will be generated on demand using sensible defaults.
			</div></div></div></div><div class="section" id="idm139946676330672"><div class="titlepage"><div><div><h2 class="title">7.6.RPC/Literal</h2></div></div></div><div class="para">
			With RPC there is a wrapper element that names the endpoint operation. Child elements of the RPC parent are the individual parameters. The SOAP body is constructed based on some simple rules: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The port type operation name defines the endpoint method name
					</div></li><li class="listitem"><div class="para">
						Message parts are endpoint method parameters
					</div></li></ul></div>
			 RPC is defined by the style attribute on the SOAP binding.
		</div><pre class="programlisting XML XML">
&lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;
   &lt;soap:binding style='rpc' transport='http://schemas.xmlsoap.org/soap/http'/&gt;
   &lt;operation name='echo'&gt;
      &lt;soap:operation soapAction=''/&gt;
      &lt;input&gt;
         &lt;soap:body namespace='http://org.jboss.ws/samples/jsr181pojo' use='literal'/&gt;
      &lt;/input&gt;
      &lt;output&gt;
         &lt;soap:body namespace='http://org.jboss.ws/samples/jsr181pojo' use='literal'/&gt;
      &lt;/output&gt;
   &lt;/operation&gt;
&lt;/binding&gt;</pre><div class="para">
			With RPC style web services the portType names the operation (i.e. the java method on the endpoint)
		</div><pre class="programlisting XML XML">
&lt;portType name='EndpointInterface'&gt;
   &lt;operation name='echo' parameterOrder='String_1'&gt;
      &lt;input message='tns:EndpointInterface_echo'/&gt;
      &lt;output message='tns:EndpointInterface_echoResponse'/&gt;
   &lt;/operation&gt;
&lt;/portType&gt;</pre><div class="para">
			Operation parameters are defined by individual message parts.
		</div><pre class="programlisting XML XML">
&lt;message name='EndpointInterface_echo'&gt;
   &lt;part name='String_1' type='xsd:string'/&gt;
&lt;/message&gt;
&lt;message name='EndpointInterface_echoResponse'&gt;
   &lt;part name='result' type='xsd:string'/&gt;
&lt;/message&gt;</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				There is no complex type in XML schema that could validate the entire SOAP message payload.
			</div></div></div><pre class="programlisting JAVA JAVA">
@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
   @WebMethod
   @WebResult(name="result")
   public String echo(@WebParam(name="String_1") String input)
   {
   ...
   }
}</pre><div class="para">
			The element names of RPC parameters/return values may be defined using the JAX-WS Annotations#javax.jws.WebParam and JAX-WS Annotations#javax.jws.WebResult respectively.
		</div></div><div class="section" id="idm139946675910736"><div class="titlepage"><div><div><h2 class="title">7.7.RPC/Encoded</h2></div></div></div><div class="para">
			SOAP encoding style is defined by <a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383512" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">chapter 5</a> of the <a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">SOAP-1.1</a> specification. It has inherent interoperability issues that cannot be fixed. The <a href="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html" class="mimir-link-warn" title="Mimir does not include content from: www.ws-i.org">Basic Profile-1.0</a> prohibits this encoding style in <a href="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16448072" class="mimir-link-warn" title="Mimir does not include content from: www.ws-i.org">4.1.7 SOAP encodingStyle Attribute</a>. JBossWS has basic support for RPC/Encoded that is provided as is for simple interop scenarios with SOAP stacks that do not support literal encoding. Specifically, JBossWS does not support:- 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						element references
					</div></li><li class="listitem"><div class="para">
						soap arrays as bean properties
					</div></li></ul></div>

		</div><div class="para">
			<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					This section should not be used in conjuction with JBoss Web Services CXF Stack.
				</div></div></div>

		</div></div><div class="section" id="idm139946675902384"><div class="titlepage"><div><div><h2 class="title">7.8.Web Service Endpoints </h2></div></div></div><div class="para">
			JAX-WS simplifies the development model for a web service endpoint a great deal. In short, an endpoint implementation bean is annotated with JAX-WS annotations and deployed to the server. The server automatically generates and publishes the abstract contract (for instance, wsdl+schema) for client consumption. All marshalling/unmarshalling is delegated to JAXB.
		</div></div><div class="section" id="idm139946675900592"><div class="titlepage"><div><div><h2 class="title">7.9.Plain old Java Object (POJO)</h2></div></div></div><div class="para">
			Let us take a look at simple POJO endpoint implementation. All endpoint associated metadata are provided via JSR-181 annotations
		</div><pre class="programlisting JAVA JAVA">@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
   @WebMethod
   public String echo(String input)
   {
    ...
   }
}</pre></div><div class="section" id="idm139946675898272"><div class="titlepage"><div><div><h2 class="title">7.10.The endpoint as a web application</h2></div></div></div><div class="para">
			A JAX-WS java service endpoint (JSE) is deployed as a web application.
		</div><pre class="programlisting">&lt;web-app ...&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;TestService&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre></div><div class="section" id="idm139946658540096"><div class="titlepage"><div><div><h2 class="title">7.11.Packaging the endpoint</h2></div></div></div><div class="para">
			A JSR-181 java service endpoint (JSE) is packaged as a web application in a <code class="filename">*.war</code> file.
		</div><pre class="programlisting XML XML">&lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;
   &lt;classes dir="${build.dir}/classes"&gt;
      &lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;
   &lt;/classes&gt;
&lt;/war&gt;</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Only the endpoint implementation bean and <code class="filename">web.xml</code> file are required.
			</div></div></div></div><div class="section" id="idm139946658535872"><div class="titlepage"><div><div><h2 class="title">7.12.Accessing the generated WSDL</h2></div></div></div><div class="para">
			A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you find the links to the generated WSDL.
		</div><pre class="screen">http://yourhost:8080/jbossws/services</pre><div class="para">
			It is also possible to generate the abstract contract off line using jboss tools. For details of that see <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSTools#TopDown_Using_wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Top Down (Using wsconsume)</a>
		</div></div><div class="section" id="idm139946658532688"><div class="titlepage"><div><div><h2 class="title">7.13.EJB3 Stateless Session Bean (SLSB)</h2></div></div></div><div class="para">
			The JAX-WS programming model support the same set of annotations on EJB3 stateless session beans as on <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Plain_old_Java_Object_POJO" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Plain old Java Object (POJO)</a> endpoints. EJB-2.1 endpoints are supported using the JAX-RPC progamming model.
		</div><pre class="programlisting JAVA JAVA">
@Stateless
@Remote(EJB3RemoteInterface.class)
@RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")
   
@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class EJB3Bean01 implements EJB3RemoteInterface
{
   @WebMethod
   public String echo(String input)
   {
   ...
   }
}</pre><div class="para">
			Above you see an EJB-3.0 stateless session bean that exposes one method both on the remote interface and as an endpoint operation.
		</div><div class="para"><div class="title">Packaging the endpoint</div><p>
				A JSR-181 EJB service endpoint is packaged as an ordinary ejb deployment.
			</p></div><pre class="programlisting XML XML">&lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;
   &lt;fileset dir="${build.dir}/classes"&gt;
      &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;
      &lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;
   &lt;/fileset&gt;
&lt;/jar&gt;</pre><div class="para"><div class="title">Accessing the generated WSDL</div><p>
				A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you will find the links to the generated WSDL.
			</p></div><pre class="programlisting"> 
  http://yourhost:8080/jbossws/services</pre><div class="para">
			It is also possible to generate the abstract contract offline using JbossWS tools. For details of that please see <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSTools#TopDown_Using_wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Top Down (Using wsconsume)</a>
		</div></div><div class="section" id="idm139946670492080"><div class="titlepage"><div><div><h2 class="title">7.14.Endpoint Provider</h2></div></div></div><div class="para">
			JAX-WS services typically implement a native Java service endpoint interface (SEI), perhaps mapped from a WSDL port type, either directly or via the use of annotations.
		</div><div class="para">
			Java SEIs provide a high level Java-centric abstraction that hides the details of converting between Java objects and their XML representations for use in XML-based messages. However, in some cases it is desirable for services to be able to operate at the XML message level. The Provider interface offers an alternative to SEIs and may be implemented by services wishing to work at the XML message level.
		</div><div class="para">
			A Provider based service instances invoke method is called for each message received for the service.
		</div><pre class="programlisting JAVA JAVA">
@WebServiceProvider
@ServiceMode(value = Service.Mode.PAYLOAD)
public class ProviderBeanPayload implements Provider&lt;Source&gt;
{
   public Source invoke(Source req)
   {
      // Access the entire request PAYLOAD and return the response PAYLOAD
   }
}</pre><div class="para">
			<span class="property">Service.Mode.PAYLOAD</span> is the default and does not have to be declared explicitly. You can also use <span class="property">Service.Mode.MESSAGE</span> to access the entire SOAP message (for example, with <span class="property">MESSAGE</span> the Provider can also see SOAP Headers)
		</div></div><div class="section" id="idm139946670486288"><div class="titlepage"><div><div><h2 class="title">7.15.WebServiceContext</h2></div></div></div><div class="para">
			The <code class="classname">WebServiceContext</code> is treated as an injectable resource that can be set at the time an endpoint is initialized. The <code class="classname">WebServiceContext</code> object will then use thread-local information to return the correct information regardless of how many threads are concurrently being used to serve requests addressed to the same endpoint object.
		</div><pre class="programlisting JAVA JAVA">
@WebService
public class EndpointJSE
{
   @Resource
   WebServiceContext wsCtx;
 
   @WebMethod
   public String testGetMessageContext()
   {
      SOAPMessageContext jaxwsContext = (SOAPMessageContext)wsCtx.getMessageContext();
      return jaxwsContext != null ? "pass" : "fail";
   }
   ...
   @WebMethod
   public String testGetUserPrincipal()
   {
      Principal principal = wsCtx.getUserPrincipal();
      return principal.getName();
   }
  
   @WebMethod
   public boolean testIsUserInRole(String role)
   {
      return wsCtx.isUserInRole(role);
   }
}</pre></div><div class="section" id="idm139946670482528"><div class="titlepage"><div><div><h2 class="title">7.16.Web Service Clients</h2></div></div></div><div class="section" id="idm139946670481728"><div class="titlepage"><div><div><h3 class="title">7.16.1.Service</h3></div></div></div><div class="para">
				<code class="literal">Service</code> is an abstraction that represents a WSDL service. A WSDL service is a collection of related ports, each of which consists of a port type bound to a particular protocol and available at a particular endpoint address.
			</div><div class="para">
				For most clients, you will start with a set of stubs generated from the WSDL. One of these will be the service, and you will create objects of that class in order to work with the service (see "static case" below).
			</div><div class="section" id="idm139946670479072"><div class="titlepage"><div><div><h4 class="title">7.16.1.1.Service Usage</h4></div></div></div><div class="para"><div class="title">Static case</div><p>
						Most clients will start with a WSDL file, and generate some stubs using jbossws tools like <span class="emphasis"><em>wsconsume</em></span>. This usually gives a mass of files, one of which is the top of the tree. This is the service implementation class.
					</p></div><div class="para">
					The generated implementation class can be recognised as it will have two public constructors, one with no arguments and one with two arguments, representing the wsdl location (a java.net.URL) and the service name (a javax.xml.namespace.QName) respectively.
				</div><div class="para">
					Usually you will use the no-argument constructor. In this case the WSDL location and service name are those found in the WSDL. These are set implicitly from the WebServiceClient annotation that decorates the generated class.
				</div><div class="para">
					The following code snippet shows the generated constructors from the generated class:
				</div><pre class="programlisting JAVA JAVA">
// Generated Service Class
  
@WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
public class StockQuoteService extends javax.xml.ws.Service 
{

   public StockQuoteService() 
   {
      super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
   }
  
   public StockQuoteService(String wsdlLocation, QName serviceName) 
   {
      super(wsdlLocation, serviceName);
   }
  
   ...
}</pre><div class="para">
					Section <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Dynamic_Proxy" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Dynamic Proxy</a> explains how to obtain a port from the service and how to invoke an operation on the port. If you need to work with the XML payload directly or with the XML representation of the entire SOAP message, have a look at <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Dispatch" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Dispatch</a>.
				</div><div class="para"><div class="title">Dynamic case</div><p>
						In the dynamic case, when nothing is generated, a web service client uses <code class="literal">Service.create</code> to create Service instances, the following code illustrates this process.
					</p></div><pre class="programlisting JAVA JAVA">
URL wsdlLocation = new URL("http://example.org/my.wsdl");
QName serviceName = new QName("http://example.org/sample", "MyService");
Service service = Service.create(wsdlLocation, serviceName);</pre><div class="para">
					This is not the recommended way to use JBossWS.
				</div></div><div class="section" id="idm139946669663936"><div class="titlepage"><div><div><h4 class="title">7.16.1.2.Handler Resolver</h4></div></div></div><div class="para">
					JAX-WS provides a flexible plug-in framework for message processing modules, known as handlers, that may be used to extend the capabilities of a JAX-WS runtime system. <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Handler_Framework" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Handler Framework</a> describes the handler framework in detail. A <code class="classname">Service</code> instance provides access to a <code class="classname">HandlerResolver</code> via a pair of <code class="methodname">getHandlerResolver</code> and <code class="methodname">setHandlerResolver</code> methods that may be used to configure a set of handlers on a per-service, per-port or per-protocol binding basis.
				</div><div class="para">
					When a <code class="classname">Service</code> instance is used to create a proxy or a <code class="classname">Dispatch</code> instance then the handler resolver currently registered with the service is used to create the required handler chain. Subsequent changes to the handler resolver configured for a <code class="classname">Service</code> instance do not affect the handlers on previously created proxies, or <code class="classname">Dispatch</code> instances.
				</div></div><div class="section" id="idm139946669657088"><div class="titlepage"><div><div><h4 class="title">7.16.1.3.Executor</h4></div></div></div><div class="para">
					<code class="classname">Service</code> instances can be configured with a <code class="classname">java.util.concurrent.Executor</code>. The executor will then be used to invoke any asynchronous callbacks requested by the application. The <code class="methodname">setExecutor</code> and <code class="methodname">getExecutor</code> methods of <code class="classname">Service</code> can be used to modify and retrieve the executor configured for a service.
				</div></div></div><div class="section" id="idm139946669653088"><div class="titlepage"><div><div><h3 class="title">7.16.2.Dynamic Proxy</h3></div></div></div><div class="para">
				You can create an instance of a client proxy using one of <code class="methodname">getPort</code> methods on the <a href="http://java.sun.com/javaee/5/docs/api/javax/xml/ws/Service.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com"> <code class="classname">Service</code> </a>.
			</div><pre class="programlisting JAVA JAVA">
/** 
 * The getPort method returns a proxy. A service client
 * uses this proxy to invoke operations on the target
 * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
 * specifies the service endpoint interface that is supported by
 * the created dynamic proxy instance.
 */
public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
{
...
}
  
/** 
 * The getPort method returns a proxy. The parameter
 * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
 * endpoint interface that is supported by the returned proxy.
 * In the implementation of this method, the JAX-WS
 * runtime system takes the responsibility of selecting a protocol
 * binding (and a port) and configuring the proxy accordingly.
 * The returned proxy should not be reconfigured by the client.
 *
 */
public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
{
...
}</pre><div class="para">
				The <span class="emphasis"><em>Service Endpoint Interface</em></span> (SEI) is usually generated using tools. For details see <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSTools#TopDown_Using_wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Top Down (Using wsconsume)</a>.
			</div><div class="para">
				A generated static <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Service" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org"> <code class="classname">Service</code> </a> usually also offers typed methods to get ports. These methods also return dynamic proxies that implement the SEI.
			</div><pre class="programlisting JAVA JAVA">
@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref", 
  wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")
public class TestEndpointService extends Service
{
   ...
   
   public TestEndpointService(URL wsdlLocation, QName serviceName) {
      super(wsdlLocation, serviceName);
   }
   
   @WebEndpoint(name = "TestEndpointPort")
   public TestEndpoint getTestEndpointPort() 
   {
      return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
   }
}</pre></div><div class="section" id="idm139946669643872"><div class="titlepage"><div><div><h3 class="title">7.16.3.WebServiceRef</h3></div></div></div><div class="para">
				The <code class="classname">WebServiceRef</code> annotation is used to declare a reference to a Web service. It follows the resource pattern exemplified by the <code class="classname">javax.annotation.Resource</code> annotation in JSR-250 [5]
			</div><div class="para">
				There are two uses to the <code class="classname">WebServiceRef</code> annotation:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						To define a reference whose type is a generated service class. In this case, the type and value element will both refer to the generated service class type. Moreover, if the reference type can be inferred by the field or method declaration then the annotation is applied to the type, and value elements <span class="emphasis"><em>may</em></span> have the default value (<code class="classname">Object.class</code>, that is). If the type cannot be inferred, then at least the type element <span class="emphasis"><em>must</em></span> be present with a non-default value.
					</div></li><li class="listitem"><div class="para">
						To define a reference whose type is a SEI. In this case, the type element <span class="emphasis"><em>may</em></span> be present with its default value if the type of the reference can be inferred from the annotated field and method declaration, but the value element <span class="emphasis"><em>must</em></span> always be present and refer to a generated service class type (a subtype of <code class="classname">javax.xml.ws.Service</code>). The <span class="property">wsdlLocation</span> element, if present, overrides <span class="property">theWSDL</span> location information specified in the <code class="classname">WebService</code> annotation of the referenced generated service class.
					</div></li></ol></div><pre class="programlisting XML XML">
public class EJB3Client implements EJB3Remote
{
   @WebServiceRef
   public TestEndpointService service4;
   
   @WebServiceRef
   public TestEndpoint port3;
}</pre><div class="para"><div class="title">WebServiceRef Customization</div><p>
					In JBoss Enterprise Application Platform 5.0 we offer a number of overrides and extensions to the <code class="classname">WebServiceRef</code> annotation. These include:
				</p></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						define the port that should be used to resolve a container-managed port
					</div></li><li class="listitem"><div class="para">
						define default <span class="property">Stub</span> property settings for Stub objects
					</div></li><li class="listitem"><div class="para">
						define the URL of a final WSDL document to be used
					</div></li></ul></div><div class="para">
				Example:
			</div><pre class="programlisting XML XML">
&lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;
&lt;/service-ref&gt;
.. 
&lt;service-ref&gt;
   &lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;
   &lt;config-name&gt;Secure Client Config&lt;/config-name&gt;
   &lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;
   &lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;
&lt;/service-ref&gt;
  
&lt;service-ref&gt;
   &lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;
   &lt;service-class-name&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-class-name&gt;
   &lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;
   &lt;port-info&gt;
      &lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;
      &lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;
      &lt;stub-property&gt;
         &lt;name&gt;javax.xml.ws.security.auth.username&lt;/name&gt;
         &lt;value&gt;kermit&lt;/value&gt;
      &lt;/stub-property&gt;
      &lt;stub-property&gt;
         &lt;name&gt;javax.xml.ws.security.auth.password&lt;/name&gt;
         &lt;value&gt;thefrog&lt;/value&gt;
      &lt;/stub-property&gt;
   &lt;/port-info&gt;
&lt;/service-ref&gt;</pre></div><div class="section" id="idm139946669624176"><div class="titlepage"><div><div><h3 class="title">7.16.4.Dispatch</h3></div></div></div><div class="para">
				XML Web Services use XML messages for communication between services and service clients. The higher level JAX-WS APIs are designed to hide the details of converting between Java method invocations and the corresponding XML messages, but in some cases operating at the XML message level is desirable. The Dispatch interface provides support for this mode of interaction.
			</div><div class="para">
				Dispatch supports two usage modes, identified by the constants <span class="property">javax.xml.ws.Service.Mode.MESSAGE</span> and <span class="property">javax.xml.ws.Service.Mode.PAYLOAD</span> respectively:
			</div><div class="para"><div class="title">Message</div><p>
					In this mode, client applications work directly with protocol-specific message structures. For example, when used with a SOAP protocol binding, a client application would work directly with a SOAP message.
				</p></div><div class="para"><div class="title">Message Payload</div><p>
					In this mode, client applications work with the payload of messages rather than the messages themselves. For example, when used with a SOAP protocol binding, a client application would work with the contents of the SOAP Body rather than the SOAP message as a whole.
				</p></div><div class="para">
				Dispatch is a low level API that requires clients to construct messages or message payloads as XML and requires an intimate knowledge of the desired message or payload structure. Dispatch is a generic class that supports input and output of messages or message payloads of any type.
			</div><pre class="programlisting JAVA JAVA">
Service service = Service.create(wsdlURL, serviceName);
Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);
  
String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));
  
payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));
</pre></div><div class="section" id="idm139946669615712"><div class="titlepage"><div><div><h3 class="title">7.16.5.Asynchronous Invocations</h3></div></div></div><div class="para">
				The <code class="classname">BindingProvider</code> interface represents a component that provides a protocol binding for use by clients, it is implemented by proxies and is extended by the <code class="classname">Dispatch</code> interface.
			</div><div class="para">
				<code class="classname">BindingProvider</code> instances may provide asynchronous operation capabilities. When used, asynchronous operation invocations are decoupled from the <code class="classname">BindingProvider</code> instance at invocation time such that the response context is not updated when the operation completes. Instead a separate response context is made available using the <code class="classname">Response</code> interface.
			</div><pre class="programlisting JAVA JAVA">
public void testInvokeAsync() throws Exception
{
   URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
   QName serviceName = new QName(targetNS, "TestEndpointService");
   Service service = Service.create(wsdlURL, serviceName);
   TestEndpoint port = service.getPort(TestEndpoint.class);
  
   Response response = port.echoAsync("Async");
  
   // access future
   String retStr = (String) response.get();
   assertEquals("Async", retStr);
}
</pre></div><div class="section" id="idm139946676576512"><div class="titlepage"><div><div><h3 class="title">7.16.6.Oneway Invocations</h3></div></div></div><div class="para">
				<span class="property">@Oneway</span> indicates that the given web method has only an input message and no output. Typically, a one-way method returns the thread of control to the calling application prior to executing the actual business method.
			</div><pre class="programlisting JAVA JAVA">
@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl
{
   private static String feedback;
   ...
   @WebMethod
   @Oneway
   public void ping()
   {
      log.info("ping");
      feedback = "ok";
   }
   ...
   @WebMethod
   public String feedback()
   {
   log.info("feedback");
   return feedback;
   }
}</pre></div></div><div class="section" id="idm139946676573216"><div class="titlepage"><div><div><h2 class="title">7.17.Common API</h2></div></div></div><div class="para">
			This sections describes concepts that apply equally to <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Web_Service_Endpoints" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Web Service Endpoints</a> and <a href="http://www.jboss.org/community/wiki/JBossWS-UserGuide#Web_Service_Clients" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Web Service Clients</a>
		</div><div class="section" id="idm139946676570608"><div class="titlepage"><div><div><h3 class="title">7.17.1.Handler Framework</h3></div></div></div><div class="para">
				The handler framework is implemented by a JAX-WS protocol binding in both client and server side runtimes. Proxies, and Dispatch instances, known collectively as binding providers, each use protocol bindings to bind their abstract functionality to specific protocols.
			</div><div class="para">
				Client and server-side handlers are organized into an ordered list known as a handler chain. The handlers within a handler chain are invoked each time a message is sent or received. Inbound messages are processed by handlers prior to binding provider processing. Outbound messages are processed by handlers after any binding provider processing.
			</div><div class="para">
				Handlers are invoked with a message context that provides methods to access and modify inbound and outbound messages and to manage a set of properties. Message context properties may be used to facilitate communication between individual handlers and between handlers and client and service implementations. Different types of handlers are invoked with different types of message context.
			</div><div class="section" id="idm139946676567392"><div class="titlepage"><div><div><h4 class="title">7.17.1.1.Logical Handler</h4></div></div></div><div class="para">
					Handlers that only operate on message context properties and message payloads. Logical handlers are protocol agnostic and are unable to affect protocol specific parts of a message. Logical handlers are handlers that implement <code class="classname">javax.xml.ws.handler.LogicalHandler</code>.
				</div></div><div class="section" id="idm139946676565280"><div class="titlepage"><div><div><h4 class="title">7.17.1.2.Protocol Handler</h4></div></div></div><div class="para">
					Handlers that operate on message context properties and protocol specific messages. Protocol handlers are specific to a particular protocol and may access and change protocol specific aspects of a message. Protocol handlers are handlers that implement any interface derived from <code class="classname">javax.xml.ws.handler.Handler</code> except <code class="classname">javax.xml.ws.handler.LogicalHandler</code>.
				</div></div><div class="section" id="idm139946676562672"><div class="titlepage"><div><div><h4 class="title">7.17.1.3.Service endpoint handlers</h4></div></div></div><div class="para">
					On the service endpoint, handlers are defined using the <span class="property">@HandlerChain</span> annotation.
				</div><pre class="programlisting JAVA JAVA">
@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
public class SOAPEndpointSourceImpl
{
...
}</pre><div class="para">
					The location of the handler chain file supports 2 formats
				</div><div class="para">
					1. An absolute java.net.URL in externalForm. (ex: <a href="http://myhandlers.foo.com/handlerfile1.xml" class="mimir-link-warn" title="Mimir does not include content from: myhandlers.foo.com">http://myhandlers.foo.com/handlerfile1.xml</a>)
				</div><div class="para">
					2. A relative path from the source file or class file. (ex: bar/handlerfile1.xml)
				</div></div><div class="section" id="idm139946676557856"><div class="titlepage"><div><div><h4 class="title">7.17.1.4.Service client handlers</h4></div></div></div><div class="para">
					On the client side, handler can be configured using the <span class="property">@HandlerChain</span> annotation on the SEI or dynamically using the API.
				</div><pre class="programlisting JAVA JAVA">
Service service = Service.create(wsdlURL, serviceName);
Endpoint port = (Endpoint)service.getPort(Endpoint.class);
  
BindingProvider bindingProvider = (BindingProvider)port;
List&lt;Handler&gt; handlerChain = new ArrayList&lt;Handler&gt;();
handlerChain.add(new LogHandler());
handlerChain.add(new AuthorizationHandler());
handlerChain.add(new RoutingHandler());
bindingProvider.getBinding().setHandlerChain(handlerChain); // important!
</pre></div></div><div class="section" id="idm139946676554592"><div class="titlepage"><div><div><h3 class="title">7.17.2.Message Context</h3></div></div></div><div class="para">
				MessageContext is the super interface for all JAX-WS message contexts. It extends Map&lt;String,Object&gt; with additional methods and constants to manage a set of properties that enable handlers in a handler chain to share processing related state. For example, a handler may use the put method to insert a property in the message context that one or more other handlers in the handler chain may subsequently obtain via the get method.
			</div><div class="para">
				Properties are scoped as either APPLICATION or HANDLER. All properties are available to all handlers associated with particular endpoint. E.g., if a logical handler puts a property in the message context, that property will also be available to any protocol handlers in the chain during the execution. APPLICATION scoped properties are also made available to client applications and service endpoint implementations. The default scope for a property is HANDLER.
			</div><div class="section" id="idm139946676551968"><div class="titlepage"><div><div><h4 class="title">7.17.2.1.Accessing the message context</h4></div></div></div><div class="para">
					Users can access the message context in handlers or in endpoints via <code class="literal">@WebServiceContext</code> annotation.
				</div></div><div class="section" id="idm139946676550112"><div class="titlepage"><div><div><h4 class="title">7.17.2.2.Logical Message Context</h4></div></div></div><div class="para">
					LogicalMessageContext is passed to <code class="literal">Logical Handlers</code> at invocation time. LogicalMessageContext extends MessageContext with methods to obtain and modify the message payload, it does not provide access to the protocol specific aspects of a message. A protocol binding defines what component of a message are available via a logical message context. The SOAP binding defines that a logical handler deployed in a SOAP binding can access the contents of the SOAP body but not the SOAP headers whereas the XML/HTTP binding defines that a logical handler can access the entire XML payload of a message.
				</div></div><div class="section" id="idm139946676547696"><div class="titlepage"><div><div><h4 class="title">7.17.2.3.SOAP Message Context</h4></div></div></div><div class="para">
					SOAPMessageContext is passed to <code class="literal">SOAP handlers</code> at invocation time. SOAPMessageContext extends MessageContext with methods to obtain and modify the SOAP message payload.
				</div></div></div><div class="section" id="idm139946676545536"><div class="titlepage"><div><div><h3 class="title">7.17.3.Fault Handling</h3></div></div></div><div class="para">
				An implementation may throw a SOAPFaultException
			</div><pre class="programlisting JAVA JAVA">
public void throwSoapFaultException()
{
   SOAPFactory factory = SOAPFactory.newInstance();
   SOAPFault fault = factory.createFault("this is a fault string!", new QName("http://foo", "FooCode"));
   fault.setFaultActor("mr.actor");
   fault.addDetail().addChildElement("test");
   throw new SOAPFaultException(fault);
}
</pre><div class="para">
				or an application specific user exception
			</div><pre class="programlisting JAVA JAVA">
public void throwApplicationException() throws UserException
{
   throw new UserException("validation", 123, "Some validation error");
}
</pre><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						In case of the latter JBossWS generates the required fault wrapper beans at runtime if they are not part of the deployment
					</div></div></div>

			</div></div></div><div class="section" id="idm139946676539632"><div class="titlepage"><div><div><h2 class="title">7.18.DataBinding</h2></div></div></div><div class="section" id="idm139946676538832"><div class="titlepage"><div><div><h3 class="title">7.18.1.Using JAXB with non annotated classes</h3></div></div></div><div class="para">
				JAXB is heavily driven by Java Annotations on the Java Bindings. It currently doesn't support an external binding configuration.
			</div><div class="para">
				In order to support this, we built on a JAXB RI feature whereby it allows you to specify a RuntimeInlineAnnotationReader implementation during JAXBContext creation (see JAXBRIContext).
			</div><div class="para">
				We call this feature "JAXB Annotation Introduction" and we've made it available for general consumption i.e. it can be checked out, built and used from SVN:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://anonsvn.jboss.org/repos/jbossws/projects/jaxbintros/" class="mimir-link-warn" title="Mimir does not include content from: anonsvn.jboss.org">http://anonsvn.jboss.org/repos/jbossws/projects/jaxbintros/</a>
					</div></li></ul></div><div class="para">
				Complete documentation can be found here:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://wiki.jboss.org/wiki/Wiki.jsp?page=JAXBIntroductions" class="mimir-link-warn" title="Mimir does not include content from: wiki.jboss.org">JAXB Introductions</a>
					</div></li></ul></div></div></div><div class="section" id="idm139946676531040"><div class="titlepage"><div><div><h2 class="title">7.19.Attachments</h2></div></div></div><div class="para">
			JBoss-WS4EE relied on a deprecated attachments technology called SwA (SOAP with Attachments). SwA required soap/encoding which is disallowed by the WS-I Basic Profile. JBossWS provides support for WS-I AP 1.0, and MTOM instead.
		</div><div class="section" id="idm139946676529536"><div class="titlepage"><div><div><h3 class="title">7.19.1.MTOM/XOP</h3></div></div></div><div class="para">
				This section describes Message Transmission Optimization Mechanism (MTOM) and XML-binary Optimized Packaging (XOP), a means of more efficiently serializing XML Infosets that have certain types of content. The related specifications are
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://www.w3.org/TR/soap12-mtom/" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">SOAP Message Transmission Optimization Mechanism (MTOM)</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.w3.org/TR/xop10/" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">XML-binary Optimized Packaging (XOP)</a>
					</div></li></ul></div><div class="section" id="idm139946676524416"><div class="titlepage"><div><div><h4 class="title">7.19.1.1.Supported MTOM parameter types</h4></div></div></div><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col width="50%" class="c1"><!--Empty--></col><col width="50%" class="c2"><!--Empty--></col></colgroup><tbody><tr><td> <div class="para">
									image/jpeg
								</div>
								 </td><td> <div class="para">
									java.awt.Image
								</div>
								 </td></tr><tr><td> <div class="para">
									text/xml
								</div>
								 </td><td> <div class="para">
									javax.xml.transform.Source
								</div>
								 </td></tr><tr><td> <div class="para">
									application/xml
								</div>
								 </td><td> <div class="para">
									javax.xml.transform.Source
								</div>
								 </td></tr><tr><td> <div class="para">
									application/octet-stream
								</div>
								 </td><td> <div class="para">
									javax.activation.DataHandler
								</div>
								 </td></tr></tbody></table></div><div class="para">
					The above table shows a list of supported endpoint parameter types. The recommended approach is to use the <a href="http://java.sun.com/j2ee/1.4/docs/api/javax/activation/DataHandler.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">javax.activation.DataHandler</a> classes to represent binary data as service endpoint parameters.
				</div><div class="para">
					<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Microsoft endpoints tend to send any data as application/octet-stream. The only Java type that can easily cope with this ambiguity is javax.activation.DataHandler
						</div></div></div>

				</div></div><div class="section" id="idm139946676507520"><div class="titlepage"><div><div><h4 class="title">7.19.1.2.Enabling MTOM per endpoint</h4></div></div></div><div class="para">
					On the server side MTOM processing is enabled through the <code class="literal">@BindingType</code> annotation. JBossWS does handle SOAP1.1 and SOAP1.2. Both come with or without MTOM flavours:
				</div><div class="para">
					<span class="bold bold"><strong>MTOM enabled service implementations</strong></span>
				</div><pre class="programlisting JAVA JAVA">
package org.jboss.test.ws.jaxws.samples.xop.doclit;
  
import javax.ejb.Remote;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.xml.ws.BindingType;
  
@Remote
@WebService(targetNamespace = "http://org.jboss.ws/xop/doclit")
@SOAPBinding(style = SOAPBinding.Style.DOCUMENT, parameterStyle = SOAPBinding.ParameterStyle.BARE)
@BindingType(value="http://schemas.xmlsoap.org/wsdl/soap/http?mtom=true")                         (1)
public interface MTOMEndpoint
{
...
}</pre><div class="orderedlist"><ol><li class="listitem"><div class="para">
							The MTOM enabled SOAP 1.1 binding ID
						</div></li></ol></div><div class="para">
					<span class="bold bold"><strong>MTOM enabled clients</strong></span>
				</div><div class="para">
					Web service clients can use the same approach described above or rely on the <code class="literal">Binding</code> API to enable MTOM (Excerpt taken from the <code class="literal">org.jboss.test.ws.jaxws.samples.xop.doclit.XOPTestCase</code>):
				</div><pre class="programlisting JAVA JAVA">
...
Service service = Service.create(wsdlURL, serviceName);
port = service.getPort(MTOMEndpoint.class);
  
// enable MTOM
binding = (SOAPBinding)((BindingProvider)port).getBinding();
binding.setMTOMEnabled(true);
</pre><div class="para">
					<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							You might as well use the JBossWS configuration templates to setup deployment defaults.
						</div></div></div>

				</div></div></div><div class="section" id="idm139946676496080"><div class="titlepage"><div><div><h3 class="title">7.19.2.SwaRef</h3></div></div></div><div class="para">
				<a href="http://www.ws-i.org/Profiles/AttachmentsProfile-1.0-2004-08-24.html" class="mimir-link-warn" title="Mimir does not include content from: www.ws-i.org">WS-I Attachment Profile 1.0</a> defines mechanism to reference MIME attachment parts using <a href="http://www.ws-i.org/Profiles/AttachmentsProfile-1.0-2004-08-24.html#Referencing_Attachments_from_the_SOAP_Envelope" class="mimir-link-warn" title="Mimir does not include content from: www.ws-i.org">swaRef</a>. In this mechanism the content of XML element of type wsi:swaRef is sent as MIME attachment and the element inside SOAP Body holds the reference to this attachment in the CID URI scheme as defined by <a href="http://www.ietf.org/rfc/rfc2111.txt" class="mimir-link-warn" title="Mimir does not include content from: www.ietf.org">RFC 2111</a>.
			</div><div class="section" id="idm139946676492128"><div class="titlepage"><div><div><h4 class="title">7.19.2.1.Using SwaRef with JAX-WS endpoints</h4></div></div></div><div class="para">
					JAX-WS endpoints delegate all marshalling/unmarshalling to the JAXB API. The most simple way to enable SwaRef encoding for <code class="literal">DataHandler</code> types is to annotate a payload bean with the <code class="literal">@XmlAttachmentRef</code> annotation as shown below:
				</div><pre class="programlisting JAVA JAVA">
/**
 * Payload bean that will use SwaRef encoding
 */
@XmlRootElement
public class DocumentPayload
{
   private DataHandler data;
  
   public DocumentPayload()
   {
   }
  
   public DocumentPayload(DataHandler data)
   {
      this.data = data;
   }
  
   @XmlElement
   @XmlAttachmentRef
   public DataHandler getData()
   {
      return data;
   }
  
   public void setData(DataHandler data)
   {
      this.data = data;
   }
}</pre><div class="para">
					With document wrapped endpoints you may even specify the <code class="literal">@XmlAttachmentRef</code> annotation on the service endpoint interface:
				</div><pre class="programlisting JAVA JAVA">
@WebService
public interface DocWrappedEndpoint
{
   @WebMethod
   DocumentPayload beanAnnotation(DocumentPayload dhw, String test);
  
   @WebMethod
   @XmlAttachmentRef
   DataHandler parameterAnnotation(@XmlAttachmentRef DataHandler data, String test);
  
}</pre><div class="para">
					The message would then refer to the attachment part by CID:
				</div><pre class="programlisting XML XML">
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
   &lt;env:Header/&gt;
   &lt;env:Body&gt;
      &lt;ns2:parameterAnnotation xmlns:ns2='http://swaref.samples.jaxws.ws.test.jboss.org/'&gt;
         &lt;arg0&gt;cid:0-1180017772935-32455963@ws.jboss.org&lt;/arg0&gt;
         &lt;arg1&gt;Wrapped test&lt;/arg1&gt;
      &lt;/ns2:parameterAnnotation&gt;
   &lt;/env:Body&gt;
&lt;/env:Envelope&gt;
</pre></div><div class="section" id="idm139946676484864"><div class="titlepage"><div><div><h4 class="title">7.19.2.2.Starting from WSDL</h4></div></div></div><div class="para">
					If you chose the contract first approach then you need to ensure that any element declaration that should use SwaRef encoding simply refers to wsi:swaRef schema type:
				</div><pre class="programlisting XML XML">
&lt;element name="data" type="wsi:swaRef" 
xmlns:wsi="http://ws-i.org/profiles/basic/1.1/xsd"/&gt;
</pre><div class="para">
					Any wsi:swaRef schema type would then be mapped to DataHandler.
				</div></div></div></div><div class="section" id="idm139946676481632"><div class="titlepage"><div><div><h2 class="title">7.20.Tools</h2></div></div></div><div class="para">
			The JAX-WS tools provided by JBossWS can be used in a variety of ways. First we will look at server-side development strategies, and then proceed to the client. When developing a Web Service Endpoint (the server-side) you have the option of starting from Java (bottom-up development), or from the abstact contract (WSDL) that defines your service (top-down development). If this is a new service (no existing contract), the bottom-up approach is the fastest route; you only need to add a few annotations to your classes to get a service up and running. However, if you are developing a service with an already defined contract, it is far simpler to use the top-down approach, since the provided tool will generate the annotated code for you.
		</div><div class="para">
			Bottom-up use cases:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Exposing an already existing EJB3 bean as a Web Service
				</div></li><li class="listitem"><div class="para">
					Providing a new service, and you want the contract to be generated for you
				</div></li></ul></div><div class="para">
			Top-down use cases:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Replacing the implementation of an existing Web Service without breaking compatibility with older clients
				</div></li><li class="listitem"><div class="para">
					Exposing a service that conforms to a contract specified by a third party (e.g. a vender that calls you back using an already defined protocol).
				</div></li><li class="listitem"><div class="para">
					Creating a service that adheres to the XML Schema and WSDL you developed by hand up front
				</div></li></ul></div><div class="para">
			The following JAX-WS command line tools are included in JBossWS:
		</div><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col width="50%" class="c1"><!--Empty--></col><col width="50%" class="c2"><!--Empty--></col></colgroup><tbody><tr><td> <div class="para">
							<span class="bold bold"><strong>Command</strong></span>
						</div>
						 </td><td> <div class="para">
							<span class="bold bold"><strong>Description</strong></span>
						</div>
						 </td></tr><tr><td> <div class="para">
							<a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide</a>
						</div>
						 </td><td> <div class="para">
							Generates JAX-WS portable artifacts, and provides the abstract contract. Used for bottom-up development.
						</div>
						 </td></tr><tr><td> <div class="para">
							<a href="http://www.jboss.org/community/wiki/JBossWS-wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsconsume</a>
						</div>
						 </td><td> <div class="para">
							Consumes the abstract contract (WSDL and Schema files), and produces artifacts for both a server and client. Used for top-down and client development
						</div>
						 </td></tr><tr><td> <div class="para">
							<a href="http://www.jboss.org/community/wiki/JBossWS-wsrunclient" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsrunclient</a>
						</div>
						 </td><td> <div class="para">
							Executes a Java client (that has a main method) using the JBossWS classpath.
						</div>
						 </td></tr></tbody></table></div><div class="section" id="idm139946676454448"><div class="titlepage"><div><div><h3 class="title">7.20.1.Bottom-Up (Using wsprovide)</h3></div></div></div><div class="para">
				The bottom-up strategy involves developing the Java code for your service, and then annotating it using JAX-WS annotations. These annotations can be used to customize the contract that is generated for your service. For example, you can change the operation name to map to anything you like. However, all of the annotations have sensible defaults, so only the @WebService annotation is required.
			</div><div class="para">
				This can be as simple as creating a single class:
			</div><pre class="programlisting JAVA JAVA">
package echo;
  
@javax.jws.WebService
public class Echo
{
   public String echo(String input)
   {
      return input;
   }
}
</pre><div class="para">
				A JSE or EJB3 deployment can be built using this class, and it is the only Java code needed to deploy on JBossWS. The WSDL, and all other Java artifacts called "wrapper classes" will be generated for you at deploy time. This actually goes beyond the JAX-WS specification, which requires that wrapper classes be generated using an offline tool. The reason for this requirement is purely a vender implementation problem, and since we do not believe in burdening a developer with a bunch of additional steps, we generate these as well. However, if you want your deployment to be portable to other application servers, you will need to use a tool and add the generated classes to your deployment.
			</div><div class="para">
				This is the primary purpose of the <a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide</a> tool, to generate portable JAX-WS artifacts. Additionally, it can be used to "provide" the abstract contract (WSDL file) for your service. This can be obtained by invoking <a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide</a> using the "-w" option:
			</div><pre class="programlisting JAVA JAVA">
$ javac -d . -classpath jboss-jaxws.jar Echo.java
$ wsprovide -w echo.Echo
Generating WSDL:
EchoService.wsdl
Writing Classes:
echo/jaxws/Echo.class
echo/jaxws/EchoResponse.class
</pre><div class="para">
				Inspecting the WSDL reveals a service called EchoService:
			</div><pre class="programlisting XML XML">
&lt;service name='EchoService'&gt;
   &lt;port binding='tns:EchoBinding' name='EchoPort'&gt;
      &lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;
   &lt;/port&gt;
&lt;/service&gt;</pre><div class="para">
				As expected, this service defines one operation, "echo":
			</div><pre class="programlisting XML XML">
&lt;portType name='Echo'&gt;
   &lt;operation name='echo' parameterOrder='echo'&gt;
      &lt;input message='tns:Echo_echo'/&gt;
      &lt;output message='tns:Echo_echoResponse'/&gt;
   &lt;/operation&gt;
&lt;/portType&gt;</pre><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Remember that <span class="bold bold"><strong>when deploying on JBossWS you do not need to run this tool.</strong></span> You only need it for generating portable artifacts and/or the abstract contract for your service.
					</div></div></div>

			</div><div class="para">
				Let us create a POJO endpoint for deployment on JBoss Enterprise Application Platform. A simple <code class="filename">web.xml</code> needs to be created:
			</div><pre class="programlisting XML XML">
&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
version="2.4"&gt;
  
   &lt;servlet&gt;
      &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
      &lt;servlet-class&gt;echo.Echo&lt;/servlet-class&gt;
   &lt;/servlet&gt;
  
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Echo&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/Echo&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</pre><div class="para">
				The <code class="filename">web.xml</code> and the single class can now be used to create a WAR:
			</div><pre class="programlisting"> 
$ mkdir -p WEB-INF/classes
$ cp -rp echo WEB-INF/classes/
$ cp web.xml WEB-INF
$ jar cvf echo.war WEB-INF
added manifest
adding: WEB-INF/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/Echo.class(in = 340) (out= 247)(deflated 27%)
adding: WEB-INF/web.xml(in = 576) (out= 271)(deflated 52%)
</pre><div class="para">
				The war can then be deployed:
			</div><pre class="programlisting"> 
 cp echo.war &lt;replaceable&gt;$JBOSS_HOME&lt;/replaceable&gt;/server/default/deploy
</pre><div class="para">
				At deploy time JBossWS will internally invoke <a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide</a>, which will generate the WSDL. If deployment was successful, and you are using the default settings, it should be available here: <a href="http://localhost:8080/echo/Echo?wsdl" class="mimir-link-warn" title="Mimir does not include content from: localhost">http://localhost:8080/echo/Echo?wsdl</a>
			</div><div class="para">
				For a portable JAX-WS deployment, the wrapper classes generated earlier could be added to the deployment.
			</div></div><div class="section" id="idm139946676433600"><div class="titlepage"><div><div><h3 class="title">7.20.2.Top-Down (Using wsconsume)</h3></div></div></div><div class="para">
				The top-down development strategy begins with the abstract contract for the service, which includes the WSDL file and zero or more schema files. The <a href="http://www.jboss.org/community/wiki/JBossWS-wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsconsume</a> tool is then used to consume this contract, and produce annotated Java classes (and optionally sources) that define it.
			</div><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						wsconsume seems to have a problem with symlinks on unix systems
					</div></div></div>

			</div><div class="para">
				Using the WSDL file from the bottom-up example, a new Java implementation that adheres to this service can be generated. The "-k" option is passed to <a href="http://www.jboss.org/community/wiki/JBossWS-wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsconsume</a> to preserve the Java source files that are generated, instead of providing just classes:
			</div><pre class="programlisting"> 
  
$ wsconsume -k EchoService.wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
</pre><div class="para">
				The following table shows the purpose of each generated file:
			</div><div class="informaltable"><table class="lt-4-cols gt-7-rows"><colgroup><col width="50%" class="c1"><!--Empty--></col><col width="50%" class="c2"><!--Empty--></col></colgroup><tbody><tr><td> <div class="para">
								<span class="bold bold"><strong>File</strong></span>
							</div>
							 </td><td> <div class="para">
								<span class="bold bold"><strong>Purpose</strong></span>
							</div>
							 </td></tr><tr><td> <div class="para">
								Echo.java
							</div>
							 </td><td> <div class="para">
								Service Endpoint Interface
							</div>
							 </td></tr><tr><td> <div class="para">
								Echo_Type.java
							</div>
							 </td><td> <div class="para">
								Wrapper bean for request message
							</div>
							 </td></tr><tr><td> <div class="para">
								EchoResponse.java
							</div>
							 </td><td> <div class="para">
								Wrapper bean for response message
							</div>
							 </td></tr><tr><td> <div class="para">
								ObjectFactory.java
							</div>
							 </td><td> <div class="para">
								JAXB XML Registry
							</div>
							 </td></tr><tr><td> <div class="para">
								package-info.java
							</div>
							 </td><td> <div class="para">
								Holder for JAXB package annotations
							</div>
							 </td></tr><tr><td> <div class="para">
								EchoService.java
							</div>
							 </td><td> <div class="para">
								Used only by JAX-WS clients
							</div>
							 </td></tr></tbody></table></div><div class="para">
				Examining the Service Endpoint Interface reveals annotations that are more explicit than in the class written by hand in the bottom-up example, however, these evaluate to the same contract:
			</div><pre class="programlisting JAVA JAVA">
@WebService(name = "Echo", targetNamespace = "http://echo/")
public interface Echo
{
   @WebMethod
   @WebResult(targetNamespace = "")
   @RequestWrapper(localName = "echo", targetNamespace = "http://echo/", className = "echo.Echo_Type")
   @ResponseWrapper(localName = "echoResponse", targetNamespace = "http://echo/", className = "echo.EchoResponse")
   public String echo(@WebParam(name = "arg0", targetNamespace = "") String arg0);
}</pre><div class="para">
				The only missing piece (besides the packaging) is the implementation class, which can now be written using the above interface.
			</div><pre class="programlisting JAVA JAVA">
package echo;
  
@javax.jws.WebService(endpointInterface="echo.Echo")
public class EchoImpl implements Echo
{
   public String echo(String arg0)
   {
      return arg0;
   }
}
</pre></div><div class="section" id="idm139946658069872"><div class="titlepage"><div><div><h3 class="title">7.20.3.Client Side</h3></div></div></div><div class="para">
				Before going into detail on the client-side it is important to understand the decoupling concept that is central to Web Services. Web Services are not the best fit for internal RPC, even though they can be used in this way; there are much better technologies for achieving this (CORBA, and RMI for example). Web Services were designed specifically for interoperable coarse-grained correspondence. There is no expectation or guarantee that any party participating in a Web Service interaction will be at any particular location, running on any particular operating system, or written in any particular programming language. So because of this, it is important to clearly separate client and server implementations. The only thing they should have in common is the abstract contract definition. If, for whatever reason, your software does not adhere to this principal, then you should not be using Web Services. For the above reasons, the <span class="bold bold"><strong> <span class="emphasis"><em>recommended methodology for developing a client is</em></span> </strong></span> to follow <span class="bold bold"><strong> <span class="emphasis"><em>the top-down approach</em></span> </strong></span> , even if the client is running on the same server.
			</div><div class="para">
				Let's repeat the process of the top-down section, although using the deployed WSDL, instead of the one generated offline by <a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide</a>. The reason why we do this is just to get the right value for soap:address. This value must be computed at deploy time, since it is based on container configuration specifics. You could of course edit the WSDL file yourself, although you need to ensure that the path is correct.
			</div><div class="para">
				Offline version:
			</div><pre class="programlisting XML XML">
&lt;service name='EchoService'&gt;
   &lt;port binding='tns:EchoBinding' name='EchoPort'&gt;
      &lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;
   &lt;/port&gt;
&lt;/service&gt;</pre><div class="para">
				Online version:
			</div><pre class="programlisting XML XML">
&lt;service name="EchoService"&gt;
   &lt;port binding="tns:EchoBinding" name="EchoPort"&gt;
      &lt;soap:address location="http://localhost.localdomain:8080/echo/Echo"/&gt;
   &lt;/port&gt;
&lt;/service&gt;</pre><div class="para">
				Using the online deployed version with <a href="http://www.jboss.org/community/wiki/JBossWS-wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsconsume</a>:
			</div><pre class="programlisting">
$ wsconsume -k http://localhost:8080/echo/Echo?wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java</pre><div class="para">
				The one class that was not examined in the top-down section, was <code class="filename">EchoService.java</code>. Notice how it stores the location the WSDL was obtained from.
			</div><pre class="programlisting JAVA JAVA">
@WebServiceClient(name = "EchoService", targetNamespace = "http://echo/", wsdlLocation = "http://localhost:8080/echo/Echo?wsdl")
public class EchoService extends Service
{
   private final static URL ECHOSERVICE_WSDL_LOCATION;
  
   static
   {
      URL url = null;
      try
      {
         url = new URL("http://localhost:8080/echo/Echo?wsdl");
      }
      catch (MalformedURLException e)
      {
         e.printStackTrace();
      }
      ECHOSERVICE_WSDL_LOCATION = url;
   }
  
   public EchoService(URL wsdlLocation, QName serviceName)
   {
      super(wsdlLocation, serviceName);
   }
  
   public EchoService()
   {
      super(ECHOSERVICE_WSDL_LOCATION, new QName("http://echo/", "EchoService"));
   }
  
   @WebEndpoint(name = "EchoPort")
   public Echo getEchoPort()
   {
      return (Echo)super.getPort(new QName("http://echo/", "EchoPort"), Echo.class);
   }
}</pre><div class="para">
				As you can see, this generated class extends the main client entry point in JAX-WS, <code class="classname">javax.xml.ws.Service</code>. While you can use <code class="classname">Service</code> directly, this is far simpler since it provides the configuration info for you. The only method we really care about is the <code class="methodname">getEchoPort()</code> method, which returns an instance of our <code class="classname">Service Endpoint Interface</code>. Any Web Services operation can then be called by just invoking a method on the returned interface.
			</div><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						It is not recommended to refer to a remote WSDL URL in a production application. This causes network I/O every time you instantiate the Service Object. Instead, use the tool on a saved local copy, or use the URL version of the constructor to provide a new WSDL location.
					</div></div></div>

			</div><div class="para">
				All that is left to do, is write and compile the client:
			</div><pre class="programlisting JAVA JAVA">
import echo.*;
..
public class EchoClient
{
   public static void main(String args[])
   {
      if (args.length != 1)
      {
         System.err.println("usage: EchoClient &lt;message&gt;");
         System.exit(1);
      }
  
      EchoService service = new EchoService();
      Echo echo = service.getEchoPort();
      System.out.println("Server said: " + echo.echo(args[0]));
   } 
}</pre><div class="para">
				It can then be easily executed using the <a href="http://www.jboss.org/community/wiki/JBossWS-wsrunclient" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsrunclient</a> tool. This is just a convenience tool that invokes java with the needed classpath:
			</div><pre class="programlisting"> 
$ wsrunclient EchoClient 'Hello World!'
Server said: Hello World!
</pre><div class="para">
				It is easy to change the endpoint address of your operation at runtime, setting <span class="property">ENDPOINT_ADDRESS_PROPERTY</span> as shown below:
			</div><pre class="programlisting JAVA JAVA">
...
EchoService service = new EchoService();
Echo echo = service.getEchoPort();
  
/* Set NEW Endpoint Location */
String endpointURL = "http://NEW_ENDPOINT_URL";
BindingProvider bp = (BindingProvider)echo;
bp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointURL);
  
System.out.println("Server said: " + echo.echo(args[0]));
...</pre></div><div class="section" id="idm139946658045696"><div class="titlepage"><div><div><h3 class="title">7.20.4.Command-line &amp; Ant Task Reference</h3></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://www.jboss.org/community/wiki/JBossWS-wsconsume" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsconsume reference page</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.jboss.org/community/wiki/JBossWS-wsprovide" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsprovide reference page</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.jboss.org/community/wiki/JBossWS-wsrunclient" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">wsrunclient reference page</a>
					</div></li></ul></div></div><div class="section" id="idm139946658039248"><div class="titlepage"><div><div><h3 class="title">7.20.5.JAX-WS binding customization</h3></div></div></div><div class="para">
				An introduction to binding customizations:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html</a>
					</div></li></ul></div><div class="para">
				The schema for the binding customization files can be found here:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="https://jax-ws.dev.java.net/source/browse/jax-ws/guide/docs/wsdl-customization.xsd?rev=1.2&amp;view=log" class="mimir-link-warn" title="Mimir does not include content from: jax-ws.dev.java.net">binding customization</a>
					</div></li></ul></div></div></div><div class="section" id="idm139946658032640"><div class="titlepage"><div><div><h2 class="title">7.21.Web Service Extensions</h2></div></div></div><div class="section" id="idm139946658031840"><div class="titlepage"><div><div><h3 class="title">7.21.1.WS-Addressing</h3></div></div></div><div class="para">
				This section describes how <a href="http://www.w3.org/TR/ws-addr-core" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">WS-Addressing</a> can be used to provide a stateful service endpoint.
			</div><div class="section" id="idm139946658029792"><div class="titlepage"><div><div><h4 class="title">7.21.1.1.Specifications</h4></div></div></div><div class="para">
					WS-Addressing is defined by a combination of the following specifications from the W3C Recommendation. The WS-Addressing API is standardized by <a href="http://www.jcp.org/en/jsr/detail?id=224" class="mimir-link-warn" title="Mimir does not include content from: www.jcp.org">JSR-224 - Java API for XML-Based Web Services (JAX-WS)</a>
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a href="http://www.w3.org/TR/ws-addr-core" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">Web Services Addressing 1.0 - Core</a>
						</div></li><li class="listitem"><div class="para">
							<a href="http://www.w3.org/TR/ws-addr-soap" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">Web Services Addressing 1.0 - SOAP Binding</a>
						</div></li></ul></div></div><div class="section" id="idm139946658023664"><div class="titlepage"><div><div><h4 class="title">7.21.1.2.Addressing Endpoint</h4></div></div></div><div class="para">
					<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							The following information should not be used in conjuction with JBoss Web Services CXF Stack.
						</div></div></div>

				</div><div class="para">
					The following endpoint implementation has a set of operation for a typical stateful shopping chart application.
				</div><pre class="programlisting JAVA JAVA">
@WebService(name = "StatefulEndpoint", targetNamespace = "http://org.jboss.ws/samples/wsaddressing", serviceName = "TestService")
@Addressing(enabled=true, required=true)
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class StatefulEndpointImpl implements StatefulEndpoint, ServiceLifecycle
{
   @WebMethod
   public void addItem(String item)
   { ... }
  
   @WebMethod
   public void checkout()
   { ... }
  
   @WebMethod
   public String getItems()
   { ... }
}</pre><div class="para">
					It uses the JAX-WS 2.1 defined <code class="literal">javax.xml.ws.soap.Addressing</code> annotation to enable the server side addressing handler.
				</div></div><div class="section" id="idm139946658017920"><div class="titlepage"><div><div><h4 class="title">7.21.1.3.Addressing Client</h4></div></div></div><div class="para">
					The client code uses <code class="literal">javax.xml.ws.soap.AddressingFeature</code> feature from JAX-WS 2.1 API to enable the WS-Addressing.
				</div><pre class="programlisting JAVA JAVA">
Service service = Service.create(wsdlURL, serviceName);
port1 = (StatefulEndpoint)service.getPort(StatefulEndpoint.class,  new AddressingFeature());
</pre><div class="para">
					<span class="bold bold"><strong>A client connecting to the stateful endpoint</strong></span>
				</div><pre class="programlisting JAVA JAVA">
public class AddressingStatefulTestCase extends JBossWSTest
{
   ...
   public void testAddItem() throws Exception
   {
      port1.addItem("Ice Cream");
      port1.addItem("Ferrari");
  
      port2.addItem("Mars Bar");
      port2.addItem("Porsche");
   }
  
   public void testGetItems() throws Exception
   {
      String items1 = port1.getItems();
      assertEquals("[Ice Cream, Ferrari]", items1);
  
      String items2 = port2.getItems();
      assertEquals("[Mars Bar, Porsche]", items2);
   }
}</pre><div class="para">
					<span class="bold bold"><strong>SOAP message exchange</strong></span>
				</div><div class="para">
					Below you see the SOAP messages that are beeing exchanged.
				</div><pre class="programlisting XML XML">
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;
&lt;wsa:To&gt;uri:jbossws-samples-wsaddr/TestService&lt;/wsa:To&gt;
&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/action&lt;/wsa:Action&gt;
&lt;wsa:ReferenceParameters&gt;
&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;
&lt;/wsa:ReferenceParameters&gt;
&lt;/env:Header&gt;
&lt;env:Body&gt;
&lt;ns1:addItem xmlns:ns1='http://org.jboss.ws/samples/wsaddr'&gt;
&lt;String_1&gt;Ice Cream&lt;/String_1&gt;
&lt;/ns1:addItem&gt;
&lt;/env:Body&gt;
&lt;/env:Envelope&gt;
  
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;
&lt;wsa:To&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/wsa:To&gt;
&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/actionReply&lt;/wsa:Action&gt;
&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;
&lt;/env:Header&gt;
&lt;env:Body&gt;
&lt;ns1:addItemResponse xmlns:ns1='http://org.jboss.ws/samples/wsaddr'/&gt;
&lt;/env:Body&gt;
&lt;/env:Envelope&gt;
  
...
  
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;
&lt;wsa:To&gt;uri:jbossws-samples-wsaddr/TestService&lt;/wsa:To&gt;
&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/action&lt;/wsa:Action&gt;
&lt;wsa:ReferenceParameters&gt;
&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;
&lt;/wsa:ReferenceParameters&gt;
&lt;/env:Header&gt;
&lt;env:Body&gt;
&lt;ns1:getItems xmlns:ns1='http://org.jboss.ws/samples/wsaddr'/&gt;
&lt;/env:Body&gt;
&lt;/env:Envelope&gt;
  
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;
&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;
&lt;wsa:To&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/wsa:To&gt;
&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/actionReply&lt;/wsa:Action&gt;
&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;
&lt;/env:Header&gt;
&lt;env:Body&gt;
&lt;ns1:getItemsResponse xmlns:ns1='http://org.jboss.ws/samples/wsaddr'&gt;
&lt;result&gt;[Ice Cream, Ferrari]&lt;/result&gt;
&lt;/ns1:getItemsResponse&gt;
&lt;/env:Body&gt;
&lt;/env:Envelope&gt;
</pre></div></div><div class="section" id="idm139946658007248"><div class="titlepage"><div><div><h3 class="title">7.21.2.WS-Security</h3></div></div></div><div class="para">
				WS-Security addresses message level security. It standardizes authorization, encryption, and digital signature processing of web services. Unlike transport security models, such as SSL, WS-Security applies security directly to the elements of the web service message. This increases the flexibility of your web services, by allowing any message model to be used (for example, point to point, or multi-hop relay).
			</div><div class="para">
				This chapter describes how to use WS-Security to sign and encrypt a simple SOAP message.
			</div><div class="para">
				<span class="bold bold"><strong>Specifications</strong></span>
			</div><div class="para">
				WS-Security is defined by the combination of the following specifications:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf" class="mimir-link-warn" title="Mimir does not include content from: docs.oasis-open.org">SOAP Message Security 1.0</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf" class="mimir-link-warn" title="Mimir does not include content from: docs.oasis-open.org">Username Token Profile 1.0</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0.pdf" class="mimir-link-warn" title="Mimir does not include content from: docs.oasis-open.org">X.509 Token Profile 1.0</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.w3.org/TR/xmlenc-core" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">W3C XML Encryption</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.w3.org/TR/xmldsig-core" class="mimir-link-warn" title="Mimir does not include content from: www.w3.org">W3C XML Signature</a>
					</div></li><li class="listitem"><div class="para">
						<a href="http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html" class="mimir-link-warn" title="Mimir does not include content from: www.ws-i.org">Basic Security Profile 1.0 (Still in Draft)</a>
					</div></li></ul></div><div class="section" id="idm139946657992560"><div class="titlepage"><div><div><h4 class="title">7.21.2.1.Endpoint configuration</h4></div></div></div><div class="para">
					JBossWS uses handlers to identify ws-security encoded requests and invoke the security components to sign and encrypt messages. In order to enable security processing, the client and server side must include a corressponding handler configuration. The preferred way is to reference a predefined <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSEndpointConfiguration" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Endpoint Configuration</a> or <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSClientConfiguration" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Client Configuration</a> respectively.
				</div><div class="para">
					<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							You must setup both the endpoint configuration and the WSSE declarations. These are two separate steps.
						</div></div></div>

				</div></div><div class="section" id="idm139946657987216"><div class="titlepage"><div><div><h4 class="title">7.21.2.2.Server side WSSE declaration (jboss-wsse-server.xml)</h4></div></div></div><div class="para">
					In this example we configure both the client and the server to sign the message body. Both also require this from each other. So, if you remove either the client or the server security deployment descriptor, you will notice that the other party will throw a fault explaining that the message did not conform to the proper security requirements.
				</div><pre class="programlisting XML XML">
&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.jboss.com/ws-security/config 
http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
(1)  &lt;key-store-file&gt;WEB-INF/wsse.keystore&lt;/key-store-file&gt;
(2)  &lt;key-store-password&gt;jbossws&lt;/key-store-password&gt;
(3)  &lt;trust-store-file&gt;WEB-INF/wsse.truststore&lt;/trust-store-file&gt;
(4)  &lt;trust-store-password&gt;jbossws&lt;/trust-store-password&gt;
(5)  &lt;config&gt;
(6)     &lt;sign type="x509v3" alias="wsse"/&gt;
(7)     &lt;requires&gt;
(8)        &lt;signature/&gt;
        &lt;/requires&gt;
     &lt;/config&gt;
&lt;/jboss-ws-security&gt;
</pre><div class="orderedlist"><ol><li class="listitem"><div class="para">
							This specifies that the key store we wish to use is <code class="filename">WEB-INF/wsse.keystore</code>, which is located in our war file.
						</div></li><li class="listitem"><div class="para">
							This specifies that the store password is "jbossws". Password can be encypted using the {EXT} and {CLASS} commands. Please see samples for their usage.
						</div></li><li class="listitem"><div class="para">
							This specifies that the trust store we wish to use is <code class="filename">WEB-INF/wsse.truststore</code>, which is located in our war file.
						</div></li><li class="listitem"><div class="para">
							This specifies that the trust store password is also "jbossws". Password can be encrypted using the {EXT} and {CLASS} commands. Please see samples for their usage.
						</div></li><li class="listitem"><div class="para">
							Here we start our root config block. The root config block is the default configuration for all services in this war file.
						</div></li><li class="listitem"><div class="para">
							This means that the server must sign the message body of all responses. Type means that we are using X.509v3 certificate (a standard certificate). The alias option says that the certificate and key pair to use for signing is in the key store under the "wsse" alias
						</div></li><li class="listitem"><div class="para">
							Here we start our optional requires block. This block specifies all security requirements that must be met when the server receives a message.
						</div></li><li class="listitem"><div class="para">
							This means that all web services in this war file require the message body to be signed.
						</div></li></ol></div><div class="para">
					By default an endpoint does not use the WS-Security configuration. Users can use proprietary <code class="literal">@EndpointConfig</code> annotation to set the config name. See <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSEndpointConfiguration" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS_Endpoint_Configuration</a> for the list of available config names.
				</div><pre class="programlisting JAVA JAVA">
@WebService
@EndpointConfig(configName = "Standard WSSecurity Endpoint")
public class HelloJavaBean
{
...
}
</pre></div><div class="section" id="idm139946657971344"><div class="titlepage"><div><div><h4 class="title">7.21.2.3.Client side WSSE declaration (jboss-wsse-client.xml)</h4></div></div></div><pre class="programlisting language-xml XML XML">
&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.jboss.com/ws-security/config 
http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
(1)  &lt;config&gt;
(2)     &lt;sign type="x509v3" alias="wsse"/&gt;
(3)     &lt;requires&gt;
(4)        &lt;signature/&gt;
        &lt;/requires&gt;
     &lt;/config&gt;
&lt;/jboss-ws-security&gt;
</pre><div class="orderedlist"><ol><li class="listitem"><div class="para">
							Here we start our root config block. The root config block is the default configuration for all web service clients (Call, Proxy objects).
						</div></li><li class="listitem"><div class="para">
							This means that the client must sign the message body of all requests it sends. Type means that we are to use a X.509v3 certificate (a standard certificate). The alias option says that the certificate/key pair to use for signing is in the key store under the "wsse" alias
						</div></li><li class="listitem"><div class="para">
							Here we start our optional requires block. This block specifies all security requirements that must be met when the client receives a response.
						</div></li><li class="listitem"><div class="para">
							This means that all web service clients must receive signed response messages.
						</div></li></ol></div><div class="section" id="idm139946657964128"><div class="titlepage"><div><div><h5 class="title">7.21.2.3.1.Client side key store configuration</h5></div></div></div><div class="para">
						We did not specify a key store or trust store, because client apps instead use the wsse System properties instead. If this was a web or ejb client (meaning a webservice client in a war or ejb jar file), then we would have specified them in the client descriptor.
					</div><div class="para">
						Here is an excerpt from the JBossWS samples:
					</div><pre class="programlisting language-xml XML XML">
&lt;sysproperty key="org.jboss.ws.wsse.keyStore"
value="${tests.output.dir}/resources/jaxrpc/samples/wssecurity/wsse.keystore"/&gt;
&lt;sysproperty key="org.jboss.ws.wsse.trustStore" 
value="${tests.output.dir}/resources/jaxrpc/samples/wssecurity/wsse.truststore"/&gt;
&lt;sysproperty key="org.jboss.ws.wsse.keyStorePassword" value="jbossws"/&gt;
&lt;sysproperty key="org.jboss.ws.wsse.trustStorePassword" value="jbossws"/&gt;
&lt;sysproperty key="org.jboss.ws.wsse.keyStoreType" value="jks"/&gt;
&lt;sysproperty key="org.jboss.ws.wsse.trustStoreType" value="jks"/&gt;
</pre><div class="para">
						<span class="bold bold"><strong>SOAP message exchange</strong></span>
					</div><div class="para">
						Below you see the incomming SOAP message with the details of the security headers ommited. The idea is, that the SOAP body is still plain text, but it is signed in the security header and therefore can not be manipulated in transit.
					</div><pre class="programlisting XML XML">
&lt;env:Envelope xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"&gt;
&lt;env:Header&gt;
&lt;wsse:Security env:mustUnderstand="1" ...&gt;
&lt;wsu:Timestamp wsu:Id="timestamp"&gt;...&lt;/wsu:Timestamp&gt;
&lt;wsse:BinarySecurityToken ...&gt;
...
&lt;/wsse:BinarySecurityToken&gt;
&lt;ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
...
&lt;/ds:Signature&gt;
&lt;/wsse:Security&gt;
&lt;/env:Header&gt;
&lt;env:Body wsu:Id="element-1-1140197309843-12388840" ...&gt;
&lt;ns1:echoUserType xmlns:ns1="http://org.jboss.ws/samples/wssecurity"&gt;
&lt;UserType_1 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
&lt;msg&gt;Kermit&lt;/msg&gt;
&lt;/UserType_1&gt;
&lt;/ns1:echoUserType&gt;
&lt;/env:Body&gt;
&lt;/env:Envelope&gt;
</pre></div></div><div class="section" id="idm139946657956816"><div class="titlepage"><div><div><h4 class="title">7.21.2.4.Installing the BouncyCastle JCE provider</h4></div></div></div><div class="para">
					The information below has originaly been provided by <a href="http://www.bouncycastle.org/specifications.html#install" class="mimir-link-warn" title="Mimir does not include content from: www.bouncycastle.org">The Legion of the Bouncy Castle</a>.
				</div><div class="para">
					The provider can be configured as part of your environment via static registration by adding an entry to the <code class="filename">java.security</code> properties file (found in <code class="filename">$JAVA_HOME/jre/lib/security/java.security</code>, where <code class="filename">$JAVA_HOME</code> is the location of your JDK and JRE distribution). You will find detailed instructions in the file but basically it comes down to adding a line:
				</div><pre class="programlisting"> 
security.provider.&lt;n&gt;=org.bouncycastle.jce.provider.BouncyCastleProvider
</pre><div class="para">
					Where <code class="code">&lt;n&gt;</code> is the preference you want the provider at.
				</div><div class="para">
					<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Issues may arise if the Sun provided providers are not first.
						</div></div></div>

				</div><div class="para">
					Where users will put the provider jar is mostly up to them, although with jdk5 the best (and in some cases only) place to have it is in <code class="filename">$JAVA_HOME/jre/lib/ext</code>. Under Windows there will normally be a JRE and a JDK install of Java. If user think he have installed it correctly and it still doesn't work then with high probability the provider installation is not used.
				</div></div><div class="section" id="idm139946657948016"><div class="titlepage"><div><div><h4 class="title">7.21.2.5.Username Token Authentication<em><span class="remark">JBOSSCC-50</span></em>
				 </h4></div></div></div><div class="para">
					If you need to authenticate clients through a Username Token, the JAAS integration will verify the received token against the configured JBoss JAAS Security Domain.
				</div><div class="example" id="idm139946657945600"><p class="title"><strong>Example7.1.Basic Username Token Configuration</strong></p><div class="example-contents"><div class="para">
						To implement this feature, you must append a <span class="markup">&lt;jboss-ws-security&gt;</span> element to <code class="filename">jboss-wsse-client.xml</code> that contains the following information.
					</div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
                         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                         xsi:schemaLocation="http://www.jboss.com/ws-security/config 
                         http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
     &lt;config&gt;
(1)    &lt;username/&gt;
(2)    &lt;timestamp ttl="300"/&gt;
     &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre><div class="para">
						Line (2) specifies that a <span class="markup">&lt;timestamp&gt;</span> element must be present in the message and that the message can not be older than 300 seconds. The seconds limitation is used to prevent replay attacks.
					</div><div class="para">
						You must then specify the same <span class="markup">&lt;timestamp&gt;</span> element and <em class="parameter"><code>seconds</code></em> attribute in the <code class="filename">jboss-wsse-server.xml</code> file so both headers match. You must also specify the <span class="markup">&lt;requires/&gt; </span>element to enforce this condition.
					</div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.jboss.com/ws-security/config
                   http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
     &lt;config&gt;
          &lt;timestamp ttl="300"/&gt;
          &lt;requires/&gt;
     &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre></div></div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
						This example configuration results in simple text user information being sent in SOAP headers. You should strongly consider implementing JBossWS Secure Transport
					</div></div></div><div class="para"><div class="title">Password Digest, Nonces, and Timestamp</div><p>
						<a class="xref" href="#exam-Basic_Username_Token_Configuration">Example7.1, Basic Username Token Configuration</a> results in the client password being sent as plain text. You can use a combination of <em class="firstterm">digested passwords</em>, <em class="firstterm">nonces</em>, and <em class="firstterm">timestamps</em> to provide further protection from replay attacks.
					</p></div><div class="para">
					To enable password digesting, you must implement the following items as described in <a class="xref" href="#exam-Enable_Password_Digesting">Example7.2, Enable Password Digesting</a>:
				</div><div class="example" id="exam-Enable_Password_Digesting"><p class="title"><strong>Example7.2.Enable Password Digesting</strong></p><div class="example-contents"><div class="para">
						In the <span class="markup">&lt;username&gt;</span> element of the <code class="filename">jboss-wsse-client.xml</code> file:
					</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
								enable the <em class="parameter"><code>digestPassword</code></em> attribute
							</div></li><li class="listitem"><div class="para">
								enable the <em class="parameter"><code>nonces</code></em> and <em class="parameter"><code>timestamps</code></em> attributes.
							</div></li></ul></div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.jboss.com/ws-security/config
    http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
  &lt;config&gt;
(3)     &lt;username digestPassword="true" useNonce="true" useCreated="true"/&gt;
       &lt;timestamp ttl="300"/&gt;
  &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre></div></div><div class="para">
					In the <code class="filename">login-config.xml</code> file, you must also implement the UsernameTokenCallback module option.
				</div><div class="example" id="exam-UsernameTokenCallback_Module"><p class="title"><strong>Example7.3.UsernameTokenCallback Module</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;application-policy name="JBossWSDigest"&gt;
  &lt;authentication&gt;
    &lt;login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule" flag="required"&gt;
      &lt;module-option name="usersProperties"&gt;META-INF/jbossws-users.properties&lt;/module-option&gt;
      &lt;module-option name="rolesProperties"&gt;META-INF/jbossws-roles.properties&lt;/module-option&gt;
      &lt;module-option name="hashAlgorithm"&gt;SHA&lt;/module-option&gt;
      &lt;module-option name="hashEncoding"&gt;BASE64&lt;/module-option&gt;
      &lt;module-option name="hashUserPassword"&gt;false&lt;/module-option&gt;
      &lt;module-option name="hashStorePassword"&gt;true&lt;/module-option&gt;
      &lt;module-option name="storeDigestCallback"&gt;org.jboss.ws.extensions.security.auth.callback.UsernameTokenCallback&lt;/module-option&gt;
      &lt;module-option name="unauthenticatedIdentity"&gt;anonymous&lt;/module-option&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/application-policy&gt;</pre></div></div><div class="para">
					You may wish to use a more sophisticated custom login module to provide more security against replay attacks. You can use your own custom login module provided you implement the following:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							plug the <code class="classname">UsernameTokenCallback</code> callback into your login module
						</div></li><li class="listitem"><div class="para">
							extend the <code class="classname">org.jboss.security.auth.spi.UsernamePasswordLoginModule</code>
						</div></li><li class="listitem"><div class="para">
							set the hash attributes (<em class="parameter"><code>hashAlgorithm</code></em>, <em class="parameter"><code>hashEncoding</code></em>, <em class="parameter"><code>hashUserPassword</code></em>, <em class="parameter"><code>hashStorePassword</code></em>) as shown in <a class="xref" href="#exam-UsernameTokenCallback_Module">Example7.3, UsernameTokenCallback Module</a>.
						</div></li></ul></div><div class="para"><div class="title">Advanced Tuning - Nonce Factory</div><p>
						The way nonces are created, and subsequently checked and stored on the server side, influences overall security against replay attacks. Currently JBossWS ships with a basic implementation of a nonce store that does not cache the received tokens on the server side.
					</p></div><div class="para">
					More complex implementation can be plugged into your modules by implementing the <code class="interfacename">NonceFactory</code> and <code class="interfacename">NonceStore</code> interfaces. You can find these interfaces in the <span class="package">org.jboss.ws.extensions.security.nonce</span> package.
				</div><div class="para">
					Once included, you specify your factory class through the <span class="markup">&lt;nonce-factory-class&gt;</span> element in the <code class="filename">jboss-wsse-server.xml</code> file.
				</div><div class="para"><div class="title">Advanced Tuning - Timestamp Verification</div><p>
						If a Timestamp is present in the <code class="literal">wsse:Security</code> header, header verification does not allow for any tolerance whatsoever in the time comparisons. If the message appears to have been created even slightly in the future or if the message has just expired it will be rejected. A new element called <span class="markup">&lt;timestamp-verification&gt;</span> is available for the wsse configuration. <a class="xref" href="#exam-Timestamp-Verification_Configuration">Example7.4, &lt;timestamp-verification&gt; Configuration</a> describes the required attributes for the <span class="markup">&lt;timestamp-verification&gt;</span> element.
					</p></div><div class="example" id="exam-Timestamp-Verification_Configuration"><p class="title"><strong>Example7.4.&lt;timestamp-verification&gt; Configuration</strong></p><div class="example-contents"><div class="para">
						The <span class="markup">&lt;timestamp-verification&gt;</span> element attributes allow you to specify the tolerance in seconds that is used when verifying the 'Created' or 'Expires' element of the 'Timestamp' header.
					</div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns='http://www.jboss.com/ws-security/config'
                   xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
                   xsi:schemaLocation='http://www.jboss.com/ws-security/config     
                   http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd'&gt;
  &lt;timestamp-verification createdTolerance="5" warnCreated="false" expiresTolerance="10" warnExpires="false" /&gt;
&lt;/jboss-ws-security&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <em class="parameter"><code>createdTolerance</code></em> </span></dt><dd><div class="para">
									Number of seconds in the future a message will be accepted. The default value is <code class="literal">0</code>
								</div></dd><dt><span class="term"> <em class="parameter"><code>expiresTolerance</code></em> </span></dt><dd><div class="para">
									Number of seconds a message is rejected after being classed as expired. The default value is <code class="literal">0</code>.
								</div></dd><dt><span class="term"> <em class="parameter"><code>warnCreated</code></em> </span></dt><dd><div class="para">
									Specifies whether to log a warning message if a message is accepted with a 'Created' value in the future. The default value is <code class="literal">true</code>.
								</div></dd><dt><span class="term"> <em class="parameter"><code>warnExpires</code></em> </span></dt><dd><div class="para">
									Specifies whether to log a warning message if a message is accepted with an 'Expired' value in the past. The default value is <code class="literal">true</code>.
								</div></dd></dl></div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The <em class="parameter"><code>warnCreated</code></em> and <em class="parameter"><code>warnExpires</code></em> attributes can be used to identify accepted messages that would normally be rejected. You can use this data to identify clients that are out of sync with the server time, without rejecting the client messages.
					</div></div></div><div class="section" id="idm139946676817856"><div class="titlepage"><div><div><h5 class="title">7.21.2.5.1.Secure Transport</h5></div></div></div><div class="para">

					</div></div></div><div class="section" id="idm139946676815824"><div class="titlepage"><div><div><h4 class="title">7.21.2.6.X509 Certificate Token<em><span class="remark">JBOSSCC-50</span></em>
				 </h4></div></div></div><div class="para">
					By using X509v3 certificates, you can both sign and encrypt messages.
				</div><div class="para"><div class="title">Encryption</div><p>
						To configure encryption, you must specify the items in <a class="xref" href="#exam-X509_Encryption_Configuration">Example7.5, X509 Encryption Configuration</a>. The configuration is the same for clients and servers.
					</p></div><div class="example" id="exam-X509_Encryption_Configuration"><p class="title"><strong>Example7.5.X509 Encryption Configuration</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.jboss.com/ws-security/config
                   http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
(1) &lt;key-store-file&gt;WEB-INF/bob-sign_enc.jks&lt;/key-store-file&gt;
    &lt;key-store-password&gt;password&lt;/key-store-password&gt;
    &lt;key-store-type&gt;jks&lt;/key-store-type&gt;
    &lt;trust-store-file&gt;WEB-INF/wsse10.truststore&lt;/trust-store-file&gt;
    &lt;trust-store-password&gt;password&lt;/trust-store-password&gt;

    &lt;config&gt;
     &lt;timestamp ttl="300"/&gt;
(2)     &lt;sign type="x509v3" alias="1" includeTimestamp="true"/&gt;
(3)     &lt;encrypt type="x509v3"
              alias="alice"
              algorithm="aes-256"
              keyWrapAlgorithm="rsa_oaep"
              tokenReference="keyIdentifier" /&gt;
(4)         &lt;requires&gt;
            &lt;signature/&gt;
              &lt;encryption/&gt;      
            &lt;/requires&gt;
    &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre><div class="para">
						The server configuration includes the following encryption information:
					</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
								Keystore and Truststore information: location of each store, the password, and type of store.
							</div></li><li class="listitem"><div class="para">
								Signature configuration: you must provide the certificate and key pair aliases to use. <em class="parameter"><code>includeTimestamp</code></em> specifies whether the timestamp is signed to prevent tampering.
							</div></li><li class="listitem"><div class="para">
								Encryption configuration: you must provide the certificate and key pair aliases to use. Refer to <a class="xref" href="#form-Algorithms">Algorithms</a> for more information.
							</div></li><li class="listitem"><div class="para">
								Optional security requirements: incoming messages must be both signed, and encrypted.
							</div></li></ol></div></div></div><div class="para"><div class="title">Dynamic Encryption</div><p>
						When replying to multiple clients, a service provider must encrypt a message according to its destination using the correct public key. The JBossWS native implementation of WS-Security obtains the correct key to use from the signature received (and verified) in the incoming message.
					</p></div><div class="example" id="exam-Dynamic_Encryption_Configuration"><p class="title"><strong>Example7.6.Dynamic Encryption Configuration</strong></p><div class="example-contents"><div class="para">
						To configure dynamic encryption, do not specify any encryption alias on the server side (1), and declare that a signature is required (2).
					</div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
                   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                   xsi:schemaLocation="http://www.jboss.com/ws-security/config
                   http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
    &lt;key-store-file&gt;WEB-INF/bob-sign_enc.jks&lt;/key-store-file&gt;
    &lt;key-store-password&gt;password&lt;/key-store-password&gt;
    &lt;key-store-type&gt;jks&lt;/key-store-type&gt;
    &lt;trust-store-file&gt;WEB-INF/wsse10.truststore&lt;/trust-store-file&gt;
    &lt;trust-store-password&gt;password&lt;/trust-store-password&gt;

    &lt;config&gt;
     &lt;timestamp ttl="300"/&gt;
        &lt;sign type="x509v3" alias="1" includeTimestamp="true"/&gt;
(1)     &lt;encrypt type="x509v3"
              algorithm="aes-256"
              keyWrapAlgorithm="rsa_oaep"
               tokenReference="keyIdentifier" /&gt;
            &lt;requires&gt;
(2)         &lt;signature/&gt;
              &lt;encryption/&gt;      
           &lt;/requires&gt;
    &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre></div></div><div class="para"><div class="title">Algorithms</div><p>
						Asymmetric and symmetric encryption is performed whenever the <span class="markup">&lt;encrypt&gt;</span> element is declared. Message data are encrypted using a generated symmetric secured key. This key is written in the SOAP header after being encrypted (wrapped) with the receiver public key. You can set both the encryption and key wrap algorithms.
					</p></div><div class="para">
					The supported encryption algorithms include:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							AES 128 (aes-128) (default)
						</div></li><li class="listitem"><div class="para">
							AES 192 (aes-192)
						</div></li><li class="listitem"><div class="para">
							AES 256 (aes-256)
						</div></li><li class="listitem"><div class="para">
							Triple DES (triple-des)
						</div></li></ul></div><div class="para">
					The supported key-wrap algorithms include:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							RSA v1.5 (rsa_15) (default)
						</div></li><li class="listitem"><div class="para">
							RSA OAEP (rsa_oaep)
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The <a href="http://java.sun.com/javase/downloads/index.jsp" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">Unlimited Strength Java(TM) Cryptography Extension</a> installation might be required to run some strong algorithms (for example, aes-256). Your country may impose limitations on the allowed cryptographic strength in applications. It is your responsibility to select the encryption level suitable for your jurisdiction.
					</div></div></div><div class="para"><div class="title">Encryption Token Reference</div><p>
						For interoperability reasons, you may need to configure the type of reference to encryption token to be used. For example, Microsoft Indigo does not support direct reference to local binary security tokens which are the default reference type used by JBossWS.
					</p></div><div class="para">
					To configure this reference, you specify the <em class="parameter"><code>tokenReference</code></em> attribute in the <span class="markup">&lt;encrypt&gt;</span> element. The values for the <em class="parameter"><code>tokenReference</code></em> attribute are:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">directReference</code> (default)
						</div></li><li class="listitem"><div class="para">
							<code class="literal">keyIdentifier</code> - specifies the token data by means of an X509 SubjectKeyIdentifier reference.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">x509IssuerSerial</code> - uniquely identifies an end entity certificate by its X509 Issuer and Serial Number
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Complete information about X509 Token Profiles are available in the <em class="citetitle">WSS X501 Certificate Token Profile 1.0</em> document, which can be obtained from the <a href="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0.pdf" class="mimir-link-warn" title="Mimir does not include content from: docs.oasis-open.org">Oasis.org docs portal</a>.
					</div></div></div><div class="para"><div class="title">Targets Configuration</div><p>
						JBossWS gives you precise control over elements that must be signed or encrypted. This allows you to encrypt important data only (such as credit card numbers) instead of other, security-trivial, information exchanged by the same service (email addresses, for example). To configure this, you must specify the Qualified Name (qname) of the SOAP elements to encrypt. The default behavior is to encrypt the whole SOAP body.
					</p></div><pre class="programlisting language-xml XML XML">&lt;encrypt type="x509v3" alias="alice"&gt;
  &lt;targets&gt;
    &lt;target type="qname"&gt;{http://www.my-company.com/cc}CardNumber&lt;/target&gt;
    &lt;target type="qname"&gt;{http://www.my-company.com/cc}CardExpiration&lt;/target&gt;
    &lt;target type="qname" contentOnly="true"&gt;{http://www.my-company.com/cc}CustomerData&lt;/target&gt;
  &lt;/targets&gt;
&lt;/encrypt&gt;</pre><div class="para"><div class="title">Payload Carriage Returns</div><p>
						Signature verification errors can occur in signed message payloads that contain carriage returns (<code class="literal">\r</code>) due to the way the special character is parsed by XML parsers. To prevent this issue, you can choose to implement custom encoding before sending the payload. Users can either encrypt the message, or force JBossWS to perform canonical normalization of messages.
					</p></div><div class="para">
					The <span class="property">org.jboss.ws.DOMContentCanonicalNormalization</span> property can normalize the payload if set to <code class="literal">true</code> in the MessageContext. The property must be set just before the invocation on the client side and in the endpoint implementation.
				</div></div><div class="section" id="idm139946676765936"><div class="titlepage"><div><div><h4 class="title">7.21.2.7.JAAS Integration<em><span class="remark">JBOSSCC-50</span></em>
				 </h4></div></div></div><div class="para">
					The WS-Security implementation allows users to achieve J2EE declarative security through JAAS integration. The calling user's identity and credentials are derived from the wsse headers of the incoming message, according to the parameters provided in the server wsse configuration file. Authentication and authorization is subsequently achieved delegating to the JAAS login modules configured for the specified security domain.
				</div><div class="para"><div class="title">Username Token</div><p>
						Username Token Profile provides a mean of specifying the caller's username and password. The wsse server configuration file can be used to have those information used when performing authentication and authorization through configured login module.
					</p></div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.jboss.com/ws-security/config
                      http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
  &lt;config&gt;
    &lt;username/&gt;
    &lt;authenticate&gt;
      &lt;usernameAuth/&gt;
    &lt;/authenticate&gt;
  &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Prior to JBossWs 3.0.2 Native the username token was always used to set principal and credential of the caller whenever specified. This means that for backward compatibility reasons, this behavior is obtained also when no authenticate tag at all is specified and the username token is used.
					</div></div></div><div class="para"><div class="title">X.509 Certificate Token</div><p>
						In previous versions of JBossWS, the username token was always used to set the principal and credential of the caller whenever specified. This behavior is retained for backward compatibility reasons where no <span class="markup">&lt;authenticate&gt;</span> element is specified and the username token is used.
					</p></div><pre class="programlisting language-xml XML XML">&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.jboss.com/ws-security/config
                      http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
  &lt;key-store-file&gt;META-INF/bob-sign.jks&lt;/key-store-file&gt;
  &lt;key-store-password&gt;password&lt;/key-store-password&gt;
  &lt;key-store-type&gt;jks&lt;/key-store-type&gt;
  &lt;trust-store-file&gt;META-INF/wsse10.truststore&lt;/trust-store-file&gt;
  &lt;trust-store-password&gt;password&lt;/trust-store-password&gt;
  &lt;config&gt;
    &lt;sign type="x509v3" alias="1" includeTimestamp="false"/&gt;
    &lt;requires&gt;
      &lt;signature/&gt;
    &lt;/requires&gt;
    &lt;authenticate&gt;
(1)   &lt;signatureCertAuth certificatePrincipal="org.jboss.security.auth.certs.SubjectCNMapping"/&gt;
    &lt;/authenticate&gt;
  &lt;/config&gt;
&lt;/jboss-ws-security&gt;</pre><div class="para">
					The optional <em class="parameter"><code>certificatePrincipal</code></em> attribute (1) specifies the class used to retrieve the principal from the X.509 certificate's attributes. The selected class must extend <code class="classname">CertificatePrincipal</code>. The default class used when no attribute is specified is <code class="classname">org.jboss.security.auth.certs.SubjectDNMapping</code>.
				</div><div class="para">
					The configured security domain must have a correctly configured BaseCertLoginModule, as described in <a class="xref" href="#exam-BaseCertLoginModule_Security_Domain">Example7.7, BaseCertLoginModule Security Domain</a>.
				</div><div class="example" id="exam-BaseCertLoginModule_Security_Domain"><p class="title"><strong>Example7.7.BaseCertLoginModule Security Domain</strong></p><div class="example-contents"><div class="para">
						The following code sample shows a security domain with a <code class="classname">CertRolesLoginModule</code> that also enables authorization (using the specified <code class="filename">jbossws-roles.properties</code> file).
					</div><pre class="programlisting language-xml XML XML">&lt;application-policy name="JBossWSCert"&gt;
  &lt;authentication&gt;
    &lt;login-module code="org.jboss.security.auth.spi.CertRolesLoginModule" flag="required"&gt;
      &lt;module-option name="rolesProperties"&gt;jbossws-roles.properties&lt;/module-option&gt;
      &lt;module-option name="unauthenticatedIdentity"&gt;anonymous&lt;/module-option&gt;
      &lt;module-option name="securityDomain"&gt;java:/jaas/JBossWSCert&lt;/module-option&gt;
    &lt;/login-module&gt;
  &lt;/authentication&gt;
&lt;/application-policy&gt;</pre></div></div><div class="para">
					The BaseCertLoginModule uses a central keystore to authenticate users. This store is configured through the <code class="classname">org.jboss.security.plugins.JaasSecurityDomain</code> MBean as shown in <a class="xref" href="#exam-BaseCertLoginModule_Keystore">Example7.8, BaseCertLoginModule Keystore</a>.
				</div><div class="example" id="exam-BaseCertLoginModule_Keystore"><p class="title"><strong>Example7.8.BaseCertLoginModule Keystore</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;mbean code="org.jboss.security.plugins.JaasSecurityDomain"
       name="jboss.security:service=SecurityDomain"&gt;
  &lt;constructor&gt;
    &lt;arg type="java.lang.String" value="JBossWSCert"/&gt;
  &lt;/constructor&gt;
  &lt;attribute name="KeyStoreURL"&gt;resource:META-INF/keystore.jks&lt;/attribute&gt;
  &lt;attribute name="KeyStorePass"&gt;password&lt;/attribute&gt;
  &lt;depends&gt;jboss.security:service=JaasSecurityManager&lt;/depends&gt;
&lt;/mbean&gt;</pre></div></div><div class="para">
					At authentication time, the specified <code class="classname">CertificatePrincipal</code> mapping class accesses the keystore using the principal obtained from the associated wsse header. If a certificate is found and is the same as the one specified in the wsse header, the user is successfully authenticated.
				</div></div><div class="section" id="idm139946676741712"><div class="titlepage"><div><div><h4 class="title">7.21.2.8.POJO Endpoint Authentication and Authorization<em><span class="remark">JBOSSCC-50</span></em>
				 </h4></div></div></div><div class="para">
					The credentials obtained by WS-Security are generally used for EJB endpoints, or for POJO endpoints when they make a call to another secured resource. It is now possible to enable authentication and authorization checking for POJO endpoints.
				</div><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
						Authentication and Authorization should not be enabled for EJB based endpoints because the EJB container handles the security requirements of the deployed bean.
					</div></div></div><div class="procedure"><p class="title"><strong>Procedure7.1.Enabling POJO Authentication and Authorization</strong></p><div class="para">
						This procedure describes the additional configuration required to enable authentication and authorization for POJO endpoints.
					</div><ol class="1"><li class="step"><p class="title"><strong>Define Security Domain in Web Archive</strong></p><div class="para">
							You must define a security domain in the WAR containing the POJO.
						</div><div class="para">
							Specify a <span class="markup">&lt;security-domain&gt;</span> in the jboss-web deployment descriptor within the <code class="filename">/WEB-INF</code> folder.
						</div><pre class="programlisting language-xml XML XML">&lt;jboss-web&gt;
  &lt;security-domain&gt;java:/jaas/JBossWS&lt;/security-domain&gt;
&lt;/jboss-web&gt;</pre></li><li class="step"><p class="title"><strong>Configure the jboss-wsse-server.xml &lt;authorize&gt; element</strong></p><div class="para">
							Specify an &lt;authorize&gt; element within the &lt;config&gt; element.
						</div><div class="para">
							The <span class="markup">&lt;config&gt;</span> element can be defined globally, be port-specific, or operation-specific.
						</div><div class="para">
							The <span class="markup">&lt;authorize&gt;</span> element must contain either the <span class="markup">&lt;unchecked/&gt;</span> element or one or more <span class="markup">&lt;role&gt;</span> elements. Each <span class="markup">&lt;role&gt;</span> element must contain the name of a valid RoleName.
						</div><div class="para">
							You can choose to implement two types of authentication: unchecked, and role-based authentication.
						</div><div class="para"><div class="title">Unchecked Authentication</div><p>
								The authentication step is performed to validate the user's username and password, but no further role checking takes place. If the user's username and password are invalid, the request is rejected.
							</p></div><div class="example" id="idm139946676726704"><p class="title"><strong>Example7.9.Unchecked Authentication</strong></p><div class="example-contents"><pre class="programlisting">&lt;jboss-ws-security&gt;
  
  &lt;config&gt;
    &lt;authorize&gt;      
      &lt;unchecked/&gt;
    &lt;/authorize&gt;
  &lt;/config&gt;
  
&lt;/jboss-ws-security&gt;</pre></div></div><div class="para"><div class="title">Role-based Authentication</div><p>
								The user is authenticated using their username and password as per Unchecked Authentication. Once the user's username and password is verified, user credentials are checked again to ensure at least of of the roles specified in the <span class="markup">&lt;role&gt;</span> element is assigned to the user.
							</p></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
								Authentication and authorization proceeds even if no username and password, or certificate was provided in the request message. In this scenario, authentication may proceed if the security domain's login module has been configured with an anonymous identity.
							</div></div></div><div class="example" id="idm139946676721888"><p class="title"><strong>Example7.10.Role-based Authentication</strong></p><div class="example-contents"><pre class="programlisting">&lt;jboss-ws-security&gt;
  
  &lt;config&gt;
    &lt;authorize&gt;      
      &lt;role&gt;friend&lt;/role&gt;
      &lt;role&gt;family&lt;/role&gt;
    &lt;/authorize&gt;
  &lt;/config&gt;
  
&lt;/jboss-ws-security&gt;</pre></div></div></li></ol></div></div></div><div class="section" id="sect-XML_Registries"><div class="titlepage"><div><div><h3 class="title">7.21.3.XML Registries</h3></div></div></div><div class="para">
				J2EE 5.0 mandates support for Java API for XML Registries (JAXR). Inclusion of a XML Registry with the J2EE 5.0 certified Application Server is optional. JBoss EAP ships a UDDI v2.0 compliant registry, the Apache jUDDI registry. JAXR Capability Level 0 (UDDI Registries) is also supported through Apache Scout integration.
			</div><div class="para">
				<a class="xref" href="#sect-XML_Registries">Section7.21.3, XML Registries</a> describes how to configure the jUDDI registry in JBoss and some sample code outlines for using JAXR API to publish and query the jUDDI registry.
			</div><div class="section" id="idm139946676716192"><div class="titlepage"><div><div><h4 class="title">7.21.3.1.Apache jUDDI Configuration</h4></div></div></div><div class="para">
					jUDDI registry configuration happens via a MBean Service that is deployed in the <code class="filename">juddi-service.sar</code> archive in the "all" configuration. The configuration of this service can be done in the <code class="filename">jboss-service.xml</code> of the META-INF directory in the <code class="filename">juddi-service.sar</code>
				</div><div class="para">
					Let us look at the individual configuration items that can be changed.
				</div><div class="para">
					DataSources configuration
				</div><pre class="programlisting language-xml XML XML">
&lt;!-- Datasource to Database --&gt;
&lt;attribute name="DataSourceUrl"&gt;java:/DefaultDS&lt;/attribute&gt;
</pre><div class="para">
					Database Tables (Should they be created on start, Should they be dropped on stop, Should they be dropped on start etc)
				</div><pre class="programlisting language-xml XML XML">
&lt;!-- Should all tables be created on Start--&gt;
&lt;attribute name="CreateOnStart"&gt;false&lt;/attribute&gt;
&lt;!-- Should all tables be dropped on Stop--&gt;
&lt;attribute name="DropOnStop"&gt;true&lt;/attribute&gt;
&lt;!-- Should all tables be dropped on Start--&gt;
&lt;attribute name="DropOnStart"&gt;false&lt;/attribute&gt;
</pre><div class="para">
					JAXR Connection Factory to be bound in JNDI. (Should it be bound? and under what name?)
				</div><pre class="programlisting XML XML">&lt;!-- Should I bind a Context to which JaxrConnectionFactory bound--&gt;
&lt;attribute name="ShouldBindJaxr"&gt;true&lt;/attribute&gt;
  
&lt;!-- Context to which JaxrConnectionFactory to bind to. If you have remote clients, please bind it to the global namespace(default behavior). 
To just cater to clients running on the same VM as JBoss, change to java:/JAXR --&gt;
&lt;attribute name="BindJaxr"&gt;JAXR&lt;/attribute&gt;
</pre><div class="para">
					Other common configuration:
				</div><div class="para">
					Add authorized users to access the jUDDI registry. (Add a sql insert statement in a single line)
				</div><pre class="programlisting"> 
Look at the script META-INF/ddl/juddi_data.ddl for more details. Example for a user 'jboss'
  
INSERT INTO PUBLISHER (PUBLISHER_ID,PUBLISHER_NAME,
EMAIL_ADDRESS,IS_ENABLED,IS_ADMIN) 
VALUES ('jboss','JBoss User','jboss@xxx','true','true');
</pre></div><div class="section" id="idm139946676705856"><div class="titlepage"><div><div><h4 class="title">7.21.3.2.JBoss JAXR Configuration</h4></div></div></div><div class="para">
					In this section, we will discuss the configuration needed to run the JAXR API. The JAXR configuration relies on System properties passed to the JVM. The System properties that are needed are:
				</div><pre class="programlisting"> 
javax.xml.registry.ConnectionFactoryClass=org.apache.ws.scout.registry.
ConnectionFactoryImpl 
jaxr.query.url=http://localhost:8080/juddi/inquiry 
jaxr.publish.url=http://localhost:8080/juddi/publish
scout.proxy.transportClass=org.jboss.jaxr.scout.transport.SaajTransport
</pre><div class="para">
					Please remember to change the hostname from "localhost" to the hostname of the UDDI service/JBoss Server.
				</div><div class="para">
					You can pass the System Properties to the JVM in the following ways:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							When the client code is running inside JBoss (maybe a servlet or an EJB). Then you will need to pass the System properties in the <code class="filename">run.sh</code> or <code class="filename">run.bat</code> scripts to the java process via the <code class="code">"-D"</code> option.
						</div></li><li class="listitem"><div class="para">
							When the client code is running in an external JVM. Then you can pass the properties either as "-D" options to the java process or explicitly set them in the client code(not recommended).
						</div></li></ul></div><pre class="programlisting"> 
System.setProperty(propertyname, propertyvalue);
</pre></div><div class="section" id="idm139946676697920"><div class="titlepage"><div><div><h4 class="title">7.21.3.3.JAXR Sample Code</h4></div></div></div><div class="para">
					There are two categories of API: JAXR Publish API and JAXR Inquiry API. The important JAXR interfaces that any JAXR client code will use are the following.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a href="http://java.sun.com/javaee/5/docs/api/javax/xml/registry/RegistryService.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">javax.xml.registry.RegistryService</a> From J2EE 5.0 JavaDoc: "This is the principal interface implemented by a JAXR provider. A registry client can get this interface from a Connection to a registry. It provides the methods that are used by the client to discover various capability specific interfaces implemented by the JAXR provider."
						</div></li><li class="listitem"><div class="para">
							<a href="http://java.sun.com/javaee/5/docs/api/javax/xml/registry/BusinessLifeCycleManager.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">javax.xml.registry.BusinessLifeCycleManager</a> From J2EE 5.0 JavaDoc: "The <code class="classname">BusinessLifeCycleManager</code> interface, which is exposed by the Registry Service, implements the life cycle management functionality of the Registry as part of a business level API. There is no authentication information provided, because the Connection interface keeps that state and context on behalf of the client."
						</div></li><li class="listitem"><div class="para">
							<a href="http://java.sun.com/javaee/5/docs/api/javax/xml/registry/BusinessQueryManager.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">javax.xml.registry.BusinessQueryManager</a> From J2EE 5.0 JavaDoc: "The <code class="classname">BusinessQueryManager</code> interface, which is exposed by the Registry Service, implements the business style query interface. It is also referred to as the focused query interface."
						</div></li></ul></div><div class="para">
					Let us now look at some of the common programming tasks performed while using the JAXR API:
				</div><div class="para">
					Getting a JAXR Connection to the registry.
				</div><pre class="programlisting JAVA JAVA">
String queryurl = System.getProperty("jaxr.query.url", "http://localhost:8080/juddi/inquiry");
String puburl = System.getProperty("jaxr.publish.url", "http://localhost:8080/juddi/publish");
.. 
Properties props = new Properties();
props.setProperty("javax.xml.registry.queryManagerURL", queryurl);
props.setProperty("javax.xml.registry.lifeCycleManagerURL", puburl);
  
String transportClass = System.getProperty("scout.proxy.transportClass", "org.jboss.jaxr.scout.transport.SaajTransport");
System.setProperty("scout.proxy.transportClass", transportClass);
  
// Create the connection, passing it the configuration properties
factory = ConnectionFactory.newInstance();
factory.setProperties(props);
connection = factory.createConnection();
</pre><div class="para">
					Authentication with the registry.
				</div><pre class="programlisting JAVA JAVA">
/**
 * Does authentication with the uddi registry
 */
protected void login() throws JAXRException
{
   PasswordAuthentication passwdAuth = new PasswordAuthentication(userid, passwd.toCharArray());
   Set creds = new HashSet();
   creds.add(passwdAuth);
  
   connection.setCredentials(creds);
}
</pre><div class="para">
					Save a Business
				</div><pre class="programlisting JAVA JAVA">
/**
 * Creates a Jaxr Organization with 1 or more services
 */
protected Organization createOrganization(String orgname) throws JAXRException
{
   Organization org = blm.createOrganization(getIString(orgname));
   org.setDescription(getIString("JBoss Inc"));
   Service service = blm.createService(getIString("JBOSS JAXR Service"));
   service.setDescription(getIString("Services of XML Registry"));
   //Create serviceBinding
   ServiceBinding serviceBinding = blm.createServiceBinding();
   serviceBinding.setDescription(blm.createInternationalString("Test Service Binding"));
  
   //Turn validation of URI off
   serviceBinding.setValidateURI(false);
   serviceBinding.setAccessURI("http://testjboss.org");
   ...
   // Add the serviceBinding to the service
   service.addServiceBinding(serviceBinding);
  
   User user = blm.createUser();
   org.setPrimaryContact(user);
   PersonName personName = blm.createPersonName("Anil S");
   TelephoneNumber telephoneNumber = blm.createTelephoneNumber();
   telephoneNumber.setNumber("111-111-7777");
   telephoneNumber.setType(null);
   PostalAddress address = blm.createPostalAddress("111", "My Drive", "BuckHead", "GA", "USA", "1111-111", "");
   Collection postalAddresses = new ArrayList();
   postalAddresses.add(address);
   Collection emailAddresses = new ArrayList();
   EmailAddress emailAddress = blm.createEmailAddress("anil@apache.org");
   emailAddresses.add(emailAddress);
  
   Collection numbers = new ArrayList();
   numbers.add(telephoneNumber);
   user.setPersonName(personName);
   user.setPostalAddresses(postalAddresses);
   user.setEmailAddresses(emailAddresses);
   user.setTelephoneNumbers(numbers);
  
   ClassificationScheme cScheme = getClassificationScheme("ntis-gov:naics", "");
   Key cKey = blm.createKey("uuid:C0B9FE13-324F-413D-5A5B-2004DB8E5CC2");
   cScheme.setKey(cKey);
   Classification classification = blm.createClassification(cScheme, "Computer Systems Design and Related Services", "5415");
   org.addClassification(classification);
   ClassificationScheme cScheme1 = getClassificationScheme("D-U-N-S", "");
   Key cKey1 = blm.createKey("uuid:3367C81E-FF1F-4D5A-B202-3EB13AD02423");
   cScheme1.setKey(cKey1);
   ExternalIdentifier ei = blm.createExternalIdentifier(cScheme1, "D-U-N-S number", "08-146-6849");
   org.addExternalIdentifier(ei);
   org.addService(service);

   return org;
}
</pre><div class="para">
					Query a Business
				</div><pre class="programlisting JAVA JAVA">
/**
 * Locale aware Search a business in the registry
 */
public void searchBusiness(String bizname) throws JAXRException
{
   try
   {
      // Get registry service and business query manager
      this.getJAXREssentials();
  
      // Define find qualifiers and name patterns
      Collection findQualifiers = new ArrayList();
      findQualifiers.add(FindQualifier.SORT_BY_NAME_ASC);
      Collection namePatterns = new ArrayList();
      String pattern = "%" + bizname + "%";
      LocalizedString ls = blm.createLocalizedString(Locale.getDefault(), pattern);
      namePatterns.add(ls);
  
      // Find based upon qualifier type and values
      BulkResponse response = bqm.findOrganizations(findQualifiers, namePatterns, null, null, null, null);
  
      // check how many organisation we have matched
      Collection orgs = response.getCollection();
      if (orgs == null)
      {
         log.debug(" -- Matched 0 orgs");
      }
      else
      {
         log.debug(" -- Matched " + orgs.size() + " organizations -- ");
  
         // then step through them
         for (Iterator orgIter = orgs.iterator(); orgIter.hasNext();)
         {
            Organization org = (Organization)orgIter.next();
            log.debug("Org name: " + getName(org));
            log.debug("Org description: " + getDescription(org));
            log.debug("Org key id: " + getKey(org));
            checkUser(org);
            checkServices(org);
         }
      }
   }
   finally
   {
      connection.close();
   }
}
</pre><div class="para">
					For more examples of code using the JAXR API, please refer to the resources in the Resources Section.
				</div></div><div class="section" id="idm139946676678288"><div class="titlepage"><div><div><h4 class="title">7.21.3.4.Troubleshooting</h4></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>I cannot connect to the registry from JAXR.</strong></span> Please check the inquiry and publish url passed to the JAXR ConnectionFactory.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>I cannot connect to the jUDDI registry.</strong></span> Please check the jUDDI configuration and see if there are any errors in the server.log. And also remember that the jUDDI registry is available only in the "all" configuration.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>I cannot authenticate to the jUDDI registry.</strong></span> Have you added an authorized user to the jUDDI database, as described earlier in the chapter?
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>I would like to view the SOAP messages in transit between the client and the UDDI Registry.</strong></span> Please use the tcpmon tool to view the messages in transit. <a href="http://tcpmon.dev.java.net/" class="mimir-link-warn" title="Mimir does not include content from: tcpmon.dev.java.net">TCPMon</a>
						</div></li></ul></div></div><div class="section" id="idm139946676668880"><div class="titlepage"><div><div><h4 class="title">7.21.3.5.Resources</h4></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<a href="http://java.sun.com/webservices/jaxr/learning/tutorial/index.html" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">JAXR Tutorial and Code Camps</a>
						</div></li><li class="listitem"><div class="para">
							<a href="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/" class="mimir-link-warn" title="Mimir does not include content from: java.sun.com">J2EE 1.4 Tutorial</a>
						</div></li><li class="listitem"><div class="para">
							<a href="http://www.amazon.com/exec/obidos/ASIN/0321146182" class="mimir-link-warn" title="Mimir does not include content from: www.amazon.com">J2EE Web Services by Richard Monson-Haefel</a>
						</div></li></ul></div></div></div></div><div class="section" id="idm139946676661968"><div class="titlepage"><div><div><h2 class="title">7.22.JBossWS Extensions</h2></div></div></div><div class="para">
			This section describes propriatary JBoss extensions to JAX-WS.
		</div><div class="section" id="idm139946676660640"><div class="titlepage"><div><div><h3 class="title">7.22.1.Proprietary Annotations</h3></div></div></div><div class="para">
				For the set of standard annotations, please have a look at <a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSAnnotations" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Annotations</a>
			</div><div class="section" id="idm139946676658480"><div class="titlepage"><div><div><h4 class="title">7.22.1.1.EndpointConfig</h4></div></div></div><pre class="programlisting JAVA JAVA">/**
 * Defines an endpoint or client configuration. 
 * This annotation is valid on an endpoint implementaion bean or a SEI.
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = { ElementType.TYPE })
public @interface EndpointConfig
{
   ... 
   /**
    * The optional config-name element gives the configuration name that must be present in
    * the configuration given by element config-file.
    * 
    * Server side default: Standard Endpoint
    * Client side default: Standard Client
    */
   String configName() default "";
   ...
   /**
    * The optional config-file element is a URL or resource name for the configuration.
    *
    * Server side default: standard-jaxws-endpoint-config.xml
    * Client side default: standard-jaxws-client-config.xml
    */
   String configFile() default "";
}</pre></div><div class="section" id="idm139946676655936"><div class="titlepage"><div><div><h4 class="title">7.22.1.2.WebContext</h4></div></div></div><pre class="programlisting JAVA JAVA">/**
 * Provides web context specific meta data to EJB based web service endpoints.
 *
 * @author thomas.diesler@jboss.org
 * @since 26-Apr-2005
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = { ElementType.TYPE })
public @interface WebContext
{
   ... 
   /** 
    * The contextRoot element specifies the context root that the web service endpoint is deployed to.
    * If it is not specified it will be derived from the deployment short name.
    * 
    * Applies to server side port components only. 
    */
   String contextRoot() default "";
   ...
   /** 
    * The virtual hosts that the web service endpoint is deployed to.
    * 
    * Applies to server side port components only.
    */
   String[] virtualHosts() default {};
    
   /** 
    * Relative path that is appended to the contextRoot to form fully qualified
    * endpoint address for the web service endpoint.
    * 
    * Applies to server side port components only. 
    */
   String urlPattern() default "";
    
   /**
    * The authMethod is used to configure the authentication mechanism for the web service. 
    * As a prerequisite to gaining access to any web service which are protected by an authorization
    * constraint, a user must have authenticated using the configured mechanism.
    *
    * Legal values for this element are "BASIC", or "CLIENT-CERT".
    */
   String authMethod() default "";
   
   /**
    * The transportGuarantee specifies that the communication
    * between client and server should be NONE, INTEGRAL, or
    * CONFIDENTIAL. NONE means that the application does not require any
    * transport guarantees. A value of INTEGRAL means that the application
    * requires that the data sent between the client and server be sent in
    * such a way that it can't be changed in transit. CONFIDENTIAL means
    * that the application requires that the data be transmitted in a
    * fashion that prevents other entities from observing the contents of
    * the transmission. In most cases, the presence of the INTEGRAL or
    * CONFIDENTIAL flag will indicate that the use of SSL is required.
    */
   String transportGuarantee() default "";
    
   /**
    * A secure endpoint does not by default publish it's wsdl on an unsecure transport.
    * You can override this behaviour by explicitly setting the secureWSDLAccess flag to false.
    * 
    * Protect access to WSDL. See http://jira.jboss.org/jira/browse/JBWS-723   
    */
   boolean secureWSDLAccess() default true;
}</pre></div><div class="section" id="idm139946676651712"><div class="titlepage"><div><div><h4 class="title">7.22.1.3.SecurityDomain</h4></div></div></div><pre class="programlisting JAVA JAVA">/**
 * Annotation for specifying the JBoss security domain for an EJB
 */
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface SecurityDomain
{
   /**
    * The required name for the security domain.
    * 
    * Do not use the JNDI name
    * 
    *    Good: "MyDomain"
    *    Bad:  "java:/jaas/MyDomain"
    */
   String value();
   
   /**
    * The name for the unauthenticated pricipal
    */
   String unauthenticatedPrincipal() default "";
}</pre></div></div></div><div class="section" id="idm139946676649184"><div class="titlepage"><div><div><h2 class="title">7.23.Web Services Appendix</h2></div></div></div><div class="para">
			<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					This information can be used with JBoss Web Services CXF Stack.
				</div></div></div>

		</div><div class="para">
			<a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSEndpointConfiguration" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Endpoint Configuration</a>
		</div><div class="para">
			<a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSClientConfiguration" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Client Configuration</a>
		</div><div class="para">
			<a href="http://www.jboss.org/community/wiki/JBossWS-JAX-WSAnnotations" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JAX-WS Annotations</a>
		</div></div><div class="section" id="idm139946676642944"><div class="titlepage"><div><div><h2 class="title">7.24.References</h2></div></div></div><div class="orderedlist"><ol><li class="listitem"><div class="para">
					<a href="http://www.jcp.org/en/jsr/detail?id=224" class="mimir-link-warn" title="Mimir does not include content from: www.jcp.org">JSR-224 - Java API for XML-Based Web Services (JAX-WS) 2.0</a>
				</div></li><li class="listitem"><div class="para">
					<a href="http://jaxb.dev.java.net/" class="mimir-link-warn" title="Mimir does not include content from: jaxb.dev.java.net">JSR 222 - Java Architecture for XML Binding (JAXB) 2.0</a>
				</div></li><li class="listitem"><div class="para">
					<a href="http://jcp.org/en/jsr/detail?id=250" class="mimir-link-warn" title="Mimir does not include content from: jcp.org">JSR-250 - Common Annotations for the Java Platform</a>
				</div></li><li class="listitem"><div class="para">
					<a href="http://jcp.org/en/jsr/detail?id=181" class="mimir-link-warn" title="Mimir does not include content from: jcp.org">JSR 181 - Web Services Metadata for the Java Platform</a>
				</div></li></ol></div></div></div><div xml:lang="en-US" class="chapter" id="jboss_aop" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter8.JBoss AOP</h2></div></div></div><div class="para">
		<a id="idm139946674818768" class="indexterm"><!--Empty--></a> <a id="idm139946673862448" class="indexterm"><!--Empty--></a> JBoss AOP is a 100% Pure Java Aspected Oriented Framework usable in any programming environment or tightly integrated with our application server. Aspects allow you to more easily modularize your code base when regular object oriented programming just doesn't fit the bill. It can provide a cleaner separation from application logic and system code. It provides a great way to expose integration points into your software. Combined with JDK 1.5 Annotations, it also is a great way to expand the Java language in a clean pluggable way rather than using annotations solely for code generation.
	</div><div class="para">
		JBoss AOP is not only a framework, but also a prepackaged set of aspects that are applied via annotations, pointcut expressions, or dynamically at runtime. Some of these include caching, asynchronous communication, transactions, security, remoting, and many many more.
	</div><div class="para">
		An aspect is a common feature that is typically scattered across methods, classes, object hierarchies, or even entire object models. It is behavior that looks and smells like it should have structure, but you can't find a way to express this structure in code with traditional object-oriented techniques.
	</div><div class="para">
		For example, metrics is one common aspect. To generate useful logs from your application, you have to (often liberally) sprinkle informative messages throughout your code. However, metrics is something that your class or object model really shouldn't be concerned about. After all, metrics is irrelevant to your actual application: it doesn't represent a customer or an account, and it doesn't realize a business rule. It's simply orthogonal.
	</div><div class="section" id="idm139946675763376"><div class="titlepage"><div><div><h2 class="title">8.1.Some key terms</h2></div></div></div><div class="para"><div class="title">Joinpoint</div><p>
				A <span class="emphasis"><em>joinpoint</em></span> is any point in your Java program. The call of a method, the execution of a constructor, the access of a field; all these are joinpoints. You could also think of a joinpoint as a particular Java event, where an event is a method call, constructor call, field access, etc.
			</p></div><div class="para"><div class="title">Invocation</div><p>
				An <span class="emphasis"><em>invocation</em></span> is a JBoss AOP class that encapsulates what a joinpiont is at runtime. It could contain information like which method is being called, the arguments of the method, etc.
			</p></div><div class="para"><div class="title">Advice</div><p>
				An <span class="emphasis"><em>advice</em></span> is a method that is called when a particular joinpoint is executed, such as the behavior that is triggered when a method is called. It could also be thought of as the code that performs the interception. Another analogy is that an advice is an "event handler".
			</p></div><div class="para"><div class="title">Pointcut</div><p>
				<span class="emphasis"><em>Pointcuts</em></span> are AOP's expression language. Just as a regular expression matches strings, a pointcut expression matches a particular joinpoint.
			</p></div><div class="para"><div class="title">Introduction</div><p>
				An <span class="emphasis"><em>introduction</em></span> modifies the type and structure of a Java class. It can be used to force an existing class to implement an interface or to add an annotation to anything.
			</p></div><div class="para"><div class="title">Aspect</div><p>
				An <span class="emphasis"><em>aspect</em></span> is a plain Java class that encapsulates any number of advices, pointcut definitions, mixins, or any other JBoss AOP construct.
			</p></div><div class="para"><div class="title">Interceptor</div><p>
				An <span class="emphasis"><em>interceptor</em></span> is an aspect with only one advice, named <code class="literal">invoke</code>. It is a specific interface that you can implement if you want your code to be checked by forcing your class to implement an interface. It also will be portable and can be reused in other JBoss environments like EJBs and JMX MBeans.
			</p></div><div class="para">
			In AOP, a feature like metrics is called a <span class="emphasis"><em>crosscutting concern</em></span>, as it is a behavior that "cuts" across multiple points in your object models, yet is distinctly different. As a development methodology, AOP recommends that you abstract and encapsulate crosscutting concerns.
		</div><div class="para">
			For example, let's say you wanted to add code to an application to measure the amount of time it would take to invoke a particular method. In plain Java, the code would look something like the following.
		</div><pre class="programlisting JAVA JAVA">public class BankAccountDAO
{
 public void withdraw(double amount)
 {
  long startTime = System.currentTimeMillis();
  try
  {
   // Actual method body...
  }
  finally
  {
   long endTime = System.currentTimeMillis() - startTime;
   System.out.println("withdraw took: " + endTime);
  }
 }
}</pre><div class="para">
			While this code works, there are a few problems with this approach: 
			<div class="orderedlist"><ol><li class="listitem"><div class="para">
						It's extremely difficult to turn metrics on and off, as you have to manually add the code in the <code class="code">try</code>/<code class="code">finally</code> blocks to each and every method or constructor you want to benchmark.
					</div></li><li class="listitem"><div class="para">
						Profiling code should not be combined with your application code. It makes your code more verbose and difficult to read, since the timings must be enclosed within the <code class="code">try</code>/<code class="code">finally</code> blocks.
					</div></li><li class="listitem"><div class="para">
						If you wanted to expand this functionality to include a method or failure count, or even to register these statistics to a more sophisticated reporting mechanism, you'd have to modify a lot of different files (again).
					</div></li></ol></div>

		</div><div class="para">
			This approach to metrics is very difficult to maintain, expand, and extend, because it is dispersed throughout your entire code base. In many cases, OOP may not always be the best way to add metrics to a class.
		</div><div class="para">
			Aspect-oriented programming gives you a way to encapsulate this type of behavior functionality. It allows you to add behavior such as metrics "around" your code. For example, AOP provides you with programmatic control to specify that you want calls to <code class="classname">BankAccountDAO</code> to go through a metrics aspect before executing the actual body of that code.
		</div></div><div class="section" id="idm139946670376432"><div class="titlepage"><div><div><h2 class="title">8.2.Creating Aspects in JBoss AOP</h2></div></div></div><div class="para">
			<a id="idm139946670375344" class="indexterm"><!--Empty--></a> In short, all AOP frameworks define two things: a way to implement crosscutting concerns, and a programmatic construct  a programming language or a set of tags to specify how you want to apply those snippets of code. Let's take a look at how JBoss AOP, its cross-cutting concerns, and how you can implement a metrics aspect in JBoss Enterprise Application Platform.
		</div><div class="para">
			The first step in creating a metrics aspect in JBoss AOP is to encapsulate the metrics feature in its own Java class. The following code extracts the <code class="code">try</code>/<code class="code">finally</code> block in our first code example's <code class="methodname">BankAccountDAO.withdraw()</code> method into <code class="literal">Metrics</code>, an implementation of a JBoss AOP Interceptor class.
		</div><div class="para">
			The following example code demonstrates implementing metrics in a JBoss AOP Interceptor
		</div><pre class="programlisting JAVA JAVA">01. public class Metrics implements org.jboss.aop.advice.Interceptor
02. {
03.   public Object invoke(Invocation invocation) throws Throwable
04.   {
05.     long startTime = System.currentTimeMillis();
06.     try
07.     {
08.       return invocation.invokeNext();
09.     }
10.     finally
11.     {
12.       long endTime = System.currentTimeMillis() - startTime;
13.       java.lang.reflect.Method m = ((MethodInvocation)invocation).method;
14.       System.out.println("method " + m.toString() + " time: " + endTime + "ms");
15.     }
16.   }
17. }</pre><div class="para">
			Under JBoss AOP, the Metrics class wraps <code class="methodname">withdraw()</code>: when calling code invokes <code class="methodname">withdraw()</code>, the AOP framework breaks the method call into its parts and encapsulates those parts into an Invocation object. The framework then calls any aspects that sit between the calling code and the actual method body.
		</div><div class="para">
			When the AOP framework is done dissecting the method call, it calls <code class="classname">Metrics</code>'s invoke method at line 3. Line 8 wraps and delegates to the actual method and uses an enclosing <code class="code">try</code>/<code class="code">finally</code> block to perform the timings. Line 13 obtains contextual information about the method call from the <code class="classname">Invocation</code> object, while line 14 displays the method name and the calculated metrics.
		</div><div class="para">
			Having the <code class="classname">Metrics</code> code within its own object allows us to easily expand and capture additional measurements later on. Now that metrics are encapsulated into an aspect, let's see how to apply it.
		</div></div><div class="section" id="idm139946670527168"><div class="titlepage"><div><div><h2 class="title">8.3.Applying Aspects in JBoss AOP</h2></div></div></div><div class="para">
			<a id="idm139946670526080" class="indexterm"><!--Empty--></a> To apply an aspect, you define when to execute the aspect code. Those points in execution are called <span class="emphasis"><em>pointcuts</em></span>. An analogy to a pointcut is a regular expression. Where a regular expression matches strings, a pointcut expression matches events or <span class="emphasis"><em>points</em></span> within your application. For example, a valid pointcut definition would be, "for all calls to the JDBC method <code class="methodname">executeQuery()</code>, call the aspect that verifies SQL syntax."
		</div><div class="para">
			An entry point could be a field access, or a method or constructor call. An event could be an exception being thrown. Some AOP implementations use languages akin to queries to specify pointcuts. Others use tags. JBoss AOP uses both.
		</div><div class="para">
			The following listing demonstrates defining a pointcut for the Metrics example in JBoss AOP:
		</div><pre class="programlisting XML XML">1. &lt;bind pointcut="public void com.mc.BankAccountDAO-&gt;withdraw(double amount)"&gt;
2.       &lt;interceptor class="com.mc.Metrics"/&gt;
3. &lt;/bind &gt;
    
4. &lt;bind pointcut="* com.mc.billing.*-&gt;*(..)"&gt;
5.       &lt;interceptor class="com.mc.Metrics"/&gt;
6. &lt;/bind &gt;
</pre><div class="para">
			Lines 1-3 define a pointcut that applies the <code class="literal">metrics</code> aspect to the specific method <code class="methodname">BankAccountDAO.withdraw()</code>. Lines 4-6 define a general pointcut that applies the <code class="literal">metrics</code> aspect to all methods in all classes in the <code class="filename">com.mc.billing</code> package. There is also an optional annotation mapping if you prefer to avoid XML. For more information, see the JBoss AOP reference documentation.
		</div><div class="para">
			JBoss AOP has a rich set of pointcut expressions that you can use to define various points or events in your Java application. Once your points are defined, you can apply aspects to them. You can attach your aspects to a specific Java class in your application or you can use more complex compositional pointcuts to specify a wide range of classes within one expression.
		</div><div class="para">
			With AOP, as this example shows, you can combine all crosscutting behavior into one object and apply it easily and simply, without complicating your code with features unrelated to business logic. Instead, common crosscutting concerns can be maintained and extended in one place.
		</div><div class="para">
			Note that code within the <code class="classname">BankAccountDAO</code> class does not detect that it is being profiled. Profiling is part of what aspect-oriented programmers deem orthogonal concerns. In the object-oriented programming code snippet at the beginning of this chapter, profiling was part of the application code. AOP allows you to remove that code. A modern promise of middleware is transparency, and AOP clearly delivers.
		</div><div class="para">
			Orthogonal behavior can also be included after development. In object-oriented code, monitoring and profiling must be added at development time. With AOP, a developer or an administrator can easily add monitoring and metrics as needed without touching the code. This is a very subtle but significant part of AOP, as this separation allows aspects to be layered on top of or below the code that they cut across. A layered design allows features to be added or removed at will. For instance, perhaps you snap on metrics only when you're doing some benchmarks, but remove it for production. With AOP, this can be done without editing, recompiling, or repackaging the code.
		</div></div><div class="section" id="idm139946670514592"><div class="titlepage"><div><div><h2 class="title">8.4.Packaging AOP Applications</h2></div></div></div><div class="para">
			To deploy an AOP application in JBoss Enterprise Application Platform you need to package it. AOP is packaged similarly to SARs (MBeans). You can either deploy an XML file directly in the <code class="filename">deploy/</code> directory with the signature <code class="filename">*-aop.xml</code> along with your package (this is how the <code class="filename">base-aop.xml</code>, included in the <code class="filename">jboss-aop.deployer</code> file works) or you can include it in the JAR file containing your classes. If you include your XML file in your JAR, it must have the file extension <code class="filename">.aop</code> and a <code class="filename">jboss-aop.xml</code> file must be contained in a <code class="filename">META-INF</code> directory, for instance: <code class="filename">META-INF/jboss-aop.xml</code>.
		</div><div class="para">
			In the JBoss Enterprise Application Platform 5, you <span class="emphasis"><em>must</em></span> specify the schema used, otherwise your information will not be parsed correctly. You do this by adding the <code class="varname">xmlns="urn:jboss:aop-beans:1:0</code> attribute to the root <code class="literal">aop</code> element, as shown here:
		</div><pre class="programlisting">
&lt;aop xmlns="urn:jboss:aop-beans:1.0"&gt;
&lt;/aop&gt;
</pre><div class="para">
			If you want to create anything more than a non-trivial example, using the <code class="filename">.aop</code> JAR files, you can make any top-level deployment contain an AOP file containing the XML binding configuration. For instance you can have an AOP file in an EAR file, or an AOP file in a WAR file. The bindings specified in the <code class="filename">META-INF/jboss-aop.xml</code> file contained in the AOP file will affect all the classes in the whole WAR file.
		</div><div class="para">
			To pick up an AOP file in an EAR file, it must be listed in the <code class="filename">.ear/META-INF/application.xml</code> as a Java module, as follows:
		</div><pre class="programlisting">
&lt;?xml version='1.0'  encoding='UTF-8'?&gt;
&lt;!DOCTYPE application PUBLIC '-//Sun Microsystems, Inc.//DTD J2EE Application 1.2//EN''http://java.sun.com/j2ee/dtds/application_1_2.dtd'&gt;
 
&lt;application&gt;
    &lt;display-name&gt;AOP in JBoss example&lt;/display-name&gt;
    &lt;module&gt;
        &lt;java&gt;example.aop&lt;/java&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;ejb&gt;aopexampleejb.jar&lt;/ejb&gt;
    &lt;/module&gt;
    &lt;module&gt;
        &lt;web&gt;
            &lt;web-uri&gt;aopexample.war&lt;/web-uri&gt;
            &lt;context-root&gt;/aopexample&lt;/context-root&gt;
        &lt;/web&gt;
    &lt;/module&gt;
&lt;/application&gt;
</pre><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
				In the JBoss Enterprise Application Platform 5, the contents of the <code class="filename">.ear</code> file are deployed in the order they are listed in the <code class="filename">application.xml</code>. When using loadtime weaving the bindings listed in the <code class="filename">example.aop</code> file must be deployed before the classes being advised are deployed, so that the bindings exist in the system before (for example) the <code class="classname">ejb</code> and <code class="classname">servlet</code> classes are loaded. This is acheived by listing the AOP file at the start of the <code class="filename">application.xml</code>. Other types of archives are deployed before anything else and so do not require special consideration, such as <code class="filename">.sar</code> and <code class="filename">.war</code> files.
			</div></div></div></div><div class="section" id="idm139946675025616"><div class="titlepage"><div><div><h2 class="title">8.5.The JBoss AspectManager Service</h2></div></div></div><div class="para">
			The <code class="classname">AspectManager</code> Service can be managed at runtime using the JMX console, which is found at <code class="filename">http://localhost:8080/jmx-console</code>. It is registered under the ObjectName <code class="literal">jboss.aop:service=AspectManager</code>. If you want to configure it on startup you need to edit some configuration files.
		</div><div class="para">
			In JBoss Enterprise Application Platform 5 the <code class="classname">AspectManager</code> Service is configured using a JBoss Microcontainer bean. The configuration file is <code class="filename">jboss-as/server/xxx/conf/bootstrap/aop.xml</code>. The <code class="classname">AspectManager</code> Service is deployed with the following XML:
		</div><pre class="programlisting">
    &lt;bean name="AspectManager" class="org.jboss.aop.deployers.AspectManagerJDK5"&gt;
     
    &lt;property name="jbossIntegration"&gt;&lt;inject bean="AOPJBossIntegration"/&gt;&lt;/property&gt;
                               
    &lt;property name="enableLoadtimeWeaving"&gt;false&lt;/property&gt;
    &lt;!-- only relevant when EnableLoadtimeWeaving is true.
    When transformer is on, every loaded class gets transformed.
    If AOP can't find the class, then it throws an exception.  
    Sometimes, classes may not have all the classes they reference.  
    So, the Suppressing is needed.  (For instance, JBoss cache in the default configuration) --&gt;
    
    &lt;property name="suppressTransformationErrors"&gt;true&lt;/property&gt;
    
    &lt;property name="prune"&gt;true&lt;/property&gt;
    
    &lt;property name="include"&gt;org.jboss.test., org.jboss.injbossaop.&lt;/property&gt;
    
    &lt;property name="exclude"&gt;org.jboss.&lt;/property&gt;
    &lt;!-- This avoids instrumentation of hibernate cglib enhanced proxies
    
    &lt;property name="ignore"&gt;*$$EnhancerByCGLIB$$*&lt;/property&gt; --&gt;
    
    &lt;property name="optimized"&gt;true&lt;/property&gt;
    
    &lt;property name="verbose"&gt;false&lt;/property&gt;
    &lt;!-- Available choices for this attribute are: org.jboss.aop.instrument.ClassicInstrumentor (default)
    org.jboss.aop.instrument.GeneratedAdvisorInstrumentor --&gt;
    
    &lt;!-- &lt;property name="instrumentor"&gt;org.jboss.aop.instrument.ClassicInstrumentor&lt;/property&gt;--&gt;
    
    &lt;!-- By default the deployment of the aspects contained in 
    ../deployers/jboss-aop-jboss5.deployer/base-aspects.xml
    are not deployed. To turn on deployment uncomment this property
    &lt;property name="useBaseXml"&gt;true&lt;/property&gt;--&gt;
&lt;/bean&gt;
</pre><div class="para">
			Later we will talk about changing the class of the <code class="classname">AspectManager</code> Service. To do this, replace the contents of the <code class="varname">class</code> attribute of the <code class="classname">bean</code> element.
		</div></div><div class="section" id="running-as-sun-jdk"><div class="titlepage"><div><div><h2 class="title">8.6.Loadtime transformation in the JBoss Enterprise Application Platform Using Sun JDK</h2></div></div></div><div class="para">
			The JBoss Enterprise Application Platform has special integration with JDK to do loadtime transformations. This section explains how to use it.
		</div><div class="para">
			If you want to do load-time transformations with JBoss Enterprise Application Platform 5 and Sun JDK, these are the steps you must take.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Set the <code class="varname">enableLoadtimeWeaving</code> attribute/property to <code class="literal">true</code>. By default, JBoss Application Server will not do load-time bytecode manipulation of AOP files unless this is set. If <code class="varname">suppressTransformationErrors</code> is <code class="literal">true</code>, failed bytecode transformation will only give an error warning. This flag is needed because sometimes a JBoss deployment will not include all of the classes referenced.
				</div></li><li class="listitem"><div class="para">
					Copy the <code class="filename">pluggable-instrumentor.jar</code> from the <code class="filename">lib/</code> directory of your JBoss AOP distribution to the <code class="filename">bin/</code> directory of your JBoss Enterprise Application Platform.
				</div></li><li class="listitem"><div class="para">
					Next edit <code class="filename">run.sh</code> or <code class="literal">run.bat</code> (depending on what OS you're on) and add the following to the <code class="varname">JAVA_OPTS</code> environment variable:
				</div><pre class="programlisting">
set JAVA_OPTS=%JAVA_OPTS% -Dprogram.name=%PROGNAME% -javaagent:pluggable-instrumentor.jar
</pre></li></ul></div><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
				The class of the AspectManager Service must be <code class="literal">org.jboss.aop.deployers.AspectManagerJDK5</code> or <code class="literal">org.jboss.aop.deployment.AspectManagerServiceJDK5</code> as these are what work with the <code class="code">-javaagent</code> option.
			</div></div></div></div><div class="section" id="idm139946672797888"><div class="titlepage"><div><div><h2 class="title">8.7.JRockit</h2></div></div></div><div class="para">
			JRockit also supports the <code class="code">-javaagent</code> switch mentioned in <a class="xref" href="#running-as-sun-jdk">Section8.6, Loadtime transformation in the JBoss Enterprise Application Platform Using Sun JDK</a>. If you wish to use that, then the steps in <a class="xref" href="#running-as-sun-jdk">Section8.6, Loadtime transformation in the JBoss Enterprise Application Platform Using Sun JDK</a> are sufficient. However, JRockit also comes with its own framework for intercepting when classes are loaded, which might be faster than the <code class="code">-javaagent</code> switch. If you want to do load-time transformations using the special JRockit hooks, these are the steps you must take.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Set the <code class="literal">enableLoadtimeWeaving</code> attribute/property to true. By default, JBoss Enterprise Application Platform will not do load-time bytecode manipulation of AOP files unless this is set. If <code class="varname">suppressTransformationErrors</code> is <code class="literal">true</code>, failed bytecode transformation will only give an error warning. This flag is needed because sometimes a JBoss deployment will not include all the classes referenced.
				</div></li><li class="listitem"><div class="para">
					Copy the <code class="filename">jrockit-pluggable-instrumentor.jar</code> from the <code class="filename">lib/</code> directory of your JBoss AOP distribution to the <code class="filename">bin/</code> directory of your the JBoss Enterprise Application Platform installation.
				</div></li><li class="listitem"><div class="para">
					Next edit <code class="filename">run.sh</code> or <code class="filename">run.bat</code> (depending on what OS you're on) and add the following to the <code class="varname">JAVA_OPTS</code> and <code class="varname">JBOSS_CLASSPATH</code> environment variables:
				</div><pre class="programlisting">
# Setup JBoss specific properties

JAVA_OPTS="$JAVA_OPTS -Dprogram.name=$PROGNAME \

-Xmanagement:class=org.jboss.aop.hook.JRockitPluggableClassPreProcessor"

JBOSS_CLASSPATH="$JBOSS_CLASSPATH:jrockit-pluggable-instrumentor.jar"
</pre></li><li class="listitem"><div class="para">
					Set the class of the <code class="classname">AspectManager</code> Service to <code class="literal">org.jboss.aop.deployers.AspectManagerJRockit</code> on JBoss Enterprise Application Platform 5, or <code class="literal">org.jboss.aop.deployment.AspectManagerService</code> as these are what work with special hooks in JRockit.
				</div></li></ul></div></div><div class="section" id="idm139946672783088"><div class="titlepage"><div><div><h2 class="title">8.8.Improving Loadtime Performance in the JBoss Enterprise Application Platform Environment</h2></div></div></div><div class="para">
			The same rules apply to the JBoss Enterprise Application Platform for tuning loadtime weaving performance as standalone Java. Switches such as pruning, optimized, include and exclude are configured through the <code class="filename">jboss-5.x.x.GA/server/xxx/conf/aop.xml</code> file talked about earlier in this chapter.
		</div></div><div class="section" id="idm139946672781072"><div class="titlepage"><div><div><h2 class="title">8.9.Scoping the AOP to the classloader</h2></div></div></div><div class="para">
			By default all deployments in JBoss are global to the whole application server. That means that any EAR, SAR, or JAR (for example), that is put in the deploy directory can see the classes from any other deployed archive. Similarly, AOP bindings are global to the whole virtual machine. This <span class="emphasis"><em>global</em></span> visibility can be turned off per top-level deployment.
		</div><div class="section" id="idm139946672779104"><div class="titlepage"><div><div><h3 class="title">8.9.1.Deploying as part of a scoped classloader</h3></div></div></div><div class="para">
				The following process may change in future versions of JBoss AOP. If you deploy an AOP file as part of a scoped archive, the bindings (for instance) applied within the <code class="filename">.aop/META-INF/jboss-aop.xml</code> file will only apply to the classes within the scoped archive and not to anything else in the application server. Another alternative is to deploy <code class="filename">-aop.xml</code> files as part of a service archive (SAR). Again, if the SAR is scoped, the bindings contained in the <code class="filename">-aop.xml</code> files will only apply to the contents of the SAR file. It is not currently possible to deploy a standalone <code class="filename">-aop.xml</code> file and have that attach to a scoped deployment. Standalone <code class="filename">-aop.xml</code> files will apply to classes in the whole application server.
			</div></div><div class="section" id="idm139946672774880"><div class="titlepage"><div><div><h3 class="title">8.9.2.Attaching to a scoped deployment</h3></div></div></div><div class="para">
				If you have an application that uses classloader isolation, as long as you have prepared your classes, you can later attach an AOP file to that deployment. If we have an EAR file scoped using a <code class="filename">jboss-app.xml</code> file, with the scoped loader repository <code class="literal">jboss.test:service=scoped</code>:
			</div><pre class="programlisting">
&lt;jboss-app&gt;
    &lt;loader-repository&gt;
        jboss.test:service=scoped
    &lt;/loader-repository&gt;
&lt;/jboss-app&gt;
</pre><div class="para">
				We can later deploy an AOP file containing aspects and configuration to attach that deployment to the scoped EAR. This is done using the <code class="literal">loader-repository</code> tag in the AOP file's <code class="filename">META-INF/jboss-aop.xml</code> file.
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;aop&gt;
    &lt;loader-repository&gt;jboss.test:service=scoped&lt;/loader-repository&gt;
                                    
    &lt;!-- Aspects and bindings --&gt; 
&lt;/aop&gt;
</pre><div class="para">
				This has the same effect as deploying the AOP file as part of the EAR as we saw previously, but allows you to hot deploy aspects into your scoped application.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="transaction" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter9.Transaction Management</h2></div></div></div><div class="para">
		This chapter presents a brief overview of the main configuration options for the JBoss Transaction Service. For more information, please refer to the <em class="citetitle">JBoss Transactions Administration Guide</em>.
	</div><div class="section" id="idm139946670209024"><div class="titlepage"><div><div><h2 class="title">9.1.Overview</h2></div></div></div><div class="para">
			Transaction support in JBoss Enterprise Application Platform is provided by JBoss Transaction Service, a mature, modular,standards based, highly configurable transaction manager. By default, the server runs with the local-only JTA module of JBoss Transaction Service installed. This module provides an implementation of the standard JTA API for use by other internal components, such as the EJB container, as well as direct use by applications. It is suitable for coordinating ACID transactions that involve one or more XA Resource managers, such as relational databases or message queues.
		</div><div class="para">
			Two additional, optional, JBoss Transaction Service transaction modules are also shipped with JBoss Enterprise Application Platform and may be deployed to provide additional functionality if required.
		</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">JBoss Transaction Service JTS</span></dt><dd><div class="para">
						A Transaction Manager capable of distributing transaction context on remote IIOP method calls, creating a single distributed transaction which spans multiple Java Virtual Machines. This is useful for large-scale applications that span multiple servers, or for standards based interoperability with transactional business logic running in CORBA based systems. The functionality of this module can be accessed through the standard JTA API. In this way, it is a drop-in replacement and does not require changes to transactional business logic. To enable it, refer to <a class="xref" href="#using-jts">Section9.8, Using the JTS Module</a> for more information.
					</div></dd><dt><span class="term">JBoss Transaction Service XTS</span></dt><dd><div class="para">
						A Transaction Manager, based on XML, which implements the <em class="firstterm">WS-AtomicTransaction (WS-AT)</em> and <em class="firstterm">WS-BusinessActivity (WS-BA)</em> specifications. This additional module uses core transaction support provided by the JTA or JTS managers, along with web services functionality provided by JBossWS Native. It is deployed into the server as an application. Applications may use WS-AT to provide standards based, distributed ACID transactions in a manner similar to JTS but using a Web Services transport, instead of CORBA. The WS-BA implementation compliments this by providing an alternative, compensation-based transaction model, well suited to coordinating long-running, loosely coupled business processes. XTS also implements a <em class="firstterm">WS-Coordination (WS-C)</em> service which is usually accessed internally by the local WS-AT and WS-BA implementations. However, this WS-C service can also be used to provide remote coordination for WS-AT and WS-BA transactions created in other JBoss server instances or non-JBoss containers. Refer to the JBoss Transactions Web Services Programmer's Guide for more details. To enable XTS, refer to <a class="xref" href="#using-xts">Section9.9, Using the XTS Module</a>.
					</div></dd></dl></div></div><div class="section" id="idm139946661043088"><div class="titlepage"><div><div><h2 class="title">9.2.Configuration Essentials</h2></div></div></div><div class="para">
			Configuration of the default JBossTS JTA is managed though a combination of the transaction manager's own properties file and the application server's deployment configuration. The configuration file resides at <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/[<em class="replaceable">name</em>]/conf/jbossts-properties.xml</code>. It contains defaults for the most commonly used properties. Many more are detailed in the accompanying JBoss Transaction Service Administration Guide. Each setting has a hard-coded default, but the system may not function properly if a configuratino file does not exist. Additional configuratino is also possible as part of the Microcontainer beans configuration found in the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/[<em class="replaceable">name</em>]/deploy/transaction-jboss-beans.xml</code> file. This ties the transaction manager into the overall server configuration, overriding the transaction configuration file settings with values specific to the application server where appropriate. In particular, it uses the Service Binding Manager to set port binding information, as well as overriding selected other properties. Configuration properties are read by the Transaction Service at server initialization, and the server must be restarted to incorporate any changes made to the configuration files.
		</div><div class="table" id="idm139946671739760"><p class="title"><strong>Table9.1.Most Critical Properties for JBoss Transaction Service</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Most Critical Properties for JBoss Transaction Service"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946671737840" scope="col"> <div class="para">
							Property Name
						</div>
						 </th><th id="idm139946671736912" scope="col"> <div class="para">
							Default Value
						</div>
						 </th><th id="idm139946676229984" scope="col"> <div class="para">
							Description
						</div>
						 </th></tr></thead><tbody><tr><td headers="idm139946671737840"> <div class="para">
							transactionTimeout
						</div>
						 </td><td headers="idm139946671736912"> <div class="para">
							300 seconds
						</div>
						 </td><td headers="idm139946676229984"> <div class="para">
							the default time, in seconds, after which a transaction will time out and be rolled back by. Adjust this to suit your environment and workload.
						</div>
						 <div class="para">
							It may come as a surprise that transactions are processed asynchronously. This was a design decision, and needs to be accounted for by your code.
						</div>
						 </td></tr><tr><td headers="idm139946671737840"> <div class="para">
							objectStoreDir
						</div>
						 </td><td headers="idm139946671736912"> <div class="para">

						</div>
						 </td><td headers="idm139946676229984"> <div class="para">
							The directory where transaction data is logged. The transaction log is required to complete transactions in the case of system failure, and needs to be on reliable storage. Normally one file is generated per transaction, and each file is a few kilobytes in size. These are distributed over a directory tree for optimal performance. If a RAID controller is used, it should be configured for write through cache, in much the same manner as database storage devices. Writing of the transaction log is automatically skipped in the case of transactions that are rolling back or contain only a single resource.
						</div>
						 </td></tr></tbody></table></div></div><div class="table" id="jbossts-additional-properties"><p class="title"><strong>Table9.2.Additional Properties for JBoss Transaction Service</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Additional Properties for JBoss Transaction Service"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946665617696" scope="col"> <div class="para">
							Property Name
						</div>
						 </th><th id="idm139946665616768" scope="col"> <div class="para">
							Default Value
						</div>
						 </th><th id="idm139946665615840" scope="col"> <div class="para">
							Description
						</div>
						 </th></tr></thead><tbody><tr><td headers="idm139946665617696"> <div class="para">
							com.arjuna.common.util.logging.DebugLevel
						</div>
						 </td><td headers="idm139946665616768"> <div class="para">
							<code class="literal">0x00000000</code>, which equates to no logging
						</div>
						 </td><td headers="idm139946665615840"> <div class="para">
							determines the internal log threshold for the transaction manager codebase. It is independent of the overall server's <span class="application"><strong>log4j</strong></span> logging configuration, and acts to suppress extraneous log entries from being printed. When the default value is active, INFO and WARN messages are still printed, and this setting provides optimal performance. <code class="literal">0xffffffff</code> enables full debug logging. This setting results in large log files.
						</div>
						 <div class="para">
							Log messages that pass the internal <code class="systemitem">DebugLevel</code> check are passed to the server's logging system for further processing. In theory, full debugging may be left on and <span class="application"><strong>log4j</strong></span> can be used to turn logging on or off, but in reality this has a performance impact.
						</div>
						 </td></tr><tr><td headers="idm139946665617696"> <div class="para">
							com.arjuna.ats.arjuna.coordinator.commitOnePhase
						</div>
						 </td><td headers="idm139946665616768"> <div class="para">
							<code class="literal">YES</code>
						</div>
						 </td><td headers="idm139946665615840"> <div class="para">
							Determines whether the transaction manager automatically applies the one-phase commit optimization to the transaction completion protocol, when only a single resource is registered with the transaction. Enabled by default to prevent writing transaction logs needlessly.
						</div>
						 </td></tr><tr><td headers="idm139946665617696"> <div class="para">
							com.arjuna.ats.arjuna.objectstore.transactionSync
						</div>
						 </td><td headers="idm139946665616768"> <div class="para">
							<code class="literal">ON</code>
						</div>
						 </td><td headers="idm139946665615840"> <div class="para">
							Controls the flushing of transaction logs to disk during transaction termination. The default value results in a <code class="classname">FileDescriptor.sync</code> call for each committing transaction. This behavior is required to provide recovery and ACID properties. If these features are unimportant to the application in question, you can achieve better performance by disabling this property. This is discouraged, since it is usually better to write such applications in a way that avoids using transactions at all.
						</div>
						 </td></tr><tr><td headers="idm139946665617696"> <div class="para">
							com.arjuna.ats.arjuna.xa.nodeIdentifier
						</div>
						 <div class="para">
							com.arjuna.ats.jta.xaRecoveryNode
						</div>
						 </td><td headers="idm139946665616768"> <div class="para">

						</div>
						 </td><td headers="idm139946665615840"> <div class="para">
							These properties determine the behavior of the transaction recovery system. They must be configured correctly to ensure that transactions are resolved correctly so that recovery can happen if the server crashes. Please refer to the Recovery chapter of the JBoss Transactions Administration Guide for more details.
						</div>
						 </td></tr><tr><td headers="idm139946665617696"> <div class="para">
							com.arjuna.ats.arjuna.coordinator.enableStatistics
						</div>
						 </td><td headers="idm139946665616768"> <div class="para">
							<code class="literal">NO</code>
						</div>
						 </td><td headers="idm139946665615840"> <div class="para">
							Enables gathering of transaction statistics. The statistics can be viewed using methods on the <code class="interfacename">TransactionManagerService</code> bean or its corresponding JMX MBean. Disabled by default.
						</div>
						 </td></tr></tbody></table></div></div></div><div class="section" id="idm139946662456960"><div class="titlepage"><div><div><h2 class="title">9.3.Transactional Resources</h2></div></div></div><div class="para">
			The Transaction Service coordinates transaction state updates using <code class="classname">XAResource</code> implementations, which are provided by the various resource managers. Resource managers may include databases, message queues or third-party JCA resource adapters. The list of databases and JDBC drivers which have been certified on JBoss Enterprise Application Platform is located at <a href="http://www.jboss.com/products/platforms/application/supportedconfigurations/" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">http://www.jboss.com/products/platforms/application/supportedconfigurations/</a>. Most standards-compliant JDBC drivers should function correctly, but you should perform extensive testing when using an uncertified configuration, since interpretations of the XA specifications different from one vendor to another.
		</div><div class="para">
			Database connection pools are configured via the application server's Datasource files, which are files named like <code class="filename">-ds.xml</code>. Datasources which use the &lt;xa-datasource&gt; property automatically interact with the transaction manager. Connections obtained by looking up such datasource in JNDI and calling <code class="methodname">getConnection</code> automatically participate in ongoing transactions. This is the preferred use case when transactional guarantees for data access are required.
		</div><div class="para">
			If you are using a database which cannot support XA transactions, you can deploy a connection pool using &lt;local-xa-datasource&gt;. This type of datasource participates in the managed transaction using the <a class="xref" href="#lrco-overview">Section9.4, Last Resource Commit Optimization (LRCO)</a>, providing more limited transactional guarantees. Connections obtained from a &lt;no-tx-datasource&gt; do not interact with the transaction manager, and any work done on such connections must be explicitly committed or rolled back by the application, using the JDBC API.
		</div><div class="para">
			Many databases require additional configuration before they can function as XA resource managers. Vendor-specific information for configuring databases is presented in <a class="xref" href="#appendix-db-specific-datasources">AppendixA, <em>Vendor-Specific Datasource Definitions</em></a>. Refer to your database administrator and the documentation which ships with your database for additional configuration directives. In addition, please consult the JBoss Transactions Administration Guide for information on setting up XA recovery properly.
		</div><div class="para">
			JBoss Messaging provides an XA-aware driver and can participate in XA transactions. Please consult the JBoss Messaging User Guide for more details.
		</div></div><div class="section" id="lrco-overview"><div class="titlepage"><div><div><h2 class="title">9.4.Last Resource Commit Optimization (LRCO)</h2></div></div></div><div class="para">
			Although the XA transaction protocol is designed to provide ACID properties by using a two-phase commit protocol, model may not always be appropriate. Sometimes it is necessary to allow a non-XA-aware resource manager to participate in a transaction. This is often the case with data stores that do not support distributed transactions.
		</div><div class="para">
			In this situation, you can use a technique known as <em class="firstterm">Last Resource Commit Optimization (LRCO)</em>. This is sometimes called the <em class="firstterm">Last Resource Gambit</em>. The one-phase-aware resource is processed last in the <code class="methodname">prepare</code> phase of the transaction, at which time an attempt is made to commit it. If the attempt is successful, the transaction log is written and the remaining resources go through the phase-two commit. If the last resource fails to commit, the transaction is rolled back. Although this protocol allows most transactions to complete normally, some errors can cause an inconsistent transaction outcome. For this reason, use LRCO as a last resort. When a single &lt;local-tx-datasource&gt; is used in a transaction, the LRCO is automatically applied to it. In other situations, you can designate a last resource by using a special marker interface. Refer to the JBoss Transactions Programmer's Guide for more details.
		</div><div class="para">
			Using more than a single one-phase resource in the same transaction is not transactionally safe, and is not recommended. JBoss Transaction Service sees an attempt to enlist a second such resource as an error and terminates the transaction. This type of error is most often found when migrating from a legacy version of JBoss Application Server. Whenever possible the &lt;local-tx-datasource&gt; should be converted to an &lt;xa-datasource&gt; to resolve the difficulty.
		</div></div><div class="section" id="transaction-timeout"><div class="titlepage"><div><div><h2 class="title">9.5.Transaction Timeout Handling</h2></div></div></div><div class="para">
			In order to prevent indefinite locking of resources, the transaction manager aborts in-flight transactions that have not completed after a specified interval, using a set of background processes coordinated by the <code class="systemitem">TransactionReaper</code>. The reaper rolls back transactions without interrupting any threads that may be operating within their scope. This prevents instability that results from interrupting threads executing arbitrary code. Furthermore, it allows for timely abort of transactions where the business logic thread may be executing non-interruptable operations such as network I/O operations. This approach may, cause unexpected behavior in code that is not designed to handle multithreaded transactions. Warning or error messages may be printed from transaction-aware components as a result of the unexpected change in transaction status. The transaction outcome should usually be unaffected. Any problems can be minimized by tuning the transaction timeout values. See <a class="xref" href="#datasource-config">Chapter13, <em>Datasource Configuration</em></a> for more information.
		</div></div><div class="section" id="idm139946671357312"><div class="titlepage"><div><div><h2 class="title">9.6.Recovery Configuration</h2></div></div></div><div class="para">
			To ensure that your configuration is robust, it is important to configure JBoss Transaction Service properly for failure and recovery. This is covered in detail in the <em class="citetitle">JBoss Transactions Administration Guide</em>, in the "Resource Recovery in JBoss Transaction Service" chapter.
		</div></div><div class="section" id="idm139946671352320"><div class="titlepage"><div><div><h2 class="title">9.7.Transaction Service FAQ</h2></div></div></div><div class="para">
			This section presents some of the most common configuration issues with JBoss Transaction Service.
		</div><div class="qandaset" id="idm139946671350944"><dl><dt>Q: <a href="#idm139946671350624">
						I turned on debug logging, but nothing is logged.
					</a></dt><dt>Q: <a href="#idm139946671344208">
						Why do server logs show WARN Adding multiple last resources is disallowed., and why are my transactions are aborted?
					</a></dt><dt>Q: <a href="#idm139946671340800">
						My server terminated unexpectedly. It is running again, but my logs are filling with messages like WARN [com.arjuna.ats.jta.logging.loggerI18N] [com.arjuna.ats.internal.jta.resources.arjunacore.norecoveryxa] Could not find new XAResource to use for recovering non-serializable XAResource.
					</a></dt><dt>Q: <a href="#idm139946658620816">
						My transactions take a long time and sometimes strange things happen. The server log contains WARN [arjLoggerI18N] [BasicAction_58] - Abort of action id ... invoked while multiple threads active within it.
					</a></dt></dl><div class="qandaset"><div class="qandaentry"><div class="question" id="idm139946671350624"><div class="label label-default">Q:</div><div class="data"><div class="para">
						I turned on debug logging, but nothing is logged.
					</div></div></div><div class="answer"><div class="label label-default">A:</div><div class="data"><div class="para">
						JBossTS sends log statements though two levels of filters.
					</div><div class="procedure"><ol class="1"><li class="step"><div class="para">
								Logs go through JBoss Transaction Service's own logging abstraction layer.
							</div></li><li class="step"><div class="para">
								Logs go through JBoss Enterprise Application Platform's <code class="systemitem">log4j</code> logging system.
							</div></li></ol></div><div class="para">
						A log statement must pass both filters to be printed. A typical mistake is enabling only one or the other of the logging systems. See <a class="xref" href="#jbossts-additional-properties">Table9.2, Additional Properties for JBoss Transaction Service</a> for more information.
					</div></div></div></div><div class="qandaentry"><div class="question" id="idm139946671344208"><div class="label label-default">Q:</div><div class="data"><div class="para">
						Why do server logs show <code class="code">WARN Adding multiple last resources is disallowed.</code>, and why are my transactions are aborted?
					</div></div></div><div class="answer"><div class="label label-default">A:</div><div class="data"><div class="para">
						You are probably using a &lt;local-xa-datasource&gt; and trying to use more than one one-phase aware participant. This is a configuration to be avoided. See <a class="xref" href="#lrco-overview">Section9.4, Last Resource Commit Optimization (LRCO)</a> for more information. If you have further concerns, please contact Global Support Services.
					</div></div></div></div><div class="qandaentry"><div class="question" id="idm139946671340800"><div class="label label-default">Q:</div><div class="data"><div class="para">
						My server terminated unexpectedly. It is running again, but my logs are filling with messages like <code class="code">WARN [com.arjuna.ats.jta.logging.loggerI18N] [com.arjuna.ats.internal.jta.resources.arjunacore.norecoveryxa] Could not find new XAResource to use for recovering non-serializable XAResource</code>.
					</div></div></div><div class="answer"><div class="label label-default">A:</div><div class="data"><div class="para">
						You may not have configured all resource managers for recovery. Refer to the Recovery chapter of the JBoss Transactions Administration Guide for more information on configuring resource managers for recovery.
					</div></div></div></div><div class="qandaentry"><div class="question" id="idm139946658620816"><div class="label label-default">Q:</div><div class="data"><div class="para">
						My transactions take a long time and sometimes strange things happen. The server log contains <code class="code">WARN [arjLoggerI18N] [BasicAction_58] - Abort of action id ... invoked while multiple threads active within it.</code>
					</div></div></div><div class="answer"><div class="label label-default">A:</div><div class="data"><div class="para">
						Transactions which exceed their timeout may be rolled back. This is done by a background thread, which can confuse some application code that may be expecting an interrupt. Refer to <a class="xref" href="#transaction-timeout">Section9.5, Transaction Timeout Handling</a> for more information.
					</div></div></div></div></div></div><div class="para">
			If you have questions besides the ones addressed above, please consult the other JBoss Transactions guides, or contact Global Support Services.
		</div></div><div class="section" id="using-jts"><div class="titlepage"><div><div><h2 class="title">9.8.Using the JTS Module</h2></div></div></div><div class="para">
			If you need transaction propagation betweenb usiness logic in different servers, you can use the JTS API. Although you can use it directly, it is typical to access it via the standard JTA classes. It is a drop-in replacement for the default local-only JTA implementation. The necessary classes are already in place, and you only need to modify the <code class="filename">jbossts-properties.xml</code> file to move between the JTA and JTS modules.
		</div><div class="para">
			A sample <code class="filename">jbossts-properties.xml</code> file is located in the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/docs/examples/transactions/</code> directory. Consult the <code class="filename">README.txt</code> file in the same directory for more information about changes that need to be made to other files, including the <code class="filename">transactions-jboss-beans.xml</code> file. An ANT script is provided to perform all of the steps automatically, but it is recommended to consult the <code class="filename">README.txt</code> carefully before running the script, as well as backing up your existing configuration.
		</div><div class="para">
			The JTS requires the server configuration to also contain the CORBA ORB service. The "all" configuration referenced in the examples is a good starting point. The choice of JTS or JTA impacts the entire server, and JTS does require additional resources. Therefore, only use it when it is needed.
		</div><div class="para">
			At application start-up, a server that is configured to use JTA outputs log files like this one:
		</div><pre class="screen">
      INFO [TransactionManagerService] JBossTS Transaction Service (JTA version - ...)
</pre><div class="para">
			If JTS is enabled, the message looks like this one:
		</div><pre class="screen">
      INFO [TransactionManagerService] JBossTS Transaction Service (JTS version - ...)
</pre></div><div class="section" id="using-xts"><div class="titlepage"><div><div><h2 class="title">9.9.Using the XTS Module</h2></div></div></div><div class="para">
			XTS, which is the Web Services component of JBoss Transaction Service, can be installed to provide WS-AT and WS-BA support for web services hosted on the Enterprise Application Platform. The module is packaged as a <em class="firstterm">Service Archive (.sar)</em> located in <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/docs/examples/transactions/</code>.
		</div><div class="procedure"><p class="title"><strong>Procedure9.1.Installing the XTS Module</strong></p><ol class="1"><li class="step"><div class="para">
					Create a subdirectory in the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/[<em class="replaceable">name</em>]/deploy/</code> directory, called <code class="filename">jbossxts.sar/</code>.
				</div></li><li class="step"><div class="para">
					Unpack the .sar, which is a ZIP archive, into this new directory.
				</div></li><li class="step"><div class="para">
					Restart JBoss Enterprise Application Platform for the module to be active.
				</div></li></ol></div><div class="para">
			The server must use either the JTA or JTS module, as well as JBossWS Native.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				XTS is not currently expected to work with other JBossWS backends such as CXF. The default XTS configuration is suitable for most deployments. It automatically detects information about the network interfaces and port bindings from the EAP configuration. manual configuration changes are only necessary for deployments whose applications need to use a transaction coordinator on a separate host. Consult the JBoss Web Service Transactions Programmer's Guide for more information.
			</div></div></div><div class="para">
			Developers can link against the <code class="filename">jbossxts-api.jar</code> file included in the XTS Service Archive, but should avoid packaging it with their applications, to avoid classloading problems. All other JAR files contain internal implementation classes and should not be used directly.
		</div><div class="para">
			Consult <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/docs/examples/transactions/README.txt</code> for emore configuration information. The JBoss Web Services Transactions User Guide contains information about using XTS in your applications.
		</div></div><div class="section" id="idm139946658594528"><div class="titlepage"><div><div><h2 class="title">9.10.Transaction Management Console</h2></div></div></div><div class="para">
			The Transaction Management Console is a simle GUI tool that is included in <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/docs/example/transactions/</code>. It is provided as an unsupported, experimental prototype. Consult the <code class="filename">README.txt</code> file for its capabilities and information about its use.
		</div></div><div class="section" id="idm139946658591888"><div class="titlepage"><div><div><h2 class="title">9.11.Experimental Components</h2></div></div></div><div class="para">
			In addition to the supported components of JBoss Transaction Service which are included in JBoss Enterprise Application Platform, there is ongoing feature work that may eventually find its way into future releases of the product. In the meantime, these prototype components are available via from the <a href="http://jboss.org" class="mimir-link-warn" title="Mimir does not include content from: jboss.org">http://jboss.org</a> Community website.
		</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				There is no guarantee these components will work correctly and they are not covered under the Enterprise Application Platform support agreement. However, some of the advanced functionality available may useful for projects in the early stages of development. Users downloading these prototypes must be aware of the limitations concerning module compatibility, in accordance with the <a class="xref" href="#transactions-source-code">Section9.12, Source Code and Upgrading</a>.
			</div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">txbridge</span></dt><dd><div class="para">
						Sometimes you may need the ability to invoke traditional transaction components, such as EJBs, within the scope of a Web Services transaction. Conversely, some traditional transactional applications may need to invoke transactional web services. The Transaction Bridge (txbridge) provides mechanisms for linking these two types of transactional services together.
					</div></dd><dt><span class="term">BA Framework</span></dt><dd><div class="para">
						The XTS API operates at a very low level, requiring the developer to undertake much of the transaction infrastructure work involved in WS-BA. The BA Framework provides high-level annotations that enable JBoss Transaction Service to handle this infrastructure. The developer can then focus more on business logic instead.
					</div></dd></dl></div></div><div class="section" id="transactions-source-code"><div class="titlepage"><div><div><h2 class="title">9.12.Source Code and Upgrading</h2></div></div></div><div class="para">
			Most problems relating to transactions can be diagnosed by Global Support Services, after you provide debug logging information from the server.
		</div><div class="para">
			However, you can debug or review the source code yourself, using your own tools. You can download the source code using the Subversion repository at <a href="http://anonsvn.jboss.org/repos/labs/labs/jbosstm/" class="mimir-link-warn" title="Mimir does not include content from: anonsvn.jboss.org">http://anonsvn.jboss.org/repos/labs/labs/jbosstm/</a>. Enterprise Application Platform outputs the version of the Transaction Service at start-up, using a string similar to this one:
		</div><pre class="screen">
      INFO [TransactionManagerService] JBossTS Transaction Service (JTA version - tag:JBOSSTS_4_6_1_GA_CP02) - JBoss Inc.
</pre><div class="para">
			The <code class="systemitem">tag</code> element corresponds to a tree under /tags/ in the Subversion repository. Note that the version refers to the version of the JBoss Transaction Service component used in the Enterprise Application Platform, not the version of EAP itself. If you build Enterprise Application Platform from source, you can also find the version by searching for the string <code class="varname">version.jboss.jbossts</code> in the <code class="filename">component-matix/pom.xml</code> file.
		</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				Installing any version of JBossTS other than those provided with the Enterprise Application Platform you are using is not supported. While some JBoss Transaction Service components are packaged separately, it is unsupported to use different versions than the ones suppolied with Enterprise Application Platform.
			</div></div></div></div></div><div xml:lang="en-US" class="chapter" id="remoting" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter10.Remoting</h2></div></div></div><div class="para">
		<a id="idm139946674256496" class="indexterm"><!--Empty--></a> The main objective of JBoss Remoting is to provide a single API for most network based invocations and related services that use pluggable transports and data marshallers. The JBoss Remoting API provides the ability for making synchronous and asynchronous remote calls, push and pull callbacks, and automatic discovery of remoting servers. The intention is to allow for the addition of different transports to fit different needs, yet still maintain the same API for making the remote invocations and only requiring configuration changes, not code changes, to fit these different needs.
	</div><div class="para">
		Out of the box, Remoting supplies multiple transports (bisocket, http, rmi, socket, servlet, and their ssl enabled counterparts), standard and compressing data marshallers, and a configurable facility for switching between standard jdk serialization and JBoss Serializabion. It is also capable of remote classloading, has extensive facilities for connection failure notification, performs call by reference optimization for client/server invocations collocated in a single JVM, and implements multihomed servers.
	</div><div class="para">
		In the Enterprise Application Platform, Remoting supplies the transport layer for the EJB2, EJB3, and Messaging subsystems. In each case, the configuration of Remoting is largely predetermined and fixed, but there are times when it is useful to know how to alter a Remoting configuration.
	</div><div class="section" id="idm139946673791408"><div class="titlepage"><div><div><h2 class="title">10.1.Background</h2></div></div></div><div class="para">
			A Remoting server consists of a Connector, which wraps and configures a transport specific server invoker. A connector is represented by an InvokerLocator string, such as
		</div><pre class="programlisting">
    socket://bluemonkeydiamond.com:8888/?timeout=10000&amp;serialization=jboss
</pre><div class="para">
			which indicates that a server using the socket transport is accessible at port 8888 of host bluemonkeydiamond.com, and that the server is configured to use a socket timeout of 10000 and to use JBoss Serialization. A Remoting client can use an InvokerLocator to connect to a given server.
		</div><div class="para">
			In the Enterprise Application Platform, Remoting servers and clients are created far below the surface and are accessible only through configuration files. Moreover, when a proxy for a SLSB, for example, is downloaded from the JNDI directory, it comes with a copy of the InvokerLocator, so that it knows how to contact the appropriate Remoting server. <span class="bold bold"><strong>The important fact to note is that, since the server and its clients share the InvokerLocator, the parameters in the InvokerLocator serve to configure both clients and servers.</strong></span>
		</div></div><div class="section" id="idm139946675082736"><div class="titlepage"><div><div><h2 class="title">10.2.JBoss Remoting Configuration</h2></div></div></div><div class="para">
			There are two kinds of XML files that can be used to create and configure a Remoting Connector. A file with a name of the form *-service.xml can be used to define a Connector as an MBean, and a file of the form *-jboss-beans.xml can be used to define a Connector as a POJO.
		</div><div class="section" id="idm139946657585792"><div class="titlepage"><div><div><h3 class="title">10.2.1.MBeans</h3></div></div></div><div class="para">
				In the JBoss Messaging JMS subsystem, a Remoting server is configured in the file remoting-bisocket-service.xml, which, in abbreviated form, looks like
			</div><pre class="programlisting">
    &lt;mbean code="org.jboss.remoting.transport.Connector"
            name="jboss.messaging:service=Connector,transport=bisocket"
            display-name="Bisocket Transport Connector"&gt;
      &lt;attribute name="Configuration"&gt;
        &lt;config&gt;
          &lt;invoker transport="bisocket"&gt;         
            &lt;attribute name="marshaller" isParam="true"&gt;org.jboss.jms.wireformat.JMSWireFormat&lt;/attribute&gt;
            &lt;attribute name="unmarshaller" isParam="true"&gt;org.jboss.jms.wireformat.JMSWireFormat&lt;/attribute&gt;            
            &lt;attribute name="serverBindAddress"&gt;${jboss.bind.address}&lt;/attribute&gt;
            &lt;attribute name="serverBindPort"&gt;4457&lt;/attribute&gt;
            &lt;attribute name="callbackTimeout"&gt;10000&lt;/attribute&gt;
                 ...     
          &lt;/invoker&gt;
              ...
        &lt;/config&gt;
      &lt;/attribute&gt;
    &lt;/mbean&gt;
</pre><div class="para">
				This configuration file tells us several facts, including
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						This server uses the bisocket transport;
					</div></li><li class="listitem"><div class="para">
						it runs on port 4457 of host ${jboss.bind.address}; and
					</div></li><li class="listitem"><div class="para">
						JBoss Messaging uses its own marshalling algorithm.
					</div></li></ul></div><div class="para">
				The InvokerLocator is derived from this file. <span class="bold bold"><strong>The important fact to note is that the attribute "isParam" determines if a parameter is to be included in the InvokerLocator.</strong></span> If "isParam" is omitted or set to false, the parameter will apply only to the server. In this case, the parameter will not be transmitted to the client. The InvokerLocator for a Remoting server with a ${jboss.bind.address} of bluemonkeydiamond.com would be:
			</div><pre class="programlisting">
      bisocket://bluemonkeydiamond.com:4457/?marshaller=
      org.jboss.jms.wireformat.JMSWireFormat&amp;
      unmarshaller=org.jboss.jms.wireformat.JMSWireFormat
</pre><div class="para">
				Note that the parameter "callbackTimeout" is not included in the InvokerLocator.
			</div></div><div class="section" id="idm139946673541712"><div class="titlepage"><div><div><h3 class="title">10.2.2.POJOs</h3></div></div></div><div class="para">
				The same Connector could be configured by way of the <code class="classname">org.jboss.remoting.ServerConfiguration</code> POJO:
			</div><pre class="programlisting">
     &lt;bean name="JBMConnector" class="org.jboss.remoting.transport.Connector"&gt;
       &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
        (name="jboss.messaging:service=Connector,transport=bisocket",
        exposedInterface=org.jboss.remoting.transport.ConnectorMBean.class,
        registerDirectly=true)&lt;/annotation&gt;
       &lt;property name="serverConfiguration"&gt;&lt;inject bean="JBMConfiguration"/&gt;&lt;/property&gt;
     &lt;/bean&gt;
     
     &lt;!-- Remoting server configuration --&gt;
     &lt;bean name="JBMConfiguration" class="org.jboss.remoting.ServerConfiguration"&gt;
       &lt;constructor&gt;
         &lt;parameter&gt;bisocket&lt;/parameter&gt;
       &lt;/constructor&gt;
     
        &lt;!-- Parameters visible to both client and server --&gt;
       &lt;property name="invokerLocatorParameters"&gt;
         &lt;map keyClass="java.lang.String" valueClass="java.lang.String"&gt;
           &lt;entry&gt;
             &lt;key&gt;serverBindAddress&lt;/key&gt;
             &lt;value&gt;
               &lt;value-factory bean="ServiceBindingManager" method="getStringBinding"&gt;
                 &lt;parameter&gt;JBMConnector&lt;/parameter&gt;
                 &lt;parameter&gt;${host}&lt;/parameter&gt;
               &lt;/value-factory&gt;
             &lt;/value&gt;
           &lt;/entry&gt;
           &lt;entry&gt;
             &lt;key&gt;serverBindPort&lt;/key&gt;
             &lt;value&gt;
               &lt;value-factory bean="ServiceBindingManager" method="getStringBinding"&gt;
                 &lt;parameter&gt;JBMConnector&lt;/parameter&gt;
                 &lt;parameter&gt;${port}&lt;/parameter&gt;
               &lt;/value-factory&gt;
             &lt;/value&gt;
           &lt;/entry&gt;
              ...
           &lt;entry&gt;&lt;key&gt;marshaller&lt;/key&gt; &lt;value&gt;org.jboss.jms.wireformat.JMSWireFormat&lt;/value&gt;&lt;/entry&gt;
           &lt;entry&gt;&lt;key&gt;unmarshaller&lt;/key&gt; &lt;value&gt;org.jboss.jms.wireformat.JMSWireFormat&lt;/value&gt;&lt;/entry&gt;
         &lt;/map
       &lt;/property&gt;
       
       &lt;!-- Parameters visible only to server --&gt;
       &lt;property name="serverParameters"&gt;
         &lt;map keyClass="java.lang.String" valueClass="java.lang.String"&gt;
           &lt;entry&gt;&lt;key&gt;callbackTimeout&lt;/key&gt; &lt;value&gt;10000&lt;/value&gt;&lt;/entry&gt;
         &lt;/map&gt;
       &lt;/property&gt;
                                  
        ...
     &lt;/bean&gt;
</pre><div class="para">
				In this version, the configuration information is expressed in the JBMConfiguration <code class="classname">ServerConfiguration</code> POJO, which is then injected into the JBMConnector <code class="classname">org.jboss.remoting.transport.Connector</code> POJO. The syntax is that of the Microcontainer, which is beyond the scope of this chapter. See <a class="xref" href="#microcontainer">Chapter5, <em>Microcontainer</em></a> for details. One variation from the MBean version is the use of the ServiceBindingManager, which is also beyond the scope of this chapter. Note that the @org.jboss.aop.microcontainer.aspects.jmx.JMX annotation causes the JBMConnector to be visible as an MBean named "jboss.messaging:service=Connector,transport=bisocket".
			</div></div></div><div class="section" id="idm139946673024352"><div class="titlepage"><div><div><h2 class="title">10.3.Multihomed servers</h2></div></div></div><div class="para">
			Remoting can create servers bound to multiple interfaces. One application of this facility would be binding a server to one interface that faces the internet and another that faces a LAN. For example, the preceding POJO example can be modified by (1) adding POJOs
		</div><pre class="programlisting">
   
   &lt;bean name="homes1" class="java.lang.StringBuffer"&gt;
      &lt;constructor&gt;
         &lt;parameter class="java.lang.String"&gt;
            &lt;value-factory bean="ServiceBindingManager" method="getStringBinding"&gt;
               &lt;parameter&gt;JBMConnector:bindingHome1&lt;/parameter&gt;
               &lt;parameter&gt;${host}:${port}&lt;/parameter&gt;
            &lt;/value-factory&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;
   
   &lt;bean name="homes2" class="java.lang.StringBuffer"&gt;
      &lt;constructor factoryMethod="append"&gt;
         &lt;factory bean="homes1"/&gt;
         &lt;parameter&gt;
            &lt;value-factory bean="ServiceBindingManager" method="getStringBinding"&gt;
               &lt;parameter&gt;JBMConnector:bindingHome2&lt;/parameter&gt;
               &lt;parameter&gt;!${host}:${port}&lt;/parameter&gt;
            &lt;/value-factory&gt;
         &lt;/parameter&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;
</pre><div class="para">
			which results in a StringBuffer with a value something like (according to the ServiceBindingManager configuration values for JBMConnector:bindingHome1 and JBMConnector:bindingHome2) "external.acme.com:5555!internal.acme.com:4444", and (2) replacing the "serverBindAddress" and "serverBindPort" parameters with
		</div><pre class="programlisting">
    &lt;entry&gt;
      &lt;key&gt;homes&lt;/key&gt;
      &lt;value&gt;&lt;value-factory bean="homes2" method="toString"/&gt;&lt;/value&gt;
    &lt;/entry&gt;
</pre><div class="para">
			which transforms the StringBuffer into the String "external.acme.com:5555!internal.acme.com:4444" and injects it into the JBMConnector. The resulting InvokerLocator will look like
		</div><pre class="programlisting">
    bisocket://multihome/?homes=external.acme.com:5555!internal.acme.com:
    4444&amp;marshaller=org.jboss.jms.wireformat.JMSWireFormat&amp;
    unmarshaller=org.jboss.jms.wireformat.JMSWireFormat
</pre></div><div class="section" id="idm139946676295024"><div class="titlepage"><div><div><h2 class="title">10.4.Address translation</h2></div></div></div><div class="para">
			Sometimes a server must be accessed through an address translating firewall, and a Remoting server can be configured with both a binding address/port and an address/port to be used by a client. Two more parameters are used: "clientConnectAddress" and "clientConnectPort". The "serverBindAddress" and "serverBindPort" values are used to create the server, and the values of "clientConnectAddress" and "clientConnectPort" are used in the InvokerLocator, which tells the client where the server is. There is also an analogous "connecthomes" parameter for multihome servers. In this case, "homes" is used to configure the server, and "connecthomes" tells the client where the server is.
		</div></div><div class="section" id="idm139946676292912"><div class="titlepage"><div><div><h2 class="title">10.5.Where are they now?</h2></div></div></div><div class="para">
			The actual Remoting configuration files for the supported subsystems are as follows:
		</div><div class="para">
			EJB2: ${JBOSS_HOME}/server/${CONFIG}/deploy/remoting-jboss-beans.xml
		</div><div class="para">
			EJB3: ${JBOSS_HOME}/server/${CONFIG}/deploy/ejb3-connectors-jboss-beans.xml
		</div><div class="para">
			JBM: ${JBOSS_HOME}/server/${CONFIG}/deploy/messaging/remoting-bisocket-service.xml
		</div></div><div class="section" id="idm139946674865808"><div class="titlepage"><div><div><h2 class="title">10.6.Further information.</h2></div></div></div><div class="para">
			Additional details may be found in the Remoting Guide at <a href="http://www.jboss.org/jbossremoting/docs/guide/2.5/html/index.html" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org"> http://www.jboss.org/jbossremoting/docs/guide/2.5/html/index.html</a>.
		</div></div></div><div xml:lang="en-US" class="chapter" id="messaging" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter11.JBoss Messaging</h2></div></div></div><div class="para">
		The most current information about using JBoss Messaging is always available from the relevant <em class="citetitle">JBoss Messaging User Guide</em> at <a href="http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/" class="mimir-link-warn" title="Mimir does not include content from: www.redhat.com">http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/</a>.
	</div></div><div xml:lang="en-US" class="chapter" id="alternative_DBs" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter12.Use Alternative Databases with JBoss Enterprise Application Platform</h2></div></div></div><div class="section" id="idm139946658783584"><div class="titlepage"><div><div><h2 class="title">12.1.How to Use Alternative Databases</h2></div></div></div><div class="para">
			<a id="idm139946675851792" class="indexterm"><!--Empty--></a> JBoss utilizes the Hypersonic database as its default database. While this is good for development and prototyping, you or your company will probably require another database to be used for production. This chapter covers configuring JBoss Enterprise Application Platform to use alternative databases. We cover the procedures for all officially supported databases on the JBoss Enterprise Application Platform. For a complete list of certified databases, refer to <a href="http://www.jboss.com/products/platforms/application/supportedconfigurations/" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">http://www.jboss.com/products/platforms/application/supportedconfigurations/</a>.
		</div><div class="para">
			Please note that in this chapter, we explain how to use alternative databases to support all services in JBoss Enterprise Application Platform. This includes all the system level services such as EJB and JMS. For individual applications (e.g., WAR or EAR) deployed in JBoss Enterprise Application Platform, you can still use any backend database by setting up the appropriate data source connection.
		</div><div class="para">
			Installing the external database is out of the scope of this document. Use the tools provided by your database vendor to set up an empty database. You will need the database name, connection URL, username, and password, in order to create the datasource the Platform will use to connect to the database.
		</div></div><div class="section" id="idm139946669709536"><div class="titlepage"><div><div><h2 class="title">12.2.Install JDBC Drivers</h2></div></div></div><div class="para">
			To use the selected external database, you must also install the JDBC driver for your database. The JDBC driver is a JAR file, which must be placed into the <code class="filename"><em class="replaceable">JBOSS_HOME</em>/server/<em class="replaceable">PROFILE</em>/lib</code> directory. Replace <code class="literal"><em class="replaceable">PROFILE</em> </code> with the server profile you are using.
		</div><div class="para">
			This file is loaded when JBoss Enterprise Application Platform starts up, so if you have the JBoss Enterprise Application Platform running, you will need to shut down and restart. Review the list below for a suitable JDBC driver. For a full list of certified JBoss Enterprise Application Platform database drivers, refer to <a href="http://www.jboss.com/products/platforms/application/supportedconfigurations/#JEAP5-0" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">http://www.jboss.com/products/platforms/application/supportedconfigurations/#JEAP5-0</a>. If the links fail to work, please file a JIRA against this documentation, but be aware that Red Hat does not control these external links. Contact your database vendor for the most current version of the driver for your database.
		</div><div class="variablelist"><p class="title"><strong>JBDC Driver Download Locations</strong></p><dl class="variablelist"><dt><span class="term">MySQL</span></dt><dd><div class="para">
						Download from <a href="http://www.mysql.com/products/connector/" class="mimir-link-warn" title="Mimir does not include content from: www.mysql.com">http://www.mysql.com/products/connector/</a>.
					</div></dd><dt><span class="term">PostgreSQL</span></dt><dd><div class="para">
						Download from <a href="http://jdbc.postgresql.org/" class="mimir-link-warn" title="Mimir does not include content from: jdbc.postgresql.org">http://jdbc.postgresql.org/</a>.
					</div></dd><dt><span class="term">Oracle</span></dt><dd><div class="para">
						Download from <a href="http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/index.html" class="mimir-link-warn" title="Mimir does not include content from: www.oracle.com">http://www.oracle.com/technology/software/tech/java/sqlj_jdbc/index.html</a>.
					</div></dd><dt><span class="term">IBM</span></dt><dd><div class="para">
						Download from <a href="http://www-306.ibm.com/software/data/db2/java/" class="mimir-link-warn" title="Mimir does not include content from: www-306.ibm.com">http://www-306.ibm.com/software/data/db2/java/</a>.
					</div></dd><dt><span class="term">Sybase</span></dt><dd><div class="para">
						Download from the Sybase jConnect product page <a href="http://www.sybase.com/products/allproductsa-z/softwaredeveloperkit/jconnect" class="mimir-link-warn" title="Mimir does not include content from: www.sybase.com">http://www.sybase.com/products/allproductsa-z/softwaredeveloperkit/jconnect</a>.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							When using Sybase database with this driver, the <code class="varname">MaxParams</code> attribute cannot be set higher than <code class="literal">481</code> due to a limitation in the driver's <code class="classname">PreparedStatement</code> class.
						</div></div></div></dd><dt><span class="term">Microsoft</span></dt><dd><div class="para">
						Download from the MSDN web site <a href="http://msdn.microsoft.com/data/jdbc/" class="mimir-link-warn" title="Mimir does not include content from: msdn.microsoft.com">http://msdn.microsoft.com/data/jdbc/</a>.
					</div></dd></dl></div><div class="section" id="idm139946674515936"><div class="titlepage"><div><div><h3 class="title">12.2.1.Special Notes on Sybase</h3></div></div></div><div class="para">
				Some of the services in JBoss uses null values for the default tables that are created. Sybase Adaptive Server should be configured to allow nulls by default.
			</div><pre class="screen">sp_dboption db_name, "allow nulls by default", true</pre><div class="para">
				Refer to the Sybase manuals for more options.
			</div><div class="para">
				Additionally, text and image values stored in the database can be very large. When a select list includes both text and image values, the length limit of the data returned is determined by the <code class="varname">@@textsize</code> global variable. The default setting for this variable depends on the software used to access Adaptive Server. For the JDBC driver, the default value is 32 kilobytes.
			</div><div class="section" id="idm139946674512320"><div class="titlepage"><div><div><h4 class="title">12.2.1.1.Enable JAVA services</h4></div></div></div><div class="para">
					To use any Java service (for example; JMS, CMP, timers) configured with Sybase, Java must be enabled on Sybase Adaptive Server. To do this use:
				</div><pre class="screen">sp_configure "enable java",1</pre><div class="para">
					Refer to the sybase manuals for more information.
				</div><div class="para">
					If Java is not enabled for Sybase Adaptive Server, the following error message may be echoed in the console.
				</div><pre class="screen">com.sybase.jdbc2.jdbc.SybSQLException: Cannot run this command because Java services are not
        enabled. A user with System Administrator (SA) role must reconfigure the system to enable Java</pre></div><div class="section" id="idm139946665755984"><div class="titlepage"><div><div><h4 class="title">12.2.1.2.CMP Configuration</h4></div></div></div><div class="para">
					To use Container Managed Persistence for user defined Java objects with Sybase Adaptive Server Enterprise, the Java classes should be installed in the database. The system table <code class="literal">sysxtypes</code> contains one row for each extended Java-SQL datatype. This table is only used for Adaptive Servers enabled for Java. Install Java classes using the <span class="application"><strong>installjava</strong></span> program.
				</div><pre class="screen">installjava -f &lt;jar-file-name&gt; -S&lt;sybase-server&gt; -U&lt;super-user&gt; -P&lt;super-pass&gt; -D&lt;db-name&gt;</pre><div class="para">
					Refer to the <span class="application"><strong>installjava</strong></span> manual in Sybase for more options.
				</div></div><div class="section" id="idm139946665751904"><div class="titlepage"><div><div><h4 class="title">12.2.1.3.Installing Java Classes</h4></div></div></div><div class="orderedlist"><ol><li class="listitem"><div class="para">
							You have to be a super-user with required privileges to install Java classes.
						</div></li><li class="listitem"><div class="para">
							The JAR file you are trying to install should be created without compression.
						</div></li><li class="listitem"><div class="para">
							Java classes that you install and use in the server must be compiled with JDK 1.2.2. If you compile a class with a later JDK, you will be able to install it in the server using the <span class="application"><strong>installjava</strong></span> utility, but you will get a <span class="errorname">java.lang.ClassFormatError</span> exception when you attempt to use the class. This is because Sybase Adaptive Server uses an older JVM internally, and requires the Java classes to be compiled with the same.
						</div></li></ol></div></div></div><div class="section" id="Configuring_JDBC_DataSources"><div class="titlepage"><div><div><h3 class="title">12.2.2.Configuring JDBC DataSources</h3></div></div></div><div class="para">
				Datasources correspond to the simplified JCA Datasource configuration specifications.
			</div><div class="para">
				Datasources need to reside in the <code class="filename"><em class="replaceable">JBOSS_HOME</em>/server/<em class="replaceable">PROFILE</em>/deploy</code> directory, alongside other deployable applications and resources. The files use a standard naming scheme of <code class="filename"><em class="replaceable">DBNAME</em>-ds.xml</code>.
			</div><div class="para">
				Example datasources for all certified databases are located in the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/docs/examples/jca</code> directory. Edit the datasource that corresponds to your database, and copy it to the <code class="filename">deploy/</code> directory before restarting the application server.
			</div><div class="para">
				See <a class="xref" href="#datasource-config">Chapter13, <em>Datasource Configuration</em></a> for information on configuring datasources. As a minimum, you will need to change the <code class="varname">connection-url</code>, <code class="varname">user-name</code>, and <code class="varname">password</code> to correspond to your database of choice.
			</div></div></div><div class="section" id="idm139946657843328"><div class="titlepage"><div><div><h2 class="title">12.3.Common Database-Related Tasks</h2></div></div></div><div class="section" id="idm139946657842560"><div class="titlepage"><div><div><h3 class="title">12.3.1.Security and Pooling</h3></div></div></div><div class="para">
				Unless the <code class="classname">ResourceAdapter</code> has <code class="literal">&lt;reauthentication-support&gt;</code>, using multiple security identities will create subpools for each identity.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The min and max pool size are per subpool, so be careful with these parameters if you have lots of identities.
				</div></div></div></div><div class="section" id="idm139946657838672"><div class="titlepage"><div><div><h3 class="title">12.3.2.Change Database for the JMS Services</h3></div></div></div><div class="para">
				The JMS service in the JBoss Enterprise Application Platform uses relational databases to persist its messages. For improved performance, we should change the JMS service to take advantage of the external database. To do that, we need to replace the file <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">$PROFILE</em>/deploy/messaging/<em class="replaceable">$DATABASE</em>-persistence-service.xml</code> with the <code class="filename"><em class="replaceable">$DATABASE</em>-persistence-service.xml</code> filename depending on your external database. 
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						MySQL: <code class="filename">mysql-persistence-service.xml</code>
					</div></li><li class="listitem"><div class="para">
						PostgreSQL: <code class="filename">postgresql-persistence-service.xml</code>
					</div></li><li class="listitem"><div class="para">
						Oracle: <code class="filename">oracle-persistence-service.xml</code>
					</div></li><li class="listitem"><div class="para">
						DB2: <code class="filename">db2-persistence-service.xml</code>
					</div></li><li class="listitem"><div class="para">
						Sybase: <code class="filename">sybase-persistence-service.xml</code>
					</div></li><li class="listitem"><div class="para">
						MS SQL Server: <code class="filename">mssql-persistence-service.xml</code>
					</div></li></ul></div></div><div class="section" id="idm139946658987536"><div class="titlepage"><div><div><h3 class="title">12.3.3.Support Foreign Keys in CMP Services</h3></div></div></div><div class="para">
				Next, we need to go change the <code class="filename">$JBOSS_HOME/server/$PROFILE/conf/standardjbosscmp-jdbc.xml</code> file so that the <code class="varname">fk-constraint</code> property is <code class="literal">true</code>. That is needed for all external databases we support on the JBoss Enterprise Application Platform. This file configures the database connection settings for the EJB2 CMP beans deployed in the JBoss Enterprise Application Platform.
			</div><pre class="programlisting XML XML">&lt;fk-constraint&gt;true&lt;/fk-constraint&gt;</pre></div><div class="section" id="idm139946671576016"><div class="titlepage"><div><div><h3 class="title">12.3.4.Specify Database Dialect for Java Persistence API</h3></div></div></div><div class="para">
				The Java Persistence API (JPA) entity manager can save EJB3 entity beans to any backend database. Hibernate provides the JPA implementation in JBoss Enterprise Application Platform. Hibernate has a dialect auto-detection mechanism that works for most databases including the dialects for databases referenced in this appendix which are listed below. If a specific dialect is needed for alternative databases, you can configure the database dialect in the <code class="filename">$JBOSS_HOME/server/$PROFILE/deployers/ejb3.deployer/META-INF/jpa-deployers-jboss-beans.xml</code> file. To configure this file you need to uncomment the set of tags related to the map entry <code class="literal">hibernate.dialect</code> and change the values to the following based on the database you setup. 
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Oracle 10g: <code class="literal">org.hibernate.dialect.Oracle10gDialect</code>
					</div></li><li class="listitem"><div class="para">
						Oracle 11g: <code class="literal">org.hibernate.dialect.Oracle10gDialect</code>
					</div></li><li class="listitem"><div class="para">
						Microsoft SQL Server 2005: <code class="literal">org.hibernate.dialect.SQLServerDialect</code>
					</div></li><li class="listitem"><div class="para">
						Microsoft SQL Server 2008: <code class="literal">org.hibernate.dialect.SQLServerDialect</code>
					</div></li><li class="listitem"><div class="para">
						PostgresSQL 8.2.3: <code class="literal">org.hibernate.dialect.PostgreSQLDialect</code>
					</div></li><li class="listitem"><div class="para">
						PostgresSQL 8.3.7: <code class="literal">org.hibernate.dialect.PostgreSQLDialect</code>
					</div></li><li class="listitem"><div class="para">
						MySQL 5.0: <code class="literal">org.hibernate.dialect.MySQL5InnoDBDialect</code>
					</div></li><li class="listitem"><div class="para">
						MySQL 5.1: <code class="literal">org.hibernate.dialect.MySQL5InnoDBDialect</code>
					</div></li><li class="listitem"><div class="para">
						DB2 9.1: <code class="literal">org.hibernate.dialect.DB2Dialect</code>
					</div></li><li class="listitem"><div class="para">
						Sybase ASE 15: <code class="literal">org.hibernate.dialect.SybaseASE15Dialect</code>
					</div></li></ul></div></div><div class="section" id="idm139946671557472"><div class="titlepage"><div><div><h3 class="title">12.3.5.Change Other JBoss Enterprise Application Platform Services to use the External Database</h3></div></div></div><div class="para">
				Besides JMS, CMP, and JPA, we still need to hook up the rest of JBoss services with the external database. There are two ways to do it. One is easy but inflexible. The other is flexible but requires more steps. Now, let's discuss those two approaches respectively.
			</div><div class="section" id="idm139946671555968"><div class="titlepage"><div><div><h4 class="title">12.3.5.1.The Easy Way</h4></div></div></div><div class="para">
					The easy way is just to change the JNDI name for the external database to <code class="literal">DefaultDS</code>. Most JBoss services are hard-wired to use the <code class="literal">DefaultDS</code> by default. So, by changing the DataSource name, we do not need to change the configuration for each service individually.
				</div><div class="para">
					To change the JNDI name, just open the <code class="filename">*-ds.xml</code> file for your external database, and change the value of the <code class="varname">jndi-name</code> property to <code class="literal">DefaultDS</code>. For instance, in <code class="filename">mysql-ds.xml</code>, you would change <code class="literal">MySqlDS</code> to <code class="literal">DefaultDS</code> and so on. You will need to remove the <code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/hsqldb-ds.xml</code> file after you are done to avoid duplicated <code class="literal">DefaultDS</code> definition.
				</div><div class="para">
					In the <code class="filename">messaging/<em class="replaceable">$DATABASE</em>-persistence-service.xml</code> file, you should also change the datasource name in the <code class="literal">depends</code> tag for the <code class="classname">PersistenceManagers</code> MBean to <code class="literal">DefaultDS</code>. For instance, for <code class="filename">mysql-persistence-service.xml</code> file, we change the <code class="literal">MySqlDS</code> to <code class="literal">DefaultDS</code>.
				</div><pre class="programlisting XML XML">&lt;mbean 
            code="org.jboss.messaging.core.jmx.JDBCPersistenceManagerService" 
            name="jboss.messaging:service=PersistenceManager" 
            xmbean-dd="xmdesc/JDBCPersistenceManager-xmbean.xml"&gt;
            
            &lt;depends&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;</pre></div><div class="section" id="idm139946671544176"><div class="titlepage"><div><div><h4 class="title">12.3.5.2.The More Flexible Way</h4></div></div></div><div class="para">
					Changing the external datasource to <code class="literal">DefaultDS</code> is convenient. But if you have applications that assume the <code class="literal">DefaultDS</code> always points to the factory-default HSQL DB, that approach could break your application. Also, changing <code class="literal">DefaultDS</code> destination forces all JBoss services to use the external database. What if you want to use the external database only on some services?
				</div><div class="para">
					A safer and more flexible way to hook up JBoss Enterprise Application Platform services with the external DataSource is to manually change the <code class="literal">DefaultDS</code> in all standard JBoss services to the DataSource JNDI name defined in your <code class="filename">*-ds.xml</code> file (for example, the <code class="literal">MySqlDS</code> in <code class="filename">mysql-ds.xml</code>, etc.). Below is a complete list of files that contain <code class="literal">DefaultDS</code>. You can update them all to use the external database on all JBoss services or update some of them to use different combination of DataSources for different services.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/conf/login-config.xml</code>: This file is used in Java EE container managed security services.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/conf/standardjbosscmp-jdbc.xml</code>: This file configures the CMP beans in the EJB container.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/ejb2-timer-service.xml</code>: This file configures the EJB timer services.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/juddi-service.sar/META-INF/jboss-service.xml</code>: This file configures the UUDI service.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/juddi-service.sar/juddi.war/WEB-INF/jboss-web.xml</code>: This file configures the UUDI service.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/juddi-service.sar/juddi.war/WEB-INF/juddi.properties</code>: This file configures the UUDI service.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/uuid-key-generator.sar/META-INF/jboss-service.xml</code>: This file configures the UUDI service.
						</div></li><li class="listitem"><div class="para">
							<code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/messaging/messaging-jboss-beans.xml</code> and <code class="filename">$JBOSS_HOME/server/$PROFILE/deploy/messaging/persistence-service.xml</code>: Those files configure the JMS persistence service as we discussed earlier.
						</div></li></ul></div></div></div><div class="section" id="idm139946671524064"><div class="titlepage"><div><div><h3 class="title">12.3.6.A Special Note About Oracle Databases</h3></div></div></div><div class="para">
				In our setup discussed in this chapter, we rely on the JBoss Enterprise Application Platform to automatically create needed tables in the external database upon server startup. That works most of the time. But for databases like Oracle, there might be some minor issues if you try to use the same database server to back more than one JBoss Enterprise Application Platform instance.
			</div><div class="para">
				The Oracle database creates tables of the form <code class="literal">schemaname.tablename</code>. The <code class="literal">TIMERS</code> and <code class="literal">HILOSEQUENCES</code> tables needed by JBoss Enterprise Application Platform would not be created on a schema if the table already existed on a different schema. To work around this issue, you need to edit the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">$PROFILE</em>/deploy/ejb2-timer-service.xml</code> file to change the table name from <code class="literal">TIMERS</code> to something like <code class="literal">schemaname2.tablename</code>.
			</div><pre class="programlisting XML XML">
          &lt;mbean code="org.jboss.ejb.txtimer.DatabasePersistencePolicy" 
          name="jboss.ejb:service=EJBTimerService,persistencePolicy=database"&gt;
          &lt;!-- DataSourceBinding ObjectName --&gt;
          &lt;depends optional-attribute-name="DataSource"&gt;
          jboss.jca:service=DataSourceBinding,name=DefaultDS
          &lt;/depends&gt;
          &lt;!-- The plugin that handles database persistence --&gt;
          &lt;attribute name="DatabasePersistencePlugin"&gt;
          org.jboss.ejb.txtimer.GeneralPurposeDatabasePersistencePlugin
          &lt;/attribute&gt;
          &lt;!-- The timers table name --&gt;
          &lt;attribute name="TimersTable"&gt;TIMERS&lt;/attribute&gt;
          &lt;/mbean&gt;
</pre><div class="para">
				Similarly, you need to change the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">$PROFILE</em>/deploy/uuid-key-generator.sar/META-INF/jboss-service.xml</code> file to change the table name from <code class="literal">HILOSEQUENCES</code> to something like <code class="literal">schemaname2.tablename</code> as well.
			</div><pre class="programlisting"> &lt;!-- HiLoKeyGeneratorFactory --&gt; &lt;mbean
          code="org.jboss.ejb.plugins.keygenerator.hilo.HiLoKeyGeneratorFactory"
          name="jboss:service=KeyGeneratorFactory,type=HiLo"&gt;
          
          &lt;depends&gt;jboss:service=TransactionManager&lt;/depends&gt;
          
          &lt;!-- Attributes common to HiLo factory instances --&gt;
          
          &lt;!-- DataSource JNDI name --&gt;
          &lt;depends optional-attribute-name="DataSource"&gt;jboss.jca:service=DataSourceBinding,name=DefaultDS&lt;/depends&gt;
          
          &lt;!-- table name --&gt;
          &lt;attribute name="TableName"&gt;HILOSEQUENCES&lt;/attribute&gt;
</pre><div class="important"><div class="admonition_header"><p><strong>Important</strong></p></div><div class="admonition"><div class="para">
					Oracle JDBC driver version 11.1.0.7.0 causes the JBoss Messaging Test Suite to fail with a <code class="exceptionname">SQLException</code> ("Bigger type length than Maximum") on Oracle 11g R1.
				</div><div class="para">
					This is caused by a regression in Oracle JDBC driver 11.1.0.7.0.
				</div><div class="para">
					We recommend Oracle JDBC driver version 11.2.0.1.0 for use with Oracle 11g R1, Oracle 11g R2, Oracle RAC 11g R1 and Oracle RAC 11g R2.
				</div></div></div></div></div></div><div xml:lang="en-US" class="chapter" id="datasource-config" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter13.Datasource Configuration</h2></div></div></div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
			The default persistence configuration works out of the box with Hypersonic (HSQLDB) so that the JBoss Enterprise Platforms are able to run "out of the box". However, <span class="emphasis"><em>Hypersonic is not supported in production and should not be used in a production environment.</em></span>
		</div><div class="para">
			Known issues with the Hypersonic Database include:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					no transaction isolation
				</div></li><li class="listitem"><div class="para">
					thread and socket leaks (<code class="methodname">connection.close()</code> does not tidy up resources)
				</div></li><li class="listitem"><div class="para">
					persistence quality (logs commonly become corrupted after a failure, preventing automatic recovery)
				</div></li><li class="listitem"><div class="para">
					database corruption
				</div></li><li class="listitem"><div class="para">
					stability under load (database processes cease when dealing with too much data)
				</div></li><li class="listitem"><div class="para">
					not viable in clustered environments
				</div></li></ul></div><div class="para">
			Check the "Using Other Databases" chapter of the <em class="citetitle">Getting Started Guide</em> for assistance.
		</div></div></div><div class="para">
		Datasources are defined inside a &lt;datasources&gt; element. The exact element depends on the type of datasource required.
	</div><div class="section" id="idm139946675010288"><div class="titlepage"><div><div><h2 class="title">13.1.Types of Datasources</h2></div></div></div><div class="variablelist"><p class="title"><strong>Datasource Definitions</strong></p><dl class="variablelist"><dt><span class="term">&lt;no-tx-datasource&gt;</span></dt><dd><div class="para">
						Does not take part in JTA transactions. The <code class="filename">java.sql.Driver</code> is used.
					</div></dd><dt><span class="term">&lt;local-tx-datasource&gt;</span></dt><dd><div class="para">
						Does not support two phase commit. The <code class="filename">java.sql.Driver</code> is used. Suitable for a single database or a non-XA-aware resource.
					</div></dd><dt><span class="term">&lt;xa-datasource&gt;</span></dt><dd><div class="para">
						Supports two phase commit. The <code class="filename">javax.sql.XADataSource</code> driver is used.
					</div></dd></dl></div></div><div class="section" id="idm139946669942112"><div class="titlepage"><div><div><h2 class="title">13.2.Datasource Parameters</h2></div></div></div><div class="variablelist"><p class="title"><strong>Common Datasource Parameters</strong></p><dl class="variablelist"><dt><span class="term">&lt;mbean&gt;</span></dt><dd><div class="para">
						A standard JBoss MBean deployment.
					</div></dd><dt><span class="term">&lt;depends&gt;</span></dt><dd><div class="para">
						The <code class="literal">ObjectName</code> of an MBean service this <code class="classname">ConnectionFactory</code> or<code class="classname">DataSource</code> deployment depends upon.
					</div></dd><dt><span class="term">&lt;jndi-name&gt;</span></dt><dd><div class="para">
						The JNDI name under which the Datasource should be bound.
					</div></dd><dt><span class="term">&lt;use-java-context&gt;</span></dt><dd><div class="para">
						Boolean value indicating whether the jndi-name should be prefixed with <em class="wordasword">java:</em>. This prefix causes the Datasource to only be accessible from within the JBoss Enterprise Application Platform virtual machine. Defaults to <code class="literal">TRUE</code>.
					</div></dd><dt><span class="term">&lt;user-name&gt;</span></dt><dd><div class="para">
						The user name used to create the connection to the datasource.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Not used when security is configured.
						</div></div></div></dd><dt><span class="term">&lt;password&gt;</span></dt><dd><div class="para">
						The password used to create the connection to the datasource.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Not used when security is configured.
						</div></div></div></dd><dt><span class="term">&lt;transaction-isolation&gt;</span></dt><dd><div class="para">
						The default transaction isolation of the connection. If not specified, the database-provided default is used.
					</div><div class="itemizedlist"><p class="title"><strong>Possible values for &lt;transaction-isolation&gt;</strong></p><ul><li class="listitem"><div class="para">
								TRANSACTION_READ_UNCOMMITTED
							</div></li><li class="listitem"><div class="para">
								TRANSACTION_READ_COMMITTED
							</div></li><li class="listitem"><div class="para">
								TRANSACTION_REPEATABLE_READ
							</div></li><li class="listitem"><div class="para">
								TRANSACTION_SERIALIZABLE
							</div></li><li class="listitem"><div class="para">
								TRANSACTION_NONE
							</div></li></ul></div></dd><dt><span class="term">&lt;new-connection-sql&gt;</span></dt><dd><div class="para">
						An SQL statement that is executed against each new connection. This can be used to set up the connection schema, for instance.
					</div></dd><dt><span class="term">&lt;check-valid-connection-sql&gt;</span></dt><dd><div class="para">
						An SQL statement that is executed before the connection is checked out from the pool to make sure it is still valid. If the SQL statement fails, the connection is closed and a new one is created.
					</div></dd><dt><span class="term">&lt;valid-connection-checker-class-name&gt;</span></dt><dd><div class="para">
						A class that checks whether a connection is valid using a vendor-specific mechanism.
					</div></dd><dt><span class="term">&lt;exception-sorter-class-name&gt;</span></dt><dd><div class="para">
						A class that parses vendor-specific messages to determine whether SQL errors are fatal, and destroys the connection if so. If empty, no errors are treated as fatal.
					</div></dd><dt><span class="term">&lt;track-statements&gt;</span></dt><dd><div class="para">
						Whether to monitor for unclosed Statements and ResultSets and issue warnings when they haven't been closed. The default value is <code class="literal">NOWARN</code>.
					</div></dd><dt><span class="term">&lt;prepared-statement-cach-size&gt;</span></dt><dd><div class="para">
						The number of prepared statements per connection to be kept open and reused in subsequent requests. They are stored in a <em class="firstterm">Least Recently Used (LRU)</em> cache. The default value is <code class="literal">0</code>, meaning that no cache is kept.
					</div></dd><dt><span class="term">&lt;share-prepared-statements&gt;</span></dt><dd><div class="para">
						When the &lt;prepared-statement-cache-size&gt; is non-zero, determines whether two requests in the same transaction should return the same statement. Defaults to <code class="literal">FALSE</code>.
					</div><div class="example" id="idm139946674839616"><p class="title"><strong>Example13.1.Using &lt;share-prepared-statements&gt;</strong></p><div class="example-contents"><div class="para">
							The goal is to work around questionable driver behavior, where the driver applies auto-commit semantics to local transactions.
						</div><pre class="programlisting language-java JAVA JAVA">
       Connection c = dataSource.getConnection(); // auto-commit == false
       PreparedStatement ps1 = c.prepareStatement(...);
       ResultSet rs1 = ps1.executeQuery();
       PreparedStatement ps2 = c.prepareStatement(...);
       ResultSet rs2 = ps2.executeQuery();
</pre><div class="para">
							This assumes that the prepared statements are the same. For some drivers, <code class="methodname">ps2.executeQuery()</code> automatically closes <code class="varname">rs1</code>, so you actually need two real prepared statements behind the scenes. This only applies to the auto-commit semantic, where re-running the query starts a new transaction automatically. For drivers that follow the specification, you can set it to <code class="literal">TRUE</code> to share the same real prepared statement.
						</div></div></div></dd><dt><span class="term">&lt;set-tx-query-timeout&gt;</span></dt><dd><div class="para">
						Whether to enable query timeout based on the length of time remaining until the transaction times out. Defaults to <code class="literal">FALSE</code>.
					</div></dd><dt><span class="term">&lt;query-timeout&gt;</span></dt><dd><div class="para">
						The maximum time, in seconds, before a query times out. You can override this value by setting &lt;set-tx-query-timeout&gt; to <code class="literal">TRUE</code>.
					</div></dd><dt><span class="term">&lt;metadata&gt;&gt;&lt;type-mapping&gt;</span></dt><dd><div class="para">
						A pointer to the type mapping in <code class="filename">conf/standardjbosscmp.xml</code>. A legacy from JBoss4.
					</div></dd><dt><span class="term">&lt;validate-on-match&gt;</span></dt><dd><div class="para">
						Whether to validate the connection when the JCA layer matches a managed connection, such as when the connection is checked out of the pool. With the addition of &lt;background-validation&gt; this is not required. It is usually not necessary to specify <code class="literal">TRUE</code> for &lt;validate-on-match&gt; in conjunction with specifying <code class="literal">TRUE</code> for &lt;background-validation&gt;. Defaults to <code class="literal">TRUE</code>.
					</div></dd><dt><span class="term">&lt;prefill&gt;</span></dt><dd><div class="para">
						Whether to attempt to prefill the connection pool to the minimum number of connections. Only <em class="firstterm">supporting pools</em> (OnePool) support this feature. A warning is logged if the pool does not support prefilling. Defaults to <code class="literal">TRUE</code>.
					</div></dd><dt><span class="term">&lt;background-validation&gt;</span></dt><dd><div class="para">
						Background connection validation reduces the overall load on the RDBMS system when validating a connection. When using this feature, EAP checks whether the current connection in the pool a seperate thread (ConnectionValidator). &lt;background-validation-minutes&gt; depends on this value also being set to <code class="literal">TRUE</code>. Defaults to <code class="literal">FALSE</code>.
					</div></dd><dt><span class="term">&lt;background-validation-millis&gt;</span></dt><dd><div class="para">
						Background connection validation reduces the overall load on the RDBMS system when validating a connection. Setting this parameter means that JBoss will attempt to validate the current connections in the pool as a separate thread (<code class="classname">ConnectionValidator</code>). This parameter's value defines the interval, in milliseconds, for which the <code class="classname">ConnectionValidator</code> will run. (This value should not be the same as your <code class="literal">&lt;idle-timeout-minutes</code> value.)
					</div></dd><dt><span class="term">&lt;idle-timeout-minutes&gt;</span></dt><dd><div class="para">
						The maximum time, in minutes, before an idle connection is closed. A value of <code class="literal">0</code> disables timeout. Defaults to <code class="literal">15</code> minutes.
					</div></dd><dt><span class="term">&lt;track-connection-by-tx&gt;</span></dt><dd><div class="para">
						Whether the connection should be locked to the transaction, instead of returning it to the pool at the end of the transaction. In previous releases, this was <code class="literal">true</code> for local connection factories and <code class="literal">false</code> for XA connection factories. The default is now <code class="literal">true</code> for both local and XA connection factories, and the element has been deprecated.
					</div></dd><dt><span class="term">&lt;interleaving&gt;</span></dt><dd><div class="para">
						Enables interleaving for XA connection factories.
					</div></dd><dt><span class="term">&lt;background-validation-minutes&gt;</span></dt><dd><div class="para">
						How often, in minutes, the ConnectionValidator runs. Defaults to <code class="literal">10</code> minutes.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							You should set this to a smallervalue than &lt;idle-timeout-minutes&gt;, unless you have specified &lt;min-pool-size&gt; a minimum pool size set.
						</div></div></div></dd><dt><span class="term">&lt;url-delimiter&gt;, &lt;url-property&gt;, &lt;url-selector-strategy-class-name&gt;</span></dt><dd><div class="para">
						Parameters dealing with database failover. As of JBoss Enterprise Application Platform 5.1, these are configured as part of the main datasource configuration. In previous versions, &lt;url-delimiter&gt; appeared as &lt;url-delimeter&gt;.
					</div></dd><dt><span class="term">&lt;stale-connection-checker-class-name&gt;</span></dt><dd><div class="para">
						An implementation of <code class="classname">org.jboss.resource.adapter.jdbc.StateConnectionChecker</code> that decides whether <code class="systemitem">SQLException</code>s that notify of bad connections throw the <code class="systemitem">org.jboss.resource.adapter.jdbc.StateConnectionException</code> exception.
					</div></dd><dt><span class="term">&lt;max-pool-size&gt;</span></dt><dd><div class="para">
						The maximum number of connections allowed in the pool. Defaults to <code class="literal">20</code>.
					</div></dd><dt><span class="term">&lt;min-pool-size&gt;</span></dt><dd><div class="para">
						The minimum number of connections maintained in the pool. Unless &lt;prefill&gt; is <code class="literal">TRUE</code>, the pool remains empty until the first use, at which point the pool is filled to the &lt;min-pool-size&gt;. When the pool size drops below the &lt;min-pool-size&gt; due to idle timeouts, the pool is refilled to the &lt;min-pool-size&gt;. Defaults to <code class="literal">0</code>.
					</div></dd><dt><span class="term">&lt;blocking-timeout-millis&gt;</span></dt><dd><div class="para">
						The length of time, in milliseconds, to wait for a connection to become available when all the connections are checked out. Defaults to <code class="literal">30000</code>, which is 30 seconds.
					</div></dd><dt><span class="term">&lt;use-fast-fail&gt;</span></dt><dd><div class="para">
						Whether to continue trying to acquire a connection from the pool even if the previous attempt has failed, or begin failover. This is to address performance issues where validation SQL takes significant time and resources to execute. Defaults to <code class="literal">FALSE</code>.
					</div></dd></dl></div><div class="variablelist"><p class="title"><strong>Parameters for <code class="filename">javax.sql.XADataSource</code> Usage</strong></p><dl class="variablelist"><dt><span class="term">&lt;connection-url&gt;</span></dt><dd><div class="para">
						The JDBC driver connection URL string
					</div></dd><dt><span class="term">&lt;driver-class&gt;</span></dt><dd><div class="para">
						The JDBC driver class implementing the <code class="classname">java.sql.Driver</code>
					</div></dd><dt><span class="term">&lt;connection-property&gt;</span></dt><dd><div class="para">
						Used to configure the connections retrieved from the <code class="classname">java.sql.Driver</code>.
					</div><div class="example" id="idm139946660109920"><p class="title"><strong>Example13.2.Example &lt;connection-property&gt;</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">
       &lt;connection-property name="char.encoding"&gt;UTF-8&lt;/connection-property&gt;
</pre></div></div></dd></dl></div><div class="variablelist"><p class="title"><strong>Parameters for <code class="filename">javax.sql.XADataSource</code> Usage</strong></p><dl class="variablelist"><dt><span class="term">&lt;xa-datasource-class&gt;</span></dt><dd><div class="para">
						The class implementing the <code class="classname">XADataSource</code>
					</div></dd><dt><span class="term">&lt;xa-datasource-property&gt;</span></dt><dd><div class="para">
						Properties used to configure the <code class="classname">XADataSource</code>.
					</div><div class="example" id="idm139946660102016"><p class="title"><strong>Example13.3.Example &lt;xa-datasource-property&gt; Declarations</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;xa-datasource-property name="IfxWAITTIME"&gt;10&lt;/xa-datasource-property&gt;
&lt;xa-datasource-property name="IfxIFXHOST"&gt;myhost.mydomain.com&lt;/xa-datasource-property&gt;
&lt;xa-datasource-property name="PortNumber"&gt;1557&lt;/xa-datasource-property&gt;
&lt;xa-datasource-property name="DatabaseName"&gt;mydb&lt;/xa-datasource-property&gt;
&lt;xa-datasource-property name="ServerName"&gt;myserver&lt;/xa-datasource-property&gt;
</pre></div></div></dd><dt><span class="term">&lt;xa-resource-timeout&gt;</span></dt><dd><div class="para">
						The number of seconds passed to <code class="methodname">XAResource.setTransactionTimeout()</code> when not zero.
					</div></dd><dt><span class="term">&lt;isSameRM-override-value&gt;</span></dt><dd><div class="para">
						When set to <code class="literal">FALSE</code>, fixes some problems with Oracle databases.
					</div></dd><dt><span class="term">&lt;no-tx-separate-pools&gt;</span></dt><dd><div class="para">
						Pool transactional and non-transactinal connections separately
					</div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
							Using this option will cause your total pool size to be twice <code class="varname">max-pool-size</code>, because two actual pools will be created.
						</div></div></div><div class="para">
						Used to fix problems with Oracle.
					</div></dd></dl></div><div class="variablelist"><p class="title"><strong>Security Parameters</strong></p><dl class="variablelist"><dt><span class="term"> <code class="literal">&lt;application-managed-security&gt;</code> </span></dt><dd><div class="para">
						Uses the username and password passed on the <code class="methodname">getConnection</code> or <code class="methodname">createConnection</code> request by the application.
					</div></dd><dt><span class="term"> <code class="literal">&lt;security-domain&gt;</code> </span></dt><dd><div class="para">
						Uses the identified login module configured in <code class="filename">conf/login-module.xml</code>.
					</div></dd><dt><span class="term"> <code class="literal">&lt;security-domain-and-application&gt;</code> </span></dt><dd><div class="para">
						Uses the identified login module configured in <code class="filename">conf/login-module.xml</code> and other connection request information supplied by the application, for example JMS Queues and Topics.
					</div></dd></dl></div></div><div class="section" id="idm139946671454688"><div class="titlepage"><div><div><h2 class="title">13.3.Datasource Examples</h2></div></div></div><div class="para">
			For database-specific examples, see <a class="xref" href="#appendix-db-specific-datasources">AppendixA, <em>Vendor-Specific Datasource Definitions</em></a>.
		</div><div class="section" id="idm139946671452960"><div class="titlepage"><div><div><h3 class="title">13.3.1.Generic Datasource Example</h3></div></div></div><div class="example" id="idm139946671452192"><p class="title"><strong>Example13.4.Generic Datasource Example</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;GenericDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;[jdbc: url for use with Driver class]&lt;/connection-url&gt;
    &lt;driver-class&gt;[fully qualified class name of java.sql.Driver implementation]&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;!-- you can include connection properties that will get passed in 
	 the DriverManager.getConnection(props) call--&gt;
    &lt;!-- look at your Driver docs to see what these might be --&gt;
    &lt;connection-property name="char.encoding"&gt;UTF-8&lt;/connection-property&gt;
    &lt;transaction-isolation&gt;TRANSACTION_SERIALIZABLE&lt;/transaction-isolation&gt;

    &lt;!--pooling parameters--&gt;
    &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;100&lt;/max-pool-size&gt;
    &lt;blocking-timeout-millis&gt;5000&lt;/blocking-timeout-millis&gt;
    &lt;idle-timeout-minutes&gt;15&lt;/idle-timeout-minutes&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

    &lt;set-tx-query-timeout&gt;&lt;/set-tx-query-timeout&gt;
    &lt;query-timeout&gt;300&lt;/query-timeout&gt; &lt;!-- maximum of 5 minutes for queries --&gt;

    &lt;!-- pooling criteria.  USE AT MOST ONE--&gt;
    &lt;!--  If you don't use JAAS login modules or explicit login 
	 getConnection(usr,pw) but rely on user/pw specified above, 
	 don't specify anything here --&gt;

    &lt;!-- If you supply the usr/pw from a JAAS login module --&gt;
    &lt;security-domain&gt;MyRealm&lt;/security-domain&gt;

    &lt;!-- if your app supplies the usr/pw explicitly getConnection(usr, pw) --&gt;
    &lt;application-managed-security&gt;&lt;/application-managed-security&gt;

    &lt;!--Anonymous depends elements are copied verbatim into the ConnectionManager mbean config--&gt;
    &lt;depends&gt;myapp.service:service=DoSomethingService&lt;/depends&gt;

  &lt;/local-tx-datasource&gt;

  &lt;!-- you can include regular mbean configurations like this one --&gt;
  &lt;mbean code="org.jboss.tm.XidFactory" 
	 name="jboss:service=XidFactory"&gt;
    &lt;attribute name="Pad"&gt;true&lt;/attribute&gt;
  &lt;/mbean&gt;


  &lt;!-- Here's an xa example --&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;GenericXADS&lt;/jndi-name&gt;
    &lt;xa-datasource-class&gt;[fully qualified name of class implementing javax.sql.XADataSource goes here]&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="SomeProperty"&gt;SomePropertyValue&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="SomeOtherProperty"&gt;SomeOtherValue&lt;/xa-datasource-property&gt;

    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;transaction-isolation&gt;TRANSACTION_SERIALIZABLE&lt;/transaction-isolation&gt;



    &lt;!--pooling parameters--&gt;
    &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;100&lt;/max-pool-size&gt;
    &lt;blocking-timeout-millis&gt;5000&lt;/blocking-timeout-millis&gt;
    &lt;idle-timeout-minutes&gt;15&lt;/idle-timeout-minutes&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;


    &lt;!-- pooling criteria.  USE AT MOST ONE--&gt;
    &lt;!--  If you don't use JAAS login modules or explicit login 
	 getConnection(usr,pw) but rely on user/pw specified above, 
	 don't specify anything here --&gt;

    &lt;!-- If you supply the usr/pw from a JAAS login module --&gt;
    &lt;security-domain&gt;&lt;/security-domain&gt;

    &lt;!-- if your app supplies the usr/pw explicitly getConnection(usr, pw) --&gt;
    &lt;application-managed-security&gt;&lt;/application-managed-security&gt;

  &lt;/xa-datasource&gt;

&lt;/datasources&gt;</pre></div></div></div><div class="section" id="idm139946671446224"><div class="titlepage"><div><div><h3 class="title">13.3.2.Configuring a DataSource for Remote Usage</h3></div></div></div><div class="para">
				JBoss EAP supports accessing a DataSource from a remote client. See <a class="xref" href="#remote-usage-example">Example13.5, Configuring a Datasource for Remote Usage</a> for the change that gives the client the ability to look up the DataSource from JNDI, which is to specify <code class="varname">use-java-context</code>=<code class="literal">false</code>.
			</div><div class="example" id="remote-usage-example"><p class="title"><strong>Example13.5.Configuring a Datasource for Remote Usage</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">
   &lt;datasources&gt;
     &lt;local-tx-datasource&gt;
       &lt;jndi-name&gt;GenericDS&lt;/jndi-name&gt;
       &lt;use-java-context&gt;false&lt;/use-java-context&gt;
       &lt;connection-url&gt;...&lt;/connection-url&gt;
       ...
</pre></div></div><div class="para">
				This causes the DataSource to be bound under the JNDI name <code class="literal">GenericDS</code> instead of the default of <code class="literal">java:/GenericDS</code>, which restricts the lookup to the same Virtual Machine as the EAP server.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Use of the &lt;use-java-context&gt; setting is not recommended in a production environment. It requires accessing a connection pool remotely and this can cause unexpected problems, since connections are not serializable. Also, transaction propagation is not supported, since it can lead to connection leaks if unreliability is present, such as in a system crash or network failure. A remote session bean facade is the preferred way to access a datasource remotely.
				</div></div></div></div><div class="section" id="idm139946671438112"><div class="titlepage"><div><div><h3 class="title">13.3.3.Configuring a Datasource to Use Login Modules</h3></div></div></div><div class="procedure"><p class="title"><strong>Procedure13.1.Configuring a Datasource to Use Login Modules</strong></p><ol class="1"><li class="step"><p class="title"><strong>Add the &lt;security-domain-parameter&gt; to the XML file for the datasource.</strong></p><pre class="programlisting language-xml XML XML">
     &lt;datasources&gt;
       &lt;local-tx-datasource&gt;
         ...
         &lt;security-domain&gt;MyDomain&lt;/security-domain&gt;
         ...
       &lt;/local-tx-datasource&gt;
     &lt;/datasources&gt;
</pre></li><li class="step"><p class="title"><strong>Add an application policy to the <code class="filename">login-config.xml</code> file.</strong></p><div class="para">
						The authentication section needs to include the configuration for your login-module. For example, to encrypt the database password, use the <code class="systemitem">SecureIdentityLoginModule</code> login module.
					</div><pre class="programlisting language-xml XML XML">
&lt;application-policy name="MyDomain"&gt;
   &lt;authentication&gt;
      &lt;login-module code="org.jboss.resource.security.SecureIdentityLoginModule" flag="required"&gt;
         &lt;module-option name="username"&gt;scott&lt;/module-option&gt;
         &lt;module-option name="password"&gt;-170dd0fbd8c13748&lt;/module-option&gt;
         &lt;module-option name="managedConnectionFactoryName"&gt;jboss.jca:service=LocalTxCM,name=OracleDSJAAS&lt;/module-option&gt;
      &lt;/login-module&gt;
   &lt;/authentication&gt;
&lt;/application-policy&gt;
</pre></li><li class="step"><div class="para">
						If you plan to fetch the data source connection from a web application, authentication must be enabled for the web application, so that the <code class="systemitem">Subject</code> is populated.
					</div></li><li class="step"><div class="para">
						If users need the ability to connect anonymously, add an additional login module to the application-policy, to populate the security credentials.
					</div></li><li class="step"><div class="para">
						Add the <code class="systemitem">UsersRolesLoginModule</code> module to the beginning of the chain. The <code class="systemitem">usersProperties</code> and <code class="systemitem">rolesProperties</code> parameters can be directed to dummy files.
					</div><pre class="programlisting language-xml XML XML">
&lt;login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule" flag="required"&gt;
   &lt;module-option name="unauthenticatedIdentity"&gt;nobody&lt;/module-option&gt;
   &lt;module-option name="usersProperties"&gt;props/users.properties&lt;/module-option&gt;
   &lt;module-option name="rolesProperties"&gt;props/roles.properties&lt;/module-option&gt;
&lt;/login-module&gt;
</pre></li></ol></div></div></div></div><div xml:lang="en-US" class="chapter" id="pooling" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter14.Pooling</h2></div></div></div><div class="section" id="idm139946657624080"><div class="titlepage"><div><div><h2 class="title">14.1.Strategy</h2></div></div></div><div class="para">
			<a id="idm139946670274848" class="indexterm"><!--Empty--></a> <a href="http://www.jboss.org/community/wiki/JBossJCA" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">JBossJCA</a> uses a <code class="literal">ManagedConnectionPool</code> to perform the pooling. The <code class="literal">ManagedConnectionPool</code> is made up of subpools depending upon the strategy chosen and other pooling parameters.
		</div><div class="informaltable"><table class="gt-4-cols lt-7-rows"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><tbody><tr><td> <div class="para">
							xml
						</div>
						 </td><td> <div class="para">
							mbean
						</div>
						 </td><td> <div class="para">
							Internal Name
						</div>
						 </td><td> <div class="para">
							Description
						</div>
						 </td></tr><tr><td> <div class="para">
							
						</div>
						 </td><td> <div class="para">
							ByNothing
						</div>
						 </td><td> <div class="para">
							OnePool
						</div>
						 </td><td> <div class="para">
							A single pool of equivalent connections
						</div>
						 </td></tr><tr><td> <div class="para">
							&lt;application-managed-security/&gt;
						</div>
						 </td><td> <div class="para">
							ByApplication
						</div>
						 </td><td> <div class="para">
							PoolByCRI
						</div>
						 </td><td> <div class="para">
							Use the connection properties from allocateConnection()
						</div>
						 </td></tr><tr><td> <div class="para">
							&lt;security-domain/&gt;
						</div>
						 </td><td> <div class="para">
							ByContainer
						</div>
						 </td><td> <div class="para">
							PoolBySubject
						</div>
						 </td><td> <div class="para">
							A pool per Subject, e.g. preconfigured or EJB/Web login subjects
						</div>
						 </td></tr><tr><td> <div class="para">
							&lt;security-domain-and-applicaton/&gt;
						</div>
						 </td><td> <div class="para">
							ByContainerAndApplicaton
						</div>
						 </td><td> <div class="para">
							PoolBySubjectAndCri
						</div>
						 </td><td> <div class="para">
							A per Subject and connection property combination
						</div>
						 </td></tr></tbody></table></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The xml names imply this is just about security. This is misleading.
			</div></div></div><div class="para">
			For &lt;security-domain-and-application/&gt; the Subject always overrides any user/password from createConnection(user, password) in the CRI:
		</div><pre class="screen">(
ConnectionRequestInfo
)</pre></div><div class="section" id="idm139946679272992"><div class="titlepage"><div><div><h2 class="title">14.2.Transaction stickness</h2></div></div></div><div class="para">
			You can force the same connection from a (sub-)pool to get reused throughout a transaction with the &lt;track-connection-by-tx/&gt; flag
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				This is the only supported behaviour for <span class="emphasis"><em>"local"</em></span> transactions. This element is deprecated in JBoss Enterprise Application Platform 5 where transaction stickiness is enabled by default. XA users can explicitly enable interleaving with &lt;interleaving/&gt; element.
			</div></div></div></div><div class="section" id="idm139946679269344"><div class="titlepage"><div><div><h2 class="title">14.3.Workaround for Oracle</h2></div></div></div><div class="para">
			Oracle does not like XA connections getting used both inside and outside a JTA transaction. To workaround the problem you can create separate sub-pools for the different contexts using &lt;no-tx-separate-pools/&gt;.
		</div></div><div class="section" id="idm139946679267696"><div class="titlepage"><div><div><h2 class="title">14.4.Pool Access</h2></div></div></div><div class="para">
			The pool is designed for concurrent usage.
		</div><div class="para">
			Upto &lt;max-pool-size/&gt; threads can be inside the pool at the same time (or using connections from a pool).
		</div><div class="para">
			Once this limit is reached, threads wait for the &lt;blocking-timeout-seconds/&gt; to use the pool before throwing a <a href="http://www.jboss.org/community/wiki/WhatDoesTheMessageNoManagedConnectionsAvailableMean" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">No Managed Connections Available</a>
		</div><div class="para">
			You may want to use the &lt;allocation-retry/&gt; and &lt;allocation-retry-wait-millis/&gt; elements to have the pool retry to obtain a connection before throwing the exception.
		</div></div><div class="section" id="idm139946669740496"><div class="titlepage"><div><div><h2 class="title">14.5.Pool Filling</h2></div></div></div><div class="para">
			The number of connections in the pool is controlled by the pool sizes.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					&lt;min-pool-size/&gt; - When the number of connections falls below this size, new connections are created
				</div></li><li class="listitem"><div class="para">
					&lt;max-pool-size/&gt; - No more than this number of connections are created
				</div></li><li class="listitem"><div class="para">
					&lt;prefill/&gt; - Feature Request has been implemented for 4.0.5. Note: the only pooling strategy that supports this feature is OnePool?, or ByNothing? pooling criteria.
				</div></li></ul></div><div class="para">
			The pool filling is done by a separate "Pool Filler" thread rather than blocking application threads.
		</div></div><div class="section" id="idm139946669734928"><div class="titlepage"><div><div><h2 class="title">14.6.Idle Connections</h2></div></div></div><div class="para">
			You can configure connections to be closed when they are idle. e.g. If you just had a peak period and now want to reap the unused ones. This is done via the &lt;idle-timeout-minutes/&gt;.
		</div><div class="para">
			Idle checking is done on a separate "Idle Remover" thread on an LRU (least recently used) basis. The check is done every idle-timeout-minutes divided by 2 for connections unused for idle-timeout-minutes.
		</div><div class="para">
			The pool itself operates on an MRU (most recently used) basis. This allows the excess connections to be easily identified.
		</div><div class="para">
			Should closing idle connections cause the pool to fall below the min-pool-size, new/fresh connections are created.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If you have long running transactions and you use interleaving (i.e. don't track-connection-by-tx) make sure the idle timeout is greater than the transaction timeout. When interleaving the connection is returned to the pool for others to use. If however nobody does use it, it would be a candidate for removal before the transaction is committed.
			</div></div></div></div><div class="section" id="idm139946676612128"><div class="titlepage"><div><div><h2 class="title">14.7.Dead connections</h2></div></div></div><div class="para">
			The JDBC protocol does not provide a natural <code class="literal">connectionErrorOccured()</code> event when a connection is broken. To support dead/broken connection checking there are a number of plugins.
		</div><div class="section" id="idm139946676610336"><div class="titlepage"><div><div><h3 class="title">14.7.1.Valid connection checking</h3></div></div></div><div class="para">
				The simplest format is to just run a "quick" sql statement: 
<pre class="screen">&lt;check-valid-connection-sql&gt;select 1 from dual&lt;/check-valid-connection-sql&gt;</pre>
				 before handing the connection to the application. If this fails, another connection is selected until there are no more connections at which point new connections are constructed.
			</div><div class="para">
				The potentially more performant check is to use vendor specific features, e.g. Oracle's or MySQL's pingDatabase() via the 
<pre class="screen">&lt;valid-connection-checker-class-name/&gt;</pre>

			</div></div><div class="section" id="idm139946676607296"><div class="titlepage"><div><div><h3 class="title">14.7.2.Errors during SQL queries</h3></div></div></div><div class="para">
				You can check if a connection broke during a query by the looking the error codes or messages of the SQLException for FATAL errors rather than normal SQLExceptions. These codes/messages can be vendor specific, e.g. 
<pre class="screen">&lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.OracleExceptionSorter&lt;/exception-sorter-class-name&gt;</pre>
				 For <code class="literal">FATAL</code> errors, the connection will be closed.
			</div></div><div class="section" id="idm139946676604656"><div class="titlepage"><div><div><h3 class="title">14.7.3.Changing/Closing/Flushing the pool</h3></div></div></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<a href="http://www.jboss.org/community/wiki/HowDoIChangeThePoolingParameters" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">change or flush()</a> the pool
					</div></li><li class="listitem"><div class="para">
						closing/undeploying the pool will do a flush first
					</div></li></ul></div></div><div class="section" id="idm139946676600720"><div class="titlepage"><div><div><h3 class="title">14.7.4.Other pooling</h3></div></div></div><div class="para">
				<a href="http://www.jboss.org/community/docs/DOC-10020?uniqueTitle=false" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">Thirdparty Pools</a> - only if you know what you are doing
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="faq" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter15.Frequently Asked Questions</h2></div></div></div><div class="section" id="idm139946673368592"><div class="titlepage"><div><div><h2 class="title">15.1.I have problems with Oracle XA?</h2></div></div></div><div class="para">
			<a id="idm139946670135520" class="indexterm"><!--Empty--></a> Check that you: 
			<div class="orderedlist"><ol><li class="listitem"><div class="para">
						You have pad=true for the XidFactory? in conf/jboss-service.xml.
					</div></li><li class="listitem"><div class="para">
						You have &lt;track-connection-by-tx/&gt; in your oracle-xa-ds.xml (not necessarily for JBoss Enterprise Application Platform 5.x where it is enabled by default and the element is deprecated).
					</div></li><li class="listitem"><div class="para">
						You have &lt;isSameRM-override-value&gt;false&lt;/isSameRM-override-value&gt; in your oracle-xa-ds.xml.
					</div></li><li class="listitem"><div class="para">
						You have &lt;no-tx-separate-pools/&gt; in your oracle-xa-ds.xml.
					</div></li><li class="listitem"><div class="para">
						That your jbosscmp-jdbc.xml is specifying the same version of oracle as the one you use.
					</div></li><li class="listitem"><div class="para">
						That the oracle server you connect to has XA.
					</div></li></ol></div>
			 Configuring Oracle Database for XA Support You can configure Oracle database to support XA resources. This enables you to use JDBC 2.0-compliant Oracle driver. To XA-initialize Oracle database, complete the following steps:
		</div><div class="para">
			Make sure that Oracle JServer is installed with your database. If it is not installed, you must add it using Oracle Database Configuration Assistant. Choose "Change an Existing DB" and then select the database to which you want to add Oracle JServer. Choose "Next", then "Oracle JServer" and then "Finish". If the settings you have made to your database previously, are not suitable or insufficient for the Oracle JServer installation, the system prompts you to enter additional parameters. The database configuration file ( init.ora ) is located in <code class="literal">\oracle\admin\&lt;your_db_name&gt;\pfile</code> directory. Execute initxa.sql over your database. By default, this script file is located in <code class="literal">\oracle\ora81\javavm\install</code>. If errors occur during the execution of the file, you must execute the SQL statements from the file manually. Use DBA Studio to create a package and package body named JAVA_XA in SYS schema, and a synonym of this package (also named JAVA_XA) in PUBLIC schema.
		</div><div class="para">
			A slightly more detailed set of instructions can be found at <a href="http://www.ibm.com/developerworks/websphere/library/techarticles/0407_woolf/0407_woolf.html?ca=dnp-327#oracle_exception" class="mimir-link-warn" title="Mimir does not include content from: www.ibm.com">Configuring and using XA distributed transactions in WebSphere Studio - Oracle Exception section</a>.
		</div></div></div></div><div class="part" id="Clustering"><div class="titlepage"><div><div><h1 class="title">PartIII.Clustering Guide</h1></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-intro.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter16.Introduction and Quick Start</h2></div></div></div><div class="para">
		Clustering allows you to run an application on several parallel servers (a.k.a cluster nodes) while providing a single view to application clients. Load is distributed across different servers, and even if one or more of the servers fails, the application is still accessible via the surviving cluster nodes. Clustering is crucial for scalable enterprise applications, as you can improve performance by adding more nodes to the cluster. Clustering is crucial for highly available enterprise applications, as it is the clustering infrastructure that supports the redundancy needed for high availability.
	</div><div class="para">
		The JBoss Enterprise Application Platform comes with clustering support out of the box, as part of the <code class="literal">all</code> configuration. The <code class="literal">all</code> configuration includes support for the following: 
		<div class="itemizedlist"><ul><li class="listitem"><div class="para">
					A scalable, fault-tolerant JNDI implementation (HA-JNDI).
				</div></li><li class="listitem"><div class="para">
					Web tier clustering, including:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							High availability for web session state via state replication.
						</div></li></ul></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Ability to integrate with hardware and software load balancers, including special integration with mod_jk and other JK-based software load balancers.
						</div></li></ul></div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Single Sign-on support across a cluster.
						</div></li></ul></div></li><li class="listitem"><div class="para">
					EJB session bean clustering, for both stateful and stateless beans, and for both EJB3 and EJB2.
				</div></li><li class="listitem"><div class="para">
					A distributed cache for JPA/Hibernate entities.
				</div></li><li class="listitem"><div class="para">
					A framework for keeping local EJB2 entity caches consistent across a cluster by invalidating cache entries across the cluster when a bean is changed on any node.
				</div></li><li class="listitem"><div class="para">
					Distributed JMS queues and topics via JBoss Messaging.
				</div></li><li class="listitem"><div class="para">
					Deploying a service or application on multiple nodes in the cluster but having it active on only one (but at least one) node is called a <span class="emphasis"><em>HA Singleton</em></span>.
				</div></li><li class="listitem"><div class="para">
					Keeping deployed content in sync on all nodes in the cluster via the <code class="literal">Farm</code> service.
				</div></li></ul></div>

	</div><div class="para">
		In this <span class="emphasis"><em>Clustering Guide</em></span> we aim to provide you with an in depth understanding of how to use JBoss Enterprise Application Platform's clustering features. In this first part of the guide, the goal is to provide some basic "Quick Start" steps to encourage you to start experimenting with JBoss Enterprise Application Platform Clustering, and then to provide some background information that will allow you to understand how JBoss Enterprise Application Platform Clustering works. The next part of the guide then explains in detail how to use these features to cluster your JEE services. Finally, we provide some more details about advanced configuration of JGroups and JBoss Cache, the core technologies that underlie JBoss Enterprise Application Platform Clustering.
	</div><div class="section" id="clustering-quickstart"><div class="titlepage"><div><div><h2 class="title">16.1.Quick Start Guide</h2></div></div></div><div class="para">
			The goal of this section is to give you the minimum information needed to let you get started experimenting with JBoss Enterprise Application Platform Clustering. Most of the areas touched on in this section are covered in much greater detail later in this guide.
		</div><div class="section" id="clustering-quickstart-setup"><div class="titlepage"><div><div><h3 class="title">16.1.1.Initial Preparation</h3></div></div></div><div class="para">
				Preparing a set of servers to act as a JBoss Enterprise Application Platform cluster involves a few simple steps:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Install JBoss Enterprise Application Platform on all your servers.</strong></span> In its simplest form, this is just a matter of unzipping the JBoss download onto the filesystem on each server. 
					</div><div class="para">
						If you want to run multiple JBoss Enterprise Application Platform instances on a single server, you can either install the full JBoss distribution onto multiple locations on your filesystem, or you can simply make copies of the <code class="literal">all</code> configuration. For example, assuming the root of the JBoss distribution was unzipped to <code class="literal">/var/jboss</code>, you would:
					</div><pre class="programlisting">
$ cd /var/jboss/server
$ cp -r all node1
$ cp -r all node2</pre></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>For each node, determine the address to bind sockets to.</strong></span> When you start JBoss, whether clustered or not, you need to tell JBoss on what address its sockets should listen for traffic. (The default is <code class="literal">localhost</code> which is secure but isn't very useful, particularly in a cluster.) So, you need to decide what those addresses will be.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Ensure multicast is working.</strong></span> By default JBoss Enterprise Application Platform uses UDP multicast for most intra-cluster communications. Make sure each server's networking configuration supports multicast and that multicast support is enabled for any switches or routers between your servers. If you are planning to run more than one node on a server, make sure the server's routing table includes a multicast route. See the JGroups documentation at <a href="http://www.jgroups.org" class="mimir-link-warn" title="Mimir does not include content from: www.jgroups.org">http://www.jgroups.org</a> for more on this general area, including information on how to use JGroups' diagnostic tools to confirm that multicast is working.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							JBoss Enterprise Application Platform clustering does not require the use of UDP multicast; the Enterprise Application Platform can also be reconfigured to use TCP unicast for intra-cluster communication.
						</div></div></div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Determine a unique integer "ServerPeerID" for each node.</strong></span> This is needed for JBoss Messaging clustering, and can be skipped if you will not be running JBoss Messaging (i.e. you will remove JBM from your server configuration's <code class="literal">deploy</code> directory). JBM requires that each node in a cluster has a unique integer id, known as a "ServerPeerID", that should remain consistent across server restarts. A simple 1, 2, 3, ..., x naming scheme is fine. We'll cover how to use these integer ids in the next section.
					</div></li></ul></div><div class="para">
				Beyond the above required steps, the following two optional steps are recommended to help ensure that your cluster is properly isolated from other JBoss Enterprise Application Platform clusters that may be running on your network:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Pick a unique name for your cluster.</strong></span> The default name for a JBoss Enterprise Application Platform cluster is "DefaultPartition". Come up with a different name for each cluster in your environment, e.g. "QAPartition" or "BobsDevPartition". The use of "Partition" is not required; it's just a semi-convention. As a small aid to performance try to keep the name short, as it gets included in every message sent around the cluster. We'll cover how to use the name you pick in the next section.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Pick a unique multicast address for your cluster.</strong></span> By default JBoss Enterprise Application Platform uses UDP multicast for most intra-cluster communication. Pick a different multicast address for each cluster you run. Generally a good multicast address is of the form <code class="literal">239.255.x.y</code>. See <a href="http://www.29west.com/docs/THPM/multicast-address-assignment.html" class="mimir-link-warn" title="Mimir does not include content from: www.29west.com"> http://www.29west.com/docs/THPM/multicast-address-assignment.html </a> for a good discussion on multicast address assignment. We'll cover how to use the address you pick in the next section.
					</div></li></ul></div><div class="para">
				See <a class="xref" href="#clustering-jgroups-isolation">Section25.6.2, Isolating JGroups Channels</a> for more on isolating clusters.
			</div></div><div class="section" id="clustering-quickstart-launching"><div class="titlepage"><div><div><h3 class="title">16.1.2.Launching a JBoss Enterprise Application Platform Cluster</h3></div></div></div><div class="para">
				The simplest way to start a JBoss server cluster is to start several JBoss instances on the same local network, using the <code class="literal">-c all</code> command line option for each instance. Those server instances will detect each other and automatically form a cluster.
			</div><div class="para">
				Let's look at a few different scenarios for doing this. In each scenario we'll be creating a two node cluster, where the ServerPeerID for the first node is <code class="literal">1</code> and for the second node is <code class="literal">2</code> . We've decided to call our cluster "DocsPartition" and to use <code class="literal">239.255.100.100</code> as our multicast address. These scenarios are meant to be illustrative; the use of a two node cluster shouldn't be taken to mean that is the best size for a cluster; it's just that's the simplest way to do the examples.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 1: Nodes on Separate Machines</strong></span>
					</div><div class="para">
						This is the most common production scenario. Assume the machines are named "node1" and "node2", while node1 has an IP address of <code class="literal">192.168.0.101</code> and node2 has an address of <code class="literal">192.168.0.102</code>. Assume the "ServerPeerID" for node1 is <code class="literal">1</code> and for node2 it's <code class="literal">2</code>. Assume on each machine JBoss is installed in <code class="literal">/var/jboss</code>.
					</div><div class="para">
						On node1, to launch JBoss:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c all -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1</pre><div class="para">
						On node2, it's the same except for a different <code class="literal">-b</code> value and ServerPeerID:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c all -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.102 -Djboss.messaging.ServerPeerID=2</pre><div class="para">
						The <code class="literal">-c</code> switch says to use the <code class="literal">all</code> config, which includes clustering support. The <code class="literal">-g</code> switch sets the cluster name. The <code class="literal">-u</code> switch sets the multicast address that will be used for intra-cluster communication. The <code class="literal">-b</code> switch sets the address on which sockets will be bound. The <code class="literal">-D</code> switch sets system property <code class="literal">jboss.messaging.ServerPeerID</code>, from which JBoss Messaging gets its unique id.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 2: Two Nodes on a Single, Multihomed, Server</strong></span>
					</div><div class="para">
						Running multiple nodes on the same machine is a common scenario in a development environment, and is also used in production in combination with Scenario 1. (Running <span class="emphasis"><em>all</em></span> the nodes in a production cluster on a single machine is generally not recommended, since the machine itself becomes a single point of failure.) In this version of the scenario, the machine is multihomed, i.e. has more than one IP address. This allows the binding of each JBoss instance to a different address, preventing port conflicts when the nodes open sockets.
					</div><div class="para">
						Assume the single machine has the <code class="literal">192.168.0.101</code> and <code class="literal">192.168.0.102</code> addresses assigned, and that the two JBoss instances use the same addresses and ServerPeerIDs as in Scenario 1. The difference from Scenario 1 is we need to be sure each Enterprise Application Platform instance has its own work area. So, instead of using the <code class="literal">all</code> config, we are going to use the <code class="literal">node1</code> and <code class="literal">node2</code> configs we copied from <code class="literal">all</code> earlier in the previous section.
					</div><div class="para">
						To launch the first instance, open a console window and:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node1 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1</pre><div class="para">
						For the second instance, it's the same except for different <span class="emphasis"><em>-b</em></span> and <span class="emphasis"><em>-c</em></span> values and a different ServerPeerID:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node2 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.102 -Djboss.messaging.ServerPeerID=2</pre></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Scenario 3: Two Nodes on a Single, Non-Multihomed, Server</strong></span>
					</div><div class="para">
						This is similar to Scenario 2, but here the machine only has one IP address available. Two processes can't bind sockets to the same address and port, so we'll have to tell JBoss to use different ports for the two instances. This can be done by configuring the ServiceBindingManager service by setting the <code class="literal">jboss.service.binding.set</code> system property.
					</div><div class="para">
						To launch the first instance, open a console window and:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node1 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=1 \
    -Djboss.service.binding.set=ports-default</pre><div class="para">
						For the second instance:
					</div><pre class="programlisting">
$ cd /var/jboss/bin
$ ./run.sh -c node2 -g DocsPartition -u 239.255.100.100 \
    -b 192.168.0.101 -Djboss.messaging.ServerPeerID=2 \
    -Djboss.service.binding.set=ports-01</pre><div class="para">
						This tells the ServiceBindingManager on the first node to use the standard set of ports (e.g. JNDI on 1099). The second node uses the "ports-01" binding set, which by default for each port has an offset of 100 from the standard port number (e.g. JNDI on 1199). See the <code class="literal">conf/bindingservice.beans/META-INF/bindings-jboss-beans.xml</code> file for the full ServiceBindingManager configuration.
					</div><div class="para">
						Note that this setup is not advised for production use, due to the increased management complexity that comes with using different ports. But it is a fairly common scenario in development environments where developers want to use clustering but cannot multihome their workstations.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							Including <code class="literal">-Djboss.service.binding.set=ports-default</code> on the command line for node1 isn't technically necessary, since <code class="literal">ports-default</code> is the default value. But using a consistent set of command line arguments across all servers is helpful to people less familiar with all the details.
						</div></div></div></li></ul></div><div class="para">
				That's it; that's all it takes to get a cluster of JBoss Enterprise Application Platform servers up and running.
			</div></div><div class="section" id="clustering-quickstart-http"><div class="titlepage"><div><div><h3 class="title">16.1.3.Web Application Clustering Quick Start</h3></div></div></div><div class="para">
				JBoss Enterprise Application Platform supports clustered web sessions, where a backup copy of each user's <code class="literal">HttpSession</code> state is stored on one or more nodes in the cluster. In case the primary node handling the session fails or is shut down, any other node in the cluster can handle subsequent requests for the session by accessing the backup copy. Web tier clustering is discussed in detail in <a class="xref" href="#clustering-http">Chapter22, <em>HTTP Services</em></a>.
			</div><div class="para">
				There are two aspects to setting up web tier clustering: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Configuring an External Load Balancer</strong></span>. Web applications require an external load balancer to balance HTTP requests across the cluster of JBoss Enterprise Application Platform instances (see <a class="xref" href="#clustering-concepts-arch-balancer">Section17.2.2, External Load Balancer Architecture</a> for more on why that is). JBoss Enterprise Application Platform itself doesn't act as an HTTP load balancer. So, you will need to set up a hardware or software load balancer. There are many possible load balancer choices, so how to configure one is really beyond the scope of a Quick Start. But see <a class="xref" href="#clustering-http-modjk">Section22.1, Configuring load balancing using Apache and mod_jk</a> for details on how to set up the popular mod_jk software load balancer.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Configuring Your Web Application for Clustering</strong></span>. This aspect involves telling JBoss you want clustering behavior for a particular web app, and it couldn't be simpler. Just add an empty <code class="literal">distributable</code> element to your application's <code class="literal">web.xml</code> file:
						</div><pre class="programlisting">&lt;?xml version="1.0"?&gt; 
&lt;web-app  xmlns="http://java.sun.com/xml/ns/javaee"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
                              http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" 
          version="2.5"&gt;
          
    &lt;distributable/&gt;
    
&lt;/web-app&gt;</pre><div class="para">
							Simply doing that is enough to get the default JBoss Enterprise Application Platform web session clustering behavior, which is appropriate for most applications. See <a class="xref" href="#clustering-http-state">Section22.2, Configuring HTTP session state replication</a> for more advanced configuration options.
						</div></li></ul></div>

			</div></div><div class="section" id="clustering-quickstart-ejbsessions"><div class="titlepage"><div><div><h3 class="title">16.1.4.EJB Session Bean Clustering Quick Start</h3></div></div></div><div class="para">
				JBoss Enterprise Application Platform supports clustered EJB session beans, whereby requests for a bean are balanced across the cluster. For stateful beans a backup copy of bean state is maintained on one or more cluster nodes, providing high availability in case the node handling a particular session fails or is shut down. Clustering of both EJB2 and EJB3 beans is supported.
			</div><div class="para">
				For EJB3 session beans, simply add the <code class="literal">org.jboss.ejb3.annotation.Clustered</code> annotation to the bean class for your stateful or stateless bean:
			</div><pre class="programlisting">
@javax.ejb.Stateless
@org.jboss.ejb3.annotation.Clustered
public class MyBean implements MySessionInt {
   
   public void test() {
      // Do something cool
   }
}</pre><div class="para">
				For EJB2 session beans, or for EJB3 beans where you prefer XML configuration over annotations, simply add a <code class="literal">clustered</code> element to the bean's section in the JBoss-specific deployment descriptor, <code class="literal">jboss.xml</code>:
			</div><pre class="programlisting">
&lt;jboss&gt;    
    &lt;enterprise-beans&gt;      
        &lt;session&gt;        
            &lt;ejb-name&gt;example.StatelessSession&lt;/ejb-name&gt;        
            &lt;jndi-name&gt;example.StatelessSession&lt;/jndi-name&gt;        
            &lt;clustered&gt;true&lt;/clustered&gt;
        &lt;/session&gt;
    &lt;/enterprise-beans&gt;
&lt;/jboss&gt;</pre><div class="para">
				See <a class="xref" href="#clustering-session">Chapter20, <em>Clustered Session EJBs</em></a> for more advanced configuration options.
			</div></div><div class="section" id="clustering-quickstart-ejb3entities"><div class="titlepage"><div><div><h3 class="title">16.1.5.Entity Clustering Quick Start</h3></div></div></div><div class="para">
				One of the big improvements in the clustering area in JBoss Enterprise Application Platform 5 is the use of the new Hibernate/JBoss Cache integration for second level entity caching that was introduced in Hibernate 3.3. In the JPA/Hibernate context, a second level cache refers to a cache whose contents are retained beyond the scope of a transaction. A second level cache <span class="emphasis"><em>may</em></span> improve performance by reducing the number of database reads. You should always load test your application with second level caching enabled and disabled to see whether it has a beneficial impact on your particular application.
			</div><div class="para">
				If you use more than one JBoss Enterprise Application Platform instance to run your JPA/Hibernate application and you use second level caching, you must use a cluster-aware cache. Otherwise a cache on server A will still hold out-of-date data after activity on server B updates some entities.
			</div><div class="para">
				JBoss Enterprise Application Platform provides a cluster-aware second level cache based on JBoss Cache. To tell JBoss Enterprise Application Platform's standard Hibernate-based JPA provider to enable second level caching with JBoss Cache, configure your <code class="literal">persistence.xml</code> as follows:
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence
   http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt; 
   &lt;persistence-unit name="somename" transaction-type="JTA"&gt;
      &lt;jta-data-source&gt;java:/SomeDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.cache.use_second_level_cache" value="true"/&gt;
         &lt;property name="hibernate.cache.region.factory_class" 
                   value="org.hibernate.cache.jbc2.JndiMultiplexedJBossCacheRegionFactory"/&gt;
         &lt;property name="hibernate.cache.region.jbc2.cachefactory" value="java:CacheManager"/&gt;
         &lt;!-- Other configuration options ... --&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre><div class="para">
				That tells Hibernate to use the JBoss Cache-based second level cache, but it doesn't tell it what entities to cache. That can be done by adding the <code class="literal">org.hibernate.annotations.Cache</code> annotation to your entity class:
			</div><pre class="programlisting">
package org.example.entities;
 
import java.io.Serializable;
import javax.persistence.Entity;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
 
@Entity
@Cache(usage=CacheConcurrencyStrategy.TRANSACTIONAL)
public class Account implements Serializable {
</pre><div class="para">
				See <a class="xref" href="#clustering-entity">Chapter21, <em>Clustered Entity EJBs</em></a> for more advanced configuration options and details on how to configure the same thing for a non-JPA Hibernate application.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Clustering can add significant overhead to a JPA/Hibernate second level cache, so don't assume that just because second level caching adds a benefit to a non-clustered application that it will be beneficial to a clustered application. Even if clustered second level caching is beneficial overall, caching of more frequently modified entity types may be beneficial in a non-clustered scenario but not in a clustered one. <span class="emphasis"><em>Always</em></span> load test your application.
				</div></div></div></div></div></div><div xml:lang="en-US" class="chapter" id="cluster.concepts.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter17.Clustering Concepts</h2></div></div></div><div class="para">
		In the next section, we discuss basic concepts behind JBoss' clustering services. It is helpful that you understand these concepts before reading the rest of the <span class="emphasis"><em>Clustering Guide</em></span>.
	</div><div class="section" id="clustering-concepts-def"><div class="titlepage"><div><div><h2 class="title">17.1.Cluster Definition</h2></div></div></div><div class="para">
			A cluster is a set of nodes that communicate with each other and work toward a common goal. In a JBoss Enterprise Application Platform cluster (also known as a partition), a node is an JBoss Enterprise Application Platform instance. Communication between the nodes is handled by the JGroups group communication library, with a JGroups <code class="literal">Channel</code> providing the core functionality of tracking who is in the cluster and reliably exchanging messages between the cluster members. JGroups channels with the same configuration and name have the ability to dynamically discover each other and form a group. This is why simply executing run -c all on two Enterprise Application Platform instances on the same network is enough for them to form a cluster  each Enterprise Application Platform starts a <code class="literal">Channel</code> (actually, several) with the same default configuration, so they dynamically discover each other and form a cluster. Nodes can be dynamically added to or removed from clusters at any time, simply by starting or stopping a <code class="literal">Channel</code> with a configuration and name that matches the other cluster members.
		</div><div class="para">
			On the same Enterprise Application Platform instance, different services can create their own <code class="literal">Channel</code>. In a standard startup of the Enterprise Application Platform 5 <span class="emphasis"><em>all</em></span> configuration, two different services create a total of four different channels  JBoss Messaging creates two and a core general purpose clustering service known as HAPartition creates two more. If you deploy clustered web applications, clustered EJB3 SFSBs or a clustered JPA/Hibernate entity cache, additional channels will be created. The channels the Enterprise Application Platform connects can be divided into three broad categories: a general purpose channel used by the HAPartition service, channels created by JBoss Cache for special purpose caching and cluster wide state replication, and two channels used by JBoss Messaging.
		</div><div class="para">
			So, if you go to two Enterprise Application Platform 5.0.x instances and execute <code class="literal">run -c all</code>, the channels will discover each other and you'll have a conceptual <code class="literal">cluster</code>. It's easy to think of this as a two node cluster, but it's important to understand that you really have multiple channels, and hence multiple two node clusters.
		</div><div class="para">
			On the same network, you may have different sets of servers whose services wish to cluster. <a class="xref" href="#clustering-Partition.fig">Figure17.1, Clusters and server nodes</a> shows an example network of JBoss server instances divided into three sets, with the third set only having one node. This sort of topology can be set up simply by configuring the Enterprise Application Platform instances such that within a set of nodes meant to form a cluster the Channel configurations and names match while they differ from any other channel configurations and names match while they differ from any other channels on the same network. The Enterprise Application Platform tries to make this is easy as possible, such that servers that are meant to cluster only need to have the same values passed on the command line to the <code class="literal">-g</code> (partition name) and <code class="literal">-u</code> (multicast address) startup switches. For each set of servers, different values should be chosen. The sections on JGroups Configuration and Isolating JGroups Channels cover in detail how to configure the Enterprise Application Platform such that desired peers find each other and unwanted peers do not.
		</div><div class="figure" id="clustering-Partition.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/cb26ee0c96888e485936d5739cc37083/clustering-Partition.png" align="middle" alt="Clusters and server nodes" /></div></div><p class="title"><strong>Figure17.1.Clusters and server nodes</strong></p></div></div><div class="section" id="clustering-concepts-arch"><div class="titlepage"><div><div><h2 class="title">17.2.Service Architectures</h2></div></div></div><div class="para">
			The clustering topography defined by the JGroups configuration on each node is of great importance to system administrators. But for most application developers, the greater concern is probably the cluster architecture from a client application's point of view. Two basic clustering architectures are used with JBoss Enterprise Application Platform: client-side interceptors (a.k.a. smart proxies or stubs) and external load balancers. Which architecture your application will use will depend on what type of client you have.
		</div><div class="section" id="clustering-concepts-arch-proxy"><div class="titlepage"><div><div><h3 class="title">17.2.1.Client-side interceptor architecture</h3></div></div></div><div class="para">
				Most remote services provided by the JBoss Enterprise Application Platform, including JNDI, EJB, JMS, RMI and JBoss Remoting, require the client to obtain (for example, to look up and download) a remote proxy object. The proxy object is generated by the server and it implements the business interface of the service. The client then makes local method calls against the proxy object. The proxy automatically routes the call across the network where it is invoked against service objects managed in the server. The proxy object figures out how to find the appropriate server node, marshal call parameters, unmarshal call results, and return the result to the caller client. In a clustered environment, the server-generated proxy object includes an interceptor that understands how to route calls to multiple nodes in the cluster.
			</div><div class="para">
				The proxy's clustering logic maintains up-to-date knowledge about the cluster. For instance, it knows the IP addresses of all available server nodes, the algorithm to distribute load across nodes (see next section), and how to failover the request if the target node not available. As part of handling each service request, if the cluster topology has changed the server node updates the proxy with the latest changes in the cluster. For instance, if a node drops out of the cluster, each proxy is updated with the new topology the next time it connects to any active node in the cluster. All the manipulations done by the proxy's clustering logic are transparent to the client application. The client-side interceptor clustering architecture is illustrated in <a class="xref" href="#clustering-InterceptorArch.fig">Figure17.2, The client-side interceptor (proxy) architecture for clustering</a>.
			</div><div class="figure" id="clustering-InterceptorArch.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/c38c82ceb81aa34edc4675f491977bd2/clustering-InterceptorArch.png" align="middle" width="444" alt="The client-side interceptor (proxy) architecture for clustering" /></div></div><p class="title"><strong>Figure17.2.The client-side interceptor (proxy) architecture for clustering</strong></p></div></div><div class="section" id="clustering-concepts-arch-balancer"><div class="titlepage"><div><div><h3 class="title">17.2.2.External Load Balancer Architecture</h3></div></div></div><div class="para">
				The HTTP-based JBoss services do not require the client to download anything. The client (for example, a web browser) sends in requests and receives responses directly over the wire using the HTTP protocol). In this case, an external load balancer is required to process all requests and dispatch them to server nodes in the cluster. The client only needs to know how to contact the load balancer; it has no knowledge of the JBoss Enterprise Application Platform instances behind the load balancer. The load balancer is logically part of the cluster, but we refer to it as external because it is not running in the same process as either the client or any of the JBoss Enterprise Application Platform instances. It can be implemented either in software or hardware. There are many vendors of hardware load balancers; the mod_jk Apache module is an excellent example of a software load balancer. An external load balancer implements its own mechanism for understanding the cluster configuration and provides its own load balancing and failover policies. The external load balancer clustering architecture is illustrated in <a class="xref" href="#clustering-BalancerArch.fig">Figure17.3, The external load balancer architecture for clustering</a>.
			</div><div class="figure" id="clustering-BalancerArch.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/8e71a3d800cb08b1e456ff7b0bae58af/clustering-BalancerArch.png" align="middle" width="444" alt="The external load balancer architecture for clustering" /></div></div><p class="title"><strong>Figure17.3.The external load balancer architecture for clustering</strong></p></div><div class="para">
				A potential problem with an external load balancer architecture is that the load balancer itself may be a single point of failure. It needs to be monitored closely to ensure high availability of the entire cluster's services.
			</div></div></div><div class="section" id="clustering-concepts-balancepolicy"><div class="titlepage"><div><div><h2 class="title">17.3.Load Balancing Policies</h2></div></div></div><div class="para">
			Both the JBoss client-side interceptor (stub) and load balancer use load balancing policies to determine to which server node a new request should be sent. In this section, let's go over the load balancing policies available in JBoss Enterprise Application Platform.
		</div><div class="section" id="clustering-concepts-balancepolicy-30"><div class="titlepage"><div><div><h3 class="title">17.3.1.Client-side interceptor architecture</h3></div></div></div><div class="para">
				In JBoss Enterprise Application Platform 5, the following load balancing options are available when the client-side interceptor architecture is used. The client-side stub maintains a list of all nodes providing the target service; the job of the load balance policy is to pick a node from this list for each request. Each policy has two implementation classes, one meant for use by legacy services like EJB2 that use the legacy detached invoker architecture, and the other meant for services like EJB3 that use AOP-based invocations.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Round-Robin: each call is dispatched to a new node, proceeding sequentially through the list of nodes. The first target node is randomly selected from the list. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.RoundRobin</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.RoundRobin</code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						Random-Robin: for each call the target node is randomly selected from the list. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.RandomRobin</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.RandomRobin </code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						First Available: one of the available target nodes is elected as the main target and is thereafter used for every call; this elected member is randomly chosen from the list of members in the cluster. When the list of target nodes changes (because a node starts or dies), the policy will choose a new target node unless the currently elected node is still available. Each client-side proxy elects its own target node independently of the other proxies, so if a particular client downloads two proxies for the same target service (for example, an EJB), each proxy will independently pick its target. This is an example of a policy that provides session affinity or sticky sessions, since the target node does not change once established. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.FirstAvailable</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailable</code> (EJB3).
					</div></li><li class="listitem"><div class="para">
						First Available Identical All Proxies: has the same behavior as the "First Available" policy but the elected target node is shared by all proxies in the same client-side VM that are associated with the same target service. So if a particular client downloads two proxies for the same target service (e.g. an EJB), each proxy will use the same target. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.FirstAvailableIdenticalAllProxies</code> (legacy) and <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailableIdenticalAllProxies</code> (EJB3).
					</div></li></ul></div><div class="para">
				Each of the above is an implementation of the <code class="classname">org.jboss.ha.framework.interfaces.LoadBalancePolicy</code> interface; users are free to write their own implementation of this simple interface if they need some special behavior. In later sections we'll see how to configure the load balance policies used by different services.
			</div></div><div class="section" id="idm139946676066848"><div class="titlepage"><div><div><h3 class="title">17.3.2.External load balancer architecture</h3></div></div></div><div class="para">
				New in JBoss Enterprise Application Platform 5 are a set of "TransactionSticky" load balance policies. These extend the standard policies above to add behavior such that all invocations that occur within the scope of a transaction are routed to the same node (if that node still exists). These are based on the legacy detached invoker architecture, so they are not available for AOP-based services like EJB3.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Transaction-Sticky Round-Robin: Transaction-sticky variant of Round-Robin. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyRoundRobin</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky Random-Robin: Transaction-sticky variant of Random-Robin. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyRandomRobin</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky First Available: Transaction-sticky variant of First Available. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyFirstAvailable</code>.
					</div></li><li class="listitem"><div class="para">
						Transaction-Sticky First Available Identical All Proxies: Transaction-sticky variant of First Available Identical All Proxies. Implemented by <code class="literal">org.jboss.ha.framework.interfaces.TransactionStickyFirstAvailableIdenticalAllProxies</code>.
					</div></li></ul></div><div class="para">
				Each of the above is an implementation of a simple interface; users are free to write their own implementations if they need some special behavior. In later sections we'll see how to configure the load balance policies used by different services.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-blocks.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter18.Clustering Building Blocks</h2></div></div></div><div class="para">
		The clustering features in JBoss Enterprise Application Platform are built on top of lower level libraries that provide much of the core functionality. <a class="xref" href="#clustering-as-arch.fig">Figure18.1, The JBoss Enterprise Application Platform clustering architecture</a> shows the main pieces:
	</div><div class="figure" id="clustering-as-arch.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/a26da93cae87860d9ae5a8db87b6b1d8/clustering-as-arch.png" align="middle" width="444" alt="The JBoss Enterprise Application Platform clustering architecture" /></div></div><p class="title"><strong>Figure18.1.The JBoss Enterprise Application Platform clustering architecture</strong></p></div><div class="para">
		<span class="bold bold"><strong>JGroups</strong></span> is a toolkit for reliable point-to-point and point-to-multipoint communication. JGroups is used for all clustering-related communications between nodes in a JBoss Enterprise Application Platform cluster. 
	</div><div class="para">
		<span class="bold bold"><strong>JBoss Cache</strong></span> is a highly flexible clustered transactional caching library. Many Enterprise Application Platform clustering services need to cache some state in memory while (1) ensuring for high availability purposes that a backup copy of that state is available on another node if it can't otherwise be recreated (e.g. the contents of a web session) and (2) ensuring that the data cached on each node in the cluster is consistent. JBoss Cache handles these concerns for most JBoss Enterprise Application Platform clustered services. JBoss Cache uses JGroups to handle its group communication requirements. <span class="bold bold"><strong>POJO Cache</strong></span> is an extension of the core JBoss Cache that JBoss Enterprise Application Platform uses to support fine-grained replication of clustered web session state. See <a class="xref" href="#clustering-blocks-jbc">Section18.2, Distributed Caching with JBoss Cache</a> for more on how JBoss Enterprise Application Platform uses JBoss Cache and POJO Cache.
	</div><div class="para">
		<span class="bold bold"><strong>HAPartition</strong></span> is an adapter on top of a JGroups channel that allows multiple services to use the channel. HAPartition also supports a distributed registry of which HAPartition-based services are running on which cluster members. It provides notifications to interested listeners when the cluster membership changes or the clustered service registry changes. See <a class="xref" href="#clustering-hapartition">Section18.3, The HAPartition Service</a> for more details on HAPartition.
	</div><div class="para">
		The other higher level clustering services make use of JBoss Cache or HAPartition, or, in the case of HA-JNDI, both. The exception to this is JBoss Messaging's clustering features, which interact with JGroups directly.
	</div><div class="section" id="clustering-blocks-jgroups"><div class="titlepage"><div><div><h2 class="title">18.1.Group Communication with JGroups</h2></div></div></div><div class="para">
			JGroups provides the underlying group communication support for JBoss Enterprise Application Platform clusters. Services deployed on JBoss Enterprise Application Platform which need group communication with their peers will obtain a JGroups <code class="literal">Channel</code> and use it to communicate. The <code class="literal">Channel</code> handles such tasks as managing which nodes are members of the group, detecting node failures, ensuring lossless, first-in-first-out delivery of messages to all group members, and providing flow control to ensure fast message senders cannot overwhelm slow message receivers.
		</div><div class="para">
			The characteristics of a JGroups <code class="literal">Channel</code> are determined by the set of <span class="emphasis"><em>protocols</em></span> that compose it. Each protocol handles a single aspect of the overall group communication task; for example the <code class="literal">UDP</code> protocol handles the details of sending and receiving UDP datagrams. A <code class="literal">Channel</code> that uses the <code class="literal">UDP</code> protocol is capable of communicating with UDP unicast and multicast; alternatively one that uses the <code class="literal">TCP</code> protocol uses TCP unicast for all messages. JGroups supports a wide variety of different protocols (see <a class="xref" href="#jgroups-configuration">Section25.1, Configuring a JGroups Channel's Protocol Stack</a> for details), but the Enterprise Application Platform ships with a default set of channel configurations that should meet most needs.
		</div><div class="para">
			By default, UDP multicast is used by all JGroups channels used by the Enterprise Application Platform (except for one TCP-based channel used by JBoss Messaging).
		</div><div class="section" id="clustering-blocks-jgroups-channelfactory"><div class="titlepage"><div><div><h3 class="title">18.1.1.The Channel Factory Service</h3></div></div></div><div class="para">
				A significant difference in JBoss Enterprise Application Platform 5 versus previous releases is that JGroups Channels needed by clustering services (for example, a channel used by a distributed HttpSession cache) are no longer configured in detail as part of the consuming service's configuration, and are no longer directly instantiated by the consuming service. Instead, a new <code class="literal">ChannelFactory</code> service is used as a registry for named channel configurations and as a factory for <code class="literal">Channel</code> instances. A service that needs a channel requests the channel from the <code class="literal">ChannelFactory</code>, passing in the name of the desired configuration.
			</div><div class="para">
				The ChannelFactory service is deployed in the <code class="literal">server/all/deploy/cluster/jgroups-channelfactory.sar</code>. On startup the ChannelFactory service parses the <code class="literal">server/all/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file, which includes various standard JGroups configurations identified by name (for example, UDP or TCP). Services needing a channel access the channel factory and ask for a channel with a particular named configuration.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					If several services request a channel with the same configuration name from the ChannelFactory, they are not handed a reference to the same underlying Channel. Each receives its own Channel, but the channels will have an identical configuration. A logical question is how those channels avoid forming a group with each other if each, for example, is using the same multicast address and port. The answer is that when a consuming service connects its Channel, it passes a unique-to-that-service <code class="literal">cluster_name</code> argument to the <code class="literal">Channel.connect(String cluster_name)</code> method. The Channel uses that <code class="literal">cluster_name</code> as one of the factors that determine whether a particular message received over the network is intended for it.
				</div></div></div><div class="section" id="clustering-blocks-jgroups-stdconfigs"><div class="titlepage"><div><div><h4 class="title">18.1.1.1.Standard Protocol Stack Configurations</h4></div></div></div><div class="para">
					The standard protocol stack configurations that ship with Enterprise Application Platform 5 are described below. Note that not all of these are actually used; many are included as a convenience to users who may wish to alter the default server configuration. The configurations actually used in a stock Enterprise Application Platform 5 <span class="bold bold"><strong>all</strong></span> configuration are <code class="literal">udp</code>, <code class="literal">jbm-control</code> and <code class="literal">jbm-data</code>, with all clustering services other than JBoss Messaging using <code class="literal">udp</code>.
				</div><div class="para">
					You can add a new stack configuration by adding a new <code class="literal">stack</code> element to the <code class="literal">server/all/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file. You can alter the behavior of an existing configuration by editing this file. Before doing this though, have a look at the other standard configurations the Enterprise Application Platform ships; perhaps one of those meets your needs. Also, please note that before editing a configuration you should understand what services are using that configuration; make sure the change you are making is appropriate for all affected services. If the change isn't appropriate for a particular service, perhaps its better to create a new configuration and change some services to use that new configuration.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>udp</strong></span>
						</div><div class="para">
							UDP multicast based stack meant to be shared between different channels. Message bundling is disabled, as it can add latency to synchronous group RPCs. Services that only make asynchronous RPCs (for example, JBoss Cache configured for REPL_ASYNC) and do so in high volume may be able to improve performance by configuring their cache to use the <code class="literal">udp-async</code> stack below. Services that only make synchronous RPCs (for example JBoss Cache configured for REPL_SYNC or INVALIDATION_SYNC) may be able to improve performance by using the <code class="literal">udp-sync</code> stack below, which does not include flow control.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>udp-async</strong></span>
						</div><div class="para">
							Same as the default <code class="literal">udp</code> stack above, except message bundling is enabled in the transport protocol (<code class="literal">enable_bundling=true</code>). Useful for services that make high-volume asynchronous RPCs (e.g. high volume JBoss Cache instances configured for REPL_ASYNC) where message bundling may improve performance.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>udp-sync</strong></span>
						</div><div class="para">
							UDP multicast based stack, without flow control and without message bundling. This can be used instead of <code class="literal">udp</code> if (1) synchronous calls are used and (2) the message volume (rate and size) is not that large. Don't use this configuration if you send messages at a high sustained rate, or you might run out of memory.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tcp</strong></span>
						</div><div class="para">
							TCP based stack, with flow control and message bundling. TCP stacks are usually used when IP multicasting cannot be used in a network (e.g. routers discard multicast).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tcp-sync</strong></span>
						</div><div class="para">
							TCP based stack, without flow control and without message bundling. TCP stacks are usually used when IP multicasting cannot be used in a network (e.g.routers discard multicast). This configuration should be used instead of <code class="literal">tcp</code> above when (1) synchronous calls are used and (2) the message volume (rate and size) is not that large. Don't use this configuration if you send messages at a high sustained rate, or you might run out of memory.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>jbm-control</strong></span>
						</div><div class="para">
							Stack optimized for the JBoss Messaging Control Channel. By default uses the same UDP transport protocol configuration as is used for the default <code class="literal">udp</code> stack defined above. This allows the JBoss Messaging Control Channel to use the same sockets, network buffers and thread pools as are used by the other standard JBoss Enterprise Application Platform clustered services (see <a class="xref" href="#clustering-blocks-jgroups-sharedtransport">Section18.1.2, The JGroups Shared Transport</a>)
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>jbm-data</strong></span>
						</div><div class="para">
							TCP-based stack optimized for the JBoss Messaging Data Channel.
						</div></li></ul></div></div></div><div class="section" id="clustering-blocks-jgroups-sharedtransport"><div class="titlepage"><div><div><h3 class="title">18.1.2.The JGroups Shared Transport</h3></div></div></div><div class="para">
				As the number of JGroups-based clustering services running in the Enterprise Application Platform has risen over the years, the need to share the resources (particularly sockets and threads) used by these channels became a glaring problem. A stock Enterprise Application Platform 5 <span class="bold bold"><strong>all</strong></span> configuration will connect 4 JGroups channels during startup, and a total of 7 or 8 will be connected if distributable web apps, clustered EJB3 SFSBs and a clustered JPA/Hibernate second level cache are all used. So many channels can consume a lot of resources, and can be a real configuration nightmare if the network environment requires configuration to ensure cluster isolation.
			</div><div class="para">
				Beginning with Enterprise Application Platform 5, JGroups supports sharing of transport protocol instances between channels. A JGroups channel is composed of a stack of individual protocols, each of which is responsible for one aspect of the channel's behavior. A transport protocol is a protocol that is responsible for actually sending messages on the network and receiving them from the network. The resources that are most desirable for sharing (sockets and thread pools) are managed by the transport protocol, so sharing a transport protocol between channels efficiently accomplishes JGroups resource sharing.
			</div><div class="para">
				To configure a transport protocol for sharing, simply add a <code class="literal">singleton_name="someName"</code> attribute to the protocol's configuration. All channels whose transport protocol configuration uses the same <code class="literal">singleton_name</code> value will share their transport. All other protocols in the stack will not be shared. <a class="xref" href="#clustering-blocks-jgroups-sharedtp.fig">Figure18.2, Services using a Shared Transport</a> illustrates 4 services running in a VM, each with its own channel. Three of the services are sharing a transport; the fourth is using its own transport.
			</div><div class="figure" id="clustering-blocks-jgroups-sharedtp.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/fa0400324c2b460555119b043bf074a3/clustering-SharedTransport.png" align="middle" width="444" alt="Services using a Shared Transport" /></div></div><p class="title"><strong>Figure18.2.Services using a Shared Transport</strong></p></div><div class="para">
				The protocol stack configurations used by the Enterprise Application Platform 5 ChannelFactory all have a <code class="literal">singleton_name</code> configured. In fact, if you add a stack to the ChannelFactory that doesn't include a <code class="literal">singleton_name</code>, before creating any channels for that stack, the ChannelFactory will synthetically create a <code class="literal">singleton_name</code> by concatenating the stack name to the string "unnamed_", e.g. unnamed_customStack.
			</div></div></div><div class="section" id="clustering-blocks-jbc"><div class="titlepage"><div><div><h2 class="title">18.2.Distributed Caching with JBoss Cache</h2></div></div></div><div class="para">
			JBoss Cache is a fully featured distributed cache framework that can be used in any application server environment or standalone. JBoss Cache provides the underlying distributed caching support used by many of the standard clustered services in a JBoss Enterprise Application Platform cluster, including: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						replication of clustered webapp sessions
					</div></li><li class="listitem"><div class="para">
						replication of clustered EJB3 Stateful Session beans
					</div></li><li class="listitem"><div class="para">
						clustered caching of JPA and Hibernate entities
					</div></li><li class="listitem"><div class="para">
						clustered Single Sign-On
					</div></li><li class="listitem"><div class="para">
						the HA-JNDI replicated tree
					</div></li><li class="listitem"><div class="para">
						DistributedStateService
					</div></li></ul></div>

		</div><div class="para">
			Users can also create their own JBoss Cache and POJO Cache instances for custom use by their applications, see <a class="xref" href="#jbosscache.chapt">Chapter26, <em>JBoss Cache Configuration and Deployment</em></a> for more on this.
		</div><div class="section" id="clustering-blocks-jbc-cachemanager"><div class="titlepage"><div><div><h3 class="title">18.2.1.The JBoss Enterprise Application Platform CacheManager Service</h3></div></div></div><div class="para">
				Many of the standard clustered services in JBoss Enterprise Application Platform use JBoss Cache to maintain consistent state across the cluster. Different services (e.g. web session clustering or second level caching of JPA/Hibernate entities) use different JBoss Cache instances, with each cache configured to meet the needs of the service that uses it. In Enterprise Application Platform 4, each of these caches was independently deployed in the <code class="literal">deploy/</code> directory, which had a number of disadvantages: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Caches that end user applications didn't need were deployed anyway, with each creating an expensive JGroups channel. For example, even if there were no clustered EJB3 SFSBs, a cache to store them was started.
						</div></li><li class="listitem"><div class="para">
							Caches are internal details of the services that use them. They shouldn't be first-class deployments.
						</div></li><li class="listitem"><div class="para">
							Services would find their cache via JMX lookups. Using JMX for purposes other exposing management interfaces is just not the JBoss Enterprise Application Platform 5 way.
						</div></li></ul></div>

			</div><div class="para">
				In JBoss Enterprise Application Platform 5, the scattered cache deployments have been replaced with a new <span class="bold bold"><strong>CacheManager</strong></span> service, deployed via the <code class="literal">JBOSS_HOME/server/all/deploy/cluster/jboss-cache-manager.sar</code>. The CacheManager is a factory and registry for JBoss Cache instances. It is configured with a set of named JBoss Cache configurations. Services that need a cache ask the cache manager for the cache by name; the cache manager creates the cache (if not already created) and returns it. The cache manager keeps a reference to each cache it has created, so all services that request the same cache configuration name will share the same cache. When a service is done with the cache, it releases it to the cache manager. The cache manager keeps track of how many services are using each cache, and will stop and destroy the cache when all services have released it.
			</div><div class="section" id="clustering-blocks-jbc-cachemanager-stdconfigs"><div class="titlepage"><div><div><h4 class="title">18.2.1.1.Standard Cache Configurations</h4></div></div></div><div class="para">
					The following standard JBoss Cache configurations ship with JBoss Enterprise Application Platform 5. You can add others to suit your needs, or edit these configurations to adjust cache behavior. Additions or changes are done by editing the <code class="literal">deploy/cluster/jboss-cache-manager.sar/META-INF/jboss-cache-manager-jboss-beans.xml</code> file (see <a class="xref" href="#jbosscache-custom-deployment-cachemgr">Section26.2.1, Deployment Via the CacheManager Service</a> for details). Note however that these configurations are specifically optimized for their intended use, and except as specifically noted in the documentation chapters for each service in this guide, it is not advisable to change them.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>standard-session-cache</strong></span>
						</div><div class="para">
							Standard cache used for web sessions.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>field-granularity-session-cache</strong></span>
						</div><div class="para">
							Standard cache used for FIELD granularity web sessions.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>sfsb-cache</strong></span>
						</div><div class="para">
							Standard cache used for EJB3 SFSB caching.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ha-partition</strong></span>
						</div><div class="para">
							Used by web tier Clustered Single Sign-On, HA-JNDI, Distributed State.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mvcc-entity</strong></span>
						</div><div class="para">
							A configuration appropriate for JPA/Hibernate entity/collection caching that uses JBoss Cache's MVCC locking (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>optimistic-entity</strong></span>
						</div><div class="para">
							A configuration appropriate for JPA/Hibernate entity/collection caching that uses JBoss Cache's optimistic locking (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>pessimistic-entity</strong></span>
						</div><div class="para">
							A configuration appropriate for JPA/Hibernate entity/collection caching that uses JBoss Cache's pessimistic locking (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mvcc-entity-repeatable</strong></span>
						</div><div class="para">
							Same as "mvcc-entity" but uses JBoss Cache's REPEATABLE_READ isolation level instead of READ_COMMITTED (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>pessimistic-entity-repeatable</strong></span>
						</div><div class="para">
							Same as "pessimistic-entity" but uses JBoss Cache's REPEATABLE_READ isolation level instead of READ_COMMITTED (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>local-query</strong></span>
						</div><div class="para">
							A configuration appropriate for JPA/Hibernate query result caching. Does not replicate query results. DO NOT store the timestamp data Hibernate uses to verify validity of query results in this cache.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>replicated-query</strong></span>
						</div><div class="para">
							A configuration appropriate for JPA/Hibernate query result caching. Replicates query results. DO NOT store the timestamp data Hibernate uses to verify validity of query result in this cache.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timestamps-cache</strong></span>
						</div><div class="para">
							A configuration appropriate for the timestamp data cached as part of JPA/Hibernate query result caching. A replicated timestamp cache is required if query result caching is used, even if the query results themselves use a non-replicating cache like <code class="literal">local-query</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mvcc-shared</strong></span>
						</div><div class="para">
							A configuration appropriate for a cache that's shared for JPA/Hibernate entity, collection, query result and timestamp caching. Not an advised configuration, since it requires cache mode REPL_SYNC, which is the least efficient mode. Also requires a full state transfer at startup, which can be expensive. Maintained for backwards compatibility reasons, as a shared cache was the only option in JBoss 4. Uses JBoss Cache's MVCC locking.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>optimistic-shared</strong></span>
						</div><div class="para">
							A configuration appropriate for a cache that's shared for JPA/Hibernate entity, collection, query result and timestamp caching. Not an advised configuration, since it requires cache mode REPL_SYNC, which is the least efficient mode. Also requires a full state transfer at startup, which can be expensive. Maintained for backwards compatibility reasons, as a shared cache was the only option in JBoss 4. Uses JBoss Cache's optimistic locking.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>pessimistic-shared</strong></span>
						</div><div class="para">
							A configuration appropriate for a cache that's shared for JPA/Hibernate entity, collection, query result and timestamp caching. Not an advised configuration, since it requires cache mode REPL_SYNC, which is the least efficient mode. Also requires a full state transfer at startup, which can be expensive. Maintained for backwards compatibility reasons, as a shared cache was the only option in JBoss 4. Uses JBoss Cache's pessimistic locking.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mvcc-shared-repeatable</strong></span>
						</div><div class="para">
							Same as "mvcc-shared" but uses JBoss Cache's REPEATABLE_READ isolation level instead of READ_COMMITTED (see notes below).
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>pessimistic-shared-repeatable</strong></span>
						</div><div class="para">
							Same as "pessimistic-shared" but uses JBoss Cache's REPEATABLE_READ isolation level instead of READ_COMMITTED. (see notes below).
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						For more on JBoss Cache's locking schemes, see <a class="xref" href="#jbosscache-configuration-concurrency">Section26.1.4, Concurrent Access</a>)
					</div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						For JPA/Hibernate second level caching, REPEATABLE_READ is only useful if the application evicts/clears entities from the EntityManager/Hibernate Session and then expects to repeatably re-read them in the same transaction. Otherwise, the Session's internal cache provides a repeatable-read semantic.
					</div></div></div></div><div class="section" id="idm139946658276720"><div class="titlepage"><div><div><h4 class="title">18.2.1.2.Cache Configuration Aliases</h4></div></div></div><div class="para">
					The CacheManager also supports aliasing of caches; i.e. allowing caches registered under one name to be looked up under a different name. Aliasing is useful for sharing caches between services whose configuration may specify different cache configuration names. It's also useful for supporting legacy EJB3 application configurations ported over from Enterprise Application Platform 4.
				</div><div class="para">
					Aliases can be configured by editing the "CacheManager" bean in the <code class="literal">jboss-cache-manager-jboss-beans.xml</code> file. The following redacted configuration shows the standard aliases in Enterprise Application Platform 5:
				</div><pre class="programlisting">
&lt;bean name="CacheManager" class="org.jboss.ha.cachemanager.CacheManager"&gt;

    . . .

    &lt;!-- Aliases for cache names. Allows caches to be shared across 
         services that may expect different cache configuration names. --&gt;
    &lt;property name="configAliases"&gt;
       &lt;map keyClass="java.lang.String" valueClass="java.lang.String"&gt;
          &lt;!-- Use the HAPartition cache for ClusteredSSO caching --&gt;
          &lt;entry&gt;
             &lt;key&gt;clustered-sso&lt;/key&gt;
             &lt;value&gt;ha-partition&lt;/value&gt;
          &lt;/entry&gt;
          &lt;!-- Handle the legacy name for the EJB3 SFSB cache --&gt;
          &lt;entry&gt;
             &lt;key&gt;jboss.cache:service=EJB3SFSBClusteredCache&lt;/key&gt;
             &lt;value&gt;sfsb-cache&lt;/value&gt;
          &lt;/entry&gt;
          &lt;!-- Handle the legacy name for the EJB3 Entity cache --&gt;
          &lt;entry&gt;
             &lt;key&gt;jboss.cache:service=EJB3EntityTreeCache&lt;/key&gt;
             &lt;value&gt;mvcc-shared&lt;/value&gt;
          &lt;/entry&gt;
       &lt;/map&gt;
    &lt;/property&gt;
    
    . . .
    
&lt;/bean&gt;</pre></div></div></div><div class="section" id="clustering-hapartition"><div class="titlepage"><div><div><h2 class="title">18.3.The HAPartition Service</h2></div></div></div><div class="para">
			HAPartition is a general purpose service used for a variety of tasks in Enterprise Application Platform clustering. At its core, it is an abstraction built on top of a JGroups <code class="literal">Channel</code> that provides support for making/receiving RPC invocations on/from one or more cluster members. HAPartition allows services that use it to share a single <code class="literal">Channel</code> and multiplex RPC invocations over it, eliminating the configuration complexity and runtime overhead of having each service create its own <code class="literal">Channel</code>. HAPartition also supports a distributed registry of which clustering services are running on which cluster members. It provides notifications to interested listeners when the cluster membership changes or the clustered service registry changes. HAPartition forms the core of many of the clustering services we'll be discussing in the rest of this guide, including smart client-side clustered proxies, EJB 2 SFSB replication and entity cache management, farming, HA-JNDI and HA singletons. Custom services can also make use of HAPartition.
		</div><div class="para">
			The following snippet shows the <code class="literal">HAPartition</code> service definition packaged with the standard JBoss Enterprise Application Platform distribution. This configuration can be found in the <code class="literal">server/all/deploy/cluster/hapartition-jboss-beans.xml</code> file.
		</div><pre class="programlisting">
&lt;bean name="HAPartitionCacheHandler" class="org.jboss.ha.framework.server.HAPartitionCacheHandlerImpl"&gt;
	&lt;property name="cacheManager"&gt;&lt;inject bean="CacheManager"/&gt;&lt;/property&gt;
	&lt;property name="cacheConfigName"&gt;ha-partition&lt;/property&gt;
&lt;/bean&gt;
&lt;bean name="HAPartition" class="org.jboss.ha.framework.server.ClusterPartition"&gt;
	&lt;depends&gt;jboss:service=Naming&lt;/depends&gt;
	&lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=HAPartition,partition=${jboss.partition.name:DefaultPartition}", exposedInterface=org.jboss.ha.framework.server.ClusterPartitionMBean.class, registerDirectly=true)&lt;/annotation&gt;
					      
	&lt;!-- ClusterPartition requires a Cache for state management --&gt;
					      
	&lt;property name="cacheHandler"&gt;&lt;inject bean="HAPartitionCacheHandler"/&gt;&lt;/property&gt;
					      
	&lt;!-- Name of the partition being built --&gt;
					      
	&lt;property name="partitionName"&gt;${jboss.partition.name:DefaultPartition}&lt;/property&gt;
					      
	&lt;!-- The address used to determine the node name --&gt;
					      
	&lt;property name="nodeAddress"&gt;${jboss.bind.address}&lt;/property&gt;
					      
	 &lt;!-- Max time (in ms) to wait for state transfer to complete. Increase for large states --&gt;
					      
	&lt;property name="stateTransferTimeout"&gt;30000&lt;/property&gt;
					      
	&lt;!-- Max time (in ms) to wait for RPC calls to complete. --&gt;
					      
	&lt;property name="methodCallTimeout"&gt;60000&lt;/property&gt;
					      
	&lt;!-- Optionally provide a thread source to allow async connect of our channel --&gt;
					      
	&lt;property name="threadPool"&gt;&lt;inject bean="jboss.system:service=ThreadPool"/&gt;&lt;/property&gt;
	&lt;property name="distributedStateImpl"&gt;
	&lt;bean name="DistributedState" class="org.jboss.ha.framework.server.DistributedStateImpl"&gt;         
							      
    &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
    (name="jboss:service=DistributedState,partitionName=${jboss.partition.name:DefaultPartition}", exposedInterface=org.jboss.ha.framework.server.DistributedStateImplMBean.class, registerDirectly=true)&lt;/annotation&gt;
							      
		&lt;property name="cacheHandler"&gt;&lt;inject bean="HAPartitionCacheHandler"/&gt;&lt;/property&gt;                  
	&lt;/bean&gt;
	&lt;/property&gt;
&lt;/bean&gt;
</pre><div class="para">
			Much of the above is generic; below we'll touch on the key points relevant to end users. There are two beans defined above, the <code class="literal">HAPartitionCacheHandler</code> and the <code class="literal">HAPartition</code> itself.
		</div><div class="para">
			The <code class="literal">HAPartition</code> bean itself exposes the following configuration properties:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>partitionName</strong></span> is an optional attribute to specify the name of the cluster. Its default value is <code class="literal">DefaultPartition</code>. Use the <code class="literal">-g </code> (a.k.a. --partition) command line switch to set this value at server startup.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>nodeAddress</strong></span> is unused and can be ignored.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>stateTransferTimeout</strong></span> specifies the timeout (in milliseconds) for initial application state transfer. State transfer refers to the process of obtaining a serialized copy of initial application state from other already-running cluster members at service startup. Its default value is <code class="literal">30000</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>methodCallTimeout</strong></span> specifies the timeout (in milliseconds) for obtaining responses to group RPCs from the other cluster members. Its default value is <code class="literal">60000</code>.
				</div></li></ul></div><div class="para">
			The <code class="literal">HAPartitionCacheHandler</code> is a small utility service that helps the HAPartition integrate with JBoss Cache (see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>). HAPartition exposes a child service called DistributedState (see <a class="xref" href="#clustering-hapartition-distributedstate">Section18.3.2, DistributedState Service</a>) that uses JBoss Cache; the <code class="literal">HAPartitionCacheHandler</code> helps ensure consistent configuration between the JGroups <code class="literal">Channel</code> used by Distributed State's cache and the one used directly by HAPartition.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>cacheConfigName</strong></span> the name of the JBoss Cache configuration to use for the HAPartition-related cache. Indirectly, this also specifies the name of the JGroups protocol stack configuration HAPartition should use. See <a class="xref" href="#jbosscache-configuration-jgroups">Section26.1.5, JGroups Integration</a> for more on how the JGroups protocol stack is configured.
				</div></li></ul></div><div class="para">
			In order for nodes to form a cluster, they must have the exact same <code class="literal">partitionName</code> and the <code class="literal">HAPartitionCacheHandler</code>'s <code class="literal">cacheConfigName</code> must specify an identical JBoss Cache configuration. Changes in either element on some but not all nodes would prevent proper clustering behavior.
		</div><div class="para">
			You can view the current cluster information by pointing your browser to the JMX console of any JBoss instance in the cluster (i.e., <code class="literal">http://hostname:8080/jmx-console/</code>) and then clicking on the <code class="literal">jboss:service=HAPartition,partition=DefaultPartition</code> MBean (change the MBean name to reflect your partitionr name if you use the -g startup switch). A list of IP addresses for the current cluster members is shown in the CurrentView field.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				While it is technically possible to put a JBoss server instance into multiple HAPartitions at the same time, this practice is generally not recommended, as it increases management complexity.
			</div></div></div><div class="section" id="clustering-hapartition-drm"><div class="titlepage"><div><div><h3 class="title">18.3.1.DistributedReplicantManager Service</h3></div></div></div><div class="para">
				The <code class="literal">DistributedReplicantManager</code> (DRM) service is a component of the HAPartition service made available to HAPartition users via the <code class="literal">HAPartition.getDistributedReplicantManager()</code> method. Generally speaking, JBoss Enterprise Application Platform users will not directly make use of the DRM; we discuss it here as an aid to those who want a deeper understanding of how Enterprise Application Platform clustering internals work.
			</div><div class="para">
				The DRM is a distributed registry that allows HAPartition users to register objects under a given key, making available to callersthe set of objects registered under that key by the various members of t he cluster. The DRM also provides a notification mechanism so interested listeners can be notified when the contents of the registry changes.
			</div><div class="para">
				There are two main usages for the DRM in JBoss Enterprise Application Platform:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>Clustered Smart Proxies</strong></span>
					</div><div class="para">
						Here the keys are the names of the various services that need a clustered smart proxy (see <a class="xref" href="#clustering-concepts-arch-proxy">Section17.2.1, Client-side interceptor architecture</a>, e.g. the name of a clustered EJB. The value object each node stores in the DRM is known as a "target". It's something a smart proxy's transport layer can use to contact the node (e.g. an RMI stub, an HTTP URL or a JBoss Remoting <code class="literal">InvokerLocator</code>). The factory that builds clustered smart proxies accesses the DRM to get the set of "targets" that should be injected into the proxy to allow it to communicate with all the nodes in a cluster.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>HASingleton</strong></span>
					</div><div class="para">
						Here the keys are the names of the various services that need to function as High Availablity Singletons (see  the HASingleton chapter). The value object each node stores in the DRM is simply a String that acts as a token to indicate that the node has the service deployed, and thus is a candidate to become the "master" node for the HA singleton service.
					</div></li></ul></div><div class="para">
				In both cases, the key under which objects are registered identifies a particular clustered service. It is useful to understand that every node in a cluster doesn't have to register an object under every key. Only services that are deployed on a particular node will register something under that service's key, and services don't have to be deployed homogeneously across the cluster. The DRM is thus useful as a mechanism for understanding a service's "topology" around the cluster  which nodes have the service deployed.
			</div></div><div class="section" id="clustering-hapartition-distributedstate"><div class="titlepage"><div><div><h3 class="title">18.3.2.DistributedState Service</h3></div></div></div><div class="para">
				The <code class="literal">DistributedState</code> service is a legacy component of the HAPartition service made available to HAPartition users via the <code class="literal">HAPartition.getDistributedState()</code> method. This service provides coordinated management of arbitary application state around the cluster. It is supported for backwards compatibility reasons, but new applications should not use it; they should use the much more sophisticated JBoss Cache instead.
			</div><div class="para">
				In JBoss Enterprise Application Platform 5 the <code class="literal">DistributedState</code> service actually delegates to an underlying JBoss Cache instance.
			</div></div><div class="section" id="clustering-hapartition-customsvcs"><div class="titlepage"><div><div><h3 class="title">18.3.3.Custom Use of HAPartition</h3></div></div></div><div class="para">
				Custom services can also use make use of HAPartition to handle interactions with the cluster. Generally the easiest way to do this is to extend the <code class="literal">org.jboss.ha.framework.server.HAServiceImpl</code> base class, or the <code class="literal">org.jboss.ha.jxm.HAServiceMBeanSupport</code> class if JMX registration and notification support are desired.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-jndi" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter19.Clustered JNDI Services</h2></div></div></div><div class="para">
		JNDI is one of the most important services provided by the application server. The JBoss HA-JNDI (High Availability JNDI) service brings the following features to JNDI:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				Transparent failover of naming operations. If an HA-JNDI naming Context is connected to the HA-JNDI service on a particular JBoss Enterprise Application Platform instance, and that service fails or is shut down, the HA-JNDI client can transparently fail over to another Enterprise Application Platform instance.
			</div></li><li class="listitem"><div class="para">
				Load balancing of naming operations. A HA-JNDI naming Context will automatically load balance its requests across all the HA-JNDI servers in the cluster.
			</div></li><li class="listitem"><div class="para">
				Automatic client discovery of HA-JNDI servers (using multicast).
			</div></li><li class="listitem"><div class="para">
				Unified view of JNDI trees cluster-wide. A client can connect to the HA-JNDI service running on any node in the cluster and find objects bound in JNDI on any other node. This is accomplished via two mechanisms: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Cross-cluster lookups. A client can perform a lookup and the server side HA-JNDI service has the ability to find things bound in regular JNDI on any node in the cluster.
						</div></li><li class="listitem"><div class="para">
							A replicated cluster-wide context tree. An object bound into the HA-JNDI service will be replicated around the cluster, and a copy of that object will be available in-VM on each node in the cluster.
						</div></li></ul></div>

			</div></li></ul></div><div class="para">
		JNDI is a key component for many other interceptor-based clustering services: those services register themselves with JNDI so the client can look up their proxies and make use of their services. HA-JNDI completes the picture by ensuring that clients have a highly-available means to look up those proxies. However, it is important to understand that using HA-JNDI (or not) has no effect whatsoever on the clustering behavior of the objects that are looked up. To illustrate:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				If an EJB is not configured as clustered, looking up the EJB via HA-JNDI does not somehow result in the addition of clustering capabilities (load balancing of EJB calls, transparent failover, state replication) to the EJB.
			</div></li><li class="listitem"><div class="para">
				If an EJB is configured as clustered, looking up the EJB via regular JNDI instead of HA-JNDI does not somehow result in the removal of the bean proxy's clustering capabilities.
			</div></li></ul></div><div class="section" id="clustering-jndi-how"><div class="titlepage"><div><div><h2 class="title">19.1.How it works</h2></div></div></div><div class="para">
			The JBoss client-side HA-JNDI naming Context is based on the client-side interceptor architecture (see  the Introduction and Quick Start chapter). The client obtains an HA-JNDI proxy object (via the <code class="literal">InitialContext</code> object) and invokes JNDI lookup services on the remote server through the proxy. The client specifies that it wants an HA-JNDI proxy by configuring the naming properties used by the <code class="literal">InitialContext</code> object. This is covered in detail in <a class="xref" href="#clustering-jndi-client">Section19.2, Client configuration</a>. Other than the need to ensure the appropriate naming properties are provided to the <code class="literal">InitialContext</code>, the fact that the naming Context is using HA-JNDI is completely transparent to the client.
		</div><div class="para">
			On the server side, the HA-JNDI service maintains a cluster-wide context tree. The cluster wide tree is always available as long as there is one node left in the cluster. Each node in the cluster also maintains its own local JNDI context tree. The HA-JNDI service on each node is able to find objects bound into the local JNDI context tree, and is also able to make a cluster-wide RPC to find objects bound in the local tree on any other node. An application can bind its objects to either tree, although in practice most objects are bound into the local JNDI context tree. The design rationale for this architecture is as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					It avoids migration issues with applications that assume that their JNDI implementation is local. This allows clustering to work out-of-the-box with just a few tweaks of configuration files.
				</div></li><li class="listitem"><div class="para">
					In a homogeneous cluster, this configuration actually cuts down on the amount of network traffic. A homogenous cluster is one where the same types of objects are bound under the same names on each node.
				</div></li><li class="listitem"><div class="para">
					Designing it in this way makes the HA-JNDI service an optional service since all underlying cluster code uses a straight new <code class="literal">InitialContext</code> to lookup or create bindings.
				</div></li></ul></div><div class="para">
			On the server side, a naming Context obtained via a call to <code class="literal">new InitialContext()</code> will be bound to the local-only, non-cluster-wide JNDI Context. So, all EJB homes and such will not be bound to the cluster-wide JNDI Context, but rather, each home will be bound into the local JNDI.
		</div><div class="para">
			When a remote client does a lookup through HA-JNDI, HA-JNDI will delegate to the local JNDI service when it cannot find the object within the global cluster-wide Context. The detailed lookup rule is as follows.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					If the binding is available in the cluster-wide JNDI tree, return it.
				</div></li><li class="listitem"><div class="para">
					If the binding is not in the cluster-wide tree, delegate the lookup query to the local JNDI service and return the received answer if available.
				</div></li><li class="listitem"><div class="para">
					If not available, the HA-JNDI service asks all other nodes in the cluster if their local JNDI service owns such a binding and returns the answer from the set it receives.
				</div></li><li class="listitem"><div class="para">
					If no local JNDI service owns such a binding, a <code class="literal">NameNotFoundException</code> is finally raised.
				</div></li></ul></div><div class="para">
			In practice, objects are rarely bound in the cluster-wide JNDI tree; rather they are bound in the local JNDI tree. For example, when EJBs are deployed, their proxies are always bound in local JNDI, not HA-JNDI. So, an EJB home lookup done through HA-JNDI will always be delegated to the local JNDI instance.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If different beans (even of the same type, but participating in different clusters) use the same JNDI name, this means that each JNDI server will have a logically different "target" bound under the same name (JNDI on node 1 will have a binding for bean A and JNDI on node 2 will have a binding, under the same name, for bean B). Consequently, if a client performs a HA-JNDI query for this name, the query will be invoked on any JNDI server of the cluster and will return the locally bound stub. Nevertheless, it may not be the correct stub that the client is expecting to receive! So, it is always best practice to ensure that across the cluster different names are used for logically different bindings.
			</div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If a binding is only made available on a few nodes in the cluster (for example because a bean is only deployed on a small subset of nodes in the cluster), the probability is higher that a lookup will hit a HA-JNDI server that does not own this binding and thus the lookup will need to be forwarded to all nodes in the cluster. Consequently, the query time will be longer than if the binding would have been available locally. Moral of the story: as much as possible, cache the result of your JNDI queries in your client.
			</div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				You cannot currently use a non-JNP JNDI implementation (i.e. LDAP) for your local JNDI implementation if you want to use HA-JNDI. However, you can use JNDI federation using the <code class="literal">ExternalContext</code> MBean to bind non-JBoss JNDI trees into the JBoss JNDI namespace. Furthermore, nothing prevents you using one centralized JNDI server for your whole cluster and scrapping HA-JNDI and JNP.
			</div></div></div></div><div class="section" id="clustering-jndi-client"><div class="titlepage"><div><div><h2 class="title">19.2.Client configuration</h2></div></div></div><div class="para">
			Configuring a client to use HA-JNDI is a matter of ensuring the correct set of naming environment properties are available when a new <code class="literal">InitialContext</code> is created. How this is done varies depending on whether the client is running inside JBoss Enterprise Application Platform itself or is in another VM.
		</div><div class="section" id="idm139946660078864"><div class="titlepage"><div><div><h3 class="title">19.2.1.For clients running inside the Enterprise Application Platform</h3></div></div></div><div class="para">
				If you want to access HA-JNDI from inside the Enterprise Application Platform, you must explicitly configure your <code class="literal">InitialContext</code> by passing in JNDI properties to the constructor. The following code shows how to create a naming Context bound to HA-JNDI:
			</div><pre class="programlisting JAVA JAVA">Properties p = new Properties();  
p.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");  
p.put(Context.URL_PKG_PREFIXES, "jboss.naming:org.jnp.interfaces");
// HA-JNDI is listening on the address passed to JBoss via -b  
String bindAddress = System.getProperty("jboss.bind.address", "localhost");
p.put(Context.PROVIDER_URL, bindAddress + ":1100"); // HA-JNDI address and port.  
return new InitialContext(p);</pre><div class="para">
				The Context.PROVIDER_URL property points to the HA-JNDI service configured in the <code class="literal">deploy/cluster/hajndi-jboss-beans.xml</code> file (see <a class="xref" href="#clustering-jndi-jboss">Section19.3, JBoss configuration</a>). By default this service listens on the interface named via the <code class="literal">jboss.bind.address</code> system property, which itself is set to whatever value you assign to the <code class="literal">-b</code> command line option when you start JBoss Enterprise Application Platform (or <code class="literal">localhost</code> if not specified). The above code shows an example of accessing this property.
			</div><div class="para">
				However, this does not work in all cases, especially when running several JBoss Enterprise Application Platform instances on the same machine and bound to the same IP address, but configured to use different ports. A safer method is to not specify the Context.PROVIDER_URL but instead allow the <code class="literal">InitialContext</code> to statically find the in-VM HA-JNDI by specifying the <code class="literal">jnp.partitionName</code> property:
			</div><pre class="programlisting JAVA JAVA">Properties p = new Properties();
p.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");
p.put(Context.URL_PKG_PREFIXES, "jboss.naming:org.jnp.interfaces");
// HA-JNDI is registered under the partition name passed to JBoss via -g  
String partitionName = System.getProperty("jboss.partition.name", "DefaultPartition");
p.put("jnp.partitionName", partitionName);
return new InitialContext(p);</pre><div class="para">
				This example uses the <code class="literal">jboss.partition.name</code> system property to identify the partition with which the HA-JNDI service works. This system property is set to whatever value you assign to the <code class="literal">-g</code> command line option when you start JBoss Enterprise Application Platform (or <code class="literal">DefaultPartition</code> if not specified).
			</div><div class="para">
				Do not attempt to simplify things by placing a <code class="literal">jndi.properties</code> file in your deployment or by editing the Enterprise Application Platform's <code class="literal">conf/jndi.properties</code> file. Doing either will almost certainly break things for your application and quite possibly across the server. If you want to externalize your client configuration, one approach is to deploy a properties file not named <code class="literal">jndi.properties</code>, and then programatically create a <code class="literal">Properties</code> object that loads that file's contents.
			</div><div class="section" id="idm139946658386864"><div class="titlepage"><div><div><h4 class="title">19.2.1.1.Accessing HA-JNDI Resources from EJBs and WARs -- Environment Naming Context</h4></div></div></div><div class="para">
					If your HA-JNDI client is an EJB or servlet, the least intrusive way to configure the lookup of resources is to bind the resources to the environment naming context of the bean or webapp performing the lookup. The binding can then be configured to use HA-JNDI instead of a local mapping. Following is an example of doing this for a JMS connection factory and queue (the most common use case for this kind of thing).
				</div><div class="para">
					Within the bean definition in the ejb-jar.xml or in the war's web.xml you will need to define two resource-ref mappings, one for the connection factory and one for the destination.
				</div><pre class="programlisting XML XML">&lt;resource-ref&gt;
	&lt;res-ref-name&gt;jms/ConnectionFactory&lt;/res-ref-name&gt;
	&lt;res-type&gt;javax.jms.QueueConnectionFactory&lt;/res-type&gt;
	&lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
	
&lt;resource-ref&gt;
	&lt;res-ref-name&gt;jms/Queue&lt;/res-ref-name&gt;
	&lt;res-type&gt;javax.jms.Queue&lt;/res-type&gt;
	&lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;</pre><div class="para">
					Using these examples the bean performing the lookup can obtain the connection factory by looking up 'java:comp/env/jms/ConnectionFactory' and can obtain the queue by looking up 'java:comp/env/jms/Queue'.
				</div><div class="para">
					Within the JBoss-specific deployment descriptor (jboss.xml for EJBs, jboss-web.xml for a WAR) these references need to be mapped to a URL that makes use of HA-JNDI.
				</div><pre class="programlisting XML XML">&lt;resource-ref&gt;
	&lt;res-ref-name&gt;jms/ConnectionFactory&lt;/res-ref-name&gt;
	&lt;jndi-name&gt;jnp://${jboss.bind.address}:1100/ConnectionFactory&lt;/jndi-name&gt;
&lt;/resource-ref&gt;
	
&lt;resource-ref&gt;
	&lt;res-ref-name&gt;jms/Queue&lt;/res-ref-name&gt;
	&lt;jndi-name&gt;jnp://${jboss.bind.address}:1100/queue/A&lt;/jndi-name&gt;
 &lt;/resource-ref&gt;</pre><div class="para">
					The URL should be the URL to the HA-JNDI server running on the same node as the bean; if the bean is available the local HA-JNDI server should also be available. The lookup will then automatically query all of the nodes in the cluster to identify which node has the JMS resources available.
				</div><div class="para">
					The <code class="literal">${jboss.bind.address}</code> syntax used above tells JBoss to use the value of the <code class="literal">jboss.bind.address</code> system property when determining the URL. That system property is itself set to whatever value you assign to the <code class="literal">-b</code> command line option when you start JBoss Enterprise Application Platform.
				</div></div><div class="section" id="idm139946658378416"><div class="titlepage"><div><div><h4 class="title">19.2.1.2.Why do this programmatically and not just put this in a jndi.properties file?</h4></div></div></div><div class="para">
					The JBoss Enterprise Application Platform's internal naming environment is controlled by the <code class="filename">conf/jndi.properties</code> file, which should not be edited.
				</div><div class="para">
					No other jndi.properties file should be deployed inside the Enterprise Application Platform because of the possibility of its being found on the classpath when it shouldn't and thus disrupting the internal operation of the server. For example, if an EJB deployment included a jndi.properties configured for HA-JNDI, when the server binds the EJB proxies into JNDI it will likely bind them into the replicated HA-JNDI tree and not into the local JNDI tree where they belong.
				</div></div><div class="section" id="idm139946658375648"><div class="titlepage"><div><div><h4 class="title">19.2.1.3.How can I tell if things are being bound into HA-JNDI that shouldn't be?</h4></div></div></div><div class="para">
					Go into the the jmx-console and execute the <code class="literal">list</code> operation on the <code class="literal">jboss:service=JNDIView</code> mbean. Towards the bottom of the results, the contents of the "HA-JNDI Namespace" are listed. Typically this will be empty; if any of your own deployments are shown there and you didn't explicitly bind them there, there's probably an improper jndi.properties file on the classpath. Please visit the following link for an example: <a href="http://www.jboss.com/index.html?module=bb&amp;op=viewtopic&amp;t=104715" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.com">Problem with removing a Node from Cluster</a>.
				</div></div></div><div class="section" id="idm139946658372224"><div class="titlepage"><div><div><h3 class="title">19.2.2.For clients running outside the Enterprise Application Platform</h3></div></div></div><div class="para">
				The JNDI client needs to be aware of the HA-JNDI cluster. You can pass a list of JNDI servers (i.e., the nodes in the HA-JNDI cluster) to the <code class="literal">java.naming.provider.url</code> JNDI setting in the <code class="literal">jndi.properties</code> file. Each server node is identified by its IP address and the JNDI port number. The server nodes are separated by commas (see <a class="xref" href="#clustering-jndi-jboss">Section19.3, JBoss configuration</a> for how to configure the servers and ports).
			</div><pre class="programlisting">java.naming.provider.url=server1:1100,server2:1100,server3:1100,server4:1100</pre><div class="para">
				When initializing, the JNP client code will try to get in touch with each server node from the list, one after the other, stopping as soon as one server has been reached. It will then download the HA-JNDI stub from this node.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					There is no load balancing behavior in the JNP client lookup process itself. It just goes through the provider lists and uses the first available server to obtain the stub. The HA-JNDI provider list only needs to contain a subset of HA-JNDI nodes in the cluster; once the HA-JNDI stub is downloaded, the stub will include information on all the available servers. A good practice is to include a set of servers such that you are certain that at least one of those in the list will be available.
				</div></div></div><div class="para">
				The downloaded smart proxy contains the list of currently running nodes and the logic to load balance naming requests and to fail-over to another node if necessary. Furthermore, each time a JNDI invocation is made to the server, the list of targets in the proxy interceptor is updated (only if the list has changed since the last call).
			</div><div class="para">
				If the property string <code class="literal">java.naming.provider.url</code> is empty or if all servers it mentions are not reachable, the JNP client will try to discover a HA-JNDI server through a multicast call on the network (auto-discovery). See <a class="xref" href="#clustering-jndi-jboss">Section19.3, JBoss configuration</a> for how to configure auto-discovery on the JNDI server nodes. Through auto-discovery, the client might be able to get a valid HA-JNDI server node without any configuration. Of course, for auto-discovery to work, the network segment(s) between the client and the server cluster must be configured to propagate such multicast datagrams.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					By default the auto-discovery feature uses multicast group address 230.0.0.4 and port 1102.
				</div></div></div><div class="para">
				In addition to the <code class="literal">java.naming.provider.url</code> property, you can specify a set of other properties. The following list shows all clustering-related client side properties you can specify when creating a new <code class="literal">InitialContext</code>. (All of the standard, non-clustering-related environment properties used with regular JNDI are also available.)
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">java.naming.provider.url</code>: Provides a list of IP addresses and port numbers for HA-JNDI provider nodes in the cluster. The client tries those providers one by one and uses the first one that responds.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.disableDiscovery</code>: When set to <code class="literal">true</code>, this property disables the automatic discovery feature. Default is <code class="literal">false</code>.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.partitionName</code>: In an environment where multiple HA-JNDI services bound to distinct clusters (a.k.a. partitions), are running, this property allows you to ensure that your client only accepts automatic-discovery responses from servers in the desired partition. If you do not use the automatic discovery feature (i.e. jnp.disableDiscovery is true), this property is not used. By default, this property is not set and the automatic discovery selects the first HA-JNDI server that responds, regardless of the cluster partition name.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryTimeout</code>: Determines how many milliseconds the context will wait for a response to its automatic discovery packet. Default is 5000 ms.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryGroup</code>: Determines which multicast group address is used for the automatic discovery. Default is 230.0.0.4. Must match the value of the AutoDiscoveryAddress configured on the server side HA-JNDI service. Note that the server side HA-JNDI service by default listens on the address specified via the <code class="literal">-u</code> startup switch, so if <code class="literal">-u</code> is used on the server side (as is recommended), jnp.discoveryGroup will need to be configured on the client side.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryPort</code>: Determines which multicast port is used for the automatic discovery. Default is 1102. Must match the value of the AutoDiscoveryPort configured on the server side HA-JNDI service.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">jnp.discoveryTTL</code>: specifies the TTL (time-to-live) for autodiscovery IP multicast packets. This value represents the number of network hops a multicast packet can be allowed to propagate before networking equipment should drop the packet. Despite its name, it does not represent a unit of time.
					</div></li></ul></div></div></div><div class="section" id="clustering-jndi-jboss"><div class="titlepage"><div><div><h2 class="title">19.3.JBoss configuration</h2></div></div></div><div class="para">
			The <code class="literal">hajndi-jboss-beans.xml</code> file in the <code class="literal">JBOSS_HOME/server/all/deploy/cluster</code> directory includes the following bean to enable HA-JNDI services.
		</div><pre class="programlisting">&lt;bean name="HAJNDI" class="org.jboss.ha.jndi.HANamingService"&gt;    

      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=HAJNDI", 
         exposedInterface=org.jboss.ha.jndi.HANamingServiceMBean.class)&lt;/annotation&gt;  
      
      &lt;!-- The partition used for group RPCs to find locally bound objects on other nodes --&gt;
      &lt;property name="HAPartition"&gt;&lt;inject bean="HAPartition"/&gt;&lt;/property&gt;
      
      &lt;!-- Handler for the replicated tree --&gt;
      &lt;property name="distributedTreeManager"&gt;
         &lt;bean class="org.jboss.ha.jndi.impl.jbc.JBossCacheDistributedTreeManager"&gt;
            &lt;property name="cacheHandler"&gt;&lt;inject bean="HAPartitionCacheHandler"/&gt;&lt;/property&gt;
         &lt;/bean&gt;
      &lt;/property&gt;
      
      &lt;property name="localNamingInstance"&gt;
         &lt;inject bean="jboss:service=NamingBeanImpl" property="namingInstance"/&gt;
      &lt;/property&gt;
      
      &lt;!-- The thread pool used to control the bootstrap and auto discovery lookups --&gt;
      &lt;property name="lookupPool"&gt;&lt;inject bean="jboss.system:service=ThreadPool"/&gt;&lt;/property&gt;
      
      &lt;!-- Bind address of bootstrap endpoint --&gt;
      &lt;property name="bindAddress"&gt;${jboss.bind.address}&lt;/property&gt;
      &lt;!-- Port on which the HA-JNDI stub is made available --&gt;
      &lt;property name="port"&gt;
         &lt;!-- Get the port from the ServiceBindingManager --&gt;
         &lt;value-factory bean="ServiceBindingManager" method="getIntBinding"&gt;
            &lt;parameter&gt;jboss:service=HAJNDI&lt;/parameter&gt;
            &lt;parameter&gt;Port&lt;/parameter&gt;
         &lt;/value-factory&gt;
      &lt;/property&gt;
      
      &lt;!-- Bind address of the HA-JNDI RMI endpoint --&gt;
      &lt;property name="rmiBindAddress"&gt;${jboss.bind.address}&lt;/property&gt;
      
      &lt;!-- RmiPort to be used by the HA-JNDI service once bound. 0 = ephemeral. --&gt;
      &lt;property name="rmiPort"&gt;
         &lt;!-- Get the port from the ServiceBindingManager --&gt;
         &lt;value-factory bean="ServiceBindingManager" method="getIntBinding"&gt;
            &lt;parameter&gt;jboss:service=HAJNDI&lt;/parameter&gt;
            &lt;parameter&gt;RmiPort&lt;/parameter&gt;
         &lt;/value-factory&gt;
      &lt;/property&gt;
      
      &lt;!-- Accept backlog of the bootstrap socket --&gt;
      &lt;property name="backlog"&gt;50&lt;/property&gt;

      &lt;!-- A flag to disable the auto discovery via multicast --&gt;
      &lt;property name="discoveryDisabled"&gt;false&lt;/property&gt;
      &lt;!-- Set the auto-discovery bootstrap multicast bind address. If not 
      specified and a BindAddress is specified, the BindAddress will be used. --&gt;
      &lt;property name="autoDiscoveryBindAddress"&gt;${jboss.bind.address}&lt;/property&gt;
      &lt;!-- Multicast Address and group port used for auto-discovery --&gt;
      &lt;property name="autoDiscoveryAddress"&gt;${jboss.partition.udpGroup:230.0.0.4}&lt;/property&gt;
      &lt;property name="autoDiscoveryGroup"&gt;1102&lt;/property&gt;
      &lt;!-- The TTL (time-to-live) for autodiscovery IP multicast packets --&gt;
      &lt;property name="autoDiscoveryTTL"&gt;16&lt;/property&gt;
      
      &lt;!-- The load balancing policy for HA-JNDI --&gt;
      &lt;property name="loadBalancePolicy"&gt;org.jboss.ha.framework.interfaces.RoundRobin&lt;/property&gt;

      &lt;!-- Client socket factory to be used for client-server
           RMI invocations during JNDI queries
      &lt;property name="clientSocketFactory"&gt;custom&lt;/property&gt;
      --&gt;
      &lt;!-- Server socket factory to be used for client-server
           RMI invocations during JNDI queries
      &lt;property name="serverSocketFactory"&gt;custom&lt;/property&gt;
      --&gt;
   &lt;/bean&gt;</pre><div class="para">
			You can see that this bean has a number of other services injected into different properties: 
			<div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>HAPartition</strong></span> accepts the core clustering service used manage HA-JNDI's clustered proxies and to make the group RPCs that find locally bound objects on other nodes. See <a class="xref" href="#clustering-hapartition">Section18.3, The HAPartition Service</a> for more.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>distributedTreeManager</strong></span> accepts a handler for the replicated tree. The standard handler uses JBoss Cache to manage the replicated tree. The JBoss Cache instance is retrieved using the injected <code class="literal">HAPartitionCacheHandler</code> bean. See <a class="xref" href="#clustering-hapartition">Section18.3, The HAPartition Service</a> for more details.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>localNamingInstance</strong></span> accepts the reference to the local JNDI service.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>lookupPool</strong></span> accepts the thread pool used to provide threads to handle the bootstrap and auto discovery lookups.
					</div></li></ul></div>

		</div><div class="para">
			Besides the above dependency injected services, the available configuration attributes for the HA-JNDI bean are as follows:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>bindAddress</strong></span> specifies the address to which the HA-JNDI server will bind to listen for naming proxy download requests from JNP clients. The default value is the value of the <code class="literal">jboss.bind.address</code> system property, or <code class="literal">localhost</code> if that property is not set. The <code class="literal">jboss.bind.address</code> system property is set if the <code class="literal">-b</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>port</strong></span> specifies the port to which the HA-JNDI server will bind to listen for naming proxy download requests from JNP clients. The value is obtained from the ServiceBindingManager bean configured in <code class="literal">conf/bootstrap/bindings.xml</code>. The default value is <code class="literal">1100</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>backlog</strong></span> specifies the maximum queue length for incoming connection indications for the TCP server socket on which the service listens for naming proxy download requests from JNP clients. The default value is <code class="literal">50</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>rmiBindAddress</strong></span> specifies the address to which the HA-JNDI server will bind to listen for RMI requests (e.g. for JNDI lookups) from naming proxies. The default value is the value of the <code class="literal">jboss.bind.address</code> system property, or <code class="literal">localhost</code> if that property is not set. The <code class="literal">jboss.bind.address</code> system property is set if the <code class="literal">-b</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>rmiPort</strong></span> specifies the port to which the server will bind to communicate with the downloaded stub. The value is obtained from the ServiceBindingManager bean configured in <code class="literal">conf/bootstrap/bindings.xml</code>. The default value is <code class="literal">1101</code>. If no value is set, the operating system automatically assigns a port.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>discoveryDisabled</strong></span> is a boolean flag that disables configuration of the auto discovery multicast listener. The default is <code class="literal">false</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryAddress</strong></span> specifies the multicast address to listen to for JNDI automatic discovery. The default value is the value of the <code class="literal">jboss.partition.udpGroup</code> system property, or 230.0.0.4 if that is not set. The <code class="literal">jboss.partition.udpGroup</code> system property is set if the <code class="literal">-u</code> command line switch is used when JBoss is started.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryGroup</strong></span> specifies the port to listen on for multicast JNDI automatic discovery packets. The default value is <code class="literal">1102</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryBindAddress</strong></span> sets the interface on which HA-JNDI should listen for auto-discovery request packets. If this attribute is not specified and a <code class="literal">bindAddress</code> is specified, the <code class="literal">bindAddress</code> will be used.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>autoDiscoveryTTL</strong></span> specifies the TTL (time-to-live) for autodiscovery IP multicast packets. This value represents the number of network hops a multicast packet can be allowed to propagate before networking equipment should drop the packet. Despite its name, it does not represent a unit of time.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>loadBalancePolicy</strong></span> specifies the class name of the LoadBalancePolicy implementation that should be included in the client proxy. See <a class="xref" href="#clustering-intro.chapt">Chapter16, <em>Introduction and Quick Start</em></a> the Introduction and Quick Start chapter for details.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>clientSocketFactory</strong></span> is an optional attribute that specifies the fully qualified classname of the <code class="literal">java.rmi.server.RMIClientSocketFactory</code> that should be used to create client sockets. The default is <code class="literal">null</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>serverSocketFactory</strong></span> is an optional attribute that specifies the fully qualified classname of the <code class="literal">java.rmi.server.RMIServerSocketFactory</code> that should be used to create server sockets. The default is <code class="literal">null</code>.
				</div></li></ul></div><div class="section" id="idm139946672662160"><div class="titlepage"><div><div><h3 class="title">19.3.1.Adding a Second HA-JNDI Service</h3></div></div></div><div class="para">
				It is possible to start several HA-JNDI services that use different HAPartitions. This can be used, for example, if a node is part of many logical clusters. In this case, make sure that you set a different port or IP address for each service. For instance, if you wanted to hook up HA-JNDI to the example cluster you set up and change the binding port, the bean descriptor would look as follows (properties that do not vary from the standard deployments are omitted):
			</div><pre class="programlisting">
   &lt;-- Cache Handler for secondary HAPartition --&gt;
   &lt;bean name="SecondaryHAPartitionCacheHandler"
         class="org.jboss.ha.framework.server.HAPartitionCacheHandlerImpl"&gt;
         &lt;property name="cacheManager"&gt;&lt;inject bean="CacheManager"/&gt;&lt;/property&gt;
         &lt;property name="cacheConfigName"&gt;secondary-ha-partition&lt;/property&gt;
   &lt;/bean&gt;
   
   &lt;-- The secondary HAPartition --&gt;
   &lt;bean name="SecondaryHAPartition" class="org.jboss.ha.framework.server.ClusterPartition"&gt;     

      &lt;depends&gt;jboss:service=Naming&lt;/depends&gt;
       
      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=HAPartition,partition=SecondaryPartition", 
      exposedInterface=org.jboss.ha.framework.server.ClusterPartitionMBean.class, registerDirectly=true)&lt;/annotation&gt;
       
      &lt;property name="cacheHandler"&gt;&lt;inject bean="SecondaryHAPartitionCacheHandler"/&gt;&lt;/property&gt;
               
      &lt;property name="partitionName"&gt;SecondaryPartition&lt;/property&gt;
      
      ....      
   &lt;/bean&gt;
   
   &lt;bean name="MySpecialPartitionHAJNDI" class="org.jboss.ha.jndi.HANamingService"&gt;    

      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=HAJNDI,partitionName=SecondaryPartition", 
         exposedInterface=org.jboss.ha.jndi.HANamingServiceMBean.class)&lt;/annotation&gt;  
      
      &lt;property name="HAPartition"&gt;&lt;inject bean="SecondaryHAPartition"/&gt;&lt;/property&gt;
      
      &lt;property name="distributedTreeManager"&gt;
         &lt;bean class="org.jboss.ha.jndi.impl.jbc.JBossCacheDistributedTreeManager"&gt;
            &lt;property name="cacheHandler"&gt;&lt;inject bean="SecondaryHAPartitionPartitionCacheHandler"/&gt;&lt;/property&gt;
         &lt;/bean&gt;
      &lt;/property&gt;
      
      &lt;property name="port"&gt;56789&lt;/property&gt;
      
      &lt;property name="rmiPort"&gt;56790&lt;/property&gt;
      
      &lt;property name="autoDiscoveryGroup"&gt;56791&lt;/property&gt;
      
      .....
   &lt;/bean&gt;</pre></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-session" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter20.Clustered Session EJBs</h2></div></div></div><div class="para">
		Session EJBs provide remote invocation services. They are clustered based on the client-side interceptor architecture. The client application for a clustered session bean is the same as the client for the non-clustered version of the session bean, except for some minor changes. No code change or re-compilation is needed on the client side. Now, let's check out how to configure clustered session beans in EJB 3.0 and EJB 2.x server applications respectively.
	</div><div class="section" id="clustering-session-slsb30"><div class="titlepage"><div><div><h2 class="title">20.1.Stateless Session Bean in EJB 3.0</h2></div></div></div><div class="para">
			Clustering stateless session beans is probably the easiest case since no state is involved. Calls can be load balanced to any participating node (i.e. any node that has this specific bean deployed) of the cluster.
		</div><div class="para">
			To cluster a stateless session bean in EJB 3.0, simply annotate the bean class with the <code class="literal">@Clustered</code> annotation. This annotation contains optional parameters for overriding both the load balance policy and partition to use.
		</div><pre class="programlisting">
public @interface Clustered
{
   String partition() default "${jboss.partition.name:DefaultPartition}";
   String loadBalancePolicy() default "LoadBalancePolicy";
}
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>partition</strong></span> specifies the name of the cluster the bean participates in. While the <code class="literal">@Clustered</code> annotation lets you override the default partition, <code class="literal">DefaultPartition</code>, for an individual bean, you can override this for all beans using the <code class="literal">jboss.partition.name</code> system property.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>loadBalancePolicy</strong></span> defines the name of a class implementing <code class="literal">org.jboss.ha.client.loadbalance.LoadBalancePolicy</code>, indicating how the bean stub should balance calls made on the nodes of the cluster. The default value, <code class="literal">LoadBalancePolicy</code> is a special token indicating the default policy for the session bean type. For stateless session beans, the default policy is <code class="literal">org.jboss.ha.client.loadbalance.RoundRobin</code>. You can override the default value using your own implementation, or choose one from the list of available policies:
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">org.jboss.ha.client.loadbalance.RoundRobin</code> </span></dt><dd><div class="para">
								Starting with a random target, always favors the next available target in the list, ensuring maximum load balancing always occurs.
							</div></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">org.jboss.ha.client.loadbalance.RandomRobin</code> </span></dt><dd><div class="para">
								Randomly selects its target without any consideration to previously selected targets.
							</div></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailable</code> </span></dt><dd><div class="para">
								Once a target is chosen, always favors that same target; i.e. no further load balancing occurs. Useful in cases where "sticky session" behavior is desired, e.g. stateful session beans.
							</div></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailableIdenticalAllProxies</code> </span></dt><dd><div class="para">
								Similar to <code class="literal">FirstAvailable</code>, except that the favored target is shared across all proxies.
							</div></dd></dl></div></li></ul></div><div class="para">
			Here is an example of a clustered EJB 3.0 stateless session bean implementation.
		</div><pre class="programlisting">
@Stateless
@Clustered
public class MyBean implements MySessionInt
{
   public void test()
   {
      // Do something cool
   }
}
</pre><div class="para">
			Rather than using the <code class="literal">@Clustered</code> annotation, you can also enable clustering for a session bean in jboss.xml:
		</div><pre class="programlisting"> 
&lt;jboss&gt;    
   &lt;enterprise-beans&gt;
      &lt;session&gt;
         &lt;ejb-name&gt;NonAnnotationStateful&lt;/ejb-name&gt;
         &lt;clustered&gt;true&lt;/clustered&gt;
         &lt;cluster-config&gt;
            &lt;partition-name&gt;FooPartition&lt;/partition-name&gt;
            &lt;load-balance-policy&gt;org.jboss.ha.framework.interfaces.RandomRobin&lt;/load-balance-policy&gt;
         &lt;/cluster-config&gt;
      &lt;/session&gt;    
   &lt;/enterprise-beans&gt;
&lt;/jboss&gt;
</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The <code class="literal">&lt;clustered&gt;true&lt;/clustered&gt;</code> element is really just an alias for the <code class="literal">&lt;container-name&gt;Clustered Stateless SessionBean&lt;/container-name&gt;</code> element in the conf/standardjboss.xml file.
			</div></div></div><div class="para">
			In the bean configuration, only the &lt;clustered&gt; element is necessary to indicate that the bean needs to support clustering features. The default values for the optional &lt;cluster-config&gt; elements match those of the corresponding properties from the <code class="literal">@Clustered</code> annotation.
		</div></div><div class="section" id="clustering-session-sfsb30"><div class="titlepage"><div><div><h2 class="title">20.2.Stateful Session Beans in EJB 3.0</h2></div></div></div><div class="para">
			Clustering stateful session beans is more complex than clustering their stateless counterparts since JBoss needs to manage the state information. The state of all stateful session beans are replicated and synchronized across the cluster each time the state of a bean changes.
		</div><div class="section" id="idm139946658802864"><div class="titlepage"><div><div><h3 class="title">20.2.1.The EJB application configuration</h3></div></div></div><div class="para">
				To cluster stateful session beans in EJB 3.0, you need to tag the bean implementation class with the <code class="literal">@Clustered</code> annotation, just as we did with the EJB 3.0 stateless session bean earlier. In contrast to stateless session beans, stateful session bean method invocations are load balanced using <code class="literal">org.jboss.ha.client.loadbalance.aop.FirstAvailable</code> policy, by default. Using this policy, methods invocations will stick to a randomly chosen node.
			</div><div class="para">
				The <code class="literal">@org.jboss.ejb3.annotation.CacheConfig</code> annotation can also be applied to the bean to override the default caching behavior. Below is the definition of the <code class="literal">@CacheConfig</code> annotation:
			</div><pre class="programlisting">
public @interface CacheConfig
{
   String name() default "";
   int maxSize() default 10000;
   long idleTimeoutSeconds() default 300;   
   boolean replicationIsPassivation() default true;   
   long removalTimeoutSeconds() default 0;
}
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">name</code> specifies the name of a cache configuration registered with the <code class="literal">CacheManager</code> service discussed in <a class="xref" href="#sfsb-jbc-cachemanager">Section20.2.3, CacheManager service configuration</a>. By default, the <code class="literal">sfsb-cache</code> configuration will be used.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">maxSize</code> specifies the maximum number of beans that can cached before the cache should start passivating beans, using an LRU algorithm.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">idleTimeoutSeconds</code> specifies the max period of time a bean can go unused before the cache should passivate it (regardless of whether maxSize beans are cached.)
					</div></li><li class="listitem"><div class="para">
						<code class="literal">removalTimeoutSeconds</code> specifies the max period of time a bean can go unused before the cache should remove it altogether.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">replicationIsPassivation</code> specifies whether the cache should consider a replication as being equivalent to a passivation, and invoke any @PrePassivate and @PostActivate callbacks on the bean. By default true, since replication involves serializing the bean, and preparing for and recovering from serialization is a common reason for implementing the callback methods.
					</div></li></ul></div><div class="para">
				Here is an example of a clustered EJB 3.0 stateful session bean implementation.
			</div><pre class="programlisting">
@Stateful
@Clustered
@CacheConfig(maxSize=5000, removalTimeoutSeconds=18000)
public class MyBean implements MySessionInt
{
   private int state = 0;

   public void increment()
   {
      System.out.println("counter: " + (state++));
   }
}
</pre><div class="para">
				As with stateless beans, the @Clustered annotation can alternatively be omitted and the clustering configuration instead applied to jboss.xml:
			</div><pre class="programlisting">
&lt;jboss&gt;    
   &lt;enterprise-beans&gt;
      &lt;session&gt;
         &lt;ejb-name&gt;NonAnnotationStateful&lt;/ejb-name&gt;
         &lt;clustered&gt;true&lt;/clustered&gt;
         &lt;cache-config&gt;
            &lt;cache-max-size&gt;5000&lt;/cache-max-size&gt;
            &lt;remove-timeout-seconds&gt;18000&lt;/remove-timeout-seconds&gt;
         &lt;/cache-config&gt;
      &lt;/session&gt;    
   &lt;/enterprise-beans&gt;
&lt;/jboss&gt;
</pre></div><div class="section" id="idm139946660186224"><div class="titlepage"><div><div><h3 class="title">20.2.2.Optimize state replication</h3></div></div></div><div class="para">
				As the replication process is a costly operation, you can optimise this behaviour by optionally implementing the org.jboss.ejb3.cache.Optimized interface in your bean class:
			</div><pre class="programlisting">
public interface Optimized
{
   boolean isModified();
}
</pre><div class="para">
				Before replicating your bean, the container will check if your bean implements the <code class="literal">Optimized</code> interface. If this is the case, the container calls the <code class="literal">isModified()</code> method and will only replicate the bean when the method returns <code class="literal">true</code>. If the bean has not been modified (or not enough to require replication, depending on your own preferences), you can return <code class="literal">false</code> and the replication would not occur.
			</div></div><div class="section" id="sfsb-jbc-cachemanager"><div class="titlepage"><div><div><h3 class="title">20.2.3.CacheManager service configuration</h3></div></div></div><div class="para">
				JBoss Cache provides the session state replication service for EJB 3.0 stateful session beans. The <code class="literal">CacheManager</code> service, described in <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a> is both a factory and registry of JBoss Cache instances. By default, stateful session beans use the <code class="literal">sfsb-cache</code> configuration from the <code class="literal">CacheManager</code>, defined as follows:
			</div><pre class="programlisting">
&lt;bean name="StandardSFSBCacheConfig" class="org.jboss.cache.config.Configuration"&gt;

  &lt;!--  No transaction manager lookup --&gt;
  
  &lt;!-- Name of cluster. Needs to be the same for all members --&gt;
  &lt;property name="clusterName"&gt;${jboss.partition.name:DefaultPartition}-SFSBCache&lt;/property&gt;
  &lt;!--
    Use a UDP (multicast) based stack. Need JGroups flow control (FC)
    because we are using asynchronous replication.
  --&gt;
  &lt;property name="multiplexerStack"&gt;${jboss.default.jgroups.stack:udp}&lt;/property&gt;
  &lt;property name="fetchInMemoryState"&gt;true&lt;/property&gt;
  
  &lt;property name="nodeLockingScheme"&gt;PESSIMISTIC&lt;/property&gt;
  &lt;property name="isolationLevel"&gt;REPEATABLE_READ&lt;/property&gt;
  &lt;property name="useLockStriping"&gt;false&lt;/property&gt;
  &lt;property name="cacheMode"&gt;REPL_ASYNC&lt;/property&gt;
  
  &lt;!--
    Number of milliseconds to wait until all responses for a
    synchronous call have been received. Make this longer 
    than lockAcquisitionTimeout.
  --&gt;
  &lt;property name="syncReplTimeout"&gt;17500&lt;/property&gt;
  &lt;!-- Max number of milliseconds to wait for a lock acquisition --&gt;
  &lt;property name="lockAcquisitionTimeout"&gt;15000&lt;/property&gt;
  &lt;!-- The max amount of time (in milliseconds) we wait until the
  state (ie. the contents of the cache) are retrieved from
  existing members at startup. --&gt;
  &lt;property name="stateRetrievalTimeout"&gt;60000&lt;/property&gt;
  
  &lt;!--
    SFSBs use region-based marshalling to provide for partial state
    transfer during deployment/undeployment.
  --&gt;
  &lt;property name="useRegionBasedMarshalling"&gt;false&lt;/property&gt;
  &lt;!-- Must match the value of "useRegionBasedMarshalling" --&gt;
  &lt;property name="inactiveOnStartup"&gt;false&lt;/property&gt;
  
  &lt;!-- Disable asynchronous RPC marshalling/sending --&gt;
  &lt;property name="serializationExecutorPoolSize"&gt;0&lt;/property&gt;        
  &lt;!-- We have no asynchronous notification listeners --&gt;
  &lt;property name="listenerAsyncPoolSize"&gt;0&lt;/property&gt;
  
  &lt;property name="exposeManagementStatistics"&gt;true&lt;/property&gt;
  
  &lt;property name="buddyReplicationConfig"&gt;
    &lt;bean class="org.jboss.cache.config.BuddyReplicationConfig"&gt;
    
      &lt;!--  Just set to true to turn on buddy replication --&gt;
      &lt;property name="enabled"&gt;false&lt;/property&gt;
      
      &lt;!--
        A way to specify a preferred replication group.  We try
        and pick a buddy who shares the same pool name (falling 
        back to other buddies if not available).
      --&gt;
      &lt;property name="buddyPoolName"&gt;default&lt;/property&gt;
      
      &lt;property name="buddyCommunicationTimeout"&gt;17500&lt;/property&gt;
      
      &lt;!-- Do not change these --&gt;
      &lt;property name="autoDataGravitation"&gt;false&lt;/property&gt;
      &lt;property name="dataGravitationRemoveOnFind"&gt;true&lt;/property&gt;
      &lt;property name="dataGravitationSearchBackupTrees"&gt;true&lt;/property&gt;
               
      &lt;property name="buddyLocatorConfig"&gt;
        &lt;bean class="org.jboss.cache.buddyreplication.NextMemberBuddyLocatorConfig"&gt;
          &lt;!-- The number of backup nodes we maintain --&gt;
          &lt;property name="numBuddies"&gt;1&lt;/property&gt;
          &lt;!-- Means that each node will *try* to select a buddy on 
               a different physical host. If not able to do so 
               though, it will fall back to colocated nodes. --&gt;
          &lt;property name="ignoreColocatedBuddies"&gt;true&lt;/property&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="cacheLoaderConfig"&gt;
    &lt;bean class="org.jboss.cache.config.CacheLoaderConfig"&gt;
      &lt;!-- Do not change these --&gt;
      &lt;property name="passivation"&gt;true&lt;/property&gt;
      &lt;property name="shared"&gt;false&lt;/property&gt;
      
      &lt;property name="individualCacheLoaderConfigs"&gt;
        &lt;list&gt;
          &lt;bean class="org.jboss.cache.loader.FileCacheLoaderConfig"&gt;
            &lt;!-- Where passivated sessions are stored --&gt;
            &lt;property name="location"&gt;${jboss.server.data.dir}${/}sfsb&lt;/property&gt;
            &lt;!-- Do not change these --&gt;
            &lt;property name="async"&gt;false&lt;/property&gt;
            &lt;property name="fetchPersistentState"&gt;true&lt;/property&gt;
            &lt;property name="purgeOnStartup"&gt;true&lt;/property&gt;
            &lt;property name="ignoreModifications"&gt;false&lt;/property&gt;
            &lt;property name="checkCharacterPortability"&gt;false&lt;/property&gt;
          &lt;/bean&gt;
        &lt;/list&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;

  &lt;!-- EJBs use JBoss Cache eviction --&gt;
  &lt;property name="evictionConfig"&gt;
    &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
      &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
      &lt;!--  Overall default --&gt;
      &lt;property name="defaultEvictionRegionConfig"&gt;
        &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
          &lt;property name="regionName"&gt;/&lt;/property&gt;
          &lt;property name="evictionAlgorithmConfig"&gt;
            &lt;bean class="org.jboss.cache.eviction.NullEvictionAlgorithmConfig"/&gt;
          &lt;/property&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
      &lt;!-- EJB3 integration code will programatically create other regions as beans are deployed --&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</pre><div class="para"><div class="title">Eviction</div><p>
					The default SFSB cache is configured to support eviction. The EJB3 SFSB container uses the JBoss Cache eviction mechanism to manage SFSB passivation. When beans are deployed, the EJB container will programatically add eviction regions to the cache, one region per bean type.
				</p></div><div class="para"><div class="title">CacheLoader</div><p>
					A JBoss Cache CacheLoader is also configured; again to support SFSB passivation. When beans are evicted from the cache, the cache loader passivates them to a persistent store; in this case to the filesystem in the <code class="filename"><code class="filename"> <em class="replaceable">$JBOSS_HOME</em> </code>/server/all/data/sfsb</code> directory. JBoss Cache supports a variety of different CacheLoader implementations that know how to store data to different persistent store types; see the JBoss Cache documentation for details. However, if you change the CacheLoaderConfiguration, be sure that you do not use a shared store, e.g. a single schema in a shared database. Each node in the cluster must have its own persistent store, otherwise as nodes independently passivate and activate clustered beans, they will corrupt each other's data.
				</p></div><div class="para"><div class="title">Buddy Replication</div><p>
					Using buddy replication, state is replicated to a configurable number of backup servers in the cluster (a.k.a. buddies), rather than to all servers in the cluster. To enable buddy replication, adjust the following properties in the <code class="literal">buddyReplicationConfig</code> property bean: 
					<div class="itemizedlist"><ul><li class="listitem"><div class="para">
								Set <code class="literal">enabled</code> to <code class="literal">true</code>.
							</div></li><li class="listitem"><div class="para">
								Use the <code class="literal">buddyPoolName</code> to form logical subgroups of nodes within the cluster. If possible, buddies will be chosen from nodes in the same buddy pool.
							</div></li><li class="listitem"><div class="para">
								Adjust the <code class="literal">buddyLocatorConfig.numBuddies</code> property to reflect the number of backup nodes to which each node should replicate its state.
							</div></li></ul></div>

				</p></div></div></div><div class="section" id="clustering-session-slsb21"><div class="titlepage"><div><div><h2 class="title">20.3.Stateless Session Bean in EJB 2.x</h2></div></div></div><div class="para">
			To make an EJB 2.x bean clustered, you need to modify its <code class="literal">jboss.xml</code> descriptor to contain a <code class="literal">&lt;clustered&gt;</code> tag.
		</div><pre class="programlisting">
&lt;jboss&gt;
  &lt;enterprise-beans&gt;
    &lt;session&gt;
      &lt;ejb-name&gt;nextgen.StatelessSession&lt;/ejb-name&gt;
      &lt;jndi-name&gt;nextgen.StatelessSession&lt;/jndi-name&gt;
      &lt;clustered&gt;true&lt;/clustered&gt;
      &lt;cluster-config&gt;
        &lt;partition-name&gt;DefaultPartition&lt;/partition-name&gt;
        &lt;home-load-balance-policy&gt;org.jboss.ha.framework.interfaces.RoundRobin&lt;/home-load-balance-policy&gt;
        &lt;bean-load-balance-policy&gt;org.jboss.ha.framework.interfaces.RoundRobin&lt;/bean-load-balance-policy&gt;
      &lt;/cluster-config&gt;
    &lt;/session&gt;
  &lt;/enterprise-beans&gt;
&lt;/jboss&gt;
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>partition-name</strong></span> specifies the name of the cluster the bean participates in. The default value is <code class="literal">DefaultPartition</code>. The default partition name can also be set system-wide using the <code class="literal">jboss.partition.name</code> system property.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>home-load-balance-policy</strong></span> indicates the class to be used by the home stub to balance calls made on the nodes of the cluster. By default, the proxy will load-balance calls in a <code class="literal">RoundRobin</code> fashion.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>bean-load-balance-policy</strong></span> Indicates the class to be used by the bean stub to balance calls made on the nodes of the cluster. By default, the proxy will load-balance calls in a <code class="literal">RoundRobin</code> fashion.
				</div></li></ul></div></div><div class="section" id="clustering-session-sfsb21"><div class="titlepage"><div><div><h2 class="title">20.4.Stateful Session Bean in EJB 2.x</h2></div></div></div><div class="para">
			Clustering stateful session beans is more complex than clustering their stateless counterparts since JBoss needs to manage the state information. The state of all stateful session beans are replicated and synchronized across the cluster each time the state of a bean changes. The JBoss Enterprise Application Platform uses the <code class="literal">HASessionStateService</code> bean to manage distributed session states for clustered EJB 2.x stateful session beans. In this section, we cover both the session bean configuration and the <code class="literal">HASessionStateService</code> bean configuration.
		</div><div class="section" id="idm139946659161504"><div class="titlepage"><div><div><h3 class="title">20.4.1.The EJB application configuration</h3></div></div></div><div class="para">
				In the EJB application, you need to modify the <code class="literal">jboss.xml</code> descriptor file for each stateful session bean and add the <code class="literal">&lt;clustered&gt;</code> tag.
			</div><pre class="programlisting">
&lt;jboss&gt;    
  &lt;enterprise-beans&gt;
    &lt;session&gt;        
      &lt;ejb-name&gt;nextgen.StatefulSession&lt;/ejb-name&gt;
      &lt;jndi-name&gt;nextgen.StatefulSession&lt;/jndi-name&gt;
      &lt;clustered&gt;True&lt;/clustered&gt;
      &lt;cluster-config&gt;
        &lt;partition-name&gt;DefaultPartition&lt;/partition-nam&gt;
        &lt;home-load-balance-policy&gt;org.jboss.ha.framework.interfaces.RoundRobin&lt;/home-load-balance-policy&gt;
        &lt;bean-load-balance-policy&gt;org.jboss.ha.framework.interfaces.FirstAvailable&lt;/bean-load-balance-policy&gt;          
        &lt;session-state-manager-jndi-name&gt;/HASessionState/Default&lt;/session-state-manager-jndi-name&gt;        
      &lt;/cluster-config&gt;
    &lt;/session&gt;
  &lt;/enterprise-beans&gt;
&lt;/jboss&gt;
</pre><div class="para">
				In the bean configuration, only the <code class="literal">&lt;clustered&gt;</code> tag is mandatory to indicate that the bean works in a cluster. The <code class="literal">&lt;cluster-config&gt;</code> element is optional and its default attribute values are indicated in the sample configuration above.
			</div><div class="para">
				The <code class="literal">&lt;session-state-manager-jndi-name&gt;</code> tag is used to give the JNDI name of the <code class="literal">HASessionStateService</code> to be used by this bean.
			</div><div class="para">
				The description of the remaining tags is identical to the one for stateless session bean. Actions on the clustered stateful session bean's home interface are by default load-balanced, round-robin. Once the bean's remote stub is available to the client, calls will not be load-balanced round-robin any more and will stay "sticky" to the first node in the list.
			</div></div><div class="section" id="idm139946659154416"><div class="titlepage"><div><div><h3 class="title">20.4.2.Optimize state replication</h3></div></div></div><div class="para">
				As the replication process is a costly operation, you can optimise this behaviour by optionally implementing in your bean class a method with the following signature:
			</div><pre class="programlisting">
public boolean isModified();
</pre><div class="para">
				Before replicating your bean, the container will detect if your bean implements this method. If your bean does, the container calls the <code class="literal">isModified()</code> method and it only replicates the bean when the method returns <code class="literal">true</code>. If the bean has not been modified (or not enough to require replication, depending on your own preferences), you can return <code class="literal">false</code> and the replication would not occur.
			</div></div><div class="section" id="idm139946659150224"><div class="titlepage"><div><div><h3 class="title">20.4.3.The HASessionStateService configuration</h3></div></div></div><div class="para">
				The <code class="literal">HASessionStateService</code> bean is defined in the <code class="code">&lt;profile&gt;/deploy/cluster/ha-legacy-jboss-beans.xml</code> file.
			</div><pre class="programlisting"> 
&lt;bean name="HASessionStateService"
      class="org.jboss.ha.hasessionstate.server.HASessionStateService"&gt;
  
  &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
  (name="jboss:service=HASessionState", 
  exposedInterface=org.jboss.ha.hasessionstate.server.
  HASessionStateServiceMBean.class, 
  registerDirectly=true)&lt;/annotation&gt;
  
  &lt;!--  Partition used for group RPCs --&gt;
  &lt;property name="HAPartition"&gt;&lt;inject bean="HAPartition"/&gt;&lt;/property&gt;
  
  &lt;!-- JNDI name under which the service is bound --&gt;
  &lt;property name="jndiName"&gt;/HASessionState/Default&lt;/property&gt;
  &lt;!-- Max delay before cleaning unreclaimed state.
       Defaults to 30*60*1000 =&gt; 30 minutes --&gt;
  &lt;property name="beanCleaningDelay"&gt;0&lt;/property&gt;
   
&lt;/bean&gt;
</pre><div class="para">
				The configuration attributes in the <code class="literal">HASessionStateService</code> bean are listed below.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>HAPartition</strong></span> is a required attribute to inject the HAPartition service that HA-JNDI uses for intra-cluster communication.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>jndiName</strong></span> is an optional attribute to specify the JNDI name under which this <code class="literal">HASessionStateService</code> bean is bound. The default value is <code class="literal">/HAPartition/Default</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>beanCleaningDelay</strong></span> is an optional attribute to specify the number of miliseconds after which the <code class="literal">HASessionStateService</code> can clean a state that has not been modified. If a node, owning a bean, crashes, its brother node will take ownership of this bean. Nevertheless, the container cache of the brother node will not know about it (because it has never seen it before) and will never delete according to the cleaning settings of the bean. That is why the <code class="literal">HASessionStateService</code> needs to do this cleanup sometimes. The default value is <code class="literal">30*60*1000</code> milliseconds (i.e., 30 minutes).
					</div></li></ul></div></div><div class="section" id="idm139946659137632"><div class="titlepage"><div><div><h3 class="title">20.4.4.Handling Cluster Restart</h3></div></div></div><div class="para">
				We have covered the HA smart client architecture in <a class="xref" href="#clustering-concepts-arch-proxy">Section17.2.1, Client-side interceptor architecture</a>. The default HA smart proxy client can only failover as long as one node in the cluster exists. If there is a complete cluster shutdown, the proxy becomes orphaned and loses knowledge of the available nodes in the cluster. There is no way for the proxy to recover from this. The proxy needs to look up a fresh set of targets out of JNDI/HA-JNDI when the nodes are restarted.
			</div><div class="para">
				RetryInterceptor can be added to the proxy client side interceptor stack to allow for a transparent recovery from such a restart failure. To enable it for an EJB, setup an invoker-proxy-binding that includes the RetryInterceptor. Below is an example jboss.xml configuration.
			</div><pre class="programlisting"> 
&lt;jboss&gt;
  &lt;session&gt;
    &lt;ejb-name&gt;nextgen_RetryInterceptorStatelessSession&lt;/ejb-name&gt;
    &lt;invoker-bindings&gt;
      &lt;invoker&gt;
        &lt;invoker-proxy-binding-name&gt;clustered-retry-stateless-rmi-invoker&lt;/invoker-proxy-binding-name&gt;
        &lt;jndi-name&gt;nextgen_RetryInterceptorStatelessSession&lt;/jndi-name&gt;
      &lt;/invoker&gt;
    &lt;/invoker-bindings&gt;
    &lt;clustered&gt;true&lt;/clustered&gt;
  &lt;/session&gt;
  &lt;invoker-proxy-binding&gt;
    &lt;name&gt;clustered-retry-stateless-rmi-invoker&lt;/name&gt;
    &lt;invoker-mbean&gt;jboss:service=invoker,type=jrmpha&lt;/invoker-mbean&gt;
    &lt;proxy-factory&gt;org.jboss.proxy.ejb.ProxyFactoryHA&lt;/proxy-factory&gt;
    &lt;proxy-factory-config&gt;
      &lt;client-interceptors&gt;
        &lt;home&gt;
          &lt;interceptor&gt;org.jboss.proxy.ejb.HomeInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.SecurityInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.TransactionInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.ejb.RetryInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.invocation.InvokerInterceptor&lt;/interceptor&gt;
        &lt;/home&gt;
        &lt;bean&gt;
          &lt;interceptor&gt;org.jboss.proxy.ejb.StatelessSessionInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.SecurityInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.TransactionInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.proxy.ejb.RetryInterceptor&lt;/interceptor&gt;
          &lt;interceptor&gt;org.jboss.invocation.InvokerInterceptor&lt;/interceptor&gt;
        &lt;/bean&gt;
      &lt;/client-interceptors&gt;
    &lt;/proxy-factory-config&gt;
  &lt;/invoker-proxy-binding&gt;
&lt;/jboss&gt;
</pre></div><div class="section" id="idm139946659132528"><div class="titlepage"><div><div><h3 class="title">20.4.5.JNDI Lookup Process</h3></div></div></div><div class="para">
				In order to recover the HA proxy, the RetryInterceptor does a lookup in JNDI. This means that internally it creates a new InitialContext and does a JNDI lookup. But, for that lookup to succeed, the InitialContext needs to be configured properly to find your naming server. The RetryInterceptor will go through the following steps in attempting to determine the proper naming environment properties:
			</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
						It will check its own static retryEnv field. This field can be set by client code via a call to RetryInterceptor.setRetryEnv(Properties). This approach to configuration has two downsides: first, it reduces portability by introducing JBoss-specific calls to the client code; and second, since a static field is used only a single configuration per VM is possible.
					</div></li><li class="listitem"><div class="para">
						If the retryEnv field is null, it will check for any environment properties bound to a ThreadLocal by the org.jboss.naming.NamingContextFactory class. To use this class as your naming context factory, in your jndi.properties set property java.naming.factory.initial=org.jboss.naming.NamingContextFactory. The advantage of this approach is use of org.jboss.naming.NamingContextFactory is simply a configuration option in your jndi.properties file, and thus your java code is unaffected. The downside is the naming properties are stored in a ThreadLocal and thus are only visible to the thread that originally created an InitialContext.
					</div></li><li class="listitem"><div class="para">
						If neither of the above approaches yield a set of naming environment properties, a default InitialContext is used. If the attempt to contact a naming server is unsuccessful, by default the InitialContext will attempt to fall back on multicast discovery to find an HA-JNDI naming server. See <a class="xref" href="#clustering-jndi">Chapter19, <em>Clustered JNDI Services</em></a> for more on multicast discovery of HA-JNDI.
					</div></li></ol></div></div><div class="section" id="idm139946659125600"><div class="titlepage"><div><div><h3 class="title">20.4.6.SingleRetryInterceptor</h3></div></div></div><div class="para">
				The RetryInterceptor is useful in many use cases, but a disadvantage it has is that it will continue attempting to re-lookup the HA proxy in JNDI until it succeeds. If for some reason it cannot succeed, this process could go on forever, and thus the EJB call that triggered the RetryInterceptor will never return. For many client applications, this possibility is unacceptable. As a result, JBoss doesn't make the RetryInterceptor part of its default client interceptor stacks for clustered EJBs.
			</div><div class="para">
				In a previous release, a new flavor of retry interceptor was introduced, the org.jboss.proxy.ejb.SingleRetryInterceptor. This version works like the RetryInterceptor, but only makes a single attempt to re-lookup the HA proxy in JNDI. If this attempt fails, the EJB call will fail just as if no retry interceptor was used. The SingleRetryInterceptor is now part of the default client interceptor stacks for clustered EJBs.
			</div><div class="para">
				The downside of the SingleRetryInterceptor is that if the retry attempt is made during a portion of a cluster restart where no servers are available, the retry will fail and no further attempts will be made.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-entity" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter21.Clustered Entity EJBs</h2></div></div></div><div class="para">
		In a JBoss Enterprise Application Platform cluster, entity bean instance caches need to be kept in sync across all nodes. If an entity bean provides remote services, the service methods need to be load balanced as well.
	</div><div class="section" id="clustering-entity-30"><div class="titlepage"><div><div><h2 class="title">21.1.Entity Bean in EJB 3.0</h2></div></div></div><div class="para">
			In EJB 3.0, entity beans primarily serve as a persistence data model. They do not provide remote services. Hence, the entity bean clustering service in EJB 3.0 primarily deals with distributed caching and replication, instead of load balancing.
		</div><div class="section" id="clustering-entity-30-cache"><div class="titlepage"><div><div><h3 class="title">21.1.1.Configure the distributed cache</h3></div></div></div><div class="para">
				To avoid round trips to the database, you can use a cache for your entities. JBoss EJB 3.0 entity beans are implemented by Hibernate, which has support for a second-level cache. The second-level cache provides the following functionalities:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						If you persist a cache-enabled entity bean instance to the database via the entity manager, the entity will be inserted into the cache.
					</div></li><li class="listitem"><div class="para">
						If you update an entity bean instance, and save the changes to the database via the entity manager, the entity will be updated in the cache.
					</div></li><li class="listitem"><div class="para">
						If you remove an entity bean instance from the database via the entity manager, the entity will be removed from the cache.
					</div></li><li class="listitem"><div class="para">
						If loading a cached entity from the database via the entity manager, and that entity does not exist in the database, it will be inserted into the cache.
					</div></li></ul></div><div class="para">
				As well as a region for caching entities, the second-level cache also contains regions for caching collections, queries, and timestamps. The Hibernate setup used for the JBoss EJB 3.0 implementation uses JBoss Cache as its underlying second-level cache implementation.
			</div><div class="para">
				Configuration of a the second-level cache is done via your EJB3 deployment's <code class="filename">persistence.xml</code>, like so:
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/persistence"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"&gt;
  &lt;persistence-unit name="tempdb" transaction-type="JTA"&gt;
    &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
    &lt;properties&gt;
      &lt;property name="hibernate.cache.use_second_level_cache" value="true"/&gt;
      &lt;property name="hibernate.cache.use_query_cache" value="true"/&gt;
      &lt;property name="hibernate.cache.region.factory_class" value="org.hibernate.cache.jbc2.JndiMultiplexedJBossCacheRegionFactory"/&gt;
      &lt;!-- region factory specific properties --&gt;
      &lt;property name="hibernate.cache.region.jbc2.cachefactory" value="java:CacheManager"/&gt;
      &lt;property name="hibernate.cache.region.jbc2.cfg.entity" value="mvcc-entity"/&gt;
      &lt;property name="hibernate.cache.region.jbc2.cfg.collection" value="mvcc-entity"/&gt;
    &lt;/properties&gt;
  &lt;/persistence-unit&gt;
&lt;/persistence&gt;
</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">hibernate.cache.use_second_level_cache</span></dt><dd><div class="para">
							Enables second-level caching of entities and collections.
						</div></dd><dt><span class="term">hibernate.cache.use_query_cache</span></dt><dd><div class="para">
							Enables second-level caching of queries.
						</div></dd><dt><span class="term">hibernate.cache.region.factory_class</span></dt><dd><div class="para">
							Defines the <code class="literal">RegionFactory</code> implementation that dictates region-specific caching behavior. Hibernate ships with 2 types of JBoss Cache-based second-level caches: shared and multiplexed.
						</div><div class="para">
							A shared region factory uses the same Cache for all cache regions - much like the legacy CacheProvider implementation in older Hibernate versions.
						</div><div class="para">
							Hibernate ships with 2 shared region factory implementations:
						</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">org.hibernate.cache.jbc2.SharedJBossCacheRegionFactory</span></dt><dd><div class="para">
										Uses a single JBoss Cache configuration, from a newly instantiated CacheManager, for all cache regions.
									</div><div class="table" id="idm139946658624640"><p class="title"><strong>Table21.1.Additional properties for SharedJBossCacheRegionFactory</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Additional properties for SharedJBossCacheRegionFactory"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946658750096" scope="col"> Property </th><th id="idm139946658749616" scope="col"> Default </th><th id="idm139946658749136" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946658750096"> hibernate.cache.region.jbc2.cfg.shared </td><td headers="idm139946658749616"> treecache.xml </td><td headers="idm139946658749136"> The classpath or filesystem resource containing the JBoss Cache configuration settings. </td></tr><tr><td headers="idm139946658750096"> hibernate.cache.region.jbc2.cfg.jgroups.stacks </td><td headers="idm139946658749616"> org/hibernate/cache/jbc2/builder/jgroups-stacks.xml </td><td headers="idm139946658749136"> The classpath or filesystem resource containing the JGroups protocol stack configurations. </td></tr></tbody></table></div></div></dd><dt><span class="term">org.hibernate.cache.jbc2.JndiSharedJBossCacheRegionFactory</span></dt><dd><div class="para">
										Uses a single JBoss Cache configuration, from an existing CacheManager bound to JNDI, for all cache regions.
									</div><div class="table" id="idm139946658922192"><p class="title"><strong>Table21.2.Additional properties for JndiSharedJBossCacheRegionFactory</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Additional properties for JndiSharedJBossCacheRegionFactory"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946658920080" scope="col"> Property </th><th id="idm139946658919600" scope="col"> Default </th><th id="idm139946658919120" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946658920080"> hibernate.cache.region.jbc2.cfg.shared </td><td headers="idm139946658919600"> <span class="emphasis"><em>Required</em></span> </td><td headers="idm139946658919120"> JNDI name to which the shared <code class="literal">Cache</code> instance is bound. </td></tr></tbody></table></div></div></dd></dl></div><div class="para">
							A multiplexed region factory uses separate Cache instances, using optimized configurations for each cache region.
						</div><div class="table" id="idm139946657743040"><p class="title"><strong>Table21.3.Common properties for multiplexed region factory implementations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Common properties for multiplexed region factory implementations"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946657740928" scope="col"> Property </th><th id="idm139946657740448" scope="col"> Default </th><th id="idm139946657739968" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946657740928"> hibernate.cache.region.jbc2.cfg.entity </td><td headers="idm139946657740448"> optimistic-entity </td><td headers="idm139946657739968"> The JBoss Cache configuration used for the entity cache region. Alternative configurations: mvcc-entity, pessimistic-entity, mvcc-entity-repeatable, optimistic-entity-repeatable, pessimistic-entity-repeatable </td></tr><tr><td headers="idm139946657740928"> hibernate.cache.region.jbc2.cfg.collection </td><td headers="idm139946657740448"> optimistic-entity </td><td headers="idm139946657739968"> The JBoss Cache configuration used for the collection cache region. The collection cache region typically uses the same configuration as the entity cache region. </td></tr><tr><td headers="idm139946657740928"> hibernate.cache.region.jbc2.cfg.query </td><td headers="idm139946657740448"> local-query </td><td headers="idm139946657739968"> The JBoss Cache configuration used for the query cache region. By default, cached query results are not replicated. Alternative configurations: replicated-query </td></tr><tr><td headers="idm139946657740928"> hibernate.cache.region.jbc2.cfg.ts </td><td headers="idm139946657740448"> timestamps-cache </td><td headers="idm139946657739968"> The JBoss Cache configuration used for the timestamp cache region. If query caching is used, the corresponding timestamp cache must be replicating, even if the query cache is non-replicating. The timestamp cache region must never share the same cache as the query cache. </td></tr></tbody></table></div></div><div class="para">
							Hibernate ships with 2 shared region factory implementations:
						</div><div class="variablelist"><dl class="variablelist"><dt><span class="term">org.hibernate.cache.jbc2.MultiplexedJBossCacheRegionFactory</span></dt><dd><div class="para">
										Uses separate JBoss Cache configurations, from a newly instantiated CacheManager, per cache region.
									</div><div class="table" id="idm139946672648304"><p class="title"><strong>Table21.4.Additional properties for MultiplexedJBossCacheRegionFactory</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Additional properties for MultiplexedJBossCacheRegionFactory"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946672646192" scope="col"> Property </th><th id="idm139946672645712" scope="col"> Default </th><th id="idm139946672645232" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946672646192"> hibernate.cache.region.jbc2.configs </td><td headers="idm139946672645712"> org/hibernate/cache/jbc2/builder/jbc2-configs.xml </td><td headers="idm139946672645232"> The classpath or filesystem resource containing the JBoss Cache configuration settings. </td></tr><tr><td headers="idm139946672646192"> hibernate.cache.region.jbc2.cfg.jgroups.stacks </td><td headers="idm139946672645712"> org/hibernate/cache/jbc2/builder/jgroups-stacks.xml </td><td headers="idm139946672645232"> The classpath or filesystem resource containing the JGroups protocol stack configurations. </td></tr></tbody></table></div></div></dd><dt><span class="term">org.hibernate.cache.jbc2.JndiMultiplexedJBossCacheRegionFactory</span></dt><dd><div class="para">
										Uses separate JBoss Cache configurations, from a JNDI-bound CacheManager, see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>, per cache region.
									</div><div class="table" id="idm139946658249168"><p class="title"><strong>Table21.5.Additional properties for JndiMultiplexedJBossCacheRegionFactory</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Additional properties for JndiMultiplexedJBossCacheRegionFactory"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946658247056" scope="col"> Property </th><th id="idm139946658246576" scope="col"> Default </th><th id="idm139946658246096" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946658247056"> hibernate.cache.region.jbc2.cachefactory </td><td headers="idm139946658246576"> <span class="emphasis"><em>Required</em></span> </td><td headers="idm139946658246096"> JNDI name to which the <code class="literal">CacheManager</code> instance is bound. </td></tr></tbody></table></div></div></dd></dl></div></dd></dl></div><div class="para">
				Now, we have JBoss Cache configured to support distributed caching of EJB 3.0 entity beans. We still have to configure individual entity beans to use the cache service.
			</div></div><div class="section" id="clustering-entity-30-bean"><div class="titlepage"><div><div><h3 class="title">21.1.2.Configure the entity beans for cache</h3></div></div></div><div class="para">
				Next we need to configure which entities to cache. The default is to not cache anything, even with the settings shown above. We use the <code class="literal">@org.hibernate.annotations.Cache</code> annotation to tag entity beans that needs to be cached.
			</div><pre class="programlisting">
@Entity 
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL) 
public class Account implements Serializable
{
   // ... ... 
}
</pre><div class="para">
				A very simplified rule of thumb is that you will typically want to do caching for objects that rarely change, and which are frequently read. You can fine tune the cache for each entity bean in the appropriate JBoss Cache configuration file, e.g. <code class="filename">jboss-cache-manager-jboss-beans.xml</code>. For instance, you can specify the size of the cache. If there are too many objects in the cache, the cache can evict the oldest or least used objects, depending on configuration, to make room for new objects. Assuming the region_prefix specified in <code class="literal">persistence.xml</code> was <code class="literal">myprefix</code>, the default name of the cache region for the <code class="literal">com.mycompany.entities.Account</code> entity bean would be <code class="literal">/myprefix/com/mycompany/entities/Account</code>.
			</div><pre class="programlisting">
&lt;bean name="..." class="org.jboss.cache.config.Configuration"&gt;
   ... ...
  &lt;property name="evictionConfig"&gt;
    &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
      &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
      &lt;!--  Overall default --&gt;
      &lt;property name="defaultEvictionRegionConfig"&gt;
        &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
          &lt;property name="regionName"&gt;/&lt;/property&gt;
          &lt;property name="evictionAlgorithmConfig"&gt;
            &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
              &lt;!-- Evict LRU node once we have more than this number of nodes --&gt;
              &lt;property name="maxNodes"&gt;10000&lt;/property&gt;
              &lt;!-- And, evict any node that hasn't been accessed in this many seconds --&gt;
              &lt;property name="timeToLiveSeconds"&gt;1000&lt;/property&gt;
              &lt;!-- Don't evict a node that's been accessed within this many seconds. 
                  Set this to a value greater than your max expected transaction length. --&gt;
              &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
            &lt;/bean&gt;
          &lt;/property&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
      &lt;property name="evictionRegionConfigs"&gt;
        &lt;list&gt;
          &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
            &lt;property name="regionName"&gt;/myprefix/com/mycompany/entities/Account&lt;/property&gt;
            &lt;property name="evictionAlgorithmConfig"&gt;
              &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                &lt;property name="maxNodes"&gt;10000&lt;/property&gt;
                &lt;property name="timeToLiveSeconds"&gt;5000&lt;/property&gt;
                &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
              &lt;/bean&gt;
            &lt;/property&gt;
          &lt;/bean&gt;
           ... ...
        &lt;/list&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</pre><div class="para">
				If you do not specify a cache region for an entity bean class, all instances of this class will be cached using the <code class="literal">defaultEvictionRegionConfig</code> as defined above. The @Cache annotation exposes an optional attribute "region" that lets you specify the cache region where an entity is to be stored, rather than having it be automatically be created from the fully-qualified class name of the entity class.
			</div><pre class="programlisting">
@Entity 
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL, region = "Account") 
public class Account implements Serializable
{ 
  // ... ... 
}
</pre><div class="para">
				The eviction configuration would then become:
			</div><pre class="programlisting">
&lt;bean name="..." class="org.jboss.cache.config.Configuration"&gt;
   ... ...
  &lt;property name="evictionConfig"&gt;
    &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
      &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
      &lt;!--  Overall default --&gt;
      &lt;property name="defaultEvictionRegionConfig"&gt;
        &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
          &lt;property name="regionName"&gt;/&lt;/property&gt;
          &lt;property name="evictionAlgorithmConfig"&gt;
            &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
              &lt;property name="maxNodes"&gt;5000&lt;/property&gt;
              &lt;property name="timeToLiveSeconds"&gt;1000&lt;/property&gt;
              &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
            &lt;/bean&gt;
          &lt;/property&gt;
        &lt;/bean&gt;
      &lt;/property&gt;
      &lt;property name="evictionRegionConfigs"&gt;
        &lt;list&gt;
          &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
            &lt;property name="regionName"&gt;/myprefix/Account&lt;/property&gt;
            &lt;property name="evictionAlgorithmConfig"&gt;
              &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                &lt;property name="maxNodes"&gt;10000&lt;/property&gt;
                &lt;property name="timeToLiveSeconds"&gt;5000&lt;/property&gt;
                &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
              &lt;/bean&gt;
            &lt;/property&gt;
          &lt;/bean&gt;
           ... ...
        &lt;/list&gt;
      &lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;
</pre></div><div class="section" id="idm139946659112368"><div class="titlepage"><div><div><h3 class="title">21.1.3.Query result caching</h3></div></div></div><div class="para">
				The EJB3 Query API also provides means for you to save the results (i.e., collections of primary keys of entity beans, or collections of scalar values) of specified queries in the second-level cache. Here we show a simple example of annotating a bean with a named query, also providing the Hibernate-specific hints that tells Hibernate to cache the query.
			</div><div class="para">
				First, in persistence.xml you need to tell Hibernate to enable query caching:
			</div><pre class="screen">&lt;property name="hibernate.cache.use_query_cache" value="true"/&gt;</pre><div class="para">
				Next, you create a named query associated with an entity, and tell Hibernate you want to cache the results of that query:
			</div><pre class="programlisting"> 
@Entity
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL, region = "Account")
@NamedQueries(
{
  @NamedQuery(
    name = "account.bybranch",
    query = "select acct from Account as acct where acct.branch = ?1",
    hints = { @QueryHint(name = "org.hibernate.cacheable", value = "true") }
  )
})
public class Account implements Serializable
{
  // ... ... 
}
</pre><div class="para">
				The @NamedQueries, @NamedQuery and @QueryHint annotations are all in the javax.persistence package. See the Hibernate and EJB3 documentation for more on how to use EJB3 queries and on how to instruct EJB3 to cache queries.
			</div><div class="para">
				By default, Hibernate stores query results in JBoss Cache in a region named &lt;region_prefix&gt;/org/hibernate/cache/StandardQueryCache. Based on this, you can set up separate eviction handling for your query results. So, if the region prefix were set to myprefix in <code class="filename">persistence.xml</code>, you could, for example, create this sort of eviction handling:
			</div><pre class="programlisting">
&lt;bean name="..." class="org.jboss.cache.config.Configuration"&gt;
    ... ...
   &lt;property name="evictionConfig"&gt;
       &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
         &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
         &lt;!--  Overall default --&gt;
         &lt;property name="defaultEvictionRegionConfig"&gt;
            &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
               &lt;property name="regionName"&gt;/&lt;/property&gt;
               &lt;property name="evictionAlgorithmConfig"&gt;
                  &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                     &lt;property name="maxNodes"&gt;5000&lt;/property&gt;
                     &lt;property name="timeToLiveSeconds"&gt;1000&lt;/property&gt;
                     &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                  &lt;/bean&gt;
               &lt;/property&gt;
            &lt;/bean&gt;
         &lt;/property&gt;
         &lt;property name="evictionRegionConfigs"&gt;
            &lt;list&gt;
               &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
                  &lt;property name="regionName"&gt;/myprefix/Account&lt;/property&gt;
                  &lt;property name="evictionAlgorithmConfig"&gt;
                     &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                        &lt;property name="maxNodes"&gt;10000&lt;/property&gt;
                        &lt;property name="timeToLiveSeconds"&gt;5000&lt;/property&gt;
                        &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                     &lt;/bean&gt;
                  &lt;/property&gt;
               &lt;/bean&gt;
               &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
                  &lt;property name="regionName"&gt;/myprefix/org/hibernate/cache/StandardQueryCache&lt;/property&gt;
                  &lt;property name="evictionAlgorithmConfig"&gt;
                     &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                        &lt;property name="maxNodes"&gt;100&lt;/property&gt;
                        &lt;property name="timeToLiveSeconds"&gt;600&lt;/property&gt;
                        &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                     &lt;/bean&gt;
                  &lt;/property&gt;
               &lt;/bean&gt;
            &lt;/list&gt;
         &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;
</pre><div class="para">
				The @NamedQuery.hints attribute shown above takes an array of vendor-specific @QueryHints as a value. Hibernate accepts the "org.hibernate.cacheRegion" query hint, where the value is the name of a cache region to use instead of the default /org/hibernate/cache/StandardQueryCache. For example:
			</div><pre class="programlisting">
@Entity
@Cache(usage = CacheConcurrencyStrategy.TRANSACTIONAL, region = "Account")
@NamedQueries(
{
  @NamedQuery(
    name = "account.bybranch",
    query = "select acct from Account as acct where acct.branch = ?1",
    hints = 
    {
      @QueryHint(name = "org.hibernate.cacheable", value = "true"),
      @QueryHint(name = "org.hibernate.cacheRegion", value = "Queries")
    }
  )
})
public class Account implements Serializable
{
  // ... ... 
}
</pre><div class="para">
				The related eviction configuration:
			</div><pre class="programlisting">
&lt;bean name="..." class="org.jboss.cache.config.Configuration"&gt;
    ... ...
   &lt;property name="evictionConfig"&gt;
       &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
         &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
         &lt;!--  Overall default --&gt;
         &lt;property name="defaultEvictionRegionConfig"&gt;
            &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
               &lt;property name="regionName"&gt;/&lt;/property&gt;
               &lt;property name="evictionAlgorithmConfig"&gt;
                  &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                     &lt;property name="maxNodes"&gt;5000&lt;/property&gt;
                     &lt;property name="timeToLiveSeconds"&gt;1000&lt;/property&gt;
                     &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                  &lt;/bean&gt;
               &lt;/property&gt;
            &lt;/bean&gt;
         &lt;/property&gt;
         &lt;property name="evictionRegionConfigs"&gt;
            &lt;list&gt;
               &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
                  &lt;property name="regionName"&gt;/myprefix/Account&lt;/property&gt;
                  &lt;property name="evictionAlgorithmConfig"&gt;
                     &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                        &lt;property name="maxNodes"&gt;10000&lt;/property&gt;
                        &lt;property name="timeToLiveSeconds"&gt;5000&lt;/property&gt;
                        &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                     &lt;/bean&gt;
                  &lt;/property&gt;
               &lt;/bean&gt;
               &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
                  &lt;property name="regionName"&gt;/myprefix/Queries&lt;/property&gt;
                  &lt;property name="evictionAlgorithmConfig"&gt;
                     &lt;bean class="org.jboss.cache.eviction.LRUAlgorithmConfig"&gt;
                        &lt;property name="maxNodes"&gt;100&lt;/property&gt;
                        &lt;property name="timeToLiveSeconds"&gt;600&lt;/property&gt;
                        &lt;property name="minTimeToLiveSeconds"&gt;120&lt;/property&gt;
                     &lt;/bean&gt;
                  &lt;/property&gt;
               &lt;/bean&gt;
                ... ...
            &lt;/list&gt;
         &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;
</pre></div></div><div class="section" id="clustering-entity-21"><div class="titlepage"><div><div><h2 class="title">21.2.Entity Bean in EJB 2.x</h2></div></div></div><div class="para">
			First of all, it is worth noting that clustering 2.x entity beans is a bad thing to do. Its exposes elements that generally are too fine grained for use as remote objects to clustered remote objects and introduces data synchronization problems that are non-trivial. Do NOT use EJB 2.x entity bean clustering unless you fit into the special case situation of read-only, or one read-write node with read-only nodes synchronized with the cache invalidation services.
		</div><div class="para">
			To use a clustered entity bean, the application does not need to do anything special, except for looking up EJB 2.x remote bean references from the clustered HA-JNDI.
		</div><div class="para">
			To cluster EJB 2.x entity beans, you need to add the <code class="literal">&lt;clustered&gt;</code> element to the application's <code class="literal">jboss.xml</code> descriptor file. Below is a typical <code class="literal">jboss.xml</code> file.
		</div><pre class="programlisting">
&lt;jboss&gt;
  &lt;enterprise-beans&gt;
    &lt;entity&gt;
      &lt;ejb-name&gt;nextgen.EnterpriseEntity&lt;/ejb-name&gt;
      &lt;jndi-name&gt;nextgen.EnterpriseEntity&lt;/jndi-name&gt;
      &lt;clustered&gt;True&lt;/clustered&gt;
      &lt;cluster-config&gt;
        &lt;partition-name&gt;DefaultPartition&lt;/partition-name&gt;
        &lt;home-load-balance-policy&gt;org.jboss.ha.framework.interfaces.RoundRobin&lt;/home-load-balance-policy&gt;
        &lt;bean-load-balance-policy&gt;org.jboss.ha.framework.interfaces.FirstAvailable&lt;/bean-load-balance-policy&gt;
      &lt;/cluster-config&gt;
    &lt;/entity&gt;
  &lt;/enterprise-beans&gt;
&lt;/jboss&gt;
</pre><div class="para">
			The EJB 2.x entity beans are clustered for load balanced remote invocations. All the bean instances are synchronized to have the same contents on all nodes.
		</div><div class="para">
			However, clustered EJB 2.x Entity Beans do not have a distributed locking mechanism or a distributed cache. They can only be synchronized by using row-level locking at the database level (see <code class="literal">&lt;row-lock&gt;</code> in the CMP specification) or by setting the Transaction Isolation Level of your JDBC driver to be <code class="literal">TRANSACTION_SERIALIZABLE</code>. Because there is no supported distributed locking mechanism or distributed cache Entity Beans use Commit Option "B" by default (see <code class="literal">standardjboss.xml</code> and the container configurations Clustered CMP 2.x EntityBean, Clustered CMP EntityBean, or Clustered BMP EntityBean). It is not recommended that you use Commit Option "A" unless your Entity Bean is read-only. 
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If you are using Bean Managed Persistence (BMP), you are going to have to implement synchronization on your own. 
			</div></div></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-http" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter22.HTTP Services</h2></div></div></div><div class="para">
		HTTP session replication is used to replicate the state associated with web client sessions to other nodes in a cluster. Thus, in the event one of your nodes crashes, another node in the cluster will be able to recover. Two distinct functions must be performed:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				Session state replication
			</div></li><li class="listitem"><div class="para">
				Load-balancing HTTP Requests
			</div></li></ul></div><div class="para">
		State replication is directly handled by JBoss. When you run JBoss in the <code class="literal">all</code> configuration, session state replication is enabled by default. Just configure your web application as <code class="literal">&lt;distributable&gt;</code> in its <code class="filename">web.xml</code> (see <a class="xref" href="#clustering-http-state">Section22.2, Configuring HTTP session state replication</a>), deploy it, and its session state is automatically replicated across all JBoss instances in the cluster.
	</div><div class="para">
		However, load-balancing is a different story; it is not handled by JBoss itself and requires an external load balancer. This function could be provided by specialized hardware switches or routers (Cisco LoadDirector for example) or by specialized software running on commodity hardware. As a very common scenario, we will demonstrate how to set up a software load balancer using Apache httpd and mod_jk.
	</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			A load-balancer tracks HTTP requests and, depending on the session to which the request is linked, it dispatches the request to the appropriate node. This is called load-balancing with sticky-sessions or session affinity: once a session is created on a node, every future request will also be processed by that same node. Using a load-balancer that supports sticky-sessions but not configuring your web application for session replication allows you to scale very well by avoiding the cost of session state replication: each request for a session will always be handled by the same node. But in case a node dies, the state of all client sessions hosted by this node (the shopping carts, for example) will be lost and the clients will most probably need to login on another node and restart with a new session. In many situations, it is acceptable not to replicate HTTP sessions because all critical state is stored in a database or on the client. In other situations, losing a client session is not acceptable and, in this case, session state replication is the price one has to pay.
		</div></div></div><div class="section" id="clustering-http-modjk"><div class="titlepage"><div><div><h2 class="title">22.1.Configuring load balancing using Apache and mod_jk</h2></div></div></div><div class="para">
			Apache is a well-known web server which can be extended by plugging in modules. One of these modules, mod_jk has been specifically designed to allow the forwarding of requests from Apache to a Servlet container. Furthermore, it is also able to load-balance HTTP calls to a set of Servlet containers while maintaining sticky sessions, which is what is most interesting for us in this section.
		</div><div class="section" id="clustering-http-download"><div class="titlepage"><div><div><h3 class="title">22.1.1.Download the software</h3></div></div></div><div class="para">
				First of all, make sure that you have Apache installed. You can download Apache directly from Apache web site at <a href="http://httpd.apache.org/" class="mimir-link-warn" title="Mimir does not include content from: httpd.apache.org">http://httpd.apache.org/</a>. Its installation is pretty straightforward and requires no specific configuration. As several versions of Apache exist, we advise you to use the latest stable 2.2.x version. We will assume, for the next sections, that you have installed Apache in the <code class="literal">APACHE_HOME</code> directory.
			</div><div class="para">
				Next, download mod_jk binaries. Several versions of mod_jk exist as well. We strongly advise the use of mod_jk 1.2.x, as both earlier versions of mod_jk, and mod_jk2, are deprecated, unsupported and no further development is going on in the community. The mod_jk 1.2.x binary can be downloaded from <a href="http://www.apache.org/dist/jakarta/tomcat-connectors/jk/binaries/" class="mimir-link-warn" title="Mimir does not include content from: www.apache.org">http://www.apache.org/dist/jakarta/tomcat-connectors/jk/binaries/</a>. Rename the downloaded file to <code class="literal">mod_jk.so</code> and copy it under <code class="literal">APACHE_HOME/modules/</code>.
			</div></div><div class="section" id="idm139946669955264"><div class="titlepage"><div><div><h3 class="title">22.1.2.Configure Apache to load mod_jk</h3></div></div></div><div class="para">
				Modify APACHE_HOME/conf/httpd.conf and add a single line at the end of the file:
			</div><pre class="programlisting">
# Include mod_jk's specific configuration file  
Include conf/mod-jk.conf
</pre><div class="para">
				Next, create a new file named <code class="literal">APACHE_HOME/conf/mod-jk.conf</code>:
			</div><pre class="programlisting">
# Load mod_jk module
# Specify the filename of the mod_jk lib
LoadModule jk_module modules/mod_jk.so
 
# Where to find workers.properties
JkWorkersFile conf/workers.properties

# Where to put jk logs
JkLogFile logs/mod_jk.log
 
# Set the jk log level [debug/error/info]
JkLogLevel info 
 
# Select the log format
JkLogStampFormat  "[%a %b %d %H:%M:%S %Y]"
 
# JkOptions indicates to send SSK KEY SIZE
JkOptions +ForwardKeySize +ForwardURICompat -ForwardDirectories
 
# JkRequestLogFormat
JkRequestLogFormat "%w %V %T"
               
# Mount your applications
JkMount /application/* loadbalancer
 
# You can use external file for mount points.
# It will be checked for updates each 60 seconds.
# The format of the file is: /url=worker
# /examples/*=loadbalancer
JkMountFile conf/uriworkermap.properties               

# Add shared memory.
# This directive is present with 1.2.10 and
# later versions of mod_jk, and is needed for
# for load balancing to work properly
JkShmFile logs/jk.shm 
              
# Add jkstatus for managing runtime data
&lt;Location /jkstatus/&gt;
    JkMount status
    Order deny,allow
    Deny from all
    Allow from 127.0.0.1
&lt;/Location&gt;
</pre><div class="para">
				Please note that two settings are very important:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The <code class="literal">LoadModule</code> directive must reference the mod_jk library you have downloaded in the previous section. You must indicate the exact same name with the "modules" file path prefix.
					</div></li><li class="listitem"><div class="para">
						The <code class="literal">JkMount</code> directive tells Apache which URLs it should forward to the mod_jk module (and, in turn, to the Servlet containers). In the above file, all requests with URL path <code class="literal">/application/*</code> are sent to the mod_jk load-balancer. This way, you can configure Apache to serve static contents (or PHP contents) directly and only use the loadbalancer for Java applications. If you only use mod_jk as a loadbalancer, you can also forward all URLs (i.e., <code class="literal">/*</code>) to mod_jk.
					</div></li></ul></div><div class="para">
				In addition to the <code class="literal">JkMount</code> directive, you can also use the <code class="literal">JkMountFile</code> directive to specify a mount points configuration file, which contains multiple Tomcat forwarding URL mappings. You just need to create a <code class="literal">uriworkermap.properties</code> file in the <code class="literal">APACHE_HOME/conf</code> directory. The format of the file is <code class="literal">/url=worker_name</code>. To get things started, paste the following example into the file you created:
			</div><pre class="programlisting">
# Simple worker configuration file

# Mount the Servlet context to the ajp13 worker
/jmx-console=loadbalancer
/jmx-console/*=loadbalancer
/web-console=loadbalancer
/web-console/*=loadbalancer
</pre><div class="para">
				This will configure mod_jk to forward requests to <code class="literal">/jmx-console</code> and <code class="literal">/web-console</code> to Tomcat.
			</div><div class="para">
				You will most probably not change the other settings in <code class="literal">mod_jk.conf</code>. They are used to tell mod_jk where to put its logging file, which logging level to use and so on.
			</div></div><div class="section" id="clustering-http-nodes"><div class="titlepage"><div><div><h3 class="title">22.1.3.Configure worker nodes in mod_jk</h3></div></div></div><div class="para">
				Next, you need to configure mod_jk workers file <code class="literal">conf/workers.properties</code>. This file specifies where the different Servlet containers are located and how calls should be load-balanced across them. The configuration file contains one section for each target servlet container and one global section. For a two nodes setup, the file could look like this:
			</div><pre class="programlisting">
# Define list of workers that will be used
# for mapping requests
worker.list=loadbalancer,status

# Define Node1
# modify the host as your host IP or DNS name.
worker.node1.port=8009
worker.node1.host=node1.mydomain.com
worker.node1.type=ajp13
worker.node1.ping_mode=A
worker.node1.lbfactor=1 

# Define Node2
# modify the host as your host IP or DNS name.
worker.node2.port=8009
worker.node2.host=node2.mydomain.com
worker.node2.type=ajp13
worker.node2.ping_mode=A
worker.node2.lbfactor=1

# Load-balancing behaviour
worker.loadbalancer.type=lb
worker.loadbalancer.balance_workers=node1,node2
worker.loadbalancer.sticky_session=1
#worker.list=loadbalancer

# Status worker for managing load balancer
worker.status.type=status
</pre><div class="para">
				Basically, the above file configures mod_jk to perform weighted round-robin load balancing with sticky sessions between two servlet containers (that is, JBoss Enterprise Application Platform instances) node1 and node2 listening on port 8009.
			</div><div class="para">
				In the <code class="literal">workers.properties</code> file, each node is defined using the <code class="literal">worker.XXX</code> naming convention where <code class="literal">XXX</code> represents an arbitrary name you choose for each of the target Servlet containers. For each worker, you must specify the host name (or IP address) and the port number of the AJP13 connector running in the Servlet container.
			</div><div class="para">
				The <code class="literal">lbfactor</code> attribute is the load-balancing factor for this specific worker. It is used to define the priority (or weight) a node should have over other nodes. The higher this number is for a given worker relative to the other workers, the more HTTP requests the worker will receive. This setting can be used to differentiate servers with different processing power.
			</div><div class="para">
				The <code class="literal">ping_mode</code> attribute enables CPing/CPong. It determines when established connections are probed to determine whether they are still working. In this case, <code class="literal">ping_mode</code> is set to <code class="literal">A</code>, which means that the connection is probed once after connecting to the backend, before sending each request to the backend, and at regular intervals during the internal maintenance cycle.
			</div><div class="para">
				The last part of the <code class="literal">conf/workers.properties</code> file defines the loadbalancer worker. The only thing you must change is the <code class="literal">worker.loadbalancer.balanced_workers</code> line: it must list all workers previously defined in the same file. Load-balancing will happen over these workers.
			</div><div class="para">
				The <code class="literal">sticky_session</code> property specifies the cluster behavior for HTTP sessions. If you specify <code class="literal">worker.loadbalancer.sticky_session=0</code>, each request will be load balanced between node1 and node2; i.e., different requests for the same session will go to different servers. But when a user opens a session on one server, it is always necessary to always forward this user's requests to the same server, as long as that server is available. This is called a "sticky session", as the client is always using the same server he reached on his first request. To enable session stickiness, you need to set <code class="literal">worker.loadbalancer.sticky_session</code> to 1.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					A non-loadbalanced setup with a single node requires a <code class="literal">worker.list=node1</code> entry.
				</div></div></div></div><div class="section" id="clustering-http-jboss"><div class="titlepage"><div><div><h3 class="title">22.1.4.Configuring JBoss to work with mod_jk</h3></div></div></div><div class="para">
				Finally, we must configure the JBoss Enterprise Application Platform instances on all clustered nodes so that they can expect requests forwarded from the mod_jk loadbalancer.
			</div><div class="para">
				On each clustered JBoss node, we have to name the node according to the name specified in <code class="literal">workers.properties</code>. For instance, on JBoss instance node1, edit the <code class="literal">JBOSS_HOME/server/all/deploy/jbossweb.sar/server.xml</code> file (replace <code class="literal">/all</code> with your own server name if necessary). Locate the <code class="literal">&lt;Engine&gt;</code> element and add an attribute <code class="literal">jvmRoute</code>:
			</div><pre class="programlisting">
&lt;Engine name="jboss.web" defaultHost="localhost" jvmRoute="node1"&gt;
...
&lt;/Engine&gt;
</pre><div class="para">
				You also need to be sure the AJP connector in server.xml is enabled (i.e., uncommented). It is enabled by default.
			</div><pre class="programlisting"> 
&lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt; 
&lt;Connector protocol="AJP/1.3" port="8009" address="${jboss.bind.address}"
   redirectPort="8443" /&gt;
</pre><div class="para">
				At this point, you have a fully working Apache with mod_jk load-balancer setup that will balance call to the Servlet containers of your cluster while taking care of session stickiness (clients will always use the same Servlet container).
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					For more updated information on using mod_jk 1.2 with JBoss AS, please refer to the JBoss wiki page at <code class="literal">http://www.jboss.org/community/wiki/UsingModjk12WithJBoss</code>.
				</div></div></div></div><div xml:lang="en-US" class="section" id="idm139946653946384" lang="en-US"><div class="titlepage"><div><div><h3 class="title">22.1.5.Configuring the NSAPI connector on Solaris</h3></div></div></div><div class="para">
		This section shows you how to configure the NSAPI connector to use a JBoss Enterprise Platform as a worker node for a Sun Java System Web Server (SJWS) master node.
	</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
			Sun Java System Web Server has recently been renamed to the Oracle iPlanet Web Server.
		</div></div></div><div class="para">
		In this section, all of the server instances are on the same machine. To use different machines for each instance, use the <code class="code">-b</code> switch to bind your instance of JBoss Enterprise Platform to a public IP address. Remember to edit the <code class="filename">workers.properties</code> file on the SJWS machine to reflect these changes in IP address.
	</div><div class="section" id="idm139946676619504"><div class="titlepage"><div><div><h4 class="title">22.1.5.1.Prerequisites</h4></div></div></div><div class="para">
			This section assumes that:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					Your worker node(s) are already installed with a JBoss Enterprise Platform 5.1 or later. The Native components are not a requirement of the NSAPI connector. Refer to the <em class="citetitle">Installation Guide</em> for assistance with this prerequisite.
				</div></li><li class="listitem"><div class="para">
					Your master node is already installed with any of the following technology combinations, and the appropriate Native binary for its operating system and architecture. Refer to the <em class="citetitle">Installation Guide</em> for assistance with this prerequisite.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Solaris 9 x86 with Sun Java System Web Server 6.1 SP12
						</div></li><li class="listitem"><div class="para">
							Solaris 9 SPARC 64 with Sun Java System Web Server 6.1 SP12
						</div></li><li class="listitem"><div class="para">
							Solaris 10 x86 with Sun Java System Web Server 7.0 U8
						</div></li><li class="listitem"><div class="para">
							Solaris 10 SPARC 64 with Sun Java System Web Server 7.0 U8
						</div></li></ul></div></li></ul></div></div><div class="section" id="idm139946655459696"><div class="titlepage"><div><div><h4 class="title">22.1.5.2.Configure JBoss Enterprise Platform as a Worker Node</h4></div></div></div><div class="para">
			This section shows you how to safely configure your JBoss Enterprise Platform instance as a worker node for use with Sun SJWS.
		</div><div class="procedure"><p class="title"><strong>Procedure22.1.Configure a JBoss Enterprise Platform instance as a worker node</strong></p><ol class="1"><li class="step"><p class="title"><strong>Create a server profile for each worker node</strong></p><div class="para">
					Make a copy of the server profile that you wish to configure as a worker node. (This procedure uses the <code class="literal">default</code> server profile.)
				</div><pre class="screen">[user@workstation jboss-eap-5.1]$ cd jboss-as/server
[user@workstation server]$ cp -r default/ default-01
[user@workstation server]$ cp -r default/ default-02</pre></li><li class="step"><p class="title"><strong>Give each instance a unique name</strong></p><div class="para">
					Edit the following line in the <code class="filename">deploy/jbossweb.sar/server.xml</code> file of each new worker instance:
				</div><pre class="screen language-xml XML XML">&lt;Engine name="jboss.web" defaultHost="localhost"&gt;</pre><div class="para">
					Add a unique <code class="varname">jvmRoute</code> value, as shown. This value is the identifier for this node in the cluster.
				</div><div class="para">
					For the <code class="literal">default-01</code> server profile:
				</div><pre class="screen language-xml XML XML">&lt;Engine name="jboss.web" defaultHost="localhost" jvmRoute="worker01"&gt;</pre><div class="para">
					For the <code class="literal">default-02</code> server profile:
				</div><pre class="screen language-xml XML XML">&lt;Engine name="jboss.web" defaultHost="localhost" jvmRoute="worker02"&gt;</pre></li><li class="step"><p class="title"><strong>Enable session handling</strong></p><div class="para">
					Edit the following line in the <code class="filename">deployers/jbossweb.deployer/META-INF/war-deployers-jboss-beans.xml</code> file of each worker node:
				</div><pre class="screen language-xml XML XML">&lt;property name="useJK"&gt;false&lt;/property&gt;</pre><div class="para">
					This property controls whether special session handling is used to coordinate with mod_jk and other connector variants. Set this property to <code class="literal">true</code> in both worker nodes:
				</div><pre class="screen language-xml XML XML">&lt;property name="useJK"&gt;true&lt;/property&gt;</pre></li><li class="step"><p class="title"><strong>Start your worker nodes</strong></p><div class="para">
					Start each worker node in a separate command line interface. Ensure that each node is bound to a different IP address with the <code class="code">-b</code> switch.
				</div><pre class="screen">[user@workstation jboss-eap-5.1]$ ./jboss-as/bin/run.sh -b 127.0.0.1 -c default-01</pre><pre class="screen">[user@workstation jboss-eap-5.1]$ ./jboss-as/bin/run.sh -b 127.0.0.100 -c default-02</pre></li></ol></div></div><div class="section" id="idm139946654348080"><div class="titlepage"><div><div><h4 class="title">22.1.5.3.Configure Sun Java System Web Server for Clustering</h4></div></div></div><div class="para">
			The procedures in the following sections assume that the contents of the Native zip appropriate for your operating system and architecture have been extracted to <code class="filename">/tmp/connectors/jboss-ep-native-5.1/</code>. This path is referred to as <em class="replaceable">NATIVE</em> in the procedures that follow. These procedures also assume that the <code class="filename">/tmp/connectors</code> directory is used to store logs, properties files and NSAPI locks.
		</div><div class="para">
			These procedures also assume that your installation of Sun Java System Web Server is in one of the following locations, depending on your version of Solaris:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					for Solaris 9 x86 or SPARC 64: <code class="filename">/opt/SUNWwbsrv61/</code>
				</div></li><li class="listitem"><div class="para">
					for Solaris 10 x86 or SPARC 64: <code class="filename">/opt/SUNWwbsrv70/</code>
				</div></li></ul></div><div class="para">
			This path is referred to as <em class="replaceable">SJWS</em> in the procedures that follow.
		</div><div class="procedure"><p class="title"><strong>Procedure22.2.Initial clustering configuration</strong></p><ol class="1"><li class="step"><p class="title"><strong>Disable servlet mappings</strong></p><div class="para">
					Under <span class="emphasis"><em>Built In Servlet Mappings</em></span> in the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/default-web.xml</code> file, disable the mappings for the following servlets, as shown in the code sample:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							default
						</div></li><li class="listitem"><div class="para">
							invoker
						</div></li><li class="listitem"><div class="para">
							jsp
						</div></li></ul></div><pre class="screen language-xml XML XML">&lt;!-- ==================== Built In Servlet Mappings ===================== --&gt;

&lt;!-- The servlet mappings for the built in servlets defined above. --&gt;

&lt;!-- The mapping for the default servlet --&gt;
&lt;!--servlet-mapping&gt;
 &lt;servlet-name&gt;default&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping--&gt;

&lt;!-- The mapping for the invoker servlet --&gt;
&lt;!--servlet-mapping&gt;
 &lt;servlet-name&gt;invoker&lt;/servlet-name&gt;
 &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
&lt;/servlet-mapping--&gt;

&lt;!-- The mapping for the JSP servlet --&gt;
&lt;!--servlet-mapping&gt;
 &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
 &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
&lt;/servlet-mapping--&gt;</pre></li><li class="step" id="init-load-mod"><p class="title"><strong>Load the required modules and properties</strong></p><div class="para">
					Append the following lines to the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/magnus.conf</code> file:
				</div><pre class="screen">Init fn="load-modules" funcs="jk_init,jk_service" shlib="<em class="replaceable">NATIVE</em>/lib/nsapi_redirector.so" shlib_flags="(global|now)"
Init fn="jk_init" worker_file="/tmp/connectors/workers.properties" log_level="debug" log_file="/tmp/connectors/nsapi.log" shm_file="/tmp/connectors/jk_shm"</pre><div class="para">
					These lines define the location of the <code class="filename">nsapi_redirector.so</code> module used by the <code class="literal">jk_init</code> and <code class="literal">jk_service</code> functions, and the location of the <code class="filename">workers.properties</code> file, which defines the worker nodes and their attributes.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The <code class="filename">lib</code> directory in the <code class="filename"><em class="replaceable">NATIVE</em>/lib/nsapi_redirector.so</code> path applies only to 32-bit machines. On 64-bit machines, this directory is called <code class="filename">lib64</code>.
					</div></div></div></li></ol></div><div class="section" id="idm139946653464944"><div class="titlepage"><div><div><h5 class="title">22.1.5.3.1.Configure a basic cluster with NSAPI</h5></div></div></div><div class="para">
				Use the following procedure to configure a basic cluster, where requests for particular paths are forwarded to particular worker nodes. In <a class="xref" href="#proc-basic-cluster">Procedure22.3, Configure a basic cluster with NSAPI</a>, worker02 serves the <code class="literal">/nc</code> path, while worker01 serves <code class="literal">/status</code> and all other paths defined in the first part of the <code class="filename">obj.conf</code> file.
			</div><div class="procedure"><p class="title"><strong>Procedure22.3.Configure a basic cluster with NSAPI</strong></p><ol class="1"><li class="step"><p class="title"><strong>Define the paths to serve via NSAPI</strong></p><div class="para">
						Edit the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/obj.conf</code> file. Define paths that should be served via NSAPI at the end of the <code class="literal">default</code> Object definition, as shown:
					</div><pre class="screen language-xml XML XML">&lt;Object name="default"&gt;
      [...]
   NameTrans fn="assign-name" from="/status" name="jknsapi"
   NameTrans fn="assign-name" from="/images(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/css(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/nc(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/jmx-console(|/*)" name="jknsapi"
&lt;/Object&gt;</pre><div class="para">
						You can map the path of any application deployed on your JBoss Enterprise Platform instance in this <code class="filename">obj.conf</code> file. In the example code, the <code class="literal">/nc</code> path is mapped to an application deployed under the name <code class="literal">nc</code>.
					</div></li><li class="step"><p class="title"><strong>Define the worker that serves each path</strong></p><div class="para">
						Edit the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/obj.conf</code> file and add the following <code class="literal">jknsapi</code> Object definition after the <code class="literal">default</code> Object definition.
					</div><pre class="screen language-xml XML XML">&lt;Object name="jknsapi"&gt;
   ObjectType fn=force-type type=text/plain
   Service fn="jk_service" worker="worker01" path="/status"
   Service fn="jk_service" worker="worker02" path="/nc(/*)"
   Service fn="jk_service" worker="worker01"
&lt;/Object&gt;</pre><div class="para">
						This <code class="literal">jknsapi</code> Object defines the worker nodes used to serve each path that was assigned to <code class="code">name="jknsapi"</code> in the <code class="literal">default</code> Object.
					</div><div class="para">
						In the example code, the third Service definition does not specify a <code class="varname">path</code> value, so the worker node defined (<code class="literal">worker01</code>) serves all of the paths assigned to <code class="literal">jknsapi</code> by default. In this case, the first Service definition in the example code, which assigns the <code class="literal">/status</code> path to <code class="literal">worker01</code>, is superfluous.
					</div></li><li class="step"><p class="title"><strong>Define the workers and their attributes</strong></p><div class="para">
						Create a <code class="filename">workers.properties</code> file in the location you defined in <a class="xref" href="#init-load-mod">Step 2</a>. Define the list of worker nodes and each worker node's properties in this file, like so:
					</div><pre class="screen"># An entry that lists all the workers defined
worker.list=worker01, worker02

# Entries that define the host and port associated with these workers
worker.worker01.host=127.0.0.1
worker.worker01.port=8009
worker.worker01.type=ajp13

worker.worker02.host=127.0.0.100
worker.worker02.port=8009
worker.worker02.type=ajp13</pre></li></ol></div></div><div class="section" id="idm139946654309392"><div class="titlepage"><div><div><h5 class="title">22.1.5.3.2.Configure a Load-balanced Cluster with NSAPI</h5></div></div></div><div class="procedure"><p class="title"><strong>Procedure22.4.Configure a load-balancing cluster with NSAPI</strong></p><ol class="1"><li class="step"><p class="title"><strong>Define the paths to serve via NSAPI</strong></p><div class="para">
						Edit the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/obj.conf</code> file. Define paths that should be served via NSAPI at the end of the <code class="literal">default</code> Object definition, as shown:
					</div><pre class="screen language-xml XML XML">&lt;Object name="default"&gt;
      [...]
   NameTrans fn="assign-name" from="/status" name="jknsapi"
   NameTrans fn="assign-name" from="/images(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/css(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/nc(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/jmx-console(|/*)" name="jknsapi"
   NameTrans fn="assign-name" from="/jkmanager/*" name="jknsapi"
&lt;/Object&gt;</pre><div class="para">
						You can map the path of any application deployed on your JBoss Enterprise Platform instance in this <code class="filename">obj.conf</code> file. In the example code, the <code class="literal">/nc</code> path is mapped to an application deployed under the name <code class="literal">nc</code>.
					</div></li><li class="step"><p class="title"><strong>Define the worker that serves each path</strong></p><div class="para">
						Edit the <code class="filename"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/config/obj.conf</code> file and add the following <code class="literal">jknsapi</code> Object definition after the <code class="literal">default</code> Object definition.
					</div><pre class="screen language-xml XML XML">&lt;Object name="jknsapi"&gt;
   ObjectType fn=force-type type=text/plain
   Service fn="jk_service" worker="status" path="/jkmanager(/*)"
   Service fn="jk_service" worker="router"
&lt;/Object&gt;</pre><div class="para">
						This <code class="literal">jknsapi</code> Object defines the worker nodes used to serve each path that was assigned to <code class="code">name="jknsapi"</code> in the <code class="literal">default</code> Object.
					</div></li><li class="step"><p class="title"><strong>Define the workers and their attributes</strong></p><div class="para">
						Create a <code class="filename">workers.properties</code> file in the location you defined in <a class="xref" href="#init-load-mod">Step 2</a>. Define the list of worker nodes and each worker node's properties in this file, like so:
					</div><pre class="screen"># The advanced router LB worker
worker.list=router,status

# Define a worker using ajp13
worker.worker01.port=8009
worker.worker01.host=127.0.0.1
worker.worker01.type=ajp13
worker.worker01.ping_mode=A
worker.worker01.socket_timeout=10
worker.worker01.lbfactor=3

# Define another worker using ajp13
worker.worker02.port=8009
worker.worker02.host=127.0.0.100
worker.worker02.type=ajp13
worker.worker02.ping_mode=A
worker.worker02.socket_timeout=10
worker.worker02.lbfactor=1

# Define the LB worker
worker.router.type=lb
worker.router.balance_workers=worker01,worker02

# Define the status worker
worker.status.type=status</pre></li></ol></div></div><div class="section" id="idm139946661874336"><div class="titlepage"><div><div><h5 class="title">22.1.5.3.3.Restart Sun Java System Web Server</h5></div></div></div><div class="para">
				Once your Sun Java System Web Server instance is configured, restart it so that your changes take effect.
			</div><div class="para">
				For Sun Java System Web Server 6.1:
			</div><pre class="screen"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/stop
<em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/start</pre><div class="para">
				For Sun Java System Web Server 7.0:
			</div><pre class="screen"><em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/bin/stopserv
<em class="replaceable">SJWS</em>/<em class="replaceable">PROFILE</em>/bin/startserv</pre></div></div></div></div><div class="section" id="clustering-http-state"><div class="titlepage"><div><div><h2 class="title">22.2.Configuring HTTP session state replication</h2></div></div></div><div class="para">
			The preceding discussion has been focused on using mod_jk as a load balancer. The content of the remainder our discussion of clustering HTTP services in JBoss Enterprise Application Platform applies no matter what load balancer is used.
		</div><div class="para">
			In <a class="xref" href="#clustering-http-nodes">Section22.1.3, Configure worker nodes in mod_jk</a>, we covered how to use sticky sessions to make sure that a client in a session always hits the same server node in order to maintain the session state. However, sticky sessions by themselves are not an ideal solution. If a node goes down, all its session data is lost. A better and more reliable solution is to replicate session data across the nodes in the cluster. This way, if a server node fails or is shut down, the load balancer can fail over the next client request to any server node and obtain the same session state.
		</div><div class="section" id="clustering-http-app"><div class="titlepage"><div><div><h3 class="title">22.2.1.Enabling session replication in your application</h3></div></div></div><div class="para">
				To enable replication of your web application you must tag the application as distributable in the <code class="literal">web.xml</code> descriptor. Here's an example:
			</div><pre class="programlisting">&lt;?xml version="1.0"?&gt; 
&lt;web-app  xmlns="http://java.sun.com/xml/ns/j2ee"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
          xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee 
                              http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" 
          version="2.4"&gt;
          
    &lt;distributable/&gt;
    
&lt;/web-app&gt;</pre><div class="para">
				You can futher configure session replication using the <code class="literal">replication-config</code> element in the <code class="literal">jboss-web.xml</code> file. However, the <code class="literal">replication-config</code> element only needs to be set if one or more of the default values described below is unacceptable. Here is an example:
			</div><pre class="programlisting">&lt;!DOCTYPE jboss-web PUBLIC
    -//JBoss//DTD Web Application 5.0//EN
    http://www.jboss.org/j2ee/dtd/jboss-web_5_0.dtd&gt;

&lt;jboss-web&gt;
   
   &lt;replication-config&gt;
      &lt;cache-name&gt;custom-session-cache&lt;/cache-name&gt;
      &lt;replication-trigger&gt;SET&lt;/replication-trigger&gt;
      &lt;replication-granularity&gt;ATTRIBUTE&lt;/replication-granularity&gt;
      &lt;replication-field-batch-mode&gt;true&lt;/replication-field-batch-mode&gt;
      &lt;use-jk&gt;false&lt;/use-jk&gt;
      &lt;max-unreplicated-interval&gt;30&lt;/max-unreplicated-interval&gt;
      &lt;snapshot-mode&gt;INSTANT&lt;/snapshot-mode&gt;
      &lt;snapshot-interval&gt;1000&lt;/snapshot-interval&gt;
      &lt;session-notification-policy&gt;com.example.CustomSessionNotificationPolicy&lt;/session-notification-policy&gt;
   &lt;/replication-config&gt;

&lt;/jboss-web&gt;</pre><div class="para">
				All of the above configuration elements are optional and can be ommitted if the default value is acceptable. A couple are commonly used; the rest are very infrequently changed from the defaults. We'll cover the commonly used ones first.
			</div><div class="para">
				The <span class="bold bold"><strong> <code class="literal">replication-trigger</code> </strong></span> element determines when the container should consider that session data must be replicated across the cluster. The rationale for this setting is that after a mutable object stored as a session attribute is accessed from the session, in the absence of a <code class="literal">setAttribute</code> call the container has no clear way to know if the object (and hence the session state) has been modified and needs to be replicated. This element has 3 valid values:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>SET_AND_GET</strong></span> is conservative but not optimal (performance-wise): it will always replicate session data even if its content has not been modified but simply accessed. This setting made (a little) sense in JBoss Enterprise Application Platform 4 since using it was a way to ensure that every request triggered replication of the session's timestamp. Since setting <code class="literal">max_unreplicated_interval</code> to 0 accomplishes the same thing at much lower cost, using <code class="literal">SET_AND_GET</code> makes no sense with Enterprise Application Platform 5.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>SET_AND_NON_PRIMITIVE_GET</strong></span> is conservative but will only replicate if an object of a non-primitive type has been accessed (i.e. the object is not of a well-known immutable JDK type such as <code class="literal">Integer</code>, <code class="literal">Long</code>, <code class="literal">String</code>, etc.) This is the default value.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>SET</strong></span> assumes that the developer will explicitly call <code class="literal">setAttribute</code> on the session if the data needs to be replicated. This setting prevents unnecessary replication and can have a major beneficial impact on performance, but requires very good coding practices to ensure <code class="literal">setAttribute</code> is always called whenever a mutable object stored in the session is modified.
					</div></li></ul></div><div class="para">
				In all cases, calling <code class="literal">setAttribute</code> marks the session as needing replication.
			</div><div class="para">
				The <span class="bold bold"><strong> <code class="literal">replication-granularity</code> </strong></span> element determines the granularity of what gets replicated if the container determines session replication is needed. The supported values are:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>SESSION</strong></span> indicates that the entire session attribute map should be replicated when any attribute is considered modified. Replication occurs at request end. This option replicates the most data and thus incurs the highest replication cost, but since all attributes values are always replicated together it ensures that any references between attribute values will not be broken when the session is deserialized. For this reason it is the default setting.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>ATTRIBUTE</strong></span> indicates that only attributes that the session considers to be potentially modified are replicated. Replication occurs at request end. For sessions carrying large amounts of data, parts of which are infrequently updated, this option can significantly increase replication performance. However, it is not suitable for applications that store objects in different attributes that share references with each other (e.g. a <code class="literal">Person</code> object in the "husband" attribute sharing with another <code class="literal">Person</code> in the "wife" attribute a reference to an <code class="literal">Address</code> object). This is because if the attributes are separately replicated, when the session is deserialized on remote nodes the shared references will be broken.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>FIELD</strong></span> is useful if the classes stored in the session have been bytecode enhanced for use by POJO Cache. If they have been, the session management layer will detect field level changes within objects stored to the session, and will replicate only those changes. This is the most performant setting. Replication is only for individual changed data fields inside session attribute objects. Shared object references will be preserved across the cluster. Potentially most performant, but requires changes to your application (this will be discussed later).
					</div></li></ul></div><div class="para">
				The other elements under the <code class="literal">replication-config</code> element are much less frequently used.
			</div><div class="para">
				The <code class="literal">cacheName</code> element indicates the name of the JBoss Cache configuration that should be used for storing distributable sessions and replicating them around the cluster. This element lets web applications that require different caching characteristics specify the use of separate, differently configured, JBoss Cache instances. In JBoss Enterprise Application Platform 4 the cache to use was a server-wide configuration that could not be changed per web application. The default value is <code class="literal">standard-session-cache</code> if the <code class="literal">replication-granularity</code> is not <code class="literal">FIELD</code>, <code class="literal">field-granularity-session-cache</code> if it is. See <a class="xref" href="#clustering-http-state-cacheconfig">Section22.2.3, Configuring the JBoss Cache instance used for session state replication</a> for more details on JBoss Cache configuration for web tier clustering.
			</div><div class="para">
				The <code class="literal">replication-field-batch-mode</code> element indicates whether all replication messages associated with a request will be batched into one message. This is applicable only if <code class="literal">replication-granularity</code> is <code class="literal">FIELD</code>. If <code class="literal">replication-field-batch-mode</code> is set to <code class="literal">true</code>, fine-grained changes made to objects stored in the session attribute map will replicate only when the HTTP request is finished; otherwise they replicate as they occur. Setting this to <code class="literal">false</code> is not advised. Default is <code class="literal">true</code>.
			</div><div class="para">
				The <code class="literal">useJK</code> element indicates whether the container should assume that a JK-based software load balancer (e.g. mod_jk, mod_proxy, mod_cluster) is being used for load balancing for this web application. If set to <code class="literal">true</code>, the container will examine the session ID associated with every request and replace the <code class="literal">jvmRoute</code> portion of the session ID if it detects a failover.
			</div><div class="para">
				The default value is <code class="literal">null</code> (i.e. unspecified). In this case the session manager will use the presence or absence of a <code class="literal">jvmRoute</code> configuration on its enclosing JBoss Web <code class="literal">Engine</code> (see <a class="xref" href="#clustering-http-jboss">Section22.1.4, Configuring JBoss to work with mod_jk</a>) to determine whether JK is used.
			</div><div class="para">
				You need only set this to <code class="literal">false</code> for web applications whose URL cannot be handled by the JK load balancer.
			</div><div class="para">
				The <code class="literal">max-unreplicated-interval</code> element configures the maximum interval between requests, in seconds, after which a request will trigger replication of the session's timestamp regardless of whether the request has otherwise made the session dirty. Such replication ensures that other nodes in the cluster are aware of the most recent value for the session's timestamp and won't incorrectly expire an unreplicated session upon failover. It also results in correct values for <code class="literal">HttpSession.getLastAccessedTime()</code> calls following failover.
			</div><div class="para">
				A value of <code class="literal">0</code> means the timestamp will be replicated whenever the session is accessed. A value of <code class="literal">-1</code> means the timestamp will be replicated only if some other activity during the request (e.g. modifying an attribute) has resulted in other replication work involving the session. A positive value greater than the <code class="literal">HttpSession.getMaxInactiveInterval()</code> value will be treated as probable misconfiguration and converted to <code class="literal">0</code>; i.e. replicate the metadata on every request. Default value is <code class="literal">60</code>.
			</div><div class="para">
				The <code class="literal">snapshot-mode</code> element configures when sessions are replicated to the other nodes. Possible values are <code class="literal">INSTANT</code> (the default) and <code class="literal">INTERVAL</code>.
			</div><div class="para">
				The typical value, <code class="literal">INSTANT</code>, replicates changes to the other nodes at the end of requests, using the request processing thread to perform the replication. In this case, the <code class="literal">snapshot-interval</code> property is ignored.
			</div><div class="para">
				With <code class="literal">INTERVAL</code> mode, a background task is created that runs every <code class="literal">snapshot-interval</code> milliseconds, checking for modified sessions and replicating them.
			</div><div class="para">
				Note that this property has no effect if <code class="literal">replication-granularity</code> is set to <code class="literal">FIELD</code>. If it is <code class="literal">FIELD</code>, <code class="literal">instant</code> mode will be used.
			</div><div class="para">
				The <code class="literal">snapshot-interval</code> element defines how often (in milliseconds) the background task that replicates modified sessions should be started for this web application. Only meaningful if <code class="literal">snapshot-mode</code> is set to <code class="literal">interval</code>.
			</div><div class="para">
				The <code class="literal">session-notification-policy</code> element specifies the fully qualified class name of the implementation of the <code class="literal">ClusteredSessionNotificationPolicy</code> interface that should be used to govern whether servlet specification notifications should be emitted to any registered <code class="literal">HttpSessionListener</code>, <code class="literal">HttpSessionAttributeListener</code> and/or <code class="literal">HttpSessionBindingListener</code>.
			</div><div class="para">
				Event notifications that may make sense in a non-clustered environment may or may not make sense in a clustered environment; see <a href="https://jira.jboss.org/jira/browse/JBAS-5778" class="mimir-link-warn" title="Mimir does not include content from: jira.jboss.org">https://jira.jboss.org/jira/browse/JBAS-5778</a> for an example of why a notification may not be desired. Configuring an appropriate <code class="literal">ClusteredSessionNotificationPolicy</code> gives the application author fine-grained control over what notifications are issued.
			</div><div class="para">
				In previous releases, the default value if not explicitly set is the <code class="literal">LegacyClusteredSessionNotificationPolicy</code>, which implements the behavior in previous JBoss versions. In JBoss Enterprise Application Platform 5, this was changed to <code class="literal">IgnoreUndeployLegacyClusteredSessionNotificationPolicy</code>, which implements the same behavior except during undeployment, during which no <code class="literal">HttpSessionListener</code> and <code class="literal">HttpSessionAttributeListener</code> notifications are sent.
			</div></div><div class="section" id="clustering-http-passivation"><div class="titlepage"><div><div><h3 class="title">22.2.2.HttpSession Passivation and Activation</h3></div></div></div><div class="para">
				Passivation is the process of controlling memory usage by removing relatively unused sessions from memory while storing them in persistent storage. If a passivated session is requested by a client, it can be "activated" back into memory and removed from the persistent store. JBoss Enterprise Application Platform 5 supports passivation of HttpSessions from web applications whose <code class="literal">web.xml</code> includes the <code class="literal">distributable</code> tag (i.e. clustered web applications).
			</div><div class="para">
				Passivation occurs at three points during the lifecycle of a web application:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						When the container requests the creation of a new session. If the number of currently active sessions exceeds a configurable limit, an attempt is made to passivate sessions to make room in memory.
					</div></li><li class="listitem"><div class="para">
						Periodically (by default every ten seconds) as the JBoss Web background task thread runs.
					</div></li><li class="listitem"><div class="para">
						When the web application is deployed and a backup copy of sessions active on other servers is acquired by the newly deploying web application's session manager.
					</div></li></ul></div><div class="para">
				A session will be passivated if one of the following holds true:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The session has not been in use for longer than a configurable maximum idle time.
					</div></li><li class="listitem"><div class="para">
						The number of active sessions exceeds a configurable maximum and the session has not been in use for longer than a configurable minimum idle time.
					</div></li></ul></div><div class="para">
				In both cases, sessions are passivated on a Least Recently Used (LRU) basis.
			</div><div class="section" id="clustering-http-passivation-config"><div class="titlepage"><div><div><h4 class="title">22.2.2.1.Configuring HttpSession Passivation</h4></div></div></div><div class="para">
					Session passivation behavior is configured via the <code class="literal">jboss-web.xml</code> deployment descriptor in your web application's <code class="literal">WEB-INF</code> directory.
				</div><pre class="programlisting">
&lt;!DOCTYPE jboss-web PUBLIC
    -//JBoss//DTD Web Application 5.0//EN
    http://www.jboss.org/j2ee/dtd/jboss-web_5_0.dtd&gt;

&lt;jboss-web&gt;
   
   &lt;max-active-sessions&gt;20&lt;/max-active-sessions&gt;
   &lt;passivation-config&gt;
      &lt;use-session-passivation&gt;true&lt;/use-session-passivation&gt;
      &lt;passivation-min-idle-time&gt;60&lt;/passivation-min-idle-time&gt;
      &lt;passivation-max-idle-time&gt;600&lt;/passivation-max-idle-time&gt;
   &lt;/passivation-config&gt;


&lt;/jboss-web&gt;</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max-active-session</strong></span>
						</div><div class="para">
							Determines the maximum number of active sessions allowed. If the number of sessions managed by the the session manager exceeds this value and passivation is enabled, the excess will be passivated based on the configured <code class="literal">passivation-min-idle-time</code>. If after passivation is completed (or if passivation is disabled), the number of active sessions still exceeds this limit, attempts to create new sessions will be rejected. If set to <code class="literal">-1</code> (the default), there is no limit.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>use-session-passivation</strong></span>
						</div><div class="para">
							Determines whether session passivation will be enabled for the web application. Default is <code class="literal">false</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>passivation-min-idle-time</strong></span>
						</div><div class="para">
							Determines the minimum time (in seconds) that a session must have been inactive before the container will consider passivating it in order to reduce the active session count to obey the value defined by <code class="literal">max-active-sessions</code>. A value of <code class="literal">-1</code> (the default) disables passivating sessions before <code class="literal">passivation-max-idle-time</code>. Neither a value of <code class="literal">-1</code> nor a high value are recommended if <code class="literal">max-active-sessions</code> is set.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>passivation-max-idle-time</strong></span>
						</div><div class="para">
							Determines the maximum time (in seconds) that a session can be inactive before the container should attempt to passivate it to save memory. Passivation of such sessions will take place regardless of whether the active session count exceeds <code class="literal">max-active-sessions</code>. Should be less than the <code class="filename">web.xml</code> <code class="literal">session-timeout</code> setting. A value of <code class="literal">-1</code> (the default) disables passivation based on maximum inactivity.
						</div></li></ul></div><div class="para">
					The total number of sessions in memory includes sessions replicated from other cluster nodes that are not being accessed on this node. Take this into account when setting <code class="literal">max-active-sessions</code>. The number of sessions replicated from other nodes will also depend on whether <span class="emphasis"><em>buddy replication</em></span> is enabled.
				</div><div class="para">
					Say, for example, that you have an eight node cluster, and each node handles requests from 100 users. With <span class="emphasis"><em>total replication</em></span>, each node would store 800 sessions in memory. With <span class="emphasis"><em>buddy replication</em></span> enabled, and the default <code class="literal">numBuddies</code> setting (<code class="literal">1</code>), each node will store 200 sessions in memory.
				</div></div></div><div class="section" id="clustering-http-state-cacheconfig"><div class="titlepage"><div><div><h3 class="title">22.2.3.Configuring the JBoss Cache instance used for session state replication</h3></div></div></div><div class="para">
				The container for a distributable web application makes use of JBoss Cache to provide HTTP session replication services around the cluster. The container integrates with the CacheManager service to obtain a reference to a JBoss Cache instance (see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>).
			</div><div class="para">
				The name of the JBoss Cache configuration to use is controlled by the <code class="literal">cacheName</code> element in the application's <code class="literal">jboss-web.xml</code> (see <a class="xref" href="#clustering-http-app">Section22.2.1, Enabling session replication in your application</a>). In most cases, though, this does not need to be set as the default values of <code class="literal">standard-session-cache</code> and <code class="literal">field-granularity-session-cache</code> (for applications configured for FIELD granularity) are appropriate.
			</div><div class="para">
				The JBoss Cache configurations in the <code class="classname">CacheManager</code> service expose a number of options. See <a class="xref" href="#jbosscache.chapt">Chapter26, <em>JBoss Cache Configuration and Deployment</em></a> and the JBoss Cache documentation for a more complete discussion. The <code class="literal">standard-session-cache</code> and <code class="literal">field-granularity-session-cache</code> configurations are already optimized for the web session replication use case, and most of the settings should not be altered. Administrators may be interested in altering the following settings:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>cacheMode</strong></span>
					</div><div class="para">
						The default is <code class="literal">REPL_ASYNC</code>, which specifies that a session replication message sent to the cluster does not wait for responses from other cluster nodes confirming that the message has been received and processed. The alternative mode, <code class="literal">REPL_SYNC</code>, offers a greater degree of confirmation that session state has been received, but reduces performance significantly. See <a class="xref" href="#jbosscache-configuration-cachemode">Section26.1.2, Cache Mode</a> for further details.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>enabled</strong></span> property in the <span class="bold bold"><strong>buddyReplicationConfig</strong></span> section
					</div><div class="para">
						Set to <code class="literal">true</code> to enable buddy replication. See <a class="xref" href="#jbosscache-configuration-buddyrepl">Section26.1.8, Buddy Replication</a>. Default is <code class="literal">false</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>numBuddies</strong></span> property in the <span class="bold bold"><strong>buddyReplicationConfig</strong></span> section
					</div><div class="para">
						Set to a value greater than the default (<code class="literal">1</code>) to increase the number of backup nodes onto which sessions are replicated. Only relevant if buddy replication is enabled. See <a class="xref" href="#jbosscache-configuration-buddyrepl">Section26.1.8, Buddy Replication</a>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>buddyPoolName</strong></span> property in the <span class="bold bold"><strong>buddyReplicationConfig</strong></span> section
					</div><div class="para">
						A way to specify a preferred replication group when buddy replication is enabled. JBoss Cache tries to pick a buddy who shares the same pool name (falling back to other buddies if not available). Only relevant if buddy replication is enabled. See <a class="xref" href="#jbosscache-configuration-buddyrepl">Section26.1.8, Buddy Replication</a>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>multiplexerStack</strong></span>
					</div><div class="para">
						Name of the JGroups protocol stack the cache should use. See <a class="xref" href="#clustering-blocks-jgroups-channelfactory">Section18.1.1, The Channel Factory Service</a>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>clusterName</strong></span>
					</div><div class="para">
						Identifying name JGroups will use for this cache's channel. Only change this if you create a new cache configuration, in which case this property should have a different value from all other cache configurations.
					</div></li></ul></div><div class="para">
				If you wish to use a completely new JBoss Cache configuration rather than editing one of the existing ones, please see <a class="xref" href="#jbosscache-custom-deployment-cachemgr">Section26.2.1, Deployment Via the CacheManager Service</a>.
			</div></div></div><div class="section" id="clustering-http-field"><div class="titlepage"><div><div><h2 class="title">22.3.Using FIELD-level replication</h2></div></div></div><div class="warning"><div class="admonition_header"><p><strong>Warning</strong></p></div><div class="admonition"><div class="para">
				This feature is deprecated as of JBoss Enterprise Web Platform 5.1, and will be removed in a future release of JBoss Enterprise Web Platform. Customers are recommended to migrate away from this feature in existing implementations, and not use it in new implementations.
			</div></div></div><div class="para">
			FIELD-level replication only replicates modified data fields inside objects stored in the session. It can reduce the data traffic between clustered nodes, and hence improve the performance of the whole cluster. To use FIELD-level replication, you must first prepare (that is, bytecode enhance) your Java class to allow the session cache to detect when fields in cached objects have been changed and need to be replicated.
		</div><div class="para">
			First, you need to identify the classes that you need to prepare. You can identify these classes by using annotations, like so:
		</div><pre class="programlisting">@org.jboss.cache.pojo.annotation.Replicable
public class Address 
{
...
}</pre><div class="para">
			If you annotate a class with <code class="literal">@Replicable</code>, then all of its subclasses will be automatically annotated as well. Similarly, you can annotate an interface with <code class="literal">@Replicable</code> and all of its implementing classes will be annotated. For example:
		</div><pre class="programlisting">
@org.jboss.cache.aop.InstanceOfAopMarker
public class Person 
{
...
}

public class Student extends Person
{
...
}
</pre><div class="para">
			There is no need to annotate <code class="literal">Student</code>. POJO Cache will recognize it as @Replicable because it is a sub-class of <code class="literal">Person</code>.
		</div><div class="para">
			JBoss Enterprise Application Platform 5 requires JDK 5 at runtime, but some users may still need to build their projects using JDK 1.4. In this case, annotating classes can be done via JDK 1.4 style annotations embedded in JavaDocs. For example:
		</div><pre class="programlisting">/**
 * Represents a street address.
 * @org.jboss.cache.pojo.annotation.Replicable
 */
public class Address 
{
...
}
</pre><div class="para">
			Once you have annotated your classes, you will need to perform a pre-processing step to bytecode enhance your classes for use by POJO Cache. You need to use the JBoss AOP pre-compiler <code class="literal">annotationc</code> and post-compiler <code class="literal">aopc</code> to process the above source code before and after they are compiled by the Java compiler. The <code class="literal">annotationc</code> step is only need if the JDK 1.4 style annotations are used; if JDK 5 annotations are used it is not necessary. Here is an example of how to invoke those commands from command line.
		</div><pre class="programlisting">
$ annotationc [classpath] [source files or directories]
$ javac -cp [classpath] [source files or directories]
$ aopc [classpath] [class files or directories]
</pre><div class="para">
			Please see the JBoss AOP documentation for the usage of the pre- and post-compiler. The JBoss AOP project also provides easy to use ANT tasks to help integrate those steps into your application build process.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				You can see a complete example of how to build, deploy, and validate a FIELD-level replicated web application from this page: <a href="http://www.jboss.org/community/wiki/httpsessionfieldlevelexample" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">http://www.jboss.org/community/wiki/httpsessionfieldlevelexample</a>. The example bundles the pre- and post-compile tools so you do not need to download JBoss AOP separately.
			</div></div></div><div class="para">
			Finally, let's see an example on how to use FIELD-level replication on those data classes. First, we see some servlet code that reads some data from the request parameters, creates a couple of objects and stores them in the session:
		</div><pre class="programlisting">
Person husband = new Person(getHusbandName(request), getHusbandAge(request)); Person wife = new
Person(getWifeName(request), getWifeAge(request)); Address addr = new Address();
addr.setPostalCode(getPostalCode(request));

husband.setAddress(addr);
wife.setAddress(addr); // husband and wife share the same address!

session.setAttribute("husband", husband); // that's it.
session.setAttribute("wife", wife); // that's it.
</pre><div class="para">
			Later, a different servlet could update the family's postal code:
		</div><pre class="programlisting">
Person wife = (Person)session.getAttribute("wife"); wife.getAddress().setPostalCode(getPostalCode(request));
// this will update and replicate the postal code
</pre><div class="para">
			Notice that in there is no need to call <code class="literal">session.setAttribute()</code> after you make changes to the data object, and all changes to the fields are automatically replicated across the cluster.
		</div><div class="para">
			Besides plain objects, you can also use regular Java collections of those objects as session attributes. POJO Cache automatically figures out how to handle those collections and replicate field changes in their member objects.
		</div></div><div class="section" id="clustering-http-sso"><div class="titlepage"><div><div><h2 class="title">22.4.Using Clustered Single Sign-on (SSO)</h2></div></div></div><div class="para">
			JBoss supports clustered single sign-on, allowing a user to authenticate to one web application and to be recognized on all web applications that are deployed on the same virtual host, whether or not they are deployed on that same machine or on another node in the cluster. Authentication replication is handled by JBoss Cache. Clustered single sign-on support is a JBoss-specific extension of the non-clustered <code class="literal">org.apache.catalina.authenticator.SingleSignOn</code> valve that is a standard part of Tomcat and JBoss Web. Both the non-clustered and clustered versions allow users to sign on to any one of the web apps associated with a virtual host and have their identity recognized by all other web apps on the same virtual host. The clustered version brings the added benefits of enabling SSO failover and allowing a load balancer to direct requests for different webapps to different servers, while maintaining the SSO.
		</div><div class="section" id="clustering-sso-configuration"><div class="titlepage"><div><div><h3 class="title">22.4.1.Configuration</h3></div></div></div><div class="para">
				To enable clustered single sign-on, you must add the <code class="literal">ClusteredSingleSignOn</code> valve to the appropriate <code class="literal">Host</code> elements of the <code class="literal">JBOSS_HOME/server/all/deploy/jbossweb.sar/server.xml</code> file. The valve element is already included in the standard file; you just need to uncomment it. The valve configuration is shown here:
			</div><pre class="programlisting">&lt;Valve className="org.jboss.web.tomcat.service.sso.ClusteredSingleSignOn" /&gt;</pre><div class="para">
				The element supports the following attributes:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>className</strong></span> is a required attribute to set the Java class name of the valve implementation to use. This must be set to <code class="literal">org.jboss.web.tomcat.service.sso.ClusteredSingleSign</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>cacheConfig</strong></span> is the name of the cache configuration (see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>) to use for the clustered SSO cache. Default is <code class="literal">clustered-sso</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>treeCacheName</strong></span> is deprecated; use <code class="literal">cacheConfig</code>. Specifies a JMX ObjectName of the JBoss Cache MBean to use for the clustered SSO cache. If no cache can be located from the CacheManager service using the value of <code class="literal">cacheConfig</code>, an attempt to locate an mbean registered in JMX under this ObjectName will be made. Default value is <code class="literal">jboss.cache:service=TomcatClusteringCache</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>cookieDomain</strong></span> is used to set the host domain to be used for sso cookies. See <a class="xref" href="#clustering-sso-cookie-domain">Section22.4.4, Configuring the Cookie Domain</a> for more. Default is <code class="literal">"/"</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>maxEmptyLife</strong></span> is the maximum number of seconds an SSO with no active sessions will be usable by a request. The clustered SSO valve tracks what cluster nodes are managing sessions related to an SSO. A positive value for this attribute allows proper handling of shutdown of a node that is the only one that had handled any of the sessions associated with an SSO. The shutdown invalidates the local copy of the sessions, eliminating all sessions from the SSO. If maxEmptyLife were zero, the SSO would terminate along with the local session copies. But, backup copies of the sessions (if they are from clustered webapps) are available on other cluster nodes. Allowing the SSO to live beyond the life of its managed sessions gives the user time to make another request which can fail over to a different cluster node, where it activates the the backup copy of the session. Default is <code class="literal">1800</code>, i.e. 30 minutes.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>processExpiresInterval</strong></span> is the minimum number of seconds between efforts by the valve to find and invalidate SSO's that have exceeded their 'maxEmptyLife'. Does not imply effort will be spent on such cleanup every 'processExpiresInterval', just that it won't occur more frequently than that. Default is <code class="literal">60</code>.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>requireReauthentication</strong></span> is a flag to determine whether each request needs to be reauthenticated to the security <span class="emphasis"><em>Realm</em></span>. If "true", this Valve uses cached security credentials (username and password) to reauthenticate to the JBoss Web security <span class="emphasis"><em>Realm</em></span> each request associated with an SSO session. If <code class="literal">false</code>, the valve can itself authenticate requests based on the presence of a valid SSO cookie, without rechecking with the <span class="emphasis"><em>Realm</em></span>. Setting to <code class="literal">true</code> can allow web applications with different <code class="literal">security-domain</code> configurations to share an SSO. Default is <code class="literal">false</code>.
					</div></li></ul></div></div><div class="section" id="clustering-sso-behavior"><div class="titlepage"><div><div><h3 class="title">22.4.2.SSO Behavior</h3></div></div></div><div class="para">
				The user will not be challenged as long as they access only unprotected resources in any of the web applications on the virtual host.
			</div><div class="para">
				Upon access to a protected resource in any web app, the user will be challenged to authenticate, using the login method defined for the web app.
			</div><div class="para">
				Once authenticated, the roles associated with this user will be utilized for access control decisions across all of the associated web applications, without challenging the user to authenticate themselves to each application individually.
			</div><div class="para">
				If the web application invalidates a session (by invoking the <code class="literal">javax.servlet.http.HttpSession.invalidate()</code> method), the user's sessions in all web applications will be invalidated.
			</div><div class="para">
				A session timeout does not invalidate the SSO if other sessions are still valid.
			</div></div><div class="section" id="clustering-sso-limitations"><div class="titlepage"><div><div><h3 class="title">22.4.3.Limitations</h3></div></div></div><div class="para">
				There are a number of known limitations to this Tomcat valve-based SSO implementation: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Only useful within a cluster of JBoss servers; SSO does not propagate to other resources.
						</div></li><li class="listitem"><div class="para">
							Requires use of container managed authentication (via <code class="literal">&lt;login-config&gt;</code> element in <code class="literal">web.xml</code>)
						</div></li><li class="listitem"><div class="para">
							Requires cookies. SSO is maintained via a cookie and URL rewriting is not supported.
						</div></li><li class="listitem"><div class="para">
							Unless <code class="literal">requireReauthentication</code> is set to <code class="literal">true</code>, all web applications configured for the same SSO valve must share the same JBoss Web <code class="literal">Realm</code> and JBoss Security <code class="literal">security-domain</code>. This means: 
							<div class="itemizedlist"><ul><li class="listitem"><div class="para">
										In <code class="literal">server.xml</code> you can nest the <code class="literal">Realm</code> element inside the <code class="literal">Host</code> element (or the surrounding <code class="literal">Engine</code> element), but not inside a <code class="literal">context.xml</code> packaged with one of the involved web applications.
									</div></li><li class="listitem"><div class="para">
										The <code class="literal">security-domain</code> configured in <code class="literal">jboss-web.xml</code> or <code class="literal">jboss-app.xml</code> must be consistent for all of the web applications.
									</div></li><li class="listitem"><div class="para">
										Even if you set <code class="literal">requireReauthentication</code> to <code class="literal">true</code> and use a different <code class="literal">security-domain</code> (or, less likely, a different <code class="literal">Realm</code>) for different webapps, the varying security integrations must all accept the same credentials (e.g. username and password).
									</div></li></ul></div>

						</div></li></ul></div>

			</div></div><div class="section" id="clustering-sso-cookie-domain"><div class="titlepage"><div><div><h3 class="title">22.4.4.Configuring the Cookie Domain</h3></div></div></div><div class="para">
				As noted above the SSO valve supports a <code class="literal">cookieDomain</code> configuration attribute. This attribute allows configuration of the SSO cookie's domain (i.e. the set of hosts to which the browser will present the cookie). By default the domain is <code class="literal">"/"</code>, meaning the browser will only present the cookie to the host that issued it. The <code class="literal">cookieDomain</code> attribute allows the cookie to be scoped to a wider domain.
			</div><div class="para">
				For example, suppose we have a case where two apps, with URLs <code class="literal">http://app1.xyz.com</code> and <code class="literal">http://app2.xyz.com</code>, that wish to share an SSO context. These apps could be running on different servers in a cluster or the virtual host with which they are associated could have multiple aliases. This can be supported with the following configuration: 
<pre class="programlisting">&lt;Valve className="org.jboss.web.tomcat.service.sso.ClusteredSingleSignOn"
                 cookieDomain="xyz.com" /&gt;</pre>

			</div></div></div></div><div xml:lang="en-US" class="chapter" id="clustering-jms" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter23.JBoss Messaging Clustering Notes</h2></div></div></div><div class="para">
		The most current information about using JBoss Messaging in a clustered environment is always available from the relevant <em class="citetitle">JBoss Messaging User Guide</em> at <a href="http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/" class="mimir-link-warn" title="Mimir does not include content from: www.redhat.com">http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/</a>.
	</div></div><div xml:lang="en-US" class="chapter" id="deployment.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter24.Clustered Deployment Options</h2></div></div></div><div class="section" id="idm139946669877856"><div class="titlepage"><div><div><h2 class="title">24.1.Clustered Singleton Services</h2></div></div></div><div class="para">
			A clustered singleton service (also known as a HA singleton) is a service that is deployed on multiple nodes in a cluster, but is providing its service on only one of the nodes. The node running the singleton service is typically called the master node.
		</div><div class="figure" id="master_node_before.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/b6cfedbbbd872e5b5a0b10c0388aa61a/master_node_before.png" align="middle" alt="Topology before the Master Node fails" /></div></div><p class="title"><strong>Figure24.1.Topology before the Master Node fails</strong></p></div><div class="para">
			When the master fails or is shut down, another master is selected from the remaining nodes and the service is restarted on the new master. Thus, other than a brief interval when one master has stopped and another has yet to take over, the service is always being provided by one but only one node.
		</div><div class="figure" id="master_node_fail.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/741f1d8d03c51fe86b9dcc63ab68c6da/master_node_fail.png" align="middle" alt="Topology after the Master Node fails" /></div></div><p class="title"><strong>Figure24.2.Topology after the Master Node fails</strong></p></div><div class="section" id="idm139946673051152"><div class="titlepage"><div><div><h3 class="title">24.1.1.HASingleton Deployment Options</h3></div></div></div><div class="para">
				The JBoss Enterprise Application Platform provides support for a number of strategies for helping you deploy clustered singleton services. In this section we will explore the different strategies. All of the strategies are built on top of the HAPartition service described in the introduction. They rely on the <code class="literal">HAPartition</code> to provide notifications when different nodes in the cluster start and stop; based on those notifications each node in the cluster can independently (but consistently) determine if it is now the master node and needs to begin providing a service.
			</div><div class="section" id="idm139946658908864"><div class="titlepage"><div><div><h4 class="title">24.1.1.1.HASingletonDeployer service</h4></div></div></div><div class="para">
					The simplest and most commonly used strategy for deploying an HA singleton is to take an ordinary deployment (war, ear, jar, whatever you would normally put in deploy) and deploy it in the <code class="literal"><em class="replaceable">$JBOSS_HOME</em>/server/all/deploy-hasingleton</code> directory instead of in <code class="literal">deploy</code>. The <code class="literal">deploy-hasingleton</code> directory does not lie under <code class="literal">deploy</code> nor <code class="literal">farm</code> directories, so its contents are not automatically deployed when an Enterprise Application Platform instance starts. Instead, deploying the contents of this directory is the responsibility of a special service, the <code class="literal">HASingletonDeployer</code> bean (which itself is deployed via the deploy/deploy-hasingleton-jboss-beans.xml file). The HASingletonDeployer service is itself an HA Singleton, one whose provided service, when it becomes master, is to deploy the contents of deploy-hasingleton; and whose service, when it stops being the master (typically at server shutdown), is to undeploy the contents of <code class="literal">deploy-hasingleton</code>.
				</div><div class="para">
					So, by placing your deployments in <code class="literal">deploy-hasingleton</code> you know that they will be deployed only on the master node in the cluster. If the master node cleanly shuts down, they will be cleanly undeployed as part of shutdown. If the master node fails or is shut down, they will be deployed on whatever node takes over as master.
				</div><div class="para">
					Using deploy-hasingleton is very simple, but it does have two drawbacks:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							There is no hot-deployment feature for services in <code class="literal">deploy-hasingleton</code> . Redeploying a service that has been deployed to <code class="literal">deploy-hasingleton</code> requires a server restart.
						</div></li><li class="listitem"><div class="para">
							If the master node fails and another node takes over as master, your singleton service needs to go through the entire deployment process before it will be providing services. Depending on the complexity of your service's deployment, and the extent of startup activity in which it engages, this could take a while, during which time the service is not being provided.
						</div></li></ul></div></div><div class="section" id="idm139946675991440"><div class="titlepage"><div><div><h4 class="title">24.1.1.2.POJO deployments using HASingletonController</h4></div></div></div><div class="para">
					If your service is a POJO (i.e., not a J2EE deployment like an ear or war or jar), you can deploy it along with a service called an HASingletonController in order to turn it into an HA singleton. It is the job of the HASingletonController to work with the HAPartition service to monitor the cluster and determine if it is now the master node for its service. If it determines it has become the master node, it invokes a method on your service telling it to begin providing service. If it determines it is no longer the master node, it invokes a method on your service telling it to stop providing service. Let's walk through an illustration.
				</div><div class="para">
					First, we have a POJO that we want to make an HA singleton. The only thing special about it is it needs to expose a public method that can be called when it should begin providing service, and another that can be called when it should stop providing service:
				</div><pre class="programlisting">public interface HASingletonExampleMBean
{
   boolean isMasterNode();
}</pre><pre class="programlisting">public class HASingletonExample implements HASingletonExampleMBean
{
   private boolean isMasterNode = false; 

   public boolean isMasterNode()
   {
      return isMasterNode; 
   }

   public void startSingleton()
   { 
      isMasterNode = true;
   }

   public void stopSingleton()
   {
      isMasterNode = false; 
   }
}
</pre><div class="para">
					We used <code class="literal">startSingleton</code> and <code class="literal">stopSingleton</code> in the above example, but you could name the methods anything.
				</div><div class="para">
					Next, we deploy our service, along with an HASingletonController to control it, most likely packaged in a .sar file, with the following <code class="literal">META-INF/jboss-beans.xml</code>:
				</div><pre class="programlisting">
&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;
  &lt;!-- This bean is an example of a clustered singleton --&gt;
  &lt;bean name="HASingletonExample" class="org.jboss.ha.examples.HASingletonExample"&gt;
    &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=HASingletonExample", 
      exposedInterface=org.jboss.ha.examples.HASingletonExampleMBean.class)&lt;/annotation&gt;
  &lt;/bean&gt;

  &lt;bean name="ExampleHASingletonController" class="org.jboss.ha.singleton.HASingletonController"&gt;
    &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="jboss:service=ExampleHASingletonController", 
      exposedInterface=org.jboss.ha.singleton.HASingletonControllerMBean.class, 
      registerDirectly=true)&lt;/annotation&gt;
    &lt;property name="HAPartition"&gt;&lt;inject bean="HAPartition"/&gt;&lt;/property&gt;
    &lt;property name="target"&gt;&lt;inject bean="HASingletonExample"/&gt;&lt;/property&gt;
    &lt;property name="targetStartMethod"&gt;startSingleton&lt;/property&gt;
    &lt;property name="targetStopMethod"&gt;stopSingleton&lt;/property&gt;
  &lt;/bean&gt;
&lt;/deployment&gt;
</pre><div class="para">
					Voila! A clustered singleton service.
				</div><div class="para">
					The primary advantage of this approach over deploy-ha-singleton. is that the above example can be placed in <code class="literal">deploy</code> or <code class="literal">farm</code> and thus can be hot deployed and farmed deployed. Also, if our example service had complex, time-consuming startup requirements, those could potentially be implemented in create() or start() methods. JBoss will invoke create() and start() as soon as the service is deployed; it doesn't wait until the node becomes the master node. So, the service could be primed and ready to go, just waiting for the controller to implement startSingleton() at which point it can immediately provide service.
				</div><div class="para">
					Although not demonstrated in the example above, the <code class="literal">HASingletonController</code> can support an optional argument for either or both of the target start and stop methods. These are specified using the <code class="literal">targetStartMethodArgument</code> and <code class="literal">TargetStopMethodArgument</code> properties, respectively. Currently, only string values are supported.
				</div></div><div class="section" id="idm139946669901328"><div class="titlepage"><div><div><h4 class="title">24.1.1.3.HASingleton deployments using a Barrier</h4></div></div></div><div class="para">
					Services deployed normally inside deploy or farm that want to be started/stopped whenever the content of deploy-hasingleton gets deployed/undeployed, (i.e., whenever the current node becomes the master), need only specify a dependency on the Barrier service:
				</div><pre class="programlisting">
&lt;depends&gt;HASingletonDeployerBarrierController&lt;/depends&gt;
</pre><div class="para">
					The way it works is that a BarrierController is deployed along with the HASingletonDeployer and listens for JMX notifications from it. A BarrierController is a relatively simple MBean that can subscribe to receive any JMX notification in the system. It uses the received notifications to control the lifecycle of a dynamically created MBean called the Barrier. The Barrier is instantiated, registered and brought to the CREATE state when the BarrierController is deployed. After that, the BarrierController starts and stops the Barrier when matching JMX notifications are received. Thus, other services need only depend on the Barrier bean using the usual &lt;depends&gt; tag, and they will be started and stopped in tandem with the Barrier. When the BarrierController is undeployed the Barrier is also destroyed.
				</div><div class="para">
					This provides an alternative to the deploy-hasingleton approach in that we can use farming to distribute the service, while content in deploy-hasingleton must be copied manually on all nodes.
				</div><div class="para">
					On the other hand, the barrier-dependent service will be instantiated/created (i.e., any create() method invoked) on all nodes, but only started on the master node. This is different with the deploy-hasingleton approach that will only deploy (instantiate/create/start) the contents of the deploy-hasingleton directory on one of the nodes.
				</div><div class="para">
					So services depending on the barrier will need to make sure they do minimal or no work inside their create() step, rather they should use start() to do the work.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The Barrier controls the start/stop of dependent services, but not their destruction, which happens only when the <code class="literal">BarrierController</code> is itself destroyed/undeployed. Thus using the <code class="literal">Barrier</code> to control services that need to be "destroyed" as part of their normal undeploy operation (like, for example, an <code class="literal">EJBContainer</code>) will not have the desired effect.
					</div></div></div></div></div><div class="section" id="idm139946658563936"><div class="titlepage"><div><div><h3 class="title">24.1.2.Determining the master node</h3></div></div></div><div class="para">
				The various clustered singleton management strategies all depend on the fact that each node in the cluster can independently react to changes in cluster membership and correctly decide whether it is now the master node. How is this done?
			</div><div class="para">
				For each member of the cluster, the HAPartition service maintains an attribute called the CurrentView, which is basically an ordered list of the current members of the cluster. As nodes join and leave the cluster, JGroups ensures that each surviving member of the cluster gets an updated view. You can see the current view by going into the JMX console, and looking at the CurrentView attribute in the <code class="literal">jboss:service=DefaultPartition</code> mbean. Every member of the cluster will have the same view, with the members in the same order.
			</div><div class="para">
				Let's say, for example, that we have a 4 node cluster, nodes A through D, and the current view can be expressed as {A, B, C, D}. Generally speaking, the order of nodes in the view will reflect the order in which they joined the cluster (although this is not always the case, and should not be assumed to be the case).
			</div><div class="para">
				To further our example, let's say there is a singleton service (i.e. an <code class="literal">HASingletonController</code>) named Foo that's deployed around the cluster, except, for whatever reason, on B. The <code class="literal">HAPartition</code> service maintains across the cluster a registry of what services are deployed where, in view order. So, on every node in the cluster, the <code class="literal">HAPartition</code> service knows that the view with respect to the Foo service is {A, C, D} (no B).
			</div><div class="para">
				Whenever there is a change in the cluster topology of the Foo service, the <code class="literal">HAPartition</code> service invokes a callback on Foo notifying it of the new topology. So, for example, when Foo started on D, the Foo service running on A, C and D all got callbacks telling them the new view for Foo was {A, C, D}. That callback gives each node enough information to independently decide if it is now the master. The Foo service on each node uses the <code class="literal">HAPartition</code>'s <code class="literal">HASingletonElectionPolicy</code> to determine if they are the master, as explained in the <a class="xref" href="#ha-singleton-election-policy">Section24.1.2.1, HA singleton election policy</a>.
			</div><div class="para">
				If A were to fail or shutdown, Foo on C and D would get a callback with a new view for Foo of {C, D}. C would then become the master. If A restarted, A, C and D would get a callback with a new view for Foo of {C, D, A}. C would remain the master  there's nothing magic about A that would cause it to become the master again just because it was before.
			</div><div class="section" id="ha-singleton-election-policy"><div class="titlepage"><div><div><h4 class="title">24.1.2.1.HA singleton election policy</h4></div></div></div><div class="para">
					The <code class="literal">HASingletonElectionPolicy</code> object is responsible for electing a master node from a list of available nodes, on behalf of an HA singleton, following a change in cluster topology.
				</div><pre class="programlisting">
public interface HASingletonElectionPolicy
{
   ClusterNode elect(List&lt;ClusterNode&gt; nodes);
}
</pre><div class="para">
					JBoss Enterprise Application Platform ships with two election policies:
				</div><div class="variablelist"><dl class="variablelist"><dt><span class="term"> <code class="literal">HASingletonElectionPolicySimple</code> </span></dt><dd><div class="para">
								This policy selects a master node based relative age. The desired age is configured via the <code class="literal">position</code> property, which corresponds to the index in the list of available nodes. <code class="literal">position = 0</code>, the default, refers to the oldest node; <code class="literal">position = 1</code>, refers to the 2nd oldest; etc. <code class="literal">position</code> can also be negative to indicate youngness; imagine the list of available nodes as a circular linked list. <code class="literal">position = -1</code>, refers to the youngest node; <code class="literal">position = -2</code>, refers to the 2nd youngest node; etc.
							</div><pre class="programlisting">
&lt;bean class="org.jboss.ha.singleton.HASingletonElectionPolicySimple"&gt;
  &lt;property name="position"&gt;-1&lt;/property&gt;
&lt;/bean&gt;
</pre></dd><dt><span class="term"> <code class="literal">PreferredMasterElectionPolicy</code> </span></dt><dd><div class="para">
								This policy extends <code class="literal">HASingletonElectionPolicySimple</code>, allowing the configuration of a preferred node. The <code class="literal">preferredMaster</code> property, specified as <span class="emphasis"><em>host:port</em></span> or <span class="emphasis"><em>address:port</em></span>, identifies a specific node that should become master, if available. If the preferred node is not available, the election policy will behave as described above.
							</div><pre class="programlisting">
&lt;bean class="org.jboss.ha.singleton.PreferredMasterElectionPolicy"&gt;
  &lt;property name="preferredMaster"&gt;server1:12345&lt;/property&gt;
&lt;/bean&gt;
</pre></dd></dl></div></div></div></div><div class="section" id="clustering-intro-farm"><div class="titlepage"><div><div><h2 class="title">24.2.Farming Deployment</h2></div></div></div><div class="para">
			The easiest way to deploy an application into the cluster is to use the farming service. Using the farming service, you can deploy an application (e.g. EAR, WAR, or SAR; either an archive file or in exploded form) to the <code class="literal">all/farm/</code> directory of any cluster member and the application will be automatically duplicate across all nodes in the same cluster. If a node joins the cluster later, it will pull in all farm deployed applications in the cluster and deploy them locally at start-up time. If you delete the application from a running clustered server node's <code class="literal">farm/</code> directory, the application will be undeployed locally and then removed from all other clustered server nodes' <code class="literal">farm/</code> directories (triggering undeployment).
		</div><div class="para">
			Farming is enabled by default in the <code class="literal">all</code> configuration in JBoss Enterprise Application Platform and thus requires no manual setup. The required <code class="filename">farm-deployment-jboss-beans.xml</code> and <code class="filename">timestamps-jboss-beans.xml</code> configuration files are located in the <code class="literal">deploy/cluster</code> directory. If you want to enable farming in a custom configuration, simply copy these files to the corresponding JBoss deploy directory <code class="literal"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">$your_own_config</em>/deploy/cluster</code>. Make sure that your custom configuration has clustering enabled.
		</div><div class="para">
			While there is little need to customize the farming service, it can be customized via the <code class="literal">FarmProfileRepositoryClusteringHandler</code> bean, whose properties and default values are listed below:
		</div><pre class="programlisting">
&lt;bean name="FarmProfileRepositoryClusteringHandler"
      class="org.jboss.profileservice.cluster.repository.
      DefaultRepositoryClusteringHandler"&gt;
  
  &lt;property name="partition"&gt;&lt;inject bean="HAPartition"/&gt;&lt;/property&gt;
  &lt;property name="profileDomain"&gt;default&lt;/property&gt;
  &lt;property name="profileServer"&gt;default&lt;/property&gt;
  &lt;property name="profileName"&gt;farm&lt;/property&gt;
  &lt;property name="immutable"&gt;false&lt;/property&gt;
  &lt;property name="lockTimeout"&gt;60000&lt;/property&gt;&lt;!-- 1 minute --&gt;
  &lt;property name="methodCallTimeout"&gt;60000&lt;/property&gt;&lt;!-- 1 minute --&gt;
  &lt;property name="synchronizationPolicy"&gt;&lt;inject bean="FarmProfileSynchronizationPolicy"/&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>partition</strong></span> is a required attribute to inject the HAPartition service that the farm service uses for intra-cluster communication.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>profile[Domain|Server|Name]</strong></span> are all used to identify the profile for which this handler is intended.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>immutable</strong></span> indicates whether or not this handler allows a node to push content changes to the cluster. A value of <code class="literal">true</code> is equivalent to setting <code class="literal">synchronizationPolicy</code> to <code class="literal">org.jboss.system.server.profileservice.repository.clustered.sync.</code> <code class="literal">ImmutableSynchronizationPolicy</code>.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>lockTimeout</strong></span> defines the number of milliseconds to wait for cluster-wide lock acquisition.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>methodCallTimeout</strong></span> defines the number of milliseconds to wait for invocations on remote cluster nodes.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>synchronizationPolicy</strong></span> decides how to handle content additions, reincarnations, updates, or removals from nodes attempting to join the cluster or from cluster merges. The policy is consulted on the "authoritative" node, i.e. the master node for the service on the cluster. <span class="emphasis"><em>Reincarnation</em></span> refers to the phenomenon where a newly started node may contain an application in its <code class="literal">farm/</code> directory that was previously removed by the farming service but might still exist on the starting node if it was not running when the removal took place. The default synchronization policy is defined as follows:
				</div><pre class="programlisting">
&lt;bean name="FarmProfileSynchronizationPolicy"
      class="org.jboss.profileservice.cluster.repository.
      DefaultSynchronizationPolicy"&gt;
  &lt;property name="allowJoinAdditions"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowJoinReincarnations"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowJoinUpdates"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowJoinRemovals"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowMergeAdditions"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowMergeReincarnations"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowMergeUpdates"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="allowMergeRemovals"&gt;&lt;null/&gt;&lt;/property&gt;
  &lt;property name="developerMode"&gt;false&lt;/property&gt;
  &lt;property name="removalTrackingTime"&gt;2592000000&lt;/property&gt;&lt;!-- 30 days --&gt;
  &lt;property name="timestampService"&gt;&lt;inject bean="TimestampDiscrepancyService"/&gt;&lt;/property&gt;
&lt;/bean&gt;
</pre><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>allow[Join|Merge][Additions|Reincarnations|Updates|Removals]</strong></span> define fixed responses to requests to allow additions, reincarnations, updates, or removals from joined or merged nodes.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>developerMode</strong></span> enables a lenient synchronization policy that allows all changes. Enabling developer mode is equivalent to setting each of the above properties to <code class="literal">true</code> and is intended for development environments.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>removalTrackingTime</strong></span> defines the number of milliseconds for which this policy should remembered removed items, for use in detecting reincarnations.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timestampService</strong></span> estimates and tracks discrepancies in system clocks for current and past members of the cluster. Default implementation is defined in <code class="filename">timestamps-jboss-beans.xml</code>.
						</div></li></ul></div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="jgroups.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter25.JGroups Services</h2></div></div></div><div class="para">
		JGroups provides the underlying group communication support for JBoss Enterprise Application Platform clusters. The interaction of clustered services with JGroups was covered in <a class="xref" href="#clustering-blocks-jgroups">Section18.1, Group Communication with JGroups</a>. This chapter focuses on the details of this interaction, with particular attention to configuration details and troubleshooting tips.
	</div><div class="para">
		This chapter is not intended as complete JGroups documentation. If you want to know more about JGroups, you can consult:
	</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
				The JGroups project documentation at <a href="http://jgroups.org/ug.html" class="mimir-link-warn" title="Mimir does not include content from: jgroups.org">http://jgroups.org/ug.html</a>
			</div></li><li class="listitem"><div class="para">
				The JGroups wiki pages at jboss.org, rooted at <a href="https://www.jboss.org/community/wiki/JGroups" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">https://www.jboss.org/community/wiki/JGroups</a>
			</div></li></ul></div><div class="para">
		The first section of this chapter covers the many JGroups configuration options in detail. JBoss Enterprise Application Platform ships with a set of default JGroups configurations. Most applications will work with the default configurations out of the box. You will only need to edit these configurations when you deploy an application with special network or performance requirements.
	</div><div class="section" id="jgroups-configuration"><div class="titlepage"><div><div><h2 class="title">25.1.Configuring a JGroups Channel's Protocol Stack</h2></div></div></div><div class="para">
			The JGroups framework provides services to enable peer-to-peer communications between nodes in a cluster. Communication occurs over a communication channel. The channel built up from a stack of network communication <span class="emphasis"><em>protocols</em></span>, each of which is responsible for adding a particular capability to the overall behavior of the channel. Key capabilities provided by various protocols include transport, cluster discovery, message ordering, lossless message delivery, detection of failed peers, and cluster membership management services.
		</div><div class="para">
			<a class="xref" href="#JGroupsStack.fig">Figure25.1, Protocol stack in JGroups</a> shows a conceptual cluster with each member's channel composed of a stack of JGroups protocols.
		</div><div class="figure" id="JGroupsStack.fig"><div class="figure-contents"><div class="mediaobject" align="center"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/images/972d9905459eb84bfbc8141ca976eb83/jbosscache-JGroupsStack.png" align="middle" width="444" alt="Protocol stack in JGroups" /></div></div><p class="title"><strong>Figure25.1.Protocol stack in JGroups</strong></p></div><div class="para">
			This section of the chapter covers some of the most commonly used protocols, according to the type of behaviour they add to the channel. We discuss a few key configuration attributes exposed by each protocol, but since these attributes should be altered only by experts, this chapter focuses on familiarizing users with the purpose of various protocols.
		</div><div class="para">
			The JGroups configurations used in JBoss Enterprise Application Platform appear as nested elements in the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/all/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file. This file is parsed by the <code class="literal">ChannelFactory</code> service, which uses the contents to provide correctly configured channels to the clustered services that require them. See <a class="xref" href="#clustering-blocks-jgroups-channelfactory">Section18.1.1, The Channel Factory Service</a> for more on the <code class="literal">ChannelFactory</code> service.
		</div><div class="para">
			The following is an example protocol stack configuration from <code class="filename">jgroups-channelfactory-stacks.xml</code>:
		</div><pre class="programlisting">&lt;stack name="udp-async"
           description="Same as the default 'udp' stack above, except message bundling
                        is enabled in the transport protocol (enable_bundling=true). 
                        Useful for services that make high-volume asynchronous 
                        RPCs (e.g. high volume JBoss Cache instances configured 
                        for REPL_ASYNC) where message bundling may improve performance."&gt;
        &lt;config&gt;
          &lt;UDP
             singleton_name="udp-async"
             mcast_port="${jboss.jgroups.udp_async.mcast_port:45689}"
             mcast_addr="${jboss.partition.udpGroup:228.11.11.11}"
             tos="8"
             ucast_recv_buf_size="20000000"
             ucast_send_buf_size="640000"
             mcast_recv_buf_size="25000000"
             mcast_send_buf_size="640000"
             loopback="true"
             discard_incompatible_packets="true"
             enable_bundling="true"
             max_bundle_size="64000"
             max_bundle_timeout="30"
             ip_ttl="${jgroups.udp.ip_ttl:2}"
             thread_naming_pattern="cl"
             timer.num_threads="12"
             enable_diagnostics="${jboss.jgroups.enable_diagnostics:true}"
             diagnostics_addr="${jboss.jgroups.diagnostics_addr:224.0.0.75}"
             diagnostics_port="${jboss.jgroups.diagnostics_port:7500}"

             thread_pool.enabled="true"
             thread_pool.min_threads="8"
             thread_pool.max_threads="200"
             thread_pool.keep_alive_time="5000"
             thread_pool.queue_enabled="true"
             thread_pool.queue_max_size="1000"
             thread_pool.rejection_policy="discard"
      
             oob_thread_pool.enabled="true"
             oob_thread_pool.min_threads="8"
             oob_thread_pool.max_threads="200"
             oob_thread_pool.keep_alive_time="1000"
             oob_thread_pool.queue_enabled="false"
             oob_thread_pool.rejection_policy="discard"/&gt;
          &lt;PING timeout="2000" num_initial_members="3"/&gt;
          &lt;MERGE2 max_interval="100000" min_interval="20000"/&gt;
          &lt;FD_SOCK/&gt;
          &lt;FD timeout="6000" max_tries="5" shun="true"/&gt;
          &lt;VERIFY_SUSPECT timeout="1500"/&gt;
          &lt;BARRIER/&gt;
          &lt;pbcast.NAKACK use_mcast_xmit="true" gc_lag="0"
                   retransmit_timeout="300,600,1200,2400,4800"
                   discard_delivered_msgs="true"/&gt;
          &lt;UNICAST timeout="300,600,1200,2400,3600"/&gt;
          &lt;pbcast.STABLE stability_delay="1000" desired_avg_gossip="50000"
                   max_bytes="400000"/&gt;          
          &lt;VIEW_SYNC avg_send_interval="10000"/&gt;
          &lt;pbcast.GMS print_local_addr="true" join_timeout="3000"
                   shun="true"
                   view_bundling="true"
                   view_ack_collection_timeout="5000"
                   resume_task_timeout="7500"/&gt;
          &lt;FC max_credits="2000000" min_threshold="0.10" 
              ignore_synchronous_response="true"/&gt;
          &lt;FRAG2 frag_size="60000"/&gt;
          &lt;!-- pbcast.STREAMING_STATE_TRANSFER/ --&gt;
          &lt;pbcast.STATE_TRANSFER/&gt;
          &lt;pbcast.FLUSH timeout="0" start_flush_timeout="10000"/&gt;
        &lt;/config&gt;
    &lt;/stack&gt;
</pre><div class="para">
			The <code class="literal">&lt;config&gt;</code> element contains all the configuration data for JGroups. This information is used to configure a JGroups <span class="emphasis"><em>channel</em></span>, which is conceptually similar to a socket, and manages communication between peers in a cluster. Each element within the <code class="literal">&lt;config&gt;</code> element defines a particular JGroups <span class="emphasis"><em>protocol</em></span>. Each protocol performs one function. The combination of these functions defines the characteristics of the channel as a whole. The next few sections describe common protocols and explain the options available to each.
		</div><div class="section" id="idm139946673209664"><div class="titlepage"><div><div><h3 class="title">25.1.1.Common Configuration Properties</h3></div></div></div><div class="para">
				The following property is exposed by all of the JGroups protocols discussed below:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">stats</code> whether the protocol should gather runtime statistics on its operations that can be exposed via tools like the AS's JMX console or the JGroups Probe utility. What, if any, statistics are gathered depends on the protocol. Default is <code class="literal">true</code>.
					</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					All of the protocols in the versions of JGroups used in JBoss Application Server 3.x and 4.x exposed <code class="literal">down_thread</code> and <code class="literal">up_thread</code> attributes. The JGroups version included in JBoss Application Server 5 and later no longer uses those attributes, and a <code class="literal">WARN</code> message will be written to the server log if they are configured for any protocol.
				</div></div></div></div><div class="section" id="jgroups-transport"><div class="titlepage"><div><div><h3 class="title">25.1.2.Transport Protocols</h3></div></div></div><div class="para">
				The transport protocols send and receive messages to and from the network. They also manage the thread pools used to deliver incoming messages to addresses higher in the protocol stack. JGroups supports <code class="literal">UDP</code>, <code class="literal">TCP</code> and <code class="literal">TUNNEL</code> as transport protocols.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					The <code class="literal">UDP</code>, <code class="literal">TCP</code>, and <code class="literal">TUNNEL</code> protocols are mutually exclusive. You can only have one transport protocol in each JGroups <code class="literal">Config</code> element
				</div></div></div><div class="section" id="jgroups-transport-udp"><div class="titlepage"><div><div><h4 class="title">25.1.2.1.UDP configuration</h4></div></div></div><div class="para">
					UDP is the preferred transport protocol for JGroups. UDP uses multicast (or, in an unusual configuration, multiple unicasts) to send and receive messages. If you choose UDP as the transport protocol for your cluster service, you need to configure it in the <code class="literal">UDP</code> sub-element in the JGroups <code class="literal">config</code> element. Here is an example.
				</div><pre class="programlisting">          &lt;UDP
             singleton_name="udp-async"
             mcast_port="${jboss.jgroups.udp_async.mcast_port:45689}"
             mcast_addr="${jboss.partition.udpGroup:228.11.11.11}"
             tos="8"
             ucast_recv_buf_size="20000000"
             ucast_send_buf_size="640000"
             mcast_recv_buf_size="25000000"
             mcast_send_buf_size="640000"
             loopback="true"
             discard_incompatible_packets="true"
             enable_bundling="true"
             max_bundle_size="64000"
             max_bundle_timeout="30"
             ip_ttl="${jgroups.udp.ip_ttl:2}"
             thread_naming_pattern="cl"
             timer.num_threads="12"
             enable_diagnostics="${jboss.jgroups.enable_diagnostics:true}"
             diagnostics_addr="${jboss.jgroups.diagnostics_addr:224.0.0.75}"
             diagnostics_port="${jboss.jgroups.diagnostics_port:7500}"

             thread_pool.enabled="true"
             thread_pool.min_threads="8"
             thread_pool.max_threads="200"
             thread_pool.keep_alive_time="5000"
             thread_pool.queue_enabled="true"
             thread_pool.queue_max_size="1000"
             thread_pool.rejection_policy="discard"
      
             oob_thread_pool.enabled="true"
             oob_thread_pool.min_threads="8"
             oob_thread_pool.max_threads="200"
             oob_thread_pool.keep_alive_time="1000"
             oob_thread_pool.queue_enabled="false"
             oob_thread_pool.rejection_policy="discard"/&gt;
</pre><div class="para">
					JGroups transport configurations have a number of attributes available. First we look at the attributes available to the <code class="literal">UDP</code> protocol, followed by the attributes that are also used by the <code class="literal">TCP</code> and <code class="literal">TUNNEL</code> transport protocols.
				</div><div class="para">
					The attributes particular to the <code class="literal">UDP</code> protocol are:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ip_mcast</strong></span> specifies whether or not to use IP multicasting. The default is <code class="literal">true</code>. If set to <code class="literal">false</code>, multiple unicast packets will be sent instead of one multicast packet. Any packet sent via <code class="literal">UDP</code> protocol are UDP datagrams.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_addr</strong></span> specifies the multicast address (class D) for communicating with the group (i.e., the cluster). The standard protocol stack configurations in JBoss AS use the value of system property <code class="literal">jboss.partition.udpGroup</code>, if set, as the value for this attribute. Using the <code class="literal">-u</code> command line switch when starting JBoss Application Server sets that value. See <a class="xref" href="#clustering-jgroups-isolation">Section25.6.2, Isolating JGroups Channels</a> for information about using this configuration attribute to ensure that JGroups channels are properly isolated from one another. If this attribute is omitted, the default value is <code class="literal">228.11.11.11</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_port</strong></span> specifies the port to use for multicast communication with the group. See <a class="xref" href="#clustering-jgroups-isolation">Section25.6.2, Isolating JGroups Channels</a> for how to use this configuration attribute to ensure JGroups channels are properly isolated from one another. If this attribute is omitted, the default is <code class="literal">45688</code>.
						</div></li><li class="listitem"><div class="para">
							<code class="literal">mcast_send_buf_size</code>, <code class="literal">mcast_recv_buf_size</code>, <code class="literal">ucast_send_buf_size</code> and <code class="literal">ucast_recv_buf_size</code> define the socket send and receive buffer sizes that JGroups will request from the operating system. A large buffer size helps to ensure that packets are not dropped due to buffer overflow. However, socket buffer sizes are limited at the operating system level, so obtaining the desired buffer may require configuration at the operating system level. See <a class="xref" href="#jgroups-perf-udpbuffer">Section25.6.2.3, Improving UDP Performance by Configuring OS UDP Buffer Limits</a> for further details.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_port</strong></span> specifies the port to which the unicast receive socket should be bound. The default is <code class="literal">0</code>; i.e. use an ephemeral port.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>port_range</strong></span> specifies the number of ports to try if the port identified by <code class="literal">bind_port</code> is not available. The default is <code class="literal">1</code>, which specifies that only <code class="literal">bind_port</code> will be tried.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ip_ttl</strong></span> specifies time-to-live (TTL) for IP Multicast packets. TTL is the commonly used term in multicast networking, but is actually something of a misnomer, since the value here refers to how many network hops a packet will be allowed to travel before networking equipment will drop it.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tos</strong></span> specifies the traffic class for sending unicast and multicast datagrams.
						</div></li></ul></div><div class="para">
					The attributes that are common to all transport protocols, and thus have the same meanings when used with <code class="literal">TCP</code> or <code class="literal">TUNNEL</code>, are:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>singleton_name</strong></span> provides a unique name for this transport protocol configuration. Used by the application server's <code class="literal">ChannelFactory</code> to support sharing of a transport protocol instance by different channels that use the same transport protocol configuration. See <a class="xref" href="#clustering-blocks-jgroups-sharedtransport">Section18.1.2, The JGroups Shared Transport</a>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface on which to receive and send messages. By default, JGroups uses the value of system property <code class="literal">jgroups.bind_addr</code>. This can also be set with the <code class="literal">-b</code> command line switch. See <a class="xref" href="#jgroups-other">Section25.6, Other Configuration Issues</a> for more on binding JGroups sockets.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>receive_on_all_interfaces</strong></span> specifies whether this node should listen on all interfaces for multicasts. The default is <code class="literal">false</code>. It overrides the <code class="literal">bind_addr</code> property for receiving multicasts. However, <code class="literal">bind_addr</code> (if set) is still used to send multicasts.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>send_on_all_interfaces</strong></span> specifies whether this node sends UDP packets via all available network interface controllers, if your machine has multiple network interface controllers available. This means that the same multicast message is sent N times, so use with care.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>receive_interfaces</strong></span> specifies a list of of interfaces on which to receive multicasts. The multicast receive socket will listen on all of these interfaces. This is a comma-separated list of IP addresses or interface names, for example, <code class="literal">192.168.5.1,eth1,127.0.0.1</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>send_interfaces</strong></span> specifies a list of of interfaces via which to send multicasts. The multicast sender socket will send on all of these interfaces. This is a comma-separated list of IP addresses or interface names, for example, <code class="literal">192.168.5.1,eth1,127.0.0.1</code>.This means that the same multicast message is sent N times, so use with care.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>enable_bundling</strong></span> specifies whether to enable message bundling. If <code class="literal">true</code>, the tranpsort protocol queues outgoing messages until <code class="literal">max_bundle_size</code> bytes have accumulated, or <code class="literal">max_bundle_time</code> milliseconds have elapsed, whichever occurs first. Then the transport protocol bundles queued messages into one large message and sends it. The messages are unbundled at the receiver. The default is <code class="literal">false</code>.
						</div><div class="para">
							Message bundling can have significant performance benefits for channels that are used for high volume sending of messages where the sender does not block waiting for a response from recipients (for example, a JBoss Cache instance configured for <code class="literal">REPL_ASYNC</code>.) It can add considerable latency to applications where senders need to block waiting for responses, so it is not recommended for certain situations, such as where a JBoss Cache instance is configured for <code class="literal">REPL_SYNC</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>loopback</strong></span> specifies whether the thread sending a message to the group should itself carry the message back up the stack for delivery. (Messages sent to the group are always delivered to the sending node as well.) If <code class="literal">false</code>, the sending thread does not carry the message; the transport protocol waits to read the message off the network and uses one of the message delivery pool threads for delivery. The default is <code class="literal">false</code>, but <code class="literal">true</code> is recommended to ensure that the channel receives its own messages, in case the network interface goes down.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>discard_incompatible_packets</strong></span> specifies whether to discard packets sent by peers that use a different version of JGroups. Each message in the cluster is tagged with a JGroups version. If <code class="literal">discard_incompatible_packets</code> is set to <code class="literal">true</code>, messages received from different versions of JGroups will be silently discarded. Otherwise, a warning will be logged. <span class="emphasis"><em>In no case will the message be delivered.</em></span> The default value is <code class="literal">false</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>enable_diagnostics</strong></span> specifies that the transport should open a multicast socket on address <code class="literal">diagnostics_addr</code> and port <code class="literal">diagnostics_port</code> to listen for diagnostic requests sent by the JGroups <a href="http://www.jboss.org/community/wiki/Probe" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org"><span class="bold bold"><strong>Probe</strong></span> utility</a>.
						</div></li><li class="listitem"><div class="para">
							The various <span class="bold bold"><strong>thread_pool</strong></span> attributes configure the behavior of the pool of threads JGroups uses to carry ordinary incoming messages up the stack. The various attributes provide the constructor arguments for an instance of <code class="literal">java.util.concurrent.ThreadPoolExecutorService</code>. In the example above, the pool will have a minimum or <span class="emphasis"><em>core size</em></span> of 8 threads, and a maximum size of 200. If more than 8 pool threads have been created, a thread returning from carrying a message will wait for up to 5000 milliseconds to be assigned a new message to carry, after which it will terminate. If no threads are available to carry a message, the (separate) thread reading messages off the socket will place messages in a queue; the queue will hold up to 1000 messages. If the queue is full, the thread reading messages off the socket will discard the message.
						</div></li><li class="listitem"><div class="para">
							The various <span class="bold bold"><strong>oob_thread_pool</strong></span> attributes are similar to the <span class="bold bold"><strong>thread_pool</strong></span> attributes in that they configure a <code class="literal">java.util.concurrent.ThreadPoolExecutorService</code> used to carry incoming messages up the protocol stack. In this case, the pool is used to carry a special type of message known as an Out-Of-Band (OOB) message. OOB messages are exempt from the ordered-delivery requirements of protocols like NAKACK and UNICAST and thus can be delivered up the stack even if NAKACK or UNICAST are queueing up messages from a particular sender. OOB messages are often used internally by JGroups protocols and can be used by applications as well. For example, when JBoss Cache is in <code class="literal">REPL_SYNC</code> mode, it uses OOB messages for the second phase of its two-phase-commit protocol.
						</div></li></ul></div></div><div class="section" id="jgroups-transport-tcp"><div class="titlepage"><div><div><h4 class="title">25.1.2.2.TCP configuration</h4></div></div></div><div class="para">
					Alternatively, a JGroups-based cluster can also work over TCP connections. Compared with UDP, TCP generates more network traffic when the cluster size increases. TCP is fundamentally a unicast protocol. To send multicast messages, JGroups uses multiple TCP unicasts. To use TCP as a transport protocol, you should define a <code class="literal">TCP</code> element in the JGroups <code class="literal">config</code> element. Here is an example of the <code class="literal">TCP</code> element.
				</div><pre class="programlisting">
&lt;TCP singleton_name="tcp" 
        start_port="7800" end_port="7800"/&gt;
</pre><div class="para">
					The following attributes are specific to the <code class="literal">TCP</code> element:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<code class="literal">start_port</code> and <code class="literal">end_port</code> define the range of TCP ports to which the server should bind. The server socket is bound to the first available port beginning with <code class="literal">start_port</code>. If no available port is found (for example, because the ports are in use by other sockets) before the <code class="literal">end_port</code>, the server throws an exception. If no <code class="literal">end_port</code> is provided, or <code class="literal">end_port</code> is lower than <code class="literal">start_port</code>, no upper limit is applied to the port range. If <code class="literal">start_port</code> is equal to <code class="literal">end_port</code>, JGroups is forced to use the specified port, since <code class="literal">start_port</code> fails if the specified port in not available. The default value is <code class="literal">7800</code>. If set to <code class="literal">0</code>, the operating system will select a port. (This will only work for <code class="literal">MPING</code> or <code class="literal">TCPGOSSIP</code> discovery protocols. <code class="literal">TCCPING</code> requires that nodes and their required ports are listed.)
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_port</strong></span> in TCP acts as an alias for <code class="literal">start_port</code>. If configured internally, it sets <code class="literal">start_port</code>.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>recv_buf_size, send_buf_size</strong></span> define receive and send buffer sizes. It is good to have a large receiver buffer size, so packets are less likely to get dropped due to buffer overflow.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>conn_expire_time</strong></span> specifies the time (in milliseconds) after which a connection can be closed by the reaper if no traffic has been received.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>reaper_interval</strong></span> specifies interval (in milliseconds) to run the reaper. If both values are 0, no reaping will be done. If either value is &gt; 0, reaping will be enabled. By default, reaper_interval is 0, which means no reaper.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>sock_conn_timeout</strong></span> specifies max time in millis for a socket creation. When doing the initial discovery, and a peer hangs, don't wait forever but go on after the timeout to ping other members. Reduces chances of *not* finding any members at all. The default is 2000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>use_send_queues</strong></span> specifies whether to use separate send queues for each connection. This prevents blocking on write if the peer hangs. The default is true.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>external_addr</strong></span> specifies external IP address to broadcast to other group members (if different to local address). This is useful when you have use (Network Address Translation) NAT, e.g. a node on a private network, behind a firewall, but you can only route to it via an externally visible address, which is different from the local address it is bound to. Therefore, the node can be configured to broadcast its external address, while still able to bind to the local one. This avoids having to use the TUNNEL protocol, (and hence a requirement for a central gossip router) because nodes outside the firewall can still route to the node inside the firewall, but only on its external address. Without setting the external_addr, the node behind the firewall will broadcast its private address to the other nodes which will not be able to route to it.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>skip_suspected_members</strong></span> specifies whether unicast messages should not be sent to suspected members. The default is true.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>tcp_nodelay</strong></span> specifies TCP_NODELAY. TCP by default nagles messages, that is, conceptually, smaller messages are bundled into larger ones. If we want to invoke synchronous cluster method calls, then we need to disable nagling in addition to disabling message bundling (by setting <code class="literal">enable_bundling</code> to false). Nagling is disabled by setting <code class="literal">tcp_nodelay</code> to true. The default is false.
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						All of the attributes common to all protocols discussed in the UDP protocol section also apply to TCP.
					</div></div></div></div><div class="section" id="jgroups-transport-tunnel"><div class="titlepage"><div><div><h4 class="title">25.1.2.3.TUNNEL configuration</h4></div></div></div><div class="para">
					The <code class="literal">TUNNEL</code> protocol uses an external router process to send messages. The external router is a Java process that runs the <code class="literal">org.jgroups.stack.GossipRouter</code> main class. Each node has to register with the router. All messages are sent to the router and forwarded on to their destinations. The TUNNEL approach can be used to set up communication with nodes behind firewalls. A node can establish a TCP connection to the <code class="classname">GossipRouter</code> through the firewall (you can use port 80). This connection is also used by the router to send messages to nodes behind the firewall, as most firewalls do not permit outside hosts to initiate a TCP connection to a host inside the firewall. The <code class="literal">TUNNEL</code> configuration is defined in the <code class="literal">TUNNEL</code> element within the JGroups <code class="literal">&lt;config&gt;</code> element, like so:
				</div><pre class="programlisting">
&lt;TUNNEL  singleton_name="tunnel"
            router_port="12001"
            router_host="192.168.5.1"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">TUNNEL</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>router_host</strong></span> specifies the host on which the GossipRouter is running.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>router_port</strong></span> specifies the port on which the GossipRouter is listening.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>reconnect_interval</strong></span> specifies the interval of time (in milliseconds) for which <code class="literal">TUNNEL</code> will attempt to connect to the <code class="classname">GossipRouter</code> if the connection is not established. The default value is <code class="literal">5000</code>.
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						All of the attributes common to all protocols discussed in the UDP protocol section also apply to <code class="literal">TUNNEL</code>.
					</div></div></div></div></div><div class="section" id="jgroups-discovery"><div class="titlepage"><div><div><h3 class="title">25.1.3.Discovery Protocols</h3></div></div></div><div class="para">
				When a channel on a node first connects, it must determine which other nodes are running compatible channels, and which of these nodes is currently acting as the <span class="emphasis"><em>coordinator</em></span> (the node responsible for letting new nodes join the group). Discovery protocols are used to find active nodes in the cluster and to determine which is the coordinator. This information is then provided to the group membership protocol (GMS), which communicates with the coordinator's GMS to add the newly-connecting node to the group. (For more information about group membership protocols, see <a class="xref" href="#jgroups-other-gms">Section25.1.6, Group Membership (GMS)</a>.)
			</div><div class="para">
				Discovery protocols also assist merge protocols (see <a class="xref" href="#jgroups-other-merge">Section25.5, Merging (MERGE2)</a>) to detect cluster-split situations.
			</div><div class="para">
				The discovery protocols sit on top of the transport protocol, so you can choose to use different discovery protocols depending on your transport protocol. These are also configured as sub-elements in the JGroups <code class="literal">&lt;config&gt;</code> element.
			</div><div class="section" id="jgroups-discovery-ping"><div class="titlepage"><div><div><h4 class="title">25.1.3.1.PING</h4></div></div></div><div class="para">
					PING is a discovery protocol that works by either multicasting PING requests to an IP multicast address or connecting to a gossip router. As such, PING normally sits on top of the UDP or TUNNEL transport protocols. Each node responds with a packet {C, A}, where C=coordinator's address and A=own address. After timeout milliseconds or num_initial_members replies, the joiner determines the coordinator from the responses, and sends a JOIN request to it (handled by). If nobody responds, we assume we are the first member of a group.
				</div><div class="para">
					Here is an example PING configuration for IP multicast.
				</div><pre class="programlisting">&lt;PING timeout="2000"
    num_initial_members="3"/&gt;
</pre><div class="para">
					Here is another example PING configuration for contacting a Gossip Router.
				</div><pre class="programlisting">&lt;PING gossip_host="localhost"
      gossip_port="1234"
       timeout="2000" 
      num_initial_members="3"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">PING</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for any responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the maximum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_host</strong></span> specifies the host on which the GossipRouter is running.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_port</strong></span> specifies the port on which the GossipRouter is listening on.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gossip_refresh</strong></span> specifies the interval (in milliseconds) for the lease from the GossipRouter. The default is 20000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-separated list of addresses or ports (for example, <code class="literal">host1[12345],host2[23456]</code>) which are pinged for discovery. Default is <code class="literal">null</code>, meaning multicast discovery should be used. If <code class="literal">initial_hosts</code> is specified, you must list all possible cluster members, not just a few well-known hosts, or <code class="literal">MERGE2</code> cluster split discovery will not work reliably.
						</div></li></ul></div><div class="para">
					If both <code class="literal">gossip_host</code> and <code class="literal">gossip_port</code> are defined, the cluster uses the GossipRouter for the initial discovery. If the <code class="literal">initial_hosts</code> is specified, the cluster pings that static list of addresses for discovery. Otherwise, the cluster uses IP multicasting for discovery.
				</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						The discovery phase returns when the <code class="literal">timeout</code> ms have elapsed or the <code class="literal">num_initial_members</code> responses have been received.
					</div></div></div></div><div class="section" id="jgroups-discovery-tcpgossip"><div class="titlepage"><div><div><h4 class="title">25.1.3.2.TCPGOSSIP</h4></div></div></div><div class="para">
					The TCPGOSSIP protocol only works with a GossipRouter. It works essentially the same way as the PING protocol configuration with valid <code class="literal">gossip_host</code> and <code class="literal">gossip_port</code> attributes. It works on top of both UDP and TCP transport protocols. Here is an example.
				</div><pre class="programlisting">&lt;TCPGOSSIP timeout="2000"
       num_initial_members="3"
       initial_hosts="192.168.5.1[12000],192.168.0.2[12000]"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">TCPGOSSIP</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for any responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the maximum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-separated list of addresses/ports (for example, <code class="literal">host1[12345],host2[23456]</code>) of <code class="literal">GossipRouter</code>s to register
						</div></li></ul></div></div><div class="section" id="jgroups-discovery-tcpping"><div class="titlepage"><div><div><h4 class="title">25.1.3.3.TCPPING</h4></div></div></div><div class="para">
					The TCPPING protocol takes a set of known members and pings them for discovery. This is essentially a static configuration. It works on top of TCP. Here is an example of the <code class="literal">TCPPING</code> configuration element in the JGroups <code class="literal">config</code> element.
				</div><pre class="programlisting">&lt;TCPPING timeout="2000"
     num_initial_members="3"/
     initial_hosts="hosta[2300],hostb[3400],hostc[4500]"
     port_range="3"&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">TCPPING</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for any responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the maximum number of responses to wait for unless timeout has expired. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>initial_hosts</strong></span> is a comma-seperated list of addresses (for example, <code class="literal">host1[12345],host2[23456]</code>) for pinging.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>port_range</strong></span> specifies the number of consecutive ports to be probed when getting the initial membership, starting with the port specified in the <code class="varname">initial_hosts</code> parameter. Given the current values of <code class="literal">port_range</code> and <code class="literal">initial_hosts</code> above, the <code class="literal">TCPPING</code> layer will try to connect to <code class="literal">hosta[2300]</code>, <code class="literal">hosta[2301]</code>, <code class="literal">hosta[2302]</code>, <code class="literal">hostb[3400]</code>, <code class="literal">hostb[3401]</code>, <code class="literal">hostb[3402]</code>, <code class="literal">hostc[4500]</code>, <code class="literal">hostc[4501]</code>, and <code class="literal">hostc[4502]</code>. This configuration option allows for multiple possible ports on the same host to be pinged without having to spell out all possible combinations. If in your TCP protocol configuration your <code class="literal">end_port</code> is greater than your <code class="literal">start_port</code>, we recommend using a TCPPING <code class="literal">port_range</code> equal to the difference, to ensure a node is pinged no matter which port it is bound to within the allowed range.
						</div></li></ul></div></div><div class="section" id="jgroups-discovery-mping"><div class="titlepage"><div><div><h4 class="title">25.1.3.4.MPING</h4></div></div></div><div class="para">
					<code class="literal">MPING</code> uses IP multicast to discover the initial membership. Unlike the other discovery protocols, which delegate the sending and receiving of discovery messages on the network to the transport protocol, <code class="literal">MPING</code> opens its own sockets to send and receive multicast discovery messages. As a result it can be used with all transports, but it is most often used with <code class="literal">TCP</code>. <code class="literal">TCP</code> usually requires <code class="literal">TCPPING</code>, which must explicitly list all possible group members. <code class="literal">MPING</code> does not have this requirement, and is typically used where <code class="literal">TCP</code> is required for regular message transport, and UDP multicasting is allowed for discovery.
				</div><pre class="programlisting">
&lt;MPING timeout="2000"
    num_initial_members="3"
    bind_to_all_interfaces="true"
    mcast_addr="228.8.8.8"
    mcast_port="7500"
    ip_ttl="8"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">MPING</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for any responses. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>num_initial_members</strong></span> specifies the maximum number of responses to wait for unless timeout has expired. The default is 2..
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface on which to send and receive multicast packets. By default JGroups uses the value of the system property <code class="literal">jgroups.bind_addr</code>, which can be set with the <code class="code">-b</code> command line switch. See <a class="xref" href="#jgroups-other">Section25.6, Other Configuration Issues</a> for more on binding JGroups sockets.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_to_all_interfaces</strong></span> overrides the <code class="literal">bind_addr</code> and uses all interfaces in multihome nodes.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>mcast_addr, mcast_port, ip_ttl</strong></span> attributes are the same as related attributes in the UDP protocol configuration.
						</div></li></ul></div></div></div><div class="section" id="jgroups-fd"><div class="titlepage"><div><div><h3 class="title">25.1.4.Failure Detection Protocols</h3></div></div></div><div class="para">
				The failure detection protocols are used to detect failed nodes. Once a failed node is detected, a <span class="emphasis"><em>suspect verification</em></span> phase can occur. If the node is still considered dead after this phase is complete, the cluster updates its membership view so that further messages are not sent to the failed node. The service using JGroups is informed that the node is no longer part of the cluster. Failure detection protocols are configured as sub-elements in the JGroups <code class="literal">&lt;config&gt;</code> element.
			</div><div class="section" id="jgroups-fd-fd"><div class="titlepage"><div><div><h4 class="title">25.1.4.1.FD</h4></div></div></div><div class="para">
					<code class="literal">FD</code> is a failure detection protocol based on 'heartbeat' messages. This protocol requires that each node periodically ping its neighbour. If the neighbour fails to respond, the calling node sends a <code class="literal">SUSPECT</code> message to the cluster. The current group coordinator can optionally verify that the suspected node is dead (<code class="literal">VERIFY_SUSPECT</code>). If the node is still considered dead after this verification step, the coordinator updates the cluster's membership view. The following is an example of <code class="literal">FD</code> configuration:
				</div><pre class="programlisting">
&lt;FD timeout="6000"
    max_tries="5"
    shun="true"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">FD</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the maximum number of milliseconds to wait for the responses to the are-you-alive messages. The default is 3000.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max_tries</strong></span> specifies the number of missed are-you-alive messages from a node before the node is suspected. The default is 2.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>shun</strong></span> specifies whether a failed node will be forbidden from sending messages to the group without formally rejoining. A shunned node would need to rejoin the cluster via the discovery process. JGroups allows applications to configure a channel such that, when a channel is shunned, the process of rejoining the cluster and transferring state takes place automatically. (This is default behavior for JBoss Application Server.)
						</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						Regular traffic from a node is proof of life, so heartbeat messages are only sent when no regular traffic is detected on the node for a long period of time.
					</div></div></div></div><div class="section" id="jgroups-fd-fdsock"><div class="titlepage"><div><div><h4 class="title">25.1.4.2.FD_SOCK</h4></div></div></div><div class="para">
					<code class="literal">FD_SOCK</code> is a failure detection protocol based on a ring of TCP sockets created between group members. Each member in a group connects to its neighbor, with the final member connecting to the first, forming a ring. Node B becomes suspected when its neighbour, Node A, detects an abnormally closed TCP socket, presumably due to a crash in Node B. (When nodes intend to leave the group, they inform their neighbours so that they do not become suspected.)
				</div><div class="para">
					The simplest <code class="literal">FD_SOCK</code> configuration does not take any attribute. You can declare an empty <code class="literal">FD_SOCK</code> element in the JGroups <code class="literal">&lt;config&gt;</code> element.
				</div><pre class="programlisting">
&lt;FD_SOCK/&gt;
</pre><div class="para">
					The attributes available to the <code class="literal">FD_SOCK</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>bind_addr</strong></span> specifies the interface to which the server socket should be bound. By default, JGroups uses the value of the system property <code class="literal">jgroups.bind_addr</code>. This system property can be set with the <code class="code">-b</code> command line switch. For more information about binding JGroups sockets, see <a class="xref" href="#jgroups-other">Section25.6, Other Configuration Issues</a>.
						</div></li></ul></div></div><div class="section" id="idm139946651266304"><div class="titlepage"><div><div><h4 class="title">25.1.4.3.VERIFY_SUSPECT</h4></div></div></div><div class="para">
					This protocol verifies whether a suspected member is really dead by pinging that member once again. This verification is performed by the coordinator of the cluster. The suspected member is dropped from the cluster group if confirmed to be dead. The aim of this protocol is to minimize false suspicions. Here's an example.
				</div><pre class="programlisting">   
&lt;VERIFY_SUSPECT timeout="1500"/&gt;
</pre><div class="para">
					The available attributes in the <code class="literal">VERIFY_SUSPECT</code> element are listed below.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies how long to wait for a response from the suspected member before considering it dead.
						</div></li></ul></div></div><div class="section" id="idm139946651260896"><div class="titlepage"><div><div><h4 class="title">25.1.4.4.FD versus FD_SOCK</h4></div></div></div><div class="para">
					FD and FD_SOCK, each taken individually, do not provide a solid failure detection layer. Let's look at the the differences between these failure detection protocols to understand how they complement each other:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="emphasis"><em>FD</em></span>
						</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
									An overloaded machine might be slow in sending are-you-alive responses.
								</div></li><li class="listitem"><div class="para">
									A member will be suspected when suspended in a debugger/profiler.
								</div></li><li class="listitem"><div class="para">
									Low timeouts lead to higher probability of false suspicions and higher network traffic.
								</div></li><li class="listitem"><div class="para">
									High timeouts will not detect and remove crashed members for some time.
								</div></li></ul></div></li><li class="listitem"><div class="para">
							<span class="emphasis"><em>FD_SOCK</em></span>:
						</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
									Suspended in a debugger is no problem because the TCP connection is still open.
								</div></li><li class="listitem"><div class="para">
									High load no problem either for the same reason.
								</div></li><li class="listitem"><div class="para">
									Members will only be suspected when TCP connection breaks, so hung members will not be detected.
								</div></li><li class="listitem"><div class="para">
									Also, a crashed switch will not be detected until the connection runs into the TCP timeout (between 2-20 minutes, depending on TCP/IP stack implementation).
								</div></li></ul></div></li></ul></div><div class="para">
					A failure detection layer is intended to report real failures promptly, while avoiding false suspicions. There are two solutions:
				</div><div class="orderedlist"><ol><li class="listitem"><div class="para">
							By default, JGroups configures the FD_SOCK socket with KEEP_ALIVE, which means that TCP sends a heartbeat on socket on which no traffic has been received in 2 hours. If a host crashed (or an intermediate switch or router crashed) without closing the TCP connection properly, we would detect this after 2 hours (plus a few minutes). This is of course better than never closing the connection (if KEEP_ALIVE is off), but may not be of much help. So, the first solution would be to lower the timeout value for KEEP_ALIVE. This can only be done for the entire kernel in most operating systems, so if this is lowered to 15 minutes, this will affect all TCP sockets.
						</div></li><li class="listitem"><div class="para">
							The second solution is to combine FD_SOCK and FD; the timeout in FD can be set such that it is much lower than the TCP timeout, and this can be configured individually per process. FD_SOCK will already generate a suspect message if the socket was closed abnormally. However, in the case of a crashed switch or host, FD will make sure the socket is eventually closed and the suspect message generated. Example:
						</div></li></ol></div><pre class="programlisting">&lt;FD_SOCK/&gt;
&lt;FD timeout="6000" max_tries="5" shun="true"/&gt;
&lt;VERIFY_SUSPECT timeout="1500"/&gt;
</pre><div class="para">
					In this example, a member becomes suspected when the neighbouring socket has been closed abnormally, in a process crash, for instance, since the operating system closes all sockets. However, if a host or switch crashes, the sockets will not be closed. <code class="literal">FD</code> will suspect the neighbour after sixty seconds (<code class="literal">6000</code> milliseconds). Note that if this example system were stopped in a breakpoint in the debugger, the node being debugged will be suspected once the <code class="varname">timeout</code> has elapsed.
				</div><div class="para">
					A combination of <code class="literal">FD</code> and <code class="literal">FD_SOCK</code> provides a solid failure detection layer, which is why this technique is used across the JGroups configurations included with JBoss Application Server.
				</div></div></div><div class="section" id="jgroups-reliable"><div class="titlepage"><div><div><h3 class="title">25.1.5.Reliable Delivery Protocols</h3></div></div></div><div class="para">
				Reliable delivery protocols within the JGroups stack ensure that messages are actually delivered, and delivered in the correct order (First In, First Out, or FIFO) to the destination node. The basis for reliable message delivery is positive and negative delivery acknowledgments (ACK and NAK). In <code class="literal">ACK</code> mode, the sender resends the message until acknowledgment is received from the receiver. In <code class="literal">NAK</code> mode, the receiver requests retransmission when it discovers a gap.
			</div><div class="section" id="jgroups-reliable-unicast"><div class="titlepage"><div><div><h4 class="title">25.1.5.1.UNICAST</h4></div></div></div><div class="para">
					The <code class="literal">UNICAST</code> protocol is used for unicast messages. It uses positive acknowlegements (<code class="literal">ACK</code>). It is configured as a sub-element under the JGroups <code class="literal">config</code> element. If the JGroups stack is configured with the TCP transport protocol, <code class="literal">UNICAST</code> is not necessary because TCP itself guarantees FIFO delivery of unicast messages. Here is an example configuration for the <code class="literal">UNICAST</code> protocol:
				</div><pre class="programlisting">
&lt;UNICAST timeout="300,600,1200,2400,3600"/&gt;
</pre><div class="para">
					There is only one configurable attribute in the <code class="literal">UNICAST</code> element.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>timeout</strong></span> specifies the retransmission timeout (in milliseconds). For instance, if the timeout is <code class="literal">100,200,400,800</code>, the sender resends the message if it has not received an <code class="literal">ACK</code> after 100 milliseconds the first time, and the second time it waits for 200 milliseconds before resending, and so on. A low value for the first timeout allows for prompt retransmission of dropped messages, but means that messages may be transmitted more than once if they have not actually been lost (that is, the message has been sent, but the <code class="literal">ACK</code> has not been received before the timeout). High values (<code class="literal">1000,2000,3000</code>) can improve performance if the network is tuned such that UDP datagram loss is infrequent. High values on networks with frequent losses will be harmful to performance, since later messages will not be delivered until lost messages have been retransmitted.
						</div></li></ul></div></div><div class="section" id="jgroups-reliable-nakack"><div class="titlepage"><div><div><h4 class="title">25.1.5.2.NAKACK</h4></div></div></div><div class="para">
					The <code class="literal">NAKACK</code> protocol is used for multicast messages. It uses negative acknowlegements (<code class="literal">NAK</code>). Under this protocol, each message is tagged with a sequence number. The receiver keeps track of the received sequence numbers and delivers the messages in order. When a gap in the series of received sequence numbers is detected, the receiver schedules a task to periodically ask the sender to retransmit the missing message. The task is cancelled if the missing message is received. <code class="literal">NAKACK</code> protocol is configured as the <code class="literal">pbcast.NAKACK</code> sub-element under the JGroups <code class="literal">&lt;config&gt;</code> element. Here is an example configuration:
				</div><pre class="programlisting">
&lt;pbcast.NAKACK max_xmit_size="60000" use_mcast_xmit="false" 
   retransmit_timeout="300,600,1200,2400,4800" gc_lag="0"
   discard_delivered_msgs="true"/&gt;
</pre><div class="para">
					The configurable attributes in the <code class="literal">pbcast.NAKACK</code> element are as follows.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>retransmit_timeout</strong></span> specifies the series of timeouts (in milliseconds) after which retransmission is requested if a missing message has not yet been received.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>use_mcast_xmit</strong></span> determines whether the sender should send the retransmission to the entire cluster rather than just to the node requesting it. This is useful when the <span class="emphasis"><em>sender</em></span>'s network layer tends to drop packets, avoiding the need to individually retransmit to each node.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>max_xmit_size</strong></span> specifies the maximum size (in bytes) for a bundled retransmission, if multiple messages are reported missing.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>discard_delivered_msgs</strong></span> specifies whether to discard delivered messages on the receiver nodes. By default, nodes save delivered messages so any node can retransmit a lost message in case the original sender has crashed or left the group. However, if we only ask the sender to resend its messages, we can enable this option and discard delivered messages.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>gc_lag</strong></span> specifies the number of messages to keep in memory for retransmission, even after the periodic cleanup protocol (see <a class="xref" href="#jgroups-other-gc">Section25.4, Distributed Garbage Collection (STABLE)</a>) indicates all peers have received the message. The default value is <code class="literal">20</code>.
						</div></li></ul></div></div></div><div class="section" id="jgroups-other-gms"><div class="titlepage"><div><div><h3 class="title">25.1.6.Group Membership (GMS)</h3></div></div></div><div class="para">
				The group membership service (GMS) protocol in the JGroups stack maintains a list of active nodes. It handles the requests to join and leave the cluster. It also handles the SUSPECT messages sent by failure detection protocols. All nodes in the cluster, as well as any interested services like JBoss Cache or HAPartition, are notified if the group membership changes. The group membership service is configured in the <code class="literal">pbcast.GMS</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
			</div><pre class="programlisting">
&lt;pbcast.GMS print_local_addr="true"
    join_timeout="3000"
    join_retry_timeout="2000"
    shun="true"
    view_bundling="true"/&gt;
</pre><div class="para">
				The configurable attributes in the <code class="literal">pbcast.GMS</code> element are as follows.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>join_timeout</strong></span> specifies the maximum number of milliseconds to wait for a new node JOIN request to succeed. Retry afterwards.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>join_retry_timeout</strong></span> specifies the number of milliseconds to wait after a failed JOIN before trying again.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>print_local_addr</strong></span> specifies whether to dump the node's own address to the standard output when started.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>shun</strong></span> specifies whether a node should shun (that is, disconnect) itself if it receives a cluster view in which it is not a member node.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>disable_initial_coord</strong></span> specifies whether to prevent this node from becoming the cluster coordinator during the initial connection of the channel. This flag does not prevent a node becoming the coordinator after the initial channel connection, if the current coordinator leaves the group.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>view_bundling</strong></span> specifies whether multiple JOIN or LEAVE requests arriving at the same time are bundled and handled together at the same time, resulting in only one new view that incorporates all changes. This is is more efficient than handling each request separately.
					</div></li></ul></div></div><div class="section" id="jgroups-other-fc"><div class="titlepage"><div><div><h3 class="title">25.1.7.Flow Control (FC)</h3></div></div></div><div class="para">
				The flow control (FC) protocol tries to adapt the data sending rate to the data receipt rate among nodes. If a sender node is too fast, it might overwhelm the receiver node and result in out-of-memory conditions or dropped packets that have to be retransmitted. In JGroups, flow control is implemented via a credit-based system. The sender and receiver nodes have the same number of credits (bytes) to start with. The sender subtracts credits by the number of bytes in messages it sends. The receiver accumulates credits for the bytes in the messages it receives. When the sender's credit drops to a threshold, the receivers send some credit to the sender. If the sender's credit is used up, the sender blocks until it receives credits from the receiver. The flow control protocol is configured in the <code class="literal">FC</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
			</div><pre class="programlisting">
&lt;FC max_credits="2000000"
    min_threshold="0.10" 
    ignore_synchronous_response="true"/&gt;
</pre><div class="para">
				The configurable attributes in the <code class="literal">FC</code> element are as follows.
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>max_credits</strong></span> specifies the maximum number of credits (in bytes). This value should be smaller than the JVM heap size.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>min_credits</strong></span> specifies the minimum number of bytes that must be received before the receiver will send more credits to the sender.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>min_threshold</strong></span> specifies the percentage of the <code class="literal">max_credits</code> that should be used to calculate <code class="literal">min_credits</code>. Setting this overrides the <code class="literal">min_credits</code> attribute.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>ignore_synchronous_response</strong></span> specifies whether threads that have carried messages up to the application should be allowed to carry outgoing messages back down through FC without blocking for credits. <span class="emphasis"><em>Synchronous response</em></span> refers to the fact that these messages are generally responses to incoming RPC-type messages. Forbidding JGroups threads to carry messages up to block in FC can help prevent certain deadlock scenarios, so we recommend setting this to <code class="literal">true</code>.
					</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					FC is required for group communication where group messages must be sent at the highest speed that the slowest receiver can handle. For example, say we have a cluster comprised of nodes A, B, C and D. D is slow (perhaps overloaded), while the rest are fast. When A sends a group message, it does so via TCP connections: A-A (theoretically), A-B, A-C and A-D.
				</div><div class="para">
					Say A sends 100 million messages to the cluster. TCP's flow control applies to A-B, A-C and A-D individually, but not to A-BCD as a group. Therefore, A, B and C will receive the 100 million messages, but D will receive only 1 million. (This is also why <code class="literal">NAKACK</code> is required, even though TCP handles its own retransmission.)
				</div><div class="para">
					JGroups must buffer all messages in memory in case an original sender <span class="emphasis"><em>S</em></span> dies and a node requests retransmission of a message sent by <span class="emphasis"><em>S</em></span>. Since all members buffer all messages that they receive, stable messages (messages seen by every node) must sometimes be purged. (The purging process is managed by the <code class="literal">STABLE</code> protocol. For more information, see <a class="xref" href="#jgroups-other-gc">Section25.4, Distributed Garbage Collection (STABLE)</a>.)
				</div><div class="para">
					In the above case, the slow node D will prevent the group from purging messages above 1M, so every member will buffer 99M messages ! This in most cases leads to OOM exceptions. Note that - although the sliding window protocol in TCP will cause writes to block if the window is full - we assume in the above case that this is still much faster for A-B and A-C than for A-D.
				</div><div class="para">
					So, in summary, even with TCP we need to FC to ensure we send messages at a rate the slowest receiver (D) can handle.
				</div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					This depends on how the application uses the JGroups channel. Referring to the example above, if there was something about the application that would naturally cause A to slow down its rate of sending because D wasn't keeping up, then FC would not be needed.
				</div><div class="para">
					A good example of such an application is one that uses JGroups to make synchronous group RPC calls. By synchronous, we mean the thread that makes the call blocks waiting for responses from all the members of the group. In that kind of application, the threads on A that are making calls would block waiting for responses from D, thus naturally slowing the overall rate of calls.
				</div><div class="para">
					A JBoss Cache cluster configured for REPL_SYNC is a good example of an application that makes synchronous group RPC calls. If a channel is only used for a cache configured for REPL_SYNC, we recommend you remove FC from its protocol stack.
				</div><div class="para">
					And, of course, if your cluster only consists of two nodes, including FC in a TCP-based protocol stack is unnecessary. There is no group beyond the single peer-to-peer relationship, and TCP's internal flow control will handle that just fine.
				</div><div class="para">
					Another case where FC may not be needed is for a channel used by a JBoss Cache configured for buddy replication and a single buddy. Such a channel will in many respects act like a two node cluster, where messages are only exchanged with one other node, the buddy. (There may be other messages related to data gravitation that go to all members, but in a properly engineered buddy replication use case these should be infrequent. But if you remove FC be sure to load test your application.)
				</div></div></div></div></div><div class="section" id="idm139946652629312"><div class="titlepage"><div><div><h2 class="title">25.2.Fragmentation (FRAG2)</h2></div></div></div><div class="para">
			This protocol fragments messages that are larger than a certain size, and reassembles them at the receiver's side. It works for both unicast and multicast messages. It is configured with the <code class="literal">FRAG2</code> sub-element in the JGroups <code class="literal">config</code> element. Here is an example configuration:
		</div><pre class="programlisting">  
      &lt;FRAG2 frag_size="60000"/&gt;
</pre><div class="para">
			The configurable attributes in the FRAG2 element are as follows.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>frag_size</strong></span> specifies the maximum message size (in bytes) before fragmentation occurs. Messages larger than this size are fragmented. For stacks that use the UDP transport, this value must be lower than 64 kilobytes (the maximum UDP datagram size). For TCP-based stacks, it must be lower than the value of <code class="varname">max_credits</code> in the FC protocol.
				</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				TCP protocol already provides fragmentation, but a JGroups fragmentation protocol is still required if FC is used. The reason for this is that if you send a message larger than <code class="literal">FC.max_credits</code>, the FC protocol will block forever. So, <code class="literal">frag_size</code> within FRAG2 must always be set to a value lower than that of <code class="literal">FC.max_credits</code>.
			</div></div></div></div><div class="section" id="jgroups-other-st"><div class="titlepage"><div><div><h2 class="title">25.3.State Transfer</h2></div></div></div><div class="para">
			The state transfer service transfers the state from an existing node (i.e., the cluster coordinator) to a newly joining node. It is configured in the <code class="literal">pbcast.STATE_TRANSFER</code> sub-element under the JGroups <code class="literal">Config</code> element. It does not have any configurable attribute. Here is an example configuration.
		</div><pre class="programlisting">
&lt;pbcast.STATE_TRANSFER/&gt;
</pre></div><div class="section" id="jgroups-other-gc"><div class="titlepage"><div><div><h2 class="title">25.4.Distributed Garbage Collection (STABLE)</h2></div></div></div><div class="para">
			In a JGroups cluster, all nodes must store all messages received for potential retransmission in case of a failure. However, if we store all messages forever, we will run out of memory. The distributed garbage collection service periodically purges messages that have been seen by all nodes, removing them from the memory in each node. The distributed garbage collection service is configured in the <code class="literal">pbcast.STABLE</code> sub-element under the JGroups <code class="literal">config</code> element. Here is an example configuration.
		</div><pre class="programlisting">
&lt;pbcast.STABLE stability_delay="1000"
    desired_avg_gossip="5000" 
    max_bytes="400000"/&gt;
</pre><div class="para">
			The configurable attributes in the <code class="literal">pbcast.STABLE</code> element are as follows.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>desired_avg_gossip</strong></span> specifies intervals (in milliseconds) of garbage collection runs. Set this to <code class="literal">0</code> to disable interval-based garbage collection.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>max_bytes</strong></span> specifies the maximum number of bytes received before the cluster triggers a garbage collection run. Set to <code class="literal">0</code> to disable garbage collection based on the bytes received.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>stability_delay</strong></span> specifies the maximum time period (in milliseconds) of a random delay introduced before a node sends its <code class="literal">STABILITY</code> message at the end of a garbage collection run. The delay gives other nodes concurrently running a <code class="literal">STABLE</code> task a chance to send first. If used together with <code class="literal">max_bytes</code>, this attribute should be set to a small number.
				</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Set the <code class="literal">max_bytes</code> attribute when you have a high traffic cluster.
			</div></div></div></div><div class="section" id="jgroups-other-merge"><div class="titlepage"><div><div><h2 class="title">25.5.Merging (MERGE2)</h2></div></div></div><div class="para">
			When a network error occurs, the cluster might be partitioned into several different partitions. JGroups has a MERGE service that allows the coordinators in partitions to communicate with each other and form a single cluster back again. The merging service is configured in the <code class="literal">MERGE2</code> sub-element under the JGroups <code class="literal">Config</code> element. Here is an example configuration.
		</div><pre class="programlisting">
&lt;MERGE2 max_interval="10000"
    min_interval="2000"/&gt;
</pre><div class="para">
			The configurable attributes in the <code class="literal">MERGE2</code> element are as follows.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<span class="bold bold"><strong>max_interval</strong></span> specifies the maximum number of milliseconds to wait before sending a MERGE message.
				</div></li><li class="listitem"><div class="para">
					<span class="bold bold"><strong>min_interval</strong></span> specifies the minimum number of milliseconds to wait before sending a MERGE message.
				</div></li></ul></div><div class="para">
			JGroups chooses a random value between <code class="literal">min_interval</code> and <code class="literal">max_interval</code> to periodically send the MERGE message.
		</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The application state maintained by the application using a channel is not merged by JGroups during a merge. This must be done by the application.
			</div></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				If <code class="literal">MERGE2</code> is used in conjunction with <code class="literal">TCPPING</code>, the <code class="literal">initial_hosts</code> attribute must contain all the nodes that could potentially be merged back, in order for the merge process to work properly. Otherwise, the merge process may not detect all sub-groups, and may miss those comprised solely of unlisted members.
			</div></div></div></div><div class="section" id="jgroups-other"><div class="titlepage"><div><div><h2 class="title">25.6.Other Configuration Issues</h2></div></div></div><div class="section" id="idm139946653403472"><div class="titlepage"><div><div><h3 class="title">25.6.1.Binding JGroups Channels to a Particular Interface</h3></div></div></div><div class="para">
				In the Transport Protocols section above, we briefly touched on how the interface to which JGroups will bind sockets is configured. Let's get into this topic in more depth:
			</div><div class="para">
				First, it is important to understand that the value set in any <code class="literal">bind_addr</code> element in an XML configuration file will be ignored by JGroups if it finds that the system property <code class="literal">jgroups.bind_addr</code> (or a deprecated earlier name for the same thing, <code class="literal">bind.address</code>) has been set. The system property has a higher priority level than the XML property. If JBoss Application Server is started with the <code class="literal">-b</code> (or <code class="literal">--host</code>) switch, the application server will set <code class="literal">jgroups.bind_addr</code> to the specified value. If <code class="literal">-b</code> is not set, the application server will bind most services to <code class="literal">localhost</code> by default.
			</div><div class="para">
				So, what are <span class="emphasis"><em>best practices</em></span> for managing how JGroups binds to interfaces?
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						Binding JGroups to the same interface as other services. Simple, just use <code class="literal">-b</code>:
					</div><pre class="screen">./run.sh -b 192.168.1.100 -c all</pre></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to one interface, but use a different one for JGroups:
					</div><pre class="screen">./run.sh -b 10.0.0.100 -Djgroups.bind_addr=192.168.1.100 -c all</pre><div class="para">
						Specifically setting the system property overrides the <code class="literal">-b</code> value. This is a common usage pattern; put client traffic on one network, with intra-cluster traffic on another.
					</div></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to all interfaces. This can be done like this: 
<pre class="screen">./run.sh -b 0.0.0.0 -c all</pre>
						 However, doing this will not cause JGroups to bind to all interfaces! Instead , JGroups will bind to the machine's default interface. See the Transport Protocols section for how to tell JGroups to receive or send on all interfaces, if that is what you really want.
					</div></li><li class="listitem"><div class="para">
						Binding services (e.g., JBoss Web) to all interfaces, but specify the JGroups interface:
					</div><pre class="screen">./run.sh -b 0.0.0.0 -Djgroups.bind_addr=192.168.1.100 -c all</pre><div class="para">
						Again, specifically setting the system property overrides the <code class="literal">-b</code> value.
					</div></li><li class="listitem"><div class="para">
						Using different interfaces for different channels:
					</div><pre class="screen">./run.sh -b 10.0.0.100 -Djgroups.ignore.bind_addr=true -c all</pre></li></ul></div><div class="para">
				This setting tells JGroups to ignore the <code class="literal">jgroups.bind_addr</code> system property, and instead use whatever is specfied in XML. You would need to edit the various XML configuration files to set the various <code class="literal">bind_addr</code> attributes to the desired interfaces.
			</div></div><div class="section" id="clustering-jgroups-isolation"><div class="titlepage"><div><div><h3 class="title">25.6.2.Isolating JGroups Channels</h3></div></div></div><div class="para">
				Within JBoss Application Server, there are a number of services that independently create JGroups channels  possibly multiple different JBoss Cache services (used for <code class="literal">HttpSession</code> replication, EJB3 stateful session bean replication and EJB3 entity replication), two JBoss Messaging channels, and <span class="application"><strong>HAPartition</strong></span>, the general purpose clustering service that underlies most other JBossHA services.
			</div><div class="para">
				It is critical that these channels only communicate with their intended peers; not with the channels used by other services and not with channels for the same service opened on machines not meant to be part of the group. Nodes improperly communicating with each other is one of the most common issues users have with JBoss Enterprise Application Platform clustering.
			</div><div class="para">
				Whom a JGroups channel will communicate with is defined by its group name and, for UDP-based channels, its multicast address and port. Isolating a JGroups channel means ensuring that different channels use different values for the group name, the multicast address and, in some cases, the multicast port.
			</div><div class="section" id="idm139946653379360"><div class="titlepage"><div><div><h4 class="title">25.6.2.1.Isolating sets of Application Server instances from each other</h4></div></div></div><div class="para">
					This section addresses the issue of having multiple independent clusters running within the same environment. For example, you might have a production cluster, a staging cluster, and a QA cluster, or multiple clusters in a QA test lab or development team environment.
				</div><div class="para">
					To isolate JGroups clusters from other clusters on the network, you must:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							Make sure the channels in the various clusters use different group names. This can be controlled with the command line arguments used to start JBoss; see <a class="xref" href="#clustering-jgroups-isolation-group-name">Section25.6.2.2.1, Changing the Group Name</a> for more information.
						</div></li><li class="listitem"><div class="para">
							Make sure the channels in the various clusters use different multicast addresses. This is also easy to control with the command line arguments used to start JBoss.
						</div></li><li class="listitem"><div class="para">
							If you are not running on Linux, Windows, Solaris or HP-UX, you may also need to ensure that the channels in each cluster use different multicast ports. This is more difficult than using different group names, although it can still be controlled from the command line. See <a class="xref" href="#clustering-jgroups-isolation-mcast_port">Section25.6.2.2.3, Changing the Multicast Port</a>. Note that using different ports should not be necessary if your servers are running on Linux, Windows, Solaris or HP-UX.
						</div></li></ul></div></div><div class="section" id="idm139946653371568"><div class="titlepage"><div><div><h4 class="title">25.6.2.2.Isolating Channels for Different Services on the Same Set of AS Instances</h4></div></div></div><div class="para">
					This section addresses the usual case: a cluster of three machines, each of which has, for example, an HAPartition deployed alongside JBoss Cache for web session clustering. The HAPartition channels should not communicate with the JBoss Cache channels. Ensuring proper isolation of these channels is straightforward, and is usually handled by the application server without any alterations on the part of the user.
				</div><div class="para">
					To isolate channels for different services from each other on the same set of application server instances, each channel must have its own group name. The configurations that ship with JBoss Application Server ensure that this is the case. However, if you create a custom service that uses JGroups directly, you must use a unique group name. If you create a custom JBoss Cache configuration, ensure that you provide a unique value in the <code class="literal">clusterName</code> configuration property.
				</div><div class="para">
					In releases prior to JBoss Application Server 5, different channels running in the same application server also had to use unique multicast ports. With the JGroups shared transport introduced in JBoss AS 5 (see <a class="xref" href="#clustering-blocks-jgroups-sharedtransport">Section18.1.2, The JGroups Shared Transport</a>), it is now common for multiple channels to use the same tranpsort protocol and its sockets. This makes configuration easier, which is one of the main benefits of the shared transport. However, if you decide to create your own custom JGroups protocol stack configuration, be sure to configure its transport protocols with a multicast port that is different from the ports used in other protocol stacks.
				</div><div class="section" id="clustering-jgroups-isolation-group-name"><div class="titlepage"><div><div><h5 class="title">25.6.2.2.1.Changing the Group Name</h5></div></div></div><div class="para">
						The group name for a JGroups channel is configured via the service that starts the channel. For all the standard clustered services, we make it easy for you to create unique groups names by simply using the <code class="literal">-g</code> (or <code class="literal">--partition</code>) switch when starting JBoss:
					</div><pre class="screen">./run.sh -g QAPartition -b 192.168.1.100 -c all</pre><div class="para">
						This switch sets the <code class="literal">jboss.partition.name</code> system property, which is used as a component in the configuration of the group name in all the standard clustering configuration files. For example, 
<pre class="programlisting">&lt;property name="clusterName"&gt;${jboss.partition.name:DefaultPartition}-SFSBCache&lt;/property&gt;</pre>

					</div></div><div class="section" id="idm139946653361648"><div class="titlepage"><div><div><h5 class="title">25.6.2.2.2.Changing the multicast address and port</h5></div></div></div><div class="para">
						The <code class="literal">-u</code> (or <code class="literal">--udp</code>) command line switch may be used to control the multicast address used by the JGroups channels opened by all standard AS services. 
<pre class="screen">/run.sh -u 230.1.2.3 -g QAPartition -b 192.168.1.100 -c all</pre>
						 This switch sets the <code class="literal">jboss.partition.udpGroup</code> system property, which is referenced in all of the standard protocol stack configurations in JBoss AS:
					</div><pre class="programlisting">&lt;UDP mcast_addr="${jboss.partition.udpGroup:228.1.2.3}" ....</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							If channels with different group names share the same multicast address and port, the lower level JGroups protocols in each channel will see, process and eventually discard messages intended for the other group. This will at a minimum hurt performance and can lead to anomalous behavior.
						</div></div></div></div><div class="section" id="clustering-jgroups-isolation-mcast_port"><div class="titlepage"><div><div><h5 class="title">25.6.2.2.3.Changing the Multicast Port</h5></div></div></div><div class="para">
						On some operating systems (Mac OS X for example), using different <code class="literal">-g</code> and <code class="literal">-u</code> values is not sufficient to isolate clusters; the channels running in the different clusters must also use different multicast ports. Unfortunately, setting the multicast ports is not as simple as <code class="literal">-g</code> and <code class="literal">-u</code>. By default, a JBoss AS instance running the <code class="literal">all</code> configuration will use up to two different instances of the JGroups UDP transport protocol, and will therefore open two multicast sockets. You can control the ports those sockets use by using system properties on the command line. For example,
					</div><pre class="programlisting">
/run.sh -u 230.1.2.3 -g QAPartition -b 192.168.1.100 -c all \\
        -Djboss.jgroups.udp.mcast_port=12345 -Djboss.messaging.datachanneludpport=23456
</pre><div class="para">
						The <code class="literal">jboss.messaging.datachanneludpport</code> property controls the multicast port used by the <code class="literal">MPING</code> protocol in JBoss Messaging's <code class="literal">DATA</code> channel. The <code class="literal">jboss.jgroups.udp.mcast_port</code> property controls the multicast port used by the UDP transport protocol shared by all other clustered services.
					</div><div class="para">
						The set of JGroups protocol stack configurations included in the <code class="literal">$JBOSS_HOME/server/all/deploy/cluster/jgroups-channelfactory.sar/META-INF/jgroups-channelfactory-stacks.xml</code> file includes a number of other example protocol stack configurations that the standard JBoss AS distribution doesn't actually use. Those configurations also use system properties to set any multicast ports. So, if you reconfigure some AS service to use one of those protocol stack configurations, use the appropriate system property to control the port from the command line.
					</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
							It should be sufficient to just change the address, but unfortunately the handling of multicast sockets is one area where the JVM fails to hide operating system behavior differences from the application. The <code class="literal">java.net.MulticastSocket</code> class provides different overloaded constructors. On some operating systems, if you use one constructor variant, packets addressed to a particular multicast port are delivered to all listeners on that port, regardless of the multicast address on which they are listening. We refer to this as the <span class="emphasis"><em>promiscuous traffic</em></span> problem. On most operating systems that exhibit the promiscuous traffic problem (Linux, Solaris and HP-UX) JGroups can use a different constructor variant that avoids the problem. However, on some operating systems with the promiscuous traffic problem (Mac OS X), multicast does not work properly if the other constructor variant is used. So, on these operating systems the recommendation is to configure different multicast ports for different clusters.
						</div></div></div></div></div><div class="section" id="jgroups-perf-udpbuffer"><div class="titlepage"><div><div><h4 class="title">25.6.2.3.Improving UDP Performance by Configuring OS UDP Buffer Limits</h4></div></div></div><div class="para">
					By default, the JGroups channels in JBoss Enterprise Application Platform use the UDP transport protocol to take advantage of IP multicast. However, one disadvantage of UDP is it does not come with the reliable delivery guarantees provided by TCP. The protocols discussed in <a class="xref" href="#jgroups-reliable">Section25.1.5, Reliable Delivery Protocols</a> allow JGroups to guarantee delivery of UDP messages, but those protocols are implemented in Java, not at the operating system network layer. For peak performance from a UDP-based JGroups channel it is important to limit the need for JGroups to retransmit messages by limiting UDP datagram loss.
				</div><div class="para">
					One of the most common causes of lost UDP datagrams is an undersized receive buffer on the socket. The UDP protocol's <code class="literal">mcast_recv_buf_size</code> and <code class="literal">ucast_recv_buf_size</code> configuration attributes are used to specify the amount of receive buffer JGroups <span class="emphasis"><em>requests</em></span> from the operating system, but the actual size of the buffer the operating system provides is limited by operating system-level maximums. These maximums are often very low:
				</div><div class="table" id="idm139946653047376"><p class="title"><strong>Table25.1.Default Max UDP Buffer Sizes</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Default Max UDP Buffer Sizes"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946653045040" scope="col"> Operating System </th><th id="idm139946653044560" scope="col"> Default Max UDP Buffer (in bytes) </th></tr></thead><tbody><tr><td headers="idm139946653045040"> Linux </td><td headers="idm139946653044560"> 131071 </td></tr><tr><td headers="idm139946653045040"> Windows </td><td headers="idm139946653044560"> No known limit </td></tr><tr><td headers="idm139946653045040"> Solaris </td><td headers="idm139946653044560"> 262144 </td></tr><tr><td headers="idm139946653045040"> FreeBSD, Darwin </td><td headers="idm139946653044560"> 262144 </td></tr><tr><td headers="idm139946653045040"> AIX </td><td headers="idm139946653044560"> 1048576 </td></tr></tbody></table></div></div><div class="para">
					The command used to increase the above limits is operating system-specific. The table below shows the command required to increase the maximum buffer to 25 megabytes. In all cases, root privileges are required:
				</div><div class="table" id="idm139946653035104"><p class="title"><strong>Table25.2.Commands to Change Max UDP Buffer Sizes</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows" summary="Commands to Change Max UDP Buffer Sizes"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946653032768" scope="col"> Operating System </th><th id="idm139946653032288" scope="col"> Command </th></tr></thead><tbody><tr><td headers="idm139946653032768"> Linux </td><td headers="idm139946653032288"> <code class="literal">sysctl -w net.core.rmem_max=26214400</code> </td></tr><tr><td headers="idm139946653032768"> Solaris </td><td headers="idm139946653032288"> <code class="literal">ndd -set /dev/udp udp_max_buf 26214400</code> </td></tr><tr><td headers="idm139946653032768"> FreeBSD, Darwin </td><td headers="idm139946653032288"> <code class="literal">sysctl -w kern.ipc.maxsockbuf=26214400</code> </td></tr><tr><td headers="idm139946653032768"> AIX </td><td headers="idm139946653032288"> <code class="literal">no -o sb_max=8388608</code> (AIX will only allow 1 megabyte, 4 megabytes or 8 megabytes). </td></tr></tbody></table></div></div></div></div><div class="section" id="idm139946653022736"><div class="titlepage"><div><div><h3 class="title">25.6.3.JGroups Troubleshooting</h3></div></div></div><div class="section" id="idm139946653021936"><div class="titlepage"><div><div><h4 class="title">25.6.3.1.Nodes do not form a cluster</h4></div></div></div><div class="para">
					Make sure your machine is set up correctly for IP multicast. There are 2 test programs that can be used to detect this: McastReceiverTest and McastSenderTest. Go to the <code class="literal">$JBOSS_HOME/server/all/lib</code> directory and start McastReceiverTest, for example: 
<pre class="screen">[lib]$ java -cp jgroups.jar org.jgroups.tests.McastReceiverTest -mcast_addr 224.10.10.10 -port 5555</pre>

				</div><div class="para">
					Then in another window start <code class="literal">McastSenderTest</code>: 
<pre class="screen">[lib]$ java -cp jgroups.jar org.jgroups.tests.McastSenderTest -mcast_addr 224.10.10.10 -port 5555</pre>

				</div><div class="para">
					If you want to bind to a specific network interface card (NIC), use <code class="command">-bind_addr <em class="replaceable">192.168.0.2</em></code>, where <em class="replaceable">192.168.0.2</em> is the IP address of the NIC to which you want to bind. Use this parameter in both the sender and the receiver.
				</div><div class="para">
					You should be able to type in the <code class="literal">McastSenderTest</code> window and see the output in the <code class="literal">McastReceiverTest</code> window. If not, try to use <code class="command">-ttl 32</code> in the sender. If this still fails, consult a system administrator to help you setup IP multicast correctly, and ask the admin to make sure that multicast will work on the interface you have chosen or, if the machines have multiple interfaces, ask to be told the correct interface. Once you know multicast is working properly on each machine in your cluster, you can repeat the above test to test the network, putting the sender on one machine and the receiver on another.
				</div></div><div class="section" id="idm139946653013792"><div class="titlepage"><div><div><h4 class="title">25.6.3.2.Causes of missing heartbeats in FD</h4></div></div></div><div class="para">
					Sometimes a member is suspected by FD because a heartbeat ack has not been received for some time T (defined by timeout and max_tries). This can have multiple reasons, e.g. in a cluster of A,B,C,D; C can be suspected if (note that A pings B, B pings C, C pings D and D pings A):
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							B or C are running at 100% CPU for more than T seconds. So even if C sends a heartbeat ack to B, B may not be able to process it because it is at 100%
						</div></li><li class="listitem"><div class="para">
							B or C are garbage collecting, same as above.
						</div></li><li class="listitem"><div class="para">
							A combination of the 2 cases above
						</div></li><li class="listitem"><div class="para">
							The network loses packets. This usually happens when there is a lot of traffic on the network, and the switch starts dropping packets (usually broadcasts first, then IP multicasts, TCP packets last).
						</div></li><li class="listitem"><div class="para">
							B or C are processing a callback. Let's say C received a remote method call over its channel and takes T+1 seconds to process it. During this time, C will not process any other messages, including heartbeats, and therefore B will not receive the heartbeat ack and will suspect C.
						</div></li></ul></div></div></div></div></div><div xml:lang="en-US" class="chapter" id="jbosscache.chapt" lang="en-US"><div class="titlepage"><div><div><h2 class="title">Chapter26.JBoss Cache Configuration and Deployment</h2></div></div></div><div class="para">
		JBoss Cache provides the underlying distributed caching support used by many of the standard clustered services in a JBoss Enterprise Application Platform cluster. You can also deploy JBoss Cache in your own application to handle custom caching requirements. In this chapter we provide some background on the main configuration options available with JBoss Cache, with an emphasis on how those options relate to the JBoss Cache usage by the standard clustered services the Enterprise Application Platform provides. We then discuss the different options available for deploying a custom cache in the Enterprise Application Platform.
	</div><div class="para">
		Users considering deploying JBoss Cache for direct use by their own application are strongly encouraged to read the JBoss Cache documentation available at the <a href="http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/" class="mimir-link-warn" title="Mimir does not include content from: www.redhat.com"> Red Hat Documentation portal</a>.
	</div><div class="para">
		See also <a class="xref" href="#clustering-blocks-jbc">Section18.2, Distributed Caching with JBoss Cache</a> for information on how the standard JBoss Enterprise Application Platform clustered services use JBoss Cache.
	</div><div class="section" id="jbosscache-configuration"><div class="titlepage"><div><div><h2 class="title">26.1.Key JBoss Cache Configuration Options</h2></div></div></div><div class="para">
			JBoss Enterprise Application Platform ships with a reasonable set of default JBoss Cache configurations that are suitable for the standard clustered service use cases (e.g. web session replication or JPA/Hibernate caching). Most applications that involve the standard clustered services just work out of the box with the default configurations. You only need to tweak them when you are deploying an application that has special network or performance requirements. In this section we provide a brief overview of some of the key configuration choices. This is by no means a complete discussion; for full details users interested in moving beyond the default configurations are encouraged to read the JBoss Cache documentation available at <a href="http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/" class="mimir-link-warn" title="Mimir does not include content from: www.redhat.com">http://www.redhat.com/docs/en-US/JBoss_Enterprise_Application_Platform/</a>.
		</div><div class="para">
			Most JBoss Cache configuration examples in this section use the JBoss Microcontainer schema for building up an <code class="literal">org.jboss.cache.config.Configuration</code> object graph from XML. JBoss Cache has its own custom XML schema, but the standard JBoss Enterprise Application Platform CacheManager service uses the JBoss Microcontainer schema to be consistent with most other internal Enterprise Application Platform services.
		</div><div class="para">
			Before getting into the key configuration options, let's have a look at the most likely place that a user would encounter them.
		</div><div class="section" id="jbosscache-configuration-cachemanager"><div class="titlepage"><div><div><h3 class="title">26.1.1.Editing the CacheManager Configuration</h3></div></div></div><div class="para">
				As discussed in <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>, the standard JBoss Enterprise Application Platform clustered services use the CacheManager service as a factory for JBoss Cache instances. So, cache configuration changes are likely to involve edits to the CacheManager service.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					Users can also use the CacheManager as a factory for custom caches used by directly by their own applications; see <a class="xref" href="#jbosscache-custom-deployment-cachemgr">Section26.2.1, Deployment Via the CacheManager Service</a>.
				</div></div></div><div class="para">
				The CacheManager is configured via the <code class="literal">$JBOSS_HOME/server/<em class="replaceable">$PROFILE</em>/deploy/cluster/jboss-cache-manager.sar/META-INF/jboss-cache-manager-jboss-beans.xml</code> file. The element most likely to be edited is the "CacheConfigurationRegistry" bean, which maintains a registry of all the named JBC configurations the CacheManager knows about. Most edits to this file would involve adding a new JBoss Cache configuration or changing a property of an existing one.
			</div><div class="para">
				The following is a redacted version of the "CacheConfigurationRegistry" bean configuration:
			</div><pre class="programlisting">
&lt;bean name="CacheConfigurationRegistry" 
      class="org.jboss.ha.cachemanager.DependencyInjectedConfigurationRegistry"&gt;
   
      &lt;!-- If users wish to add configs using a more familiar JBC config format
           they can add them to a cache-configs.xml file specified by this property.
           However, use of the microcontainer format used below is recommended.
      &lt;property name="configResource"&gt;META-INF/jboss-cache-configs.xml&lt;/property&gt;      
      --&gt;
      
      &lt;!-- The configurations. A Map&lt;String name, Configuration config&gt; --&gt;
      &lt;property name="newConfigurations"&gt;
        &lt;map keyClass="java.lang.String" valueClass="org.jboss.cache.config.Configuration"&gt;
   
   &lt;!-- The standard configurations follow.  You can add your own and/or edit these. --&gt;   
      
   &lt;!-- Standard cache used for web sessions --&gt;
   &lt;entry&gt;&lt;key&gt;standard-session-cache&lt;/key&gt;
   &lt;value&gt;      
      &lt;bean name="StandardSessionCacheConfig" class="org.jboss.cache.config.Configuration"&gt;
         
         &lt;!-- Provides batching functionality for caches that don't want to 
              interact with regular JTA Transactions --&gt;
         &lt;property name="transactionManagerLookupClass"&gt;
            org.jboss.cache.transaction.BatchModeTransactionManagerLookup
         &lt;/property&gt;
               
         &lt;!-- Name of cluster. Needs to be the same for all members --&gt;
         &lt;property name="clusterName"&gt;${jboss.partition.name:DefaultPartition}-SessionCache&lt;/property&gt;
         &lt;!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
              because we are using asynchronous replication. --&gt;
         &lt;property name="multiplexerStack"&gt;${jboss.default.jgroups.stack:udp}&lt;/property&gt;
         &lt;property name="fetchInMemoryState"&gt;true&lt;/property&gt;
         
         &lt;property name="nodeLockingScheme"&gt;PESSIMISTIC&lt;/property&gt;
         &lt;property name="isolationLevel"&gt;REPEATABLE_READ&lt;/property&gt;
         &lt;property name="cacheMode"&gt;REPL_ASYNC&lt;/property&gt;
      
          .... more details of the standard-session-cache configuration
      &lt;/bean&gt;      
   &lt;/value&gt;
   &lt;/entry&gt;
   
   &lt;!-- Appropriate for web sessions with FIELD granularity --&gt;
   &lt;entry&gt;&lt;key&gt;field-granularity-session-cache&lt;/key&gt;
   &lt;value&gt;      
      
      &lt;bean name="FieldSessionCacheConfig" class="org.jboss.cache.config.Configuration"&gt;              
           .... details of the field-granularity-standard-session-cache configuration
      &lt;/bean&gt;      

   &lt;/value&gt;

   &lt;/entry&gt;

   ... entry elements for the other configurations

  &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="para">
				The actual JBoss Cache configurations are specified using the JBoss Microcontainer's schema rather than one of the standard JBoss Cache configuration formats. When JBoss Cache parses one of its standard configuration formats, it creates a Java Bean of type <code class="literal">org.jboss.cache.config.Configuration</code> with a tree of child Java Beans for some of the more complex sub-configurations (i.e. cache loading, eviction, buddy replication). Rather than delegating this task of XML parsing/Java Bean creation to JBC, we let the Enterprise Application Platform's microcontainer do it directly. This has the advantage of making the microcontainer aware of the configuration beans, which in later Enterprise Application Platform 5.x releases will be helpful in allowing external management tools to manage the JBC configurations.
			</div><div class="para">
				The configuration format should be fairly self-explanatory if you look at the standard configurations the Enterprise Application Platform ships; they include all the major elements. The types and properties of the various java beans that make up a JBoss Cache configuration can be seen in the JBoss Cache Javadocs. Here is a fairly complete example:
			</div><pre class="programlisting">
&lt;bean name="StandardSFSBCacheConfig" class="org.jboss.cache.config.Configuration"&gt;

   &lt;!--  No transaction manager lookup --&gt;
         
   &lt;!-- Name of cluster. Needs to be the same for all members --&gt;
   &lt;property name="clusterName"&gt;${jboss.partition.name:DefaultPartition}-SFSBCache&lt;/property&gt;
   &lt;!-- Use a UDP (multicast) based stack. Need JGroups flow control (FC)
        because we are using asynchronous replication. --&gt;
   &lt;property name="multiplexerStack"&gt;${jboss.default.jgroups.stack:udp}&lt;/property&gt;
   &lt;property name="fetchInMemoryState"&gt;true&lt;/property&gt;
   
   &lt;property name="nodeLockingScheme"&gt;PESSIMISTIC&lt;/property&gt;
   &lt;property name="isolationLevel"&gt;REPEATABLE_READ&lt;/property&gt;
   &lt;property name="cacheMode"&gt;REPL_ASYNC&lt;/property&gt;
   
   &lt;property name="useLockStriping"&gt;false&lt;/property&gt;

   &lt;!-- Number of milliseconds to wait until all responses for a
        synchronous call have been received. Make this longer 
        than lockAcquisitionTimeout.--&gt;
   &lt;property name="syncReplTimeout"&gt;17500&lt;/property&gt;
   &lt;!-- Max number of milliseconds to wait for a lock acquisition --&gt;
   &lt;property name="lockAcquisitionTimeout"&gt;15000&lt;/property&gt;
   &lt;!-- The max amount of time (in milliseconds) we wait until the
    state (ie. the contents of the cache) are retrieved from
    existing members at startup. --&gt;
   &lt;property name="stateRetrievalTimeout"&gt;60000&lt;/property&gt;

   &lt;!--
    SFSBs use region-based marshalling to provide for partial state
    transfer during deployment/undeployment.
   --&gt;
   &lt;property name="useRegionBasedMarshalling"&gt;false&lt;/property&gt;
   &lt;!-- Must match the value of "useRegionBasedMarshalling" --&gt;
   &lt;property name="inactiveOnStartup"&gt;false&lt;/property&gt;
   
   &lt;!-- Disable asynchronous RPC marshalling/sending --&gt;
   &lt;property name="serializationExecutorPoolSize"&gt;0&lt;/property&gt;        
   &lt;!-- We have no asynchronous notification listeners --&gt;
   &lt;property name="listenerAsyncPoolSize"&gt;0&lt;/property&gt;
     
   &lt;property name="exposeManagementStatistics"&gt;true&lt;/property&gt;

   &lt;property name="buddyReplicationConfig"&gt;
      &lt;bean class="org.jboss.cache.config.BuddyReplicationConfig"&gt;
         
         &lt;!--  Just set to true to turn on buddy replication --&gt;
         &lt;property name="enabled"&gt;false&lt;/property&gt;
         
         &lt;!-- A way to specify a preferred replication group.  We try
              and pick a buddy who shares the same pool name (falling 
              back to other buddies if not available). --&gt;
         &lt;property name="buddyPoolName"&gt;default&lt;/property&gt;
         
         &lt;property name="buddyCommunicationTimeout"&gt;17500&lt;/property&gt;
         
         &lt;!-- Do not change these --&gt;
         &lt;property name="autoDataGravitation"&gt;false&lt;/property&gt;
         &lt;property name="dataGravitationRemoveOnFind"&gt;true&lt;/property&gt;
         &lt;property name="dataGravitationSearchBackupTrees"&gt;true&lt;/property&gt;
         
         &lt;property name="buddyLocatorConfig"&gt;
            &lt;bean class="org.jboss.cache.buddyreplication.NextMemberBuddyLocatorConfig"&gt;
               &lt;!-- The number of backup nodes we maintain --&gt;
               &lt;property name="numBuddies"&gt;1&lt;/property&gt;
               &lt;!-- Means that each node will *try* to select a buddy on 
                    a different physical host. If not able to do so 
                    though, it will fall back to colocated nodes. --&gt;
               &lt;property name="ignoreColocatedBuddies"&gt;true&lt;/property&gt;
             &lt;/bean&gt;
         &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
   &lt;property name="cacheLoaderConfig"&gt;
      &lt;bean class="org.jboss.cache.config.CacheLoaderConfig"&gt;
             &lt;!-- Do not change these --&gt;
             &lt;property name="passivation"&gt;true&lt;/property&gt;
             &lt;property name="shared"&gt;false&lt;/property&gt;
             
             &lt;property name="individualCacheLoaderConfigs"&gt;
               &lt;list&gt;
                  &lt;bean class="org.jboss.cache.loader.FileCacheLoaderConfig"&gt;
                     &lt;!-- Where passivated sessions are stored --&gt;
                     &lt;property name="location"&gt;${jboss.server.data.dir}${/}sfsb&lt;/property&gt;
                     &lt;!-- Do not change these --&gt;
                     &lt;property name="async"&gt;false&lt;/property&gt;
                     &lt;property name="fetchPersistentState"&gt;true&lt;/property&gt;
                     &lt;property name="purgeOnStartup"&gt;true&lt;/property&gt;
                     &lt;property name="ignoreModifications"&gt;false&lt;/property&gt;
                     &lt;property name="checkCharacterPortability"&gt;false&lt;/property&gt;
                  &lt;/bean&gt;
               &lt;/list&gt;
             &lt;/property&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
  
   &lt;!-- EJBs use JBoss Cache eviction --&gt;
   &lt;property name="evictionConfig"&gt;
       &lt;bean class="org.jboss.cache.config.EvictionConfig"&gt;
         &lt;property name="wakeupInterval"&gt;5000&lt;/property&gt;
         &lt;!--  Overall default --&gt;
         &lt;property name="defaultEvictionRegionConfig"&gt;
            &lt;bean class="org.jboss.cache.config.EvictionRegionConfig"&gt;
               &lt;property name="regionName"&gt;/&lt;/property&gt;
               &lt;property name="evictionAlgorithmConfig"&gt;
                  &lt;bean class="org.jboss.cache.eviction.NullEvictionAlgorithmConfig"/&gt;
               &lt;/property&gt;
            &lt;/bean&gt;
         &lt;/property&gt;
         &lt;!-- EJB3 integration code will programatically create
              other regions as beans are deployed --&gt;
      &lt;/bean&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><div class="para">
				Basically, the XML specifies the creation of an <code class="literal">org.jboss.cache.config.Configuration</code> java bean and the setting of a number of properties on that bean. Most of the properties are of simple types, but some, such as <code class="literal">buddyReplicationConfig</code> and <code class="literal">cacheLoaderConfig</code> take various types java beans as their values.
			</div><div class="para">
				Next we'll look at some of the key configuration options.
			</div></div><div class="section" id="jbosscache-configuration-cachemode"><div class="titlepage"><div><div><h3 class="title">26.1.2.Cache Mode</h3></div></div></div><div class="para">
				JBoss Cache's <code class="literal">cacheMode</code> configuration attribute combines into a single property two related aspects:
			</div><div class="para">
				<span class="bold bold"><strong>Handling of Cluster Updates</strong></span>
			</div><div class="para">
				This controls how a cache instance on one node should notify the rest of the cluster when it makes changes in its local state. There are three options: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Synchronous</strong></span> means the cache instance sends a message to its peers notifying them of the change(s) and before returning waits for them to acknowledge that they have applied the same changes. If the changes are made as part of a JTA transaction, this is done as part of a two-phase commit process during transaction commit. Any locks are held until this acknowledgment is received. Waiting for acknowledgement from all nodes adds delays, but it ensures consistency around the cluster. Synchronous mode is needed when all the nodes in the cluster may access the cached data resulting in a high need for consistency.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Asynchronous</strong></span> means the cache instance sends a message to its peers notifying them of the change(s) and then immediately returns, without any acknowledgement that they have applied the same changes. It <span class="emphasis"><em>does not</em></span> mean sending the message is handled by some other thread besides the one that changed the cache content; the thread that makes the change still spends some time dealing with sending messages to the cluster, just not as much as with synchronous communication. Asynchronous mode is most useful for cases like session replication, where the cache doing the sending expects to be the only one that accesses the data and the cluster messages are used to provide backup copies in case of failure of the sending node. Asynchronous messaging adds a small risk that a later user request that fails over to another node may see out-of-date state, but for many session-type applications this risk is acceptable given the major performance benefits asynchronous mode has over synchronous mode.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Local</strong></span> means the cache instance doesn't send a message at all. A JGroups channel isn't even used by the cache. JBoss Cache has many useful features besides its clustering capabilities and is a very useful caching library even when not used in a cluster. Also, even in a cluster, some cached data does not need to be kept consistent around the cluster, in which case Local mode will improve performance. Caching of JPA/Hibernate query result sets is an example of this; Hibernate's second level caching logic uses a separate mechanism to invalidate stale query result sets from the second level cache, so JBoss Cache doesn't need to send messages around the cluster for a query result set cache.
						</div></li></ul></div>

			</div><div class="para">
				<span class="bold bold"><strong>Replication vs. Invalidation</strong></span>
			</div><div class="para">
				This aspect deals with the content of messages sent around the cluster when a cache changes its local state, i.e. what should the other caches in the cluster do to reflect the change: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Replication</strong></span> means the other nodes should update their state to reflect the new state on the sending node. This means the sending node needs to include the changed state, increasing the cost of the message. Replication is necessary if the other nodes have no other way to obtain the state.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Invalidation</strong></span> means the other nodes should remove the changed state from their local state. Invalidation reduces the cost of the cluster update messages, since only the cache key of the changed state needs to be transmitted, not the state itself. However, it is only an option if the removed state can be retrieved from another source. It is an excellent option for a clustered JPA/Hibernate entity cache, since the cached state can be re-read from the database.
						</div></li></ul></div>

			</div><div class="para">
				These two aspects combine to form 5 valid values for the <code class="literal">cacheMode</code> configuration attribute: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>LOCAL</strong></span> means no cluster messages are needed.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>REPL_SYNC</strong></span> means synchronous replication messages are sent.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>REPL_ASYNC</strong></span> means asynchronous replication messages are sent.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>INVALIDATION_SYNC</strong></span> means synchronous invalidation messages are sent.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>INVALIDATION_ASYNC</strong></span> means asynchronous invalidation messages are sent.
						</div></li></ul></div>

			</div></div><div class="section" id="jbosscache-configuration-transactions"><div class="titlepage"><div><div><h3 class="title">26.1.3.Transaction Handling</h3></div></div></div><div class="para">
				JBoss Cache integrates with JTA transaction managers to allow transactional access to the cache. When JBoss Cache detects the presence of a transaction, any locks are held for the life of the transaction, changes made to the cache will be reverted if the transaction rolls back, and any cluster-wide messages sent to inform other nodes of changes are deferred and sent in a batch as part of transaction commit (reducing chattiness).
			</div><div class="para">
				Integration with a transaction manager is accomplished by setting the <code class="literal">transactionManagerLookupClass</code> configuration attribute; this specifies the fully qualified class name of a class JBoss Cache can use to find the local transaction manager. Inside JBoss Enterprise Application Platform, this attribute would have one of two values:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>org.jboss.cache.transaction.JBossTransactionManagerLookup</strong></span>
					</div><div class="para">
						This finds the standard transaction manager running in the application server. Use this for any custom caches you deploy where you want caching to participate in any JTA transactions.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>org.jboss.cache.transaction.BatchModeTransactionManagerLookup</strong></span>
					</div><div class="para">
						This is used in the cache configurations used for web session and EJB SFSB caching. It specifies a simple mock <code class="literal">TransactionManager</code> that ships with JBoss Cache called the <code class="literal">BatchModeTransactionManager</code>. This transaction manager is not a true JTA transaction manager and should not be used for anything other than JBoss Cache. Its usage in JBoss Enterprise Application Platform is to get most of the benefits of JBoss Cache's transactional behavior for the session replication use cases, but without getting tangled up with end user transactions that may run during a request.
					</div></li></ul></div></div><div class="section" id="jbosscache-configuration-concurrency"><div class="titlepage"><div><div><h3 class="title">26.1.4.Concurrent Access</h3></div></div></div><div class="para">
				JBoss Cache is a thread safe caching API, and uses its own efficient mechanisms of controlling concurrent access. Concurrency is configured via the <code class="literal">nodeLockingScheme</code> and <code class="literal">isolationLevel</code> configuration attributes.
			</div><div class="para">
				There are three choices for <code class="literal">nodeLockingScheme</code>: 
				<div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>MVCC</strong></span> or multi-version concurrency control, is a locking scheme commonly used by modern database implementations to control fast, safe concurrent access to shared data. JBoss Cache 3.x uses an innovative implementation of MVCC as the default locking scheme. MVCC is designed to provide the following features for concurrent access: 
							<div class="itemizedlist"><ul><li class="listitem"><div class="para">
										Readers that don't block writers
									</div></li><li class="listitem"><div class="para">
										Writers that fail fast
									</div></li></ul></div>
							 It achieves this by using data versioning and copying for concurrent writers. The theory is that readers continue reading shared state, while writers copy the shared state, increment a version id, and write that shared state back after verifying that the version is still valid (i.e., another concurrent writer has not changed this state first).
						</div><div class="para">
							MVCC is the recommended choice for JPA/Hibernate entity caching.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>PESSIMISTIC</strong></span> locking involves threads/transactions acquiring either exclusive or non-exclusive locks on nodes before reading or writing. Which is acquired depends on the <code class="literal">isolationLevel</code> (see below) but in most cases a non-exclusive lock is acquired for a read and an exclusive lock is acquired for a write. Pessimistic locking requires considerably more overhead than MVCC and allows lesser concurrency, since reader threads must block until a write has completed and released its exclusive lock (potentially a long time if the write is part of a transaction). A write will also be delayed due to ongoing reads.
						</div><div class="para">
							Generally MVCC is a better choice than PESSIMISTIC, which is deprecated as of JBoss Cache 3.0. But, for the session caching usage in JBoss Enterprise Application Platform 5.0.0, PESSIMISTIC is still the default. This is largely because for the session use case there are generally not concurrent threads accessing the same cache location, so the benefits of MVCC are not as great. 
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>OPTIMISTIC</strong></span> locking seeks to improve upon the concurrency available with PESSIMISTIC by creating a "workspace" for each request/transaction that accesses the cache. Data accessed by the request/transaction (even reads) is <span class="emphasis"><em>copied</em></span> into the workspace, which is adds overhead. All data is versioned; on completion of non-transactional requests or commits of transactions the version of data in the workspace is compared to the main cache, and an exception is raised if there are are inconsistencies. Otherwise changes to the workspace are applied to the main cache.
						</div><div class="para">
							OPTIMISTIC locking is deprecated but is still provided to support backward compatibility. Users are encouraged to use MVCC instead, which provides the same benefits at lower cost.
						</div></li></ul></div>

			</div><div class="para">
				The <code class="literal">isolationLevel</code> attribute has two possible values <span class="bold bold"><strong>READ_COMMITTED</strong></span> and <span class="bold bold"><strong>REPEATABLE_READ</strong></span> which correspond in semantic to database-style isolation levels. Previous versions of JBoss Cache supported all 5 database isolation levels, and if an unsupported isolation level is configured, it is either upgraded or downgraded to the closest supported level.
			</div><div class="para">
				REPEATABLE_READ is the default isolation level, to maintain compatibility with previous versions of JBoss Cache. READ_COMMITTED, while providing a slightly weaker isolation, has a significant performance benefit over REPEATABLE_READ.
			</div></div><div class="section" id="jbosscache-configuration-jgroups"><div class="titlepage"><div><div><h3 class="title">26.1.5.JGroups Integration</h3></div></div></div><div class="para">
				Each JBoss Cache instance internally uses a JGroups <code class="literal">Channel</code> to handle group communications. Inside JBoss Enterprise Application Platform, we strongly recommend that you use the Enterprise Application Platform's JGroups Channel Factory service  as the source for your cache's <code class="literal">Channel</code>. In this section we discuss how to configure your cache to get it's channel from the Channel Factory; if you wish to configure the channel in some other way see the JBoss Cache documentation.
			</div><div class="para">
				<span class="bold bold"><strong>Caches obtained from the CacheManager Service</strong></span>
			</div><div class="para">
				This is the simplest approach. The CacheManager service already has a reference to the Channel Factory service, so the only configuration task is to configure the name of the JGroups protocol stack configuration to use.
			</div><div class="para">
				If you are configuring your cache via the CacheManager service's <code class="literal">jboss-cache-manager-jboss-beans.xml</code> file (see <a class="xref" href="#jbosscache-custom-deployment-cachemgr">Section26.2.1, Deployment Via the CacheManager Service</a>), add the following to your cache configuration, where the value is the name of the protocol stack configuration.:
			</div><pre class="programlisting">&lt;property name="multiplexerStack"&gt;udp&lt;/property&gt;</pre><div class="para">
				<span class="bold bold"><strong>Caches Deployed via a <code class="literal">-jboss-beans.xml</code> File</strong></span>
			</div><div class="para">
				If you are deploying a cache via a JBoss Microcontainer <code class="literal">-jboss-beans.xml</code> file (see <a class="xref" href="#jbosscache-custom-deployment-beans.xml">Section26.2.3, Deployment Via a <code class="literal">-jboss-beans.xml</code> File</a>), you need inject a reference to the Channel Factory service as well as specifying the protocol stack configuration:
			</div><pre class="programlisting">
&lt;property name="runtimeConfig"&gt;
   &lt;bean class="org.jboss.cache.config.RuntimeConfig"&gt;
      &lt;property name="muxChannelFactory"&gt;&lt;inject bean="JChannelFactory"/&gt;&lt;/property&gt;
   &lt;/bean&gt;
&lt;/property&gt;
&lt;property name="multiplexerStack"&gt;udp&lt;/property&gt;</pre><div class="para">
				<span class="bold bold"><strong>Caches Deployed via a <code class="literal">-service.xml</code> File</strong></span>
			</div><div class="para">
				If you are deploying a cache MBean via <code class="literal">-service.xml</code> file (see <a class="xref" href="#jbosscache-custom-deployment-service.xml">Section26.2.2, Deployment Via a <code class="literal">-service.xml</code> File</a>), <code class="literal">CacheJmxWrapper</code> is the class of your MBean; that class exposes a <code class="literal">MuxChannelFactory</code> MBean attribute. You dependency inject the Channel Factory service into this attribute, and set the protocol stack name via the <code class="literal">MultiplexerStack</code> attribute:
			</div><pre class="programlisting">
&lt;attribute name="MuxChannelFactory"&gt;&lt;inject bean="JChannelFactory"/&gt;&lt;/attribute&gt;
&lt;attribute name="MultiplexerStack"&gt;udp&lt;/attribute&gt;</pre></div><div class="section" id="jbosscache-configuration-eviction"><div class="titlepage"><div><div><h3 class="title">26.1.6.Eviction</h3></div></div></div><div class="para">
				Eviction allows the cache to control memory by removing data (typically the least frequently used data). If you wish to configure eviction for a custom cache, see the JBoss Cache documentation for all of the available options. For details on configuring it for JPA/Hibernate caching, see the Eviction chapter in the "Using JBoss Cache as a Hibernate Second Level Cache" guide at <a href="http://www.jboss.org/jbossclustering/docs/hibernate-jbosscache-guide-3.pdf" class="mimir-link-warn" title="Mimir does not include content from: www.jboss.org">http://www.jboss.org/jbossclustering/docs/hibernate-jbosscache-guide-3.pdf</a>. For web session caches, eviction should not be configured; the distributable session manager handles eviction itself. For EJB 3 SFSB caches, stick with the eviction configuration in the Enterprise Application Platform's standard <code class="literal">sfsb-cache</code> configuration (see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>). The EJB container will configure eviction itself using the values included in each bean's configuration.
			</div></div><div class="section" id="jbosscache-configuration-cacheloaders"><div class="titlepage"><div><div><h3 class="title">26.1.7.Cache Loaders</h3></div></div></div><div class="para">
				Cache loading allows JBoss Cache to store data in a persistent store in addition to what it keeps in memory. This data can either be an overflow, where the data in the persistent store is not reflected in memory. Or it can be a superset of what is in memory, where everything in memory is also reflected in the persistent store, along with items that have been evicted from memory. Which of these two modes is used depends on the setting of the <code class="literal">passivation</code> flag in the JBoss Cache cache loader configuration section. A <code class="literal">true</code> value means the persistent store acts as an overflow area written to when data is evicted from the in-memory cache.
			</div><div class="para">
				If you wish to configure cache loading for a custom cache, see the JBoss Cache documentation for all of the available options. Do not configure cache loading for a JPA/Hibernate cache, as the database itself serves as a persistent store; adding a cache loader is just redundant.
			</div><div class="para">
				The caches used for web session and EJB3 SFSB caching use passivation. Next we'll discuss the cache loader configuration for those caches in some detail.
			</div><div class="section" id="jbosscache-configuration-cacheloaders-session"><div class="titlepage"><div><div><h4 class="title">26.1.7.1.CacheLoader Configuration for Web Session and SFSB Caches</h4></div></div></div><div class="para">
					HttpSession and SFSB passivation rely on JBoss Cache's Cache Loader passivation for storing and retrieving the passivated sessions. Therefore the cache instance used by your webapp's clustered session manager or your bean's EJB container must be configured to enable Cache Loader passivaton.
				</div><div class="para">
					In most cases you don't need to do anything to alter the cache loader configurations for the standard web session and SFSB caches; the standard JBoss Enterprise Application Platform configurations should suit your needs. The following is a bit more detail in case you're interested or want to change from the defaults.
				</div><div class="para">
					The Cache Loader configuration for the <code class="literal">standard-session-cache</code> config serves as a good example:
				</div><pre class="programlisting">
&lt;property name="cacheLoaderConfig"&gt;
   &lt;bean class="org.jboss.cache.config.CacheLoaderConfig"&gt;
          &lt;!-- Do not change these --&gt;
          &lt;property name="passivation"&gt;true&lt;/property&gt;
          &lt;property name="shared"&gt;false&lt;/property&gt;
          
          &lt;property name="individualCacheLoaderConfigs"&gt;
            &lt;list&gt;
               &lt;bean class="org.jboss.cache.loader.FileCacheLoaderConfig"&gt;
                  &lt;!-- Where passivated sessions are stored --&gt;
                  &lt;property name="location"&gt;${jboss.server.data.dir}${/}session&lt;/property&gt;
                  &lt;!-- Do not change these --&gt;
                  &lt;property name="async"&gt;false&lt;/property&gt;
                  &lt;property name="fetchPersistentState"&gt;true&lt;/property&gt;
                  &lt;property name="purgeOnStartup"&gt;true&lt;/property&gt;
                  &lt;property name="ignoreModifications"&gt;false&lt;/property&gt;
                  &lt;property name="checkCharacterPortability"&gt;false&lt;/property&gt;
               &lt;/bean&gt;
            &lt;/list&gt;
          &lt;/property&gt;
   &lt;/bean&gt;
&lt;/property&gt;</pre><div class="para">
					Some explanation:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>passivation</strong></span> property MUST be <code class="literal">true</code>
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>shared</strong></span> property MUST be <code class="literal">false</code>. Do not passivate sessions to a shared persistent store, otherwise if another node activates the session, it will be gone from the persistent store and also gone from memory on other nodes that have passivated it. Backup copies will be lost.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>individualCacheLoaderConfigs</strong></span> property accepts a list of Cache Loader configurations. JBC allows you to chain cache loaders; see the JBoss Cache docs. For the session passivation use case a single cache loader is sufficient.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>class</strong></span> attribute on a cache loader config bean must refer to the configuration class for a cache loader implementation (e.g. <code class="literal">org.jboss.cache.loader.FileCacheLoaderConfig</code> or <code class="literal">org.jboss.cache.loader.JDBCCacheLoaderConfig</code>). See the JBoss Cache documentation for more on the available CacheLoader implementations. If you wish to use JDBCCacheLoader (to persist to a database rather than the filesystem used by FileCacheLoader) note the comment above about the <code class="literal">shared</code> property. Don't use a shared database, or at least not a shared table in the database. Each node in the cluster must have its own storage location.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>location</strong></span> property for FileCacheLoaderConfig defines the root node of the filesystem tree where passivated sessions should be stored. The default is to store them in your JBoss Enterprise Application Platform configuration's <code class="literal">data</code> directory.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>async</strong></span> MUST be <code class="literal">false</code> to ensure passivated sessions are promptly written to the persistent store.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>fetchPersistentState</strong></span> property MUST be <code class="literal">true</code> to ensure passivated sessions are included in the set of session backup copies transferred over from other nodes when the cache starts.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>purgeOnStartup</strong></span> should be <code class="literal">true</code> to ensure out-of-date session data left over from a previous shutdown of a server doesn't pollute the current data set.
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>ignoreModifications</strong></span> should be <code class="literal">false</code>
						</div></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>checkCharacterPortability</strong></span> should be <code class="literal">false</code> as a minor performance optimization.
						</div></li></ul></div></div></div><div class="section" id="jbosscache-configuration-buddyrepl"><div class="titlepage"><div><div><h3 class="title">26.1.8.Buddy Replication</h3></div></div></div><div class="para">
				Buddy Replication is a JBoss Cache feature that allows you to suppress replicating your data to all instances in a cluster. Instead, each instance picks one or more 'buddies' in the cluster, and only replicates to those specific buddies. This greatly helps scalability as there is no longer a memory and network traffic impact every time another instance is added to a cluster.
			</div><div class="para">
				If the cache on another node needs data that it doesn't have locally, it can ask the other nodes in the cluster to provide it; nodes that have a copy will provide it as part of a process called "data gravitation". The new node will become the owner of the data, placing a backup copy of the data on its buddies. The ability to gravitate data means there is no need for all requests for data to occur on a node that has a copy of it; any node can handle a request for any data. However, data gravitation is expensive and should not be a frequent occurence; ideally it should only occur if the node that is using some data fails or is shut down, forcing interested clients to fail over to a different node. This makes buddy replication primarily useful for session-type applications with session affinity (a.k.a. "sticky sessions") where all requests for a particular session are normally handled by a single server.
			</div><div class="para">
				Buddy replication can be enabled for the web session and EJB3 SFSB caches. Do not add buddy replication to the cache configurations used for other standard clustering services (e.g. JPA/Hibernate caching). Services not specifically engineered for buddy replication are highly unlikely to work correctly if it is introduced.
			</div><div class="para">
				Configuring buddy replication is fairly straightforward. As an example we'll look at the buddy replication configuration section from the CacheManager service's <code class="literal">standard-session-cache</code> config:
			</div><pre class="programlisting">
&lt;property name="buddyReplicationConfig"&gt;
   &lt;bean class="org.jboss.cache.config.BuddyReplicationConfig"&gt;
               
      &lt;!--  Just set to true to turn on buddy replication --&gt;
      &lt;property name="enabled"&gt;true&lt;/property&gt;
               
      &lt;!-- A way to specify a preferred replication group.  We try
           and pick a buddy who shares the same pool name (falling 
           back to other buddies if not available). --&gt;
      &lt;property name="buddyPoolName"&gt;default&lt;/property&gt;
               
      &lt;property name="buddyCommunicationTimeout"&gt;17500&lt;/property&gt;
               
      &lt;!-- Do not change these --&gt;
      &lt;property name="autoDataGravitation"&gt;false&lt;/property&gt;
      &lt;property name="dataGravitationRemoveOnFind"&gt;true&lt;/property&gt;
      &lt;property name="dataGravitationSearchBackupTrees"&gt;true&lt;/property&gt;
               
      &lt;property name="buddyLocatorConfig"&gt;
         &lt;bean class="org.jboss.cache.buddyreplication.NextMemberBuddyLocatorConfig"&gt;
            &lt;!-- The number of backup copies we maintain --&gt;
            &lt;property name="numBuddies"&gt;1&lt;/property&gt;
            &lt;!-- Means that each node will *try* to select a buddy on 
                 a different physical host. If not able to do so 
                 though, it will fall back to colocated nodes. --&gt;
            &lt;property name="ignoreColocatedBuddies"&gt;true&lt;/property&gt;
          &lt;/bean&gt;
      &lt;/property&gt;
   &lt;/bean&gt;
&lt;/property&gt;</pre><div class="para">
				The main things you would be likely to configure are:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="bold bold"><strong>buddyReplicationEnabled</strong></span>  <code class="literal">true</code> if you want buddy replication; <code class="literal">false</code> if data should be replicated to all nodes in the cluster, in which case none of the other buddy replication configurations matter.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>numBuddies</strong></span>  to how many backup nodes should each node replicate its state.
					</div></li><li class="listitem"><div class="para">
						<span class="bold bold"><strong>buddyPoolName</strong></span>  allows logical subgrouping of nodes within the cluster; if possible, buddies will be chosen from nodes in the same buddy pool.
					</div></li></ul></div><div class="para">
				The <code class="literal">ignoreColocatedBuddies</code> switch means that when the cache is trying to find a buddy, it will if possible not choose a buddy on the same physical host as itself. If the only server it can find is running on its own machine, it will use that server as a buddy.
			</div><div class="para">
				Do not change the settings for <code class="literal">autoDataGravitation</code>, <code class="literal">dataGravitationRemoveOnFind</code> and <code class="literal">dataGravitationSearchBackupTrees</code>. Session replication will not work properly if these are changed.
			</div></div></div><div class="section" id="jbosscache-custom-deployment"><div class="titlepage"><div><div><h2 class="title">26.2.Deploying Your Own JBoss Cache Instance</h2></div></div></div><div class="para">
			It's quite common for users to deploy their own instances of JBoss Cache inside JBoss Enterprise Application Platform for custom use by their applications. In this section we describe the various ways caches can be deployed.
		</div><div class="section" id="jbosscache-custom-deployment-cachemgr"><div class="titlepage"><div><div><h3 class="title">26.2.1.Deployment Via the CacheManager Service</h3></div></div></div><div class="para">
				The standard JBoss clustered services that use JBoss Cache obtain a reference to their cache from the Enterprise Application Platform's CacheManager service (see <a class="xref" href="#clustering-blocks-jbc-cachemanager">Section18.2.1, The JBoss Enterprise Application Platform CacheManager Service</a>). End user applications can do the same thing; here's how.
			</div><div class="para">
				<a class="xref" href="#jbosscache-configuration-cachemanager">Section26.1.1, Editing the CacheManager Configuration</a> shows the configuration of the CacheManager's "CacheConfigurationRegistry" bean. To add a new configuration, you would add an additional element inside that bean's <code class="literal">newConfigurations</code> &lt;map&gt;:
			</div><pre class="programlisting">
&lt;bean name="CacheConfigurationRegistry" 
      class="org.jboss.ha.cachemanager.DependencyInjectedConfigurationRegistry"&gt;
   .....
   &lt;property name="newConfigurations"&gt;
     &lt;map keyClass="java.lang.String" valueClass="org.jboss.cache.config.Configuration"&gt;
                  
       &lt;entry&gt;&lt;key&gt;my-custom-cache&lt;/key&gt;
         &lt;value&gt;          
           &lt;bean name="MyCustomCacheConfig" class="org.jboss.cache.config.Configuration"&gt;              
             .... details of the my-custom-cache configuration
           &lt;/bean&gt; 
          &lt;/value&gt;
       &lt;/entry&gt;    
       .....
</pre><div class="para">
				See <a class="xref" href="#jbosscache-configuration-cachemanager">Section26.1.1, Editing the CacheManager Configuration</a> for an example configuration.
			</div><div class="section" id="idm139946655497056"><div class="titlepage"><div><div><h4 class="title">26.2.1.1.Accessing the CacheManager</h4></div></div></div><div class="para">
					Once you've added your cache configuration to the CacheManager, the next step is to provide a reference to the CacheManager to your application. There are three ways to do this:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							<span class="bold bold"><strong>Dependency Injection</strong></span>
						</div><div class="para">
							If your application uses the JBoss Microcontainer for configuration, the simplest mechanism is to have it inject the CacheManager into your service.
						</div><pre class="programlisting">
&lt;bean name="MyService" class="com.example.MyService"&gt;
   &lt;property name="cacheManager"&gt;&lt;inject bean="CacheManager"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>JNDI Lookup</strong></span>
						</div><div class="para">
							Alternatively, you can find look up the CacheManger is JNDI. It is bound under <code class="literal">java:CacheManager</code>.
						</div><pre class="programlisting">
import org.jboss.ha.cachemanager.CacheManager;

public class MyService {
   private CacheManager cacheManager;
   
   public void start() throws Exception {
       Context ctx = new InitialContext();
       cacheManager = (CacheManager) ctx.lookup("java:CacheManager");
   }
}</pre></li><li class="listitem"><div class="para">
							<span class="bold bold"><strong>CacheManagerLocator</strong></span>
						</div><div class="para">
							JBoss Enterprise Application Platform also provides a service locator object that can be used to access the CacheManager.
						</div><pre class="programlisting">
import org.jboss.ha.cachemanager.CacheManager;
import org.jboss.ha.framework.server.CacheManagerLocator;

public class MyService {
   private CacheManager cacheManager;
   
   public void start() throws Exception {
       CacheManagerLocator locator = CacheManagerLocator.getCacheManagerLocator();
       // Locator accepts as param a set of JNDI properties to help in lookup;
       // this isn't necessary inside the Enterprise Application Platform
       cacheManager = locator.getCacheManager(null);
   }
}</pre></li></ul></div><div class="para">
					Once a reference to the CacheManager is obtained; usage is simple. Access a cache by passing in the name of the desired configuration. The CacheManager will not start the cache; this is the responsibility of the application. The cache may, however, have been started by another application running in the cache server; the cache may be shared. When the application is done using the cache, it should not stop. Just inform the CacheManager that the cache is no longer being used; the manager will stop the cache when all callers that have asked for the cache have released it.
				</div><pre class="programlisting">
import org.jboss.cache.Cache;
import org.jboss.ha.cachemanager.CacheManager;
import org.jboss.ha.framework.server.CacheManagerLocator;

public class MyService {
   private CacheManager cacheManager;
   private Cache cache;
   
   public void start() throws Exception {
       Context ctx = new InitialContext();
       cacheManager = (CacheManager) ctx.lookup("java:CacheManager");
       
       // "true" param tells the manager to instantiate the cache if
       // it doesn't exist yet
       cache = cacheManager.getCache("my-cache-config", true);
       
       cache.start();
   }
   
   public void stop() throws Exception {
       cacheManager.releaseCache("my-cache-config");
   }
}</pre><div class="para">
					The CacheManager can also be used to access instances of POJO Cache.
				</div><pre class="programlisting">
import org.jboss.cache.pojo.PojoCache;
import org.jboss.ha.cachemanager.CacheManager;
import org.jboss.ha.framework.server.CacheManagerLocator;

public class MyService {
   private CacheManager cacheManager;
   private PojoCache pojoCache;
   
   public void start() throws Exception {
       Context ctx = new InitialContext();
       cacheManager = (CacheManager) ctx.lookup("java:CacheManager");
       
       // "true" param tells the manager to instantiate the cache if
       // it doesn't exist yet
       pojoCache = cacheManager.getPojoCache("my-cache-config", true);
       
       pojoCache.start();
   }
   
   public void stop() throws Exception {
       cacheManager.releasePojoCache("my-cache-config");
   }
}</pre></div></div><div class="section" id="jbosscache-custom-deployment-service.xml"><div class="titlepage"><div><div><h3 class="title">26.2.2.Deployment Via a <code class="literal">-service.xml</code> File</h3></div></div></div><div class="para">
				As in JBoss Enterprise Application Platform 4.x, you can also deploy a JBoss Cache instance as an MBean service via a <code class="literal">-service.xml</code> file. The primary difference from JBoss Enterprise Application Platform 4.x is the value of the <code class="literal">code</code> attribute in the <code class="literal">mbean</code> element. In JBoss Enterprise Application Platform 4.x, this was <code class="literal">org.jboss.cache.TreeCache</code>; in JBoss Enterprise Application Platform 5.x it is <code class="literal">org.jboss.cache.jmx.CacheJmxWrapper</code>. Here's an example:
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;server&gt;
  &lt;mbean code="org.jboss.cache.jmx.CacfheJmxWrapper" 
         name="foo:service=ExampleCacheJmxWrapper"&gt;
      
     &lt;attribute name="TransactionManagerLookupClass"&gt;
       org.jboss.cache.transaction.JBossTransactionManagerLookup
     &lt;/attribute&gt;
     
     &lt;attribute name="MuxChannelFactory"&gt;&lt;inject bean="JChannelFactory"/&gt;&lt;/attribute&gt;
     
     &lt;attribute name="MultiplexerStack"&gt;udp&lt;/attribute&gt;
     &lt;attribute name="ClusterName"&gt;Example-EntityCache&lt;/attribute&gt;        
     &lt;attribute name="IsolationLevel"&gt;REPEATABLE_READ&lt;/attribute&gt;
     &lt;attribute name="CacheMode"&gt;REPL_SYNC&lt;/attribute&gt;
     &lt;attribute name="InitialStateRetrievalTimeout"&gt;15000&lt;/attribute&gt;
     &lt;attribute name="SyncReplTimeout"&gt;20000&lt;/attribute&gt;
     &lt;attribute name="LockAcquisitionTimeout"&gt;15000&lt;/attribute&gt;
     &lt;attribute name="ExposeManagementStatistics"&gt;true&lt;/attribute&gt;
         
  &lt;/mbean&gt;
&lt;/server&gt;</pre><div class="para">
				The <code class="literal">CacheJmxWrapper</code> is not the cache itself (i.e. you can't store stuff in it). Rather, as it's name implies, it's a wrapper around an <code class="literal">org.jboss.cache.Cache</code> that handles integration with JMX. <code class="literal">CacheJmxWrapper</code> exposes the <code class="literal">org.jboss.cache.Cache</code> via its <code class="literal">CacheJmxWrapperMBean</code> MBean interfaces <code class="literal">Cache</code> attribute; services that need the cache can obtain a reference to it via that attribute.
			</div></div><div class="section" id="jbosscache-custom-deployment-beans.xml"><div class="titlepage"><div><div><h3 class="title">26.2.3.Deployment Via a <code class="literal">-jboss-beans.xml</code> File</h3></div></div></div><div class="para">
				Much like it can deploy MBean services described with a <code class="literal">-service.xml</code>, JBoss Enterprise Application Platform 5 can also deploy services that consist of Plain Old Java Objects (POJOs) if the POJOs are described using the JBoss Microcontainer schema in a <code class="literal">-jboss-beans.xml</code> file. You create such a file and deploy it, either directly in the <code class="literal">deploy</code> dir, or packaged in an ear or sar. Following is an example:
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- First we create a Configuration object for the cache --&gt;
   &lt;bean name="ExampleCacheConfig"
         class="org.jboss.cache.config.Configuration"&gt;

      &lt;!-- Externally injected services --&gt;  
      &lt;property name="runtimeConfig"&gt;
         &lt;bean name="ExampleCacheRuntimeConfig" class="org.jboss.cache.config.RuntimeConfig"&gt;
            &lt;property name="transactionManager"&gt;
               &lt;inject bean="jboss:service=TransactionManager" 
                       property="TransactionManager"/&gt;
            &lt;/property&gt;
            &lt;property name="muxChannelFactory"&gt;&lt;inject bean="JChannelFactory"/&gt;&lt;/property&gt;
         &lt;/bean&gt;
      &lt;/property&gt;
      
      &lt;property name="multiplexerStack"&gt;udp&lt;/property&gt;
      &lt;property name="clusterName"&gt;Example-EntityCache&lt;/property&gt;        
      &lt;property name="isolationLevel"&gt;REPEATABLE_READ&lt;/property&gt;
      &lt;property name="cacheMode"&gt;REPL_SYNC&lt;/property&gt;
      &lt;property name="initialStateRetrievalTimeout"&gt;15000&lt;/property&gt;
      &lt;property name="syncReplTimeout"&gt;20000&lt;/property&gt;
      &lt;property name="lockAcquisitionTimeout"&gt;15000&lt;/property&gt;
      &lt;property name="exposeManagementStatistics"&gt;true&lt;/property&gt;

   &lt;/bean&gt;
 
   &lt;!-- Factory to build the Cache. --&gt;
   &lt;bean name="DefaultCacheFactory" class="org.jboss.cache.DefaultCacheFactory"&gt;      
      &lt;constructor factoryClass="org.jboss.cache.DefaultCacheFactory" /&gt;
   &lt;/bean&gt;
  
   &lt;!-- The cache itself --&gt;
   &lt;bean name="ExampleCache" class="org.jboss.cache.Cache"&gt;
      &lt;constructor factoryMethod="createCache"&gt;
          &lt;factory bean="DefaultCacheFactory"/&gt;
          &lt;parameter class="org.jboss.cache.config.Configuration"&gt;&lt;inject bean="ExampleCacheConfig"/&gt;&lt;/parameter&gt;
          &lt;parameter class="boolean"&gt;false&lt;/false&gt;
      &lt;/constructor&gt;
   &lt;/bean&gt;
   
   &lt;bean name="ExampleService" class="org.foo.ExampleService"&gt;
      &lt;property name="cache"&gt;&lt;inject bean="ExampleCache"/&gt;&lt;/property&gt;
   &lt;/bean&gt;

&lt;/deployment&gt;</pre><div class="para">
				The bulk of the above is the creation of a JBoss Cache <code class="literal">Configuration</code> object; this is the same as what we saw in the configuration of the CacheManager service (see <a class="xref" href="#jbosscache-configuration-cachemanager">Section26.1.1, Editing the CacheManager Configuration</a>). In this case we're not using the CacheManager service as a cache factory, so instead we create our own factory bean and then use it to create the cache (the "ExampleCache" bean). The "ExampleCache" is then injected into a (fictitious) service that needs it.
			</div><div class="para">
				An interesting thing to note in the above example is the use of the <code class="literal">RuntimeConfig</code> object. External resources like a <code class="literal">TransactionManager</code> and a JGroups <code class="literal">ChannelFactory</code> that are visible to the microcontainer are dependency injected into the <code class="literal">RuntimeConfig</code>. The assumption here is that in some other deployment descriptor in the Enterprise Application Platform, the referenced beans have already been described.
			</div><div class="para">
				Using the configuration above, the "ExampleCache" cache will not be visible in JMX. Here's an alternate approach that results in the cache being bound into JMX:
			</div><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;

   &lt;!-- First we create a Configuration object for the cache --&gt;
   &lt;bean name="ExampleCacheConfig"
         class="org.jboss.cache.config.Configuration"&gt;

      .... same as above

   &lt;/bean&gt;
 
   &lt;bean name="ExampleCacheJmxWrapper" class="org.jboss.cache.jmx.CacheJmxWrapper"&gt;
         
      &lt;annotation&gt;@org.jboss.aop.microcontainer.aspects.jmx.JMX
      (name="foo:service=ExampleCacheJmxWrapper",
                  exposedInterface=org.jboss.cache.jmx.CacheJmxWrapperMBean.class, 
                  registerDirectly=true)
      &lt;/annotation&gt;
      
      &lt;property name="configuration"&gt;&lt;inject bean="ExampleCacheConfig"/&gt;&lt;/property&gt;
      
   &lt;/bean&gt;
   
   &lt;bean name="ExampleService" class="org.foo.ExampleService"&gt;
      &lt;property name="cache"&gt;&lt;inject bean="ExampleCacheJmxWrapper" property="cache"/&gt;&lt;/property&gt;
   &lt;/bean&gt;

&lt;/deployment&gt;</pre><div class="para">
				Here the "ExampleCacheJmxWrapper" bean handles the task of creating the cache from the configuration. <code class="literal">CacheJmxWrapper</code> is a JBoss Cache class that provides an MBean interface for a cache. Adding an &lt;annotation&gt; element binds the JBoss Microcontainer <code class="literal">@JMX</code> annotation to the bean; that in turn results in JBoss Enterprise Application Platform registering the bean in JXM as part of the deployment process.
			</div><div class="para">
				The actual underlying <code class="literal">org.jboss.cache.Cache</code> instance is available from the <code class="literal">CacheJmxWrapper</code> via its <code class="literal">cache</code> property; the example shows how this can be used to inject the cache into the "ExampleService".
			</div></div></div></div></div><div class="part" id="Appendices"><div class="titlepage"><div><div><h1 class="title">PartIV.Appendices</h1></div></div></div><div xml:lang="en-US" class="appendix" id="appendix-db-specific-datasources" lang="en-US"><div class="titlepage"><div><div><h2 class="title">AppendixA.Vendor-Specific Datasource Definitions</h2></div></div></div><div class="para">
		This appendix includes datasource definitions for databases supported by JBoss Enterprise Application Platform.
	</div><div class="section" id="idm139946673620080"><div class="titlepage"><div><div><h2 class="title">A.1.Deployer Location and Naming</h2></div></div></div><div class="para">
			All database deployers should be saved to the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/default/deploy/oracle-ds.xml</code> directory on the server. Each deployer file needs to end with the suffix <code class="filename">-ds.xml</code>. For instance, an Oracle datasource deployer might be named <code class="filename">oracle-ds.xml</code>. If files are not named properly, the are not found by the server.
		</div></div><div class="section" id="idm139946670367776"><div class="titlepage"><div><div><h2 class="title">A.2.DB2</h2></div></div></div><div class="example" id="idm139946658556448"><p class="title"><strong>ExampleA.1.DB2 Local-XA</strong></p><div class="example-contents"><div class="para">
				Copy the <code class="filename"><em class="replaceable">$db2_install_dir</em>/java/db2jcc.jar</code> and <code class="filename"><em class="replaceable">$db2_install_dir</em>/java/db2jcc_license_cu.jar</code> files into the <code class="filename"><em class="replaceable">$jboss_install_dir</em>/server/default/lib</code> directory. The <code class="filename">db2java.zip</code> file, which is part of the legacy CLI driver, is normally not required when using the DB2 Universal JDBC driver included in DB2 v8.1 and later.
			</div><pre class="programlisting language-xml XML XML">&lt;datasources&gt;

  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;DB2DS&lt;/jndi-name&gt;
    &lt;!-- Use the syntax 'jdbc:db2:yourdatabase' for jdbc type 2 connection --&gt;
    &lt;!-- Use the syntax 'jdbc:db2://serveraddress:port/yourdatabase' for jdbc type 4 connection --&gt;
    &lt;connection-url&gt;jdbc:db2://serveraddress:port/yourdatabase&lt;/connection-url&gt;
    &lt;driver-class&gt;com.ibm.db2.jcc.DB2Driver&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;min-pool-size&gt;0&lt;/min-pool-size&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;DB2&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654206960"><p class="title"><strong>ExampleA.2.DB2 XA</strong></p><div class="example-contents"><div class="para">
				Copy the <code class="filename"><em class="replaceable">$db2_install_dir</em>/java/db2jcc.jar</code> and <code class="filename"><em class="replaceable">$db2_install_dir</em>/java/db2jcc_license_cu.jar</code> files into the <code class="filename"><em class="replaceable">$jboss_install_dir</em>/server/default/lib</code> directory.
			</div><div class="para">
				The <code class="filename">db2java.zip</code> file is required when using the DB2 Universal JDBC driver (type 4) for XA on DB2 v8.1 fixpak 14 (and the corresponding DB2 v8.2 fixpak 7).
			</div><pre class="programlisting language-xml XML XML">&lt;datasources&gt;
  &lt;!--
      XADatasource for DB2 v8.x (app driver)
  --&gt;

  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;DB2XADS&lt;/jndi-name&gt;

    &lt;xa-datasource-class&gt;com.ibm.db2.jcc.DB2XADataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="ServerName"&gt;your_server_address&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="PortNumber"&gt;your_server_port&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="DatabaseName"&gt;your_database_name&lt;/xa-datasource-property&gt;
    &lt;!-- DriverType can be either 2 or 4, but you most likely want to use the JDBC type 4 as it doesn't require a DB" client --&gt;
    &lt;xa-datasource-property name="DriverType"&gt;4&lt;/xa-datasource-property&gt;
    &lt;!-- If driverType 4 is used, the following two tags are needed --&gt;     
    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;
    &lt;isSameRM-override-value&gt;false&lt;/isSameRM-override-value&gt;

    &lt;xa-datasource-property name="User"&gt;your_user&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;your_password&lt;/xa-datasource-property&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;DB2&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/xa-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654224672"><p class="title"><strong>ExampleA.3.DB2 on AS/400</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- ===================================================================== --&gt;
&lt;!--                                                                       --&gt;
&lt;!--  JBoss Server Configuration                                           --&gt;
&lt;!--                                                                       --&gt;
&lt;!-- ===================================================================== --&gt;

&lt;!-- $Id: db2-400-ds.xml,v 1.1.4.2 2004/10/27 18:44:10 pilhuhn Exp $ --&gt;

&lt;!-- You need the jt400.jar that is delivered with IBM iSeries Access or the
OpenSource Project jtopen.

[systemname] Hostame of the iSeries
[schema]     Default schema is needed so jboss could use metadat to test if the tables exists
--&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;DB2-400&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:as400://[systemname]/[schema];extended dynamic=true;package=jbpkg;package cache=true;package library=jboss;errors=full&lt;/connection-url&gt;
    &lt;driver-class&gt;com.ibm.as400.access.AS400JDBCDriver&lt;/driver-class&gt;
    &lt;user-name&gt;[username]&lt;/user-name&gt;
    &lt;password&gt;[password]&lt;/password&gt;
    &lt;min-pool-size&gt;0&lt;/min-pool-size&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;
    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;DB2/400&lt;/type-mapping&gt;
    &lt;/metadata&gt;

  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654222528"><p class="title"><strong>ExampleA.4.DB2 on AS/400 "native"</strong></p><div class="example-contents"><div class="para">
				The <em class="wordasword">Native</em> JDBC driver is shipped as part of the IBM Developer Kit for Java (57xxJV1). It is implemented by making native method calls to the SQL <em class="firstterm">CLI (Call Level Interface)</em>, and it only runs on the i5/OS JVM. The class name to register is <code class="classname">com.ibm.db2.jdbc.app.DB2Driver</code>. The URL subprotocol is <code class="literal">db2</code>. See JDBC FAQKS at <a href="http://www-03.ibm.com/systems/i/software/toolbox/faqjdbc.html#faqA1" class="mimir-link-warn" title="Mimir does not include content from: www-03.ibm.com">http://www-03.ibm.com/systems/i/software/toolbox/faqjdbc.html#faqA1</a> for more information.
			</div><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!-- ===================================================================== --&gt; 
&lt;!--                                                                       --&gt; 
&lt;!--  JBoss Server Configuration                                           --&gt; 
&lt;!--                                                                       --&gt;
&lt;!-- ===================================================================== --&gt; 
&lt;!-- $Id: db2-400-ds.xml,v 1.1.4.2 2004/10/27 18:44:10 pilhuhn Exp $       --&gt; 
&lt;!-- You need the jt400.jar that is delivered with IBM iSeries Access or the      
OpenSource Project jtopen.      
[systemname] Hostame of the iSeries      
[schema]     Default schema is needed so jboss could use metadat to test if the tables exists  --&gt; 
&lt;datasources&gt;  
  &lt;local-tx-datasource&gt;    
    &lt;jndi-name&gt;DB2-400&lt;/jndi-name&gt;    
    &lt;connection-url&gt;jdbc:db2://[systemname]/[schema];extended dynamic=true;package=jbpkg;package cache=true;package library=jboss;errors=full&lt;/connection-url&gt;    
    &lt;driver-class&gt;com.ibm.db2.jdbc.app.DB2Driver&lt;/driver-class&gt;    
    &lt;user-name&gt;[username]&lt;/user-name&gt;    
    &lt;password&gt;[password]&lt;/password&gt;    
    &lt;min-pool-size&gt;0&lt;/min-pool-size&gt;        
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;        --&gt;        

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool        
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;        --&gt;      
    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;      
    &lt;metadata&gt;          
      &lt;type-mapping&gt;DB2/400&lt;/type-mapping&gt;      
    &lt;/metadata&gt;  
  &lt;/local-tx-datasource&gt; 
&lt;/datasources&gt;</pre><div class="itemizedlist"><p class="title"><strong>Tips</strong></p><ul><li class="listitem"><div class="para">
						This driver is sensitive to the jobs CCSID, but works fine with <code class="varname">CCSID</code>=<code class="literal">37</code>.
					</div></li><li class="listitem"><div class="para">
						<code class="varname">[systemname]</code> must be defined as entry <code class="literal">WRKRDBDIRE</code> like <code class="varname">*local</code>.
					</div></li></ul></div></div></div></div><div class="section" id="idm139946670954992"><div class="titlepage"><div><div><h2 class="title">A.3.Oracle</h2></div></div></div><div class="example" id="idm139946670954192"><p class="title"><strong>ExampleA.5.Oracle Local-TX Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- ===================================================================== --&gt;
&lt;!--                                                                       --&gt;
&lt;!--  JBoss Server Configuration                                           --&gt;
&lt;!--                                                                       --&gt;
&lt;!-- ===================================================================== --&gt;

&lt;!-- $Id: oracle-ds.xml,v 1.6 2004/09/15 14:37:40 loubyansky Exp $ --&gt;
&lt;!-- ==================================================================== --&gt;
&lt;!--  Datasource config for Oracle originally from Steven Coy             --&gt;
&lt;!-- ==================================================================== --&gt;


&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;OracleDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:oracle:thin:@youroraclehost:1521:yoursid&lt;/connection-url&gt;
    &lt;!--
	See on WIKI page below how to use Oracle's thin JDBC driver to connect with enterprise RAC.
    --&gt;
    &lt;!--
	Here are a couple of the possible OCI configurations.
	For more information, see http://otn.oracle.com/docs/products/oracle9i/doc_library/release2/java.920/a96654/toc.htm

&lt;connection-url&gt;jdbc:oracle:oci:@youroracle-tns-name&lt;/connection-url&gt;
or
&lt;connection-url&gt;jdbc:oracle:oci:@(description=(address=(host=youroraclehost)(protocol=tcp)(port=1521))(connect_data=(SERVICE_NAME=yourservicename)))&lt;/connection-url&gt;

Clearly, its better to have TNS set up properly.
    --&gt;
    &lt;driver-class&gt;oracle.jdbc.driver.OracleDriver&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    
    &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;100&lt;/max-pool-size&gt;

    &lt;!-- Uses the pingDatabase method to check a connection is still valid before handing it out from the pool --&gt;
    &lt;!--valid-connection-checker-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.OracleValidConnectionChecker&lt;/valid-connection-checker-class-name--&gt;
    &lt;!-- Checks the Oracle error codes and messages for fatal errors --&gt;
    &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.OracleExceptionSorter&lt;/exception-sorter-class-name&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool - the OracleValidConnectionChecker is prefered
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;Oracle9i&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654171696"><p class="title"><strong>ExampleA.6.Oracle XA Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- ===================================================================== --&gt;
&lt;!--                                                                       --&gt;
&lt;!--  JBoss Server Configuration                                           --&gt;
&lt;!--                                                                       --&gt;
&lt;!-- ===================================================================== --&gt;

&lt;!-- $Id: oracle-xa-ds.xml,v 1.13 2004/09/15 14:37:40 loubyansky Exp $ --&gt;

&lt;!-- ===================================================================== --&gt;
&lt;!-- ATTENTION:  DO NOT FORGET TO SET Pad=true IN transaction-service.xml  --&gt;
&lt;!-- ===================================================================== --&gt;

&lt;datasources&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;XAOracleDS&lt;/jndi-name&gt;
    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;
    &lt;isSameRM-override-value&gt;false&lt;/isSameRM-override-value&gt;
    &lt;xa-datasource-class&gt;oracle.jdbc.xa.client.OracleXADataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="URL"&gt;jdbc:oracle:oci8:@tc&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="User"&gt;scott&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;tiger&lt;/xa-datasource-property&gt;
    &lt;!-- Uses the pingDatabase method to check a connection is still valid before handing it out from the pool --&gt;
    &lt;!--valid-connection-checker-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.OracleValidConnectionChecker&lt;/valid-connection-checker-class-name--&gt;
    &lt;!-- Checks the Oracle error codes and messages for fatal errors --&gt;
    &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.OracleExceptionSorter&lt;/exception-sorter-class-name&gt;
    &lt;!-- Oracles XA datasource cannot reuse a connection outside a transaction once enlisted in a global transaction and vice-versa --&gt;
    &lt;no-tx-separate-pools&gt;&lt;/no-tx-separate-pools&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;Oracle9i&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/xa-datasource&gt;

  &lt;mbean code="org.jboss.resource.adapter.jdbc.vendor.OracleXAExceptionFormatter" 
         name="jboss.jca:service=OracleXAExceptionFormatter"&gt;
    &lt;depends optional-attribute-name="TransactionManagerService"&gt;jboss:service=TransactionManager&lt;/depends&gt;
  &lt;/mbean&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654167168"><p class="title"><strong>ExampleA.7.Oracle's Thin JDBC Driver with Enterprise RAC</strong></p><div class="example-contents"><div class="para">
				The extra configuration to use Oracle's Thin JDBC driver to connect with Enterprise RAC involves the &lt;connection-url&gt;. The two hostnames provide load balancing and failover to the underlying physical database.
			</div><pre class="programlisting language-xml XML XML">...
&lt;connection-url&gt;jdbc:oracle:thin:@(description=(address_list=(load_balance=on)(failover=on)(address=(protocol=tcp)(host=xxxxhost1)(port=1521))(address=(protocol=tcp)(host=xxxxhost2)(port=1521)))(connect_data=(service_name=xxxxsid)(failover_mode=(type=select)(method=basic))))&lt;/connection-url&gt;
...
</pre><div class="para">
				<div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						This example has only been tested against Oracle 10g.
					</div></div></div>

			</div></div></div><div class="section" id="idm139946671041904"><div class="titlepage"><div><div><h3 class="title">A.3.1.Changes in Oracle 10g JDBC Driver</h3></div></div></div><div class="para">
				It is no longer necessary to enable the <code class="varname">Pad</code> option in your <code class="filename">jboss-service.xml</code> file. Further, you no longer need the &lt;no-tx-seperate-pool/&gt;.
			</div></div><div class="section" id="idm139946671039600"><div class="titlepage"><div><div><h3 class="title">A.3.2.Type Mapping for Oracle 10g</h3></div></div></div><div class="para">
				You need to specify Oracle9i type mapping for Oracle 10g datasource configurations.
			</div><div class="example" id="idm139946671038384"><p class="title"><strong>ExampleA.8.Oracle9i Type Mapping</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">....
&lt;metadata&gt;
  &lt;type-mapping&gt;Oracle9i&lt;/type-mapping&gt;
&lt;/metadata&gt;
....</pre></div></div></div><div class="section" id="idm139946671036080"><div class="titlepage"><div><div><h3 class="title">A.3.3.Retrieving the Underlying Oracle Connection Object</h3></div></div></div><div class="example" id="idm139946671035312"><p class="title"><strong>ExampleA.9.Oracle Connection Object</strong></p><div class="example-contents"><pre class="programlisting language-java JAVA JAVA"> Connection conn = myJBossDatasource.getConnection();
WrappedConnection wrappedConn = (WrappedConnection)conn;
Connection underlyingConn = wrappedConn.getUnderlyingConnection();
OracleConnection oracleConn = (OracleConnection)underlyingConn;
</pre></div></div></div></div><div class="section" id="idm139946671032464"><div class="titlepage"><div><div><h2 class="title">A.4.Sybase</h2></div></div></div><div class="example" id="idm139946671031664"><p class="title"><strong>ExampleA.10.Sybase Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;jdbc/SybaseDB&lt;/jndi-name&gt;
    &lt;!-- Sybase jConnect URL for the database. 
	 NOTE: The hostname and port are made up values. The optional
	 database name is provided, as well as some additinal Driver
	 parameters.
    --&gt;
    &lt;connection-url&gt;jdbc:sybase:Tds:host.at.some.domain:5000/db_name?JCONNECT_VERSION=6&lt;/connection-url&gt;
    &lt;driver-class&gt;com.sybase.jdbc2.jdbc.SybDataSource&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.SybaseExceptionSorter&lt;/exception-sorter-class-name&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;Sybase&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre><div class="para">
				<a href="#ftn.idm139946671028192" class="footnote"><sup class="footnote" id="idm139946671028192">[1]</sup></a>
			</div></div></div></div><div class="section" id="idm139946671323536"><div class="titlepage"><div><div><h2 class="title">A.5.Microsoft SQL Server</h2></div></div></div><div class="para">
			To evaluate those drivers, you can use a simple JSP page to query the <code class="systemitem">pubs</code> database shipped with Microsoft SQL Server.
		</div><div class="para">
			Move the WAR archive located in <a href="https://access.redhat.com/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Administration_And_Configuration_Guide-en-US/files/mssql-test.zip" class="mimir-link-warn" title="This content is not included in Mimir.">files/mssql-test.zip</a> to the <code class="filename">/deploy</code>, start the server, and navigate your web browser to <a href="http://localhost:8080/test/test.jsp" class="mimir-link-warn" title="Mimir does not include content from: localhost">http://localhost:8080/test/test.jsp</a>.
		</div><div class="example" id="idm139946671319952"><p class="title"><strong>ExampleA.11.Local-TX Datasource Using DataDirect Driver</strong></p><div class="example-contents"><div class="para">
				This example uses the <span class="package">DataDirect Connect for JDBC</span> drivers from <a href="http://www.datadirect.com" class="mimir-link-warn" title="Mimir does not include content from: www.datadirect.com">http://www.datadirect.com</a>.
			</div><pre class="programlisting language-xml XML XML"> &lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;MerliaDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:datadirect:sqlserver://localhost:1433;DatabaseName=jboss&lt;/connection-url&gt;
    &lt;driver-class&gt;com.ddtek.jdbc.sqlserver.SQLServerDriver&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;sa&lt;/password&gt;
    
    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;
  
&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946671315776"><p class="title"><strong>ExampleA.12.Local-TX Datasource Using Merlia Driver</strong></p><div class="example-contents"><div class="para">
				This example uses the <span class="package">Merlia JDBC Driver</span> drivers from <a href="http://www.inetsoftware.de" class="mimir-link-warn" title="Mimir does not include content from: www.inetsoftware.de">http://www.inetsoftware.de</a>.
			</div><pre class="programlisting language-xml XML XML"> &lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;MerliaDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:inetdae7:localhost:1433?database=pubs&lt;/connection-url&gt;
    &lt;driver-class&gt;com.inet.tds.TdsDataSource&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;sa&lt;/password&gt;
    
    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;
  
&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946671311600"><p class="title"><strong>ExampleA.13.XA Datasource Using Merlia Driver</strong></p><div class="example-contents"><div class="para">
				This example uses the <span class="package">Merlia JDBC Driver</span> drivers from <a href="http://www.inetsoftware.de" class="mimir-link-warn" title="Mimir does not include content from: www.inetsoftware.de">http://www.inetsoftware.de</a>.
			</div><pre class="programlisting language-xml XML XML"> &lt;datasources&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;MerliaXADS&lt;/jndi-name&gt;
    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;
    &lt;isSameRM-override-value&gt;false&lt;/isSameRM-override-value&gt;
    &lt;xa-datasource-class&gt;com.inet.tds.DTCDataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="ServerName"&gt;localhost&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="DatabaseName"&gt;pubs&lt;/xa-datasource-property&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;sa&lt;/password&gt;
    
    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/xa-datasource&gt;
  
&lt;/datasources&gt;</pre></div></div><div class="section" id="idm139946671307216"><div class="titlepage"><div><div><h3 class="title">A.5.1.Microsoft JDBC Drivers</h3></div></div></div><div class="para">
				The Microsoft JDBC driver for MS SQL Server comes now in two flavors:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						SQL Server 2000 Driver for JDBC Service Pack 3 which can be used with SQL Server 2000
					</div></li><li class="listitem"><div class="para">
						Microsoft SQL Server 2005 JDBC Driver which be used with either SQL Server 2000 or 2005. This version contains numerous fixes and has been certified for JBoss Hibernate. This driver runs under JDK 5.
					</div></li></ul></div><div class="para">
				Make sure to read the <code class="filename">release.txt</code> included in the driver distribution to understand the differences between these drivers, especially the new package name introduced with 2005 and the potential conflicts when using both drivers in the same app server.
			</div><div class="example" id="idm139946671302272"><p class="title"><strong>ExampleA.14.Microsoft SQL Server 2000 Local-TX Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;MSSQL2000DS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:microsoft:sqlserver://localhost:1433;SelectMethod=cursor;DatabaseName=pubs&lt;/connection-url&gt;
    &lt;driver-class&gt;com.microsoft.jdbc.sqlserver.SQLServerDriver&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;jboss&lt;/password&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946671299568"><p class="title"><strong>ExampleA.15.Microsoft SQL Server 2005 Local-TX Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;


&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;MSSQL2005DS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:sqlserver://localhost:1433;DatabaseName=pubs&lt;/connection-url&gt;
    &lt;driver-class&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;jboss&lt;/password&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946671296880"><p class="title"><strong>ExampleA.16.Microsoft SQL Server 2005 XA Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;MSSQL2005XADS&lt;/jndi-name&gt;
    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;
    &lt;isSameRM-override-value&gt;false&lt;/isSameRM-override-value&gt;
    &lt;xa-datasource-class&gt;com.microsoft.sqlserver.jdbc.SQLServerXADataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="ServerName"&gt;localhost&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="DatabaseName"&gt;pubs&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="SelectMethod"&gt;cursor&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="User"&gt;sa&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;jboss&lt;/xa-datasource-property&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/xa-datasource&gt;

&lt;/datasources&gt;

</pre></div></div></div><div class="section" id="idm139946671293680"><div class="titlepage"><div><div><h3 class="title">A.5.2.JSQL Drivers</h3></div></div></div><div class="example" id="idm139946671292880"><p class="title"><strong>ExampleA.17.JSQL Driver</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML"> &lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;JSQLDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:JSQLConnect://localhost:1433/databaseName=testdb&lt;/connection-url&gt;
    &lt;driver-class&gt;com.jnetdirect.jsql.JSQLDriver&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div></div><div class="section" id="idm139946671289744"><div class="titlepage"><div><div><h3 class="title">A.5.3.jTDS JDBC Driver</h3></div></div></div><div class="para">
				jTDS is an open source 100% pure Java (type 4) JDBC 3.0 driver for Microsoft SQL Server (6.5, 7, 2000 and 2005) and Sybase (10, 11, 12, 15). jTDS is based on FreeTDS and is currently the fastest production-ready JDBC driver for microsoft SQL Server and Sybase. jTDS is 100% JDBC 3.0 compatible, supporting forward-only and scrollable/updateable ResultSets, concurrent (completely independent) Statements and implementing all the <code class="methodname">DatabaseMetaData</code> and <code class="methodname">ResultSetMetaData</code> methods.
			</div><div class="para">
				Download jTDS from <a href="http://jtds.sourceforge.net/" class="mimir-link-warn" title="Mimir does not include content from: jtds.sourceforge.net">http://jtds.sourceforge.net/</a>.
			</div><div class="example" id="idm139946671286160"><p class="title"><strong>ExampleA.18.jTDS Local-TX Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;


&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;jtdsDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:jtds:sqlserver://localhost:1433;databaseName=pubs&lt;/connection-url&gt;
    &lt;driver-class&gt;net.sourceforge.jtds.jdbc.Driver&lt;/driver-class&gt;
    &lt;user-name&gt;sa&lt;/user-name&gt;
    &lt;password&gt;jboss&lt;/password&gt;

    &lt;!-- optional parameters --&gt;
    &lt;transaction-isolation&gt;TRANSACTION_READ_COMMITTED&lt;/transaction-isolation&gt;
    &lt;min-pool-size&gt;10&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;30&lt;/max-pool-size&gt;
    &lt;idle-timeout-minutes&gt;15&lt;/idle-timeout-minutes&gt;
    &lt;blocking-timeout-millis&gt;5000&lt;/blocking-timeout-millis&gt;    
    &lt;new-connection-sql&gt;select 1&lt;/new-connection-sql&gt;
    &lt;check-valid-connection-sql&gt;select 1&lt;/check-valid-connection-sql&gt;
    &lt;set-tx-query-timeout&gt;&lt;/set-tx-query-timeout&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;
&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946671283104"><p class="title"><strong>ExampleA.19.jTDS XA Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;jtdsXADS&lt;/jndi-name&gt;
    &lt;xa-datasource-class&gt;net.sourceforge.jtds.jdbcx.JtdsDataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="ServerName"&gt;localhost&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="DatabaseName"&gt;pubs&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="User"&gt;sa&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;jboss&lt;/xa-datasource-property&gt;

    &lt;!-- 
	 When set to true, emulate XA distributed transaction support. Set to false to use experimental 
	 true distributed transaction support. True distributed transaction support is only available for 
	 SQL Server 2000 and requires the installation of an external stored procedure in the target server 
	 (see the README.XA file in the distribution for details).
    --&gt;
    &lt;xa-datasource-property name="XaEmulation"&gt;true&lt;/xa-datasource-property&gt;

    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;

    &lt;!-- optional parameters --&gt;
    &lt;transaction-isolation&gt;TRANSACTION_READ_COMMITTED&lt;/transaction-isolation&gt;
    &lt;min-pool-size&gt;10&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;30&lt;/max-pool-size&gt;
    &lt;idle-timeout-minutes&gt;15&lt;/idle-timeout-minutes&gt;
    &lt;blocking-timeout-millis&gt;5000&lt;/blocking-timeout-millis&gt;    
    &lt;new-connection-sql&gt;select 1&lt;/new-connection-sql&gt;
    &lt;check-valid-connection-sql&gt;select 1&lt;/check-valid-connection-sql&gt;
    &lt;set-tx-query-timeout&gt;&lt;/set-tx-query-timeout&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;MS SQLSERVER2000&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/xa-datasource&gt;

&lt;/datasources&gt;</pre></div></div></div><div class="section" id="idm139946671279184"><div class="titlepage"><div><div><h3 class="title">A.5.4."Invalid object name 'JMS_SUBSCRIPTIONS' Exception</h3></div></div></div><div class="para">
				If you receive an exception like the one in <a class="xref" href="#jms_subscriptions_exception">ExampleA.20, JMS_SUBSCRIPTIONS Exception</a> during startup, specify a <code class="methodname">SelectMethod</code> in the connection URL, as shown in <a class="xref" href="#SelectMethod-specification">ExampleA.21, Specifying a SelectMethod</a>.
			</div><div class="example" id="jms_subscriptions_exception"><p class="title"><strong>ExampleA.20.JMS_SUBSCRIPTIONS Exception</strong></p><div class="example-contents"><pre class="screen">
	  17:17:57,167 WARN  [ServiceController] Problem starting service jboss.mq.destination:name=testTopic,service=Topic
	  org.jboss.mq.SpyJMSException: Error getting durable subscriptions for topic TOPIC.testTopic; - nested throwable: (java.sql.SQLException: [Microsoft][SQLServer 2000 Driver for JDBC][SQLServer]Invalid object name 'JMS_SUBSCRIPTIONS'.)
	  at org.jboss.mq.sm.jdbc.JDBCStateManager.getDurableSubscriptionIdsForTopic(JDBCStateManager.java:290)
	  at org.jboss.mq.server.JMSDestinationManager.addDestination(JMSDestinationManager.java:656)
</pre></div></div><div class="example" id="SelectMethod-specification"><p class="title"><strong>ExampleA.21.Specifying a SelectMethod</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">
	  &lt;connection-url&gt;jdbc:microsoft:sqlserver://localhost:1433;SelectMethod=cursor;DatabaseName=jboss&lt;/connection-url&gt;
</pre></div></div></div></div><div class="section" id="idm139946671271728"><div class="titlepage"><div><div><h2 class="title">A.6.MySQL Datasource</h2></div></div></div><div class="section" id="idm139946671270928"><div class="titlepage"><div><div><h3 class="title">A.6.1.Installing the Driver</h3></div></div></div><div class="procedure"><p class="title"><strong>ProcedureA.1.Installing the Driver</strong></p><ol class="1"><li class="step"><div class="para">
						Download the driver from <a href="http://www.mysql.com/products/connector/j/" class="mimir-link-warn" title="Mimir does not include content from: www.mysql.com">http://www.mysql.com/products/connector/j/</a>. Make sure to choose the driver based on your version of MySQL.
					</div></li><li class="step"><div class="para">
						Expand the driver ZIP or TAR file, and locate the <code class="filename">.jar</code> file.
					</div></li><li class="step"><div class="para">
						Move the <code class="filename">.jar</code> file into <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">config_name</em>/lib</code>.
					</div></li><li class="step"><div class="para">
						Copy the <code class="filename"><em class="replaceable">$JBOSS_HOME</em>docs/examples/jca/mysql-ds.xml</code> example datasource deployer file to <code class="filename"><em class="replaceable">$JBOSS_HOME</em>/server/<em class="replaceable">config_name</em>/deploy/</code>, for use as a template.
					</div></li></ol></div></div><div class="section" id="idm139946671260560"><div class="titlepage"><div><div><h3 class="title">A.6.2.MySQL Local-TX Datasource</h3></div></div></div><div class="example" id="idm139946654643616"><p class="title"><strong>ExampleA.22.MySQL Local-TX Datasource</strong></p><div class="example-contents"><div class="para">
					This example uses a database hosted on <code class="systemitem">localhost</code>, on port 3306, with <code class="systemitem">autoReconnect</code> enabled. This is not a recommended configuration, unless you do not need any Transactions support.
				</div><pre class="programlisting language-xml XML XML">&lt;datasources&gt; 
  &lt;local-tx-datasource&gt; 
    
    &lt;jndi-name&gt;MySqlDS&lt;/jndi-name&gt; 
    
    &lt;connection-url&gt;jdbc:mysql://localhost:3306/database&lt;/connection-url&gt; 
    &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt; 
    
    &lt;user-name&gt;username&lt;/user-name&gt; 
    &lt;password&gt;secret&lt;/password&gt; 
    
    &lt;connection-property name="autoReconnect"&gt;true&lt;/connection-property&gt;
    
    &lt;!-- Typemapping for JBoss 4.0 --&gt; 
    &lt;metadata&gt; 
      &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt; 
    &lt;/metadata&gt; 
    
  &lt;/local-tx-datasource&gt; 
&lt;/datasources&gt; </pre></div></div></div><div class="section" id="idm139946654639280"><div class="titlepage"><div><div><h3 class="title">A.6.3.MySQL Using a Named Pipe</h3></div></div></div><div class="example" id="idm139946654638512"><p class="title"><strong>ExampleA.23.MySQL Using a Named Pipe</strong></p><div class="example-contents"><div class="para">
					This example uses a database hosted locally, but uses a named pipe instead of TCP/IP.
				</div><pre class="programlisting language-xml XML XML">&lt;datasources&gt; 
  &lt;local-tx-datasource&gt; 
    
    &lt;jndi-name&gt;MySQLDS&lt;/jndi-name&gt; 
    &lt;connection-url&gt;jdbc:mysql://./database&lt;/connection-url&gt; 
    &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt; 
    
    &lt;user-name&gt;username&lt;/user-name&gt; 
    &lt;password&gt;secret&lt;/password&gt; 
    
    &lt;connection-property name="socketFactory"&gt;com.mysql.jdbc.NamedPipeSocketFactory&lt;/connection-property&gt; 

    &lt;metadata&gt; 
      &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt; 
    &lt;/metadata&gt; 
    
  &lt;/local-tx-datasource&gt; 
&lt;/datasources&gt; </pre></div></div></div></div><div class="section" id="idm139946654634992"><div class="titlepage"><div><div><h2 class="title">A.7.PostgreSQL</h2></div></div></div><div class="example" id="idm139946654634192"><p class="title"><strong>ExampleA.24.PostgreSQL Local-TX Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;PostgresDS&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:postgresql://[servername]:[port]/[database name]&lt;/connection-url&gt;
    &lt;driver-class&gt;org.postgresql.Driver&lt;/driver-class&gt;
    &lt;user-name&gt;x&lt;/user-name&gt;
    &lt;password&gt;y&lt;/password&gt;
    &lt;!-- sql to call when connection is created
	 &lt;new-connection-sql&gt;some arbitrary sql&lt;/new-connection-sql&gt;
    --&gt;

    &lt;!-- sql to call on an existing pooled connection when it is obtained from pool 
	 &lt;check-valid-connection-sql&gt;some arbitrary sql&lt;/check-valid-connection-sql&gt;
    --&gt;

    &lt;!-- corresponding type-mapping in the standardjbosscmp-jdbc.xml (optional) --&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;PostgreSQL 7.2&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;

&lt;/datasources&gt;</pre></div></div><div class="example" id="idm139946654631024"><p class="title"><strong>ExampleA.25.PostgreSQL XA Datasource</strong></p><div class="example-contents"><div class="para">
				This configuratino works for PostgreSQL 8.x and later.
			</div><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;xa-datasource&gt;
    &lt;jndi-name&gt;PostgresDS&lt;/jndi-name&gt;

    &lt;xa-datasource-class&gt;org.postgresql.xa.PGXADataSource&lt;/xa-datasource-class&gt;
    &lt;xa-datasource-property name="ServerName"&gt;[servername]&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="PortNumber"&gt;5432&lt;/xa-datasource-property&gt;

    &lt;xa-datasource-property name="DatabaseName"&gt;[database name]&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="User"&gt;[username]&lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;[password]&lt;/xa-datasource-property&gt;

    &lt;track-connection-by-tx&gt;&lt;/track-connection-by-tx&gt;
  &lt;/xa-datasource&gt;
&lt;/datasources&gt;</pre></div></div></div><div class="section" id="idm139946654627376"><div class="titlepage"><div><div><h2 class="title">A.8.Ingres</h2></div></div></div><div class="example" id="idm139946654626576"><p class="title"><strong>ExampleA.26.Ingres Datasource</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;IngresDS&lt;/jndi-name&gt;
    &lt;use-java-context&gt;false&lt;/use-java-context&gt;
    &lt;driver-class&gt;com.ingres.jdbc.IngresDriver&lt;/driver-class&gt;
    &lt;connection-url&gt;jdbc:ingres://localhost:II7/testdb&lt;/connection-url&gt;
    &lt;datasource-class&gt;com.ingres.jdbc.IngresDataSource&lt;/datasource-class&gt;
    &lt;datasource-property name="ServerName"&gt;localhost&lt;/datasource-property&gt;
    &lt;datasource-property name="PortName"&gt;II7&lt;/datasource-property&gt;
    &lt;datasource-property name="DatabaseName"&gt;testdb&lt;/datasource-property&gt;
    &lt;datasource-property name="User"&gt;testuser&lt;/datasource-property&gt;
    &lt;datasource-property name="Password"&gt;testpassword&lt;/datasource-property&gt;
    &lt;new-connection-sql&gt;select count(*) from iitables&lt;/new-connection-sql&gt;

    &lt;check-valid-connection-sql&gt;select count(*) from iitables&lt;/check-valid-connection-sql&gt;
    &lt;metadata&gt;
      &lt;type-mapping&gt;Ingres&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;
&lt;/datasources&gt;</pre><div class="para">
				<a href="#ftn.idm139946654623024" class="footnote"><sup class="footnote" id="idm139946654623024">[2]</sup></a>
			</div></div></div></div><div class="footnotes"><br/><hr width="100" align="left"/><div id="ftn.idm139946671028192" class="footnote"><div class="para"><a href="#idm139946671028192" class="para"><sup class="para">[1] </sup></a>
					Source: <em class="citetitle"><a href="http://community.jboss.org/wiki/SetUpASybaseDatasource" class="mimir-link-warn" title="Mimir does not include content from: community.jboss.org">http://community.jboss.org/wiki/SetUpASybaseDatasource</a></em>
				</div></div><div id="ftn.idm139946654623024" class="footnote"><div class="para"><a href="#idm139946654623024" class="para"><sup class="para">[2] </sup></a>
					Source: <em class="citetitle"><a href="http://community.ingres.com" class="mimir-link-warn" title="Mimir does not include content from: community.ingres.com">http://community.ingres.com</a></em>
				</div></div></div></div><div xml:lang="en-US" class="appendix" id="logging-appendix" lang="en-US"><div class="titlepage"><div><div><h2 class="title">AppendixB.Logging Information and Recipes</h2></div></div></div><div class="section" id="idm139946676123056"><div class="titlepage"><div><div><h2 class="title">B.1.Log Level Descriptions</h2></div></div></div><div class="para">
			<a class="xref" href="#log-levels-table">TableB.1, <span class="application">log4j</span> Log Level Definitions</a> lists the typical meanings for different log levels in <span class="application"><strong>log4j</strong></span>. Your application may interpret these levels differently, depending on your choices.
		</div><div class="table" id="log-levels-table"><p class="title"><strong>TableB.1.<span class="application">log4j</span> Log Level Definitions</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="log4j Log Level Definitions"><colgroup><col><!--Empty--></col><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th id="idm139946676337456" scope="col"> <span class="application"><strong>log4j</strong></span> Level </th><th id="idm139946674034480" scope="col"> JDK Level </th><th id="idm139946669680496" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm139946676337456"> FATAL </td><td headers="idm139946674034480"> </td><td headers="idm139946669680496"> <div class="para">
							The Application Service is likely to crash.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> ERROR </td><td headers="idm139946674034480"> SEVERE </td><td headers="idm139946669680496"> <div class="para">
							A definite problem exists.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> WARN </td><td headers="idm139946674034480"> WARNING </td><td headers="idm139946669680496"> <div class="para">
							Likely to be a problem, but may be recoverable.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> INFO </td><td headers="idm139946674034480"> INFO </td><td headers="idm139946669680496"> <div class="para">
							Low-volume detailed logging. Something of interest, but not a problem.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> DEBUG </td><td headers="idm139946674034480"> FINE </td><td headers="idm139946669680496"> <div class="para">
							Low-volume detailed logging. Information that is probably not of interest.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> </td><td headers="idm139946674034480"> FINER </td><td headers="idm139946669680496"> <div class="para">
							Medium-volume detailed logging.
						</div>
						 </td></tr><tr><td headers="idm139946676337456"> TRACE </td><td headers="idm139946674034480"> FINEST </td><td headers="idm139946669680496"> <div class="para">
							High-volume detailed logging.
						</div>
						 </td></tr></tbody></table></div></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				The more verbose logging levels are not appropriate for production systems, because of the high level of output they generate.
			</div></div></div><div class="example" id="idm139946670965888"><p class="title"><strong>ExampleB.1.Restricting Logged Information to a Specific Log Level</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML">&lt;!-- Show the evolution of the DataSource pool in the logs [inUse/Available/Max]--&gt;
&lt;category name="org.jboss.resource.connectionmanager.JBossManagedConnectionPool"&gt;
  &lt;priority value="TRACE" class="org.jboss.logging.XLevel"&gt;&lt;/priority&gt;
&lt;/category&gt;</pre></div></div></div><div class="section" id="idm139946670963344"><div class="titlepage"><div><div><h2 class="title">B.2.Separate Log Files Per Application</h2></div></div></div><div class="para">
			To segregate logging output per application, assign <span class="application"><strong>log4j</strong></span> categories to specific appenders. This is typically done in the <code class="filename">conf/log4j.xml</code> deployment descriptor.
		</div><div class="example" id="idm139946670961232"><p class="title"><strong>ExampleB.2.Filtering App1 Log Output to a Separate File</strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML"> &lt;appender name="App1Log" class="org.apache.log4j.FileAppender"&gt;
  &lt;errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"&gt;&lt;/errorHandler&gt;
  &lt;param name="Append" value="false"/&gt;
  &lt;param name="File" value="${jboss.server.home.dir}/log/app1.log"/&gt;
  &lt;layout class="org.apache.log4j.PatternLayout"&gt;
    &lt;param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n"/&gt;
  &lt;/layout&gt;
&lt;/appender&gt;

...

&lt;category name="com.app1"&gt;
  &lt;appender-ref ref="App1Log"&gt;&lt;/appender-ref&gt;
&lt;/category&gt;
&lt;category name="com.util"&gt;
  &lt;appender-ref ref="App1Log"&gt;&lt;/appender-ref&gt;
&lt;/category&gt;

</pre></div></div><div class="example" id="idm139946670908592"><p class="title"><strong>ExampleB.3.Using TCLMCFilter</strong></p><div class="example-contents"><div class="para">
				Enterprise Platform 5.1 includes the new class <code class="classname">jboss.logging.filter.TCLMCFilter</code>, which allows you to filter based on the deployment URL.
			</div><pre class="programlisting language-xml XML XML"> &lt;appender name="App1Log" class="org.apache.log4j.FileAppender"&gt;
  &lt;errorHandler class="org.jboss.logging.util.OnlyOnceErrorHandler"&gt;&lt;/errorHandler&gt;
  &lt;param name="Append" value="false"/&gt;
  &lt;param name="File" value="${jboss.server.home.dir}/log/app1.log"/&gt;
  &lt;layout class="org.apache.log4j.PatternLayout"&gt;
	 &lt;param name="ConversionPattern" value="%d{ABSOLUTE} %-5p [%c{1}] %m%n"/&gt;
  &lt;/layout&gt;
  &lt;filter class="org.jboss.logging.filter.TCLMCFilter"&gt;
	 &lt;param name="AcceptOnMatch" value="true"/&gt;
	 &lt;param name="DeployURL" value="app1.ear"/&gt;
  &lt;/filter&gt;    
  
  &lt;!-- end the filter chain here --&gt;
  &lt;filter class="org.apache.log4j.varia.DenyAllFilter"&gt;&lt;/filter&gt;

&lt;/appender&gt;</pre></div></div></div><div class="section" id="idm139946670904576"><div class="titlepage"><div><div><h2 class="title">B.3.Redirecting Category Output</h2></div></div></div><div class="para">
			When you increase the level of logging for one or more categories, it is often useful to redirect the output to a seperate file for easier investigation. To do this you add an <code class="option">appender-ref</code> to the category.
		</div><div class="example" id="idm139946655259232"><p class="title"><strong>ExampleB.4.Adding an <code class="option">appender-ref</code></strong></p><div class="example-contents"><pre class="programlisting language-xml XML XML"> &lt;appender name="JSR77" class="org.apache.log4j.FileAppender"&gt;
  &lt;param name="File" value="${jboss.server.home.dir}/log/jsr77.log"/&gt;
  ...
&lt;/appender&gt;

&lt;!-- Limit the JSR77 categories --&gt;
&lt;category name="org.jboss.management" additivity="false"&gt;
  &lt;priority value="DEBUG"&gt;&lt;/priority&gt;
  &lt;appender-ref ref="JSR77"&gt;&lt;/appender-ref&gt;
&lt;/category&gt;</pre></div></div><div class="para">
			All <code class="classname">org.jboss.management</code> output goes to the <code class="filename">jsr77.log</code> file. The <code class="option">additivity</code> attribute controls whether output continues to go to the root category appender. If <code class="literal">false</code>, output only goes to the appenders referred to by the category.
		</div></div></div></div><div><div class="legalnotice"><a id="idm139946671941360"><!--Empty--></a><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span> 2010 Red Hat, Inc.
	</div><div class="para">
		This document is licensed by Red Hat under the <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="mimir-link-warn" title="Mimir does not include content from: creativecommons.org">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. If you distribute this document, or a modified version of it, you must provide attribution to Red Hat, Inc. and provide a link to the original. If the document is modified, all Red Hat trademarks must be removed.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span> is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span> is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span> is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span> is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span> is an official trademark of Joyent. Red Hat Software Collections is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span> Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></body>

        
        
    </div>
    

</div> 


                            </bdo>
                        </main>
                    </div>
                </main>
            </div>
        
            <!--#include virtual="/includes/footer/index.html" -->
        </div>
    </body>
</html>
