<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir.min.css">
        




    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_Bwzy34i9pSdDlzGALvqVwG4fpgGp08KLMAkClGNY9M4.css" />



<link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir-doc-toc.min.css" />



        
        <!--#include virtual="/includes/head/index.html" -->

        
        <title>
Hibernate Entity Manager Reference Guide - JBoss Enterprise Application Platform Common Criteria Certification 5
</title>
        
<meta name="product" content="JBoss Enterprise Application Platform Common Criteria Certification" />
<meta name="documentation_version" content="5" />
<meta name="documentKind" content="documentation" />
<meta name="portal_content_subtype" content="title" />
<meta name="lastModifiedDate" content="2017-11-28T18:42:57.000Z" />


        
            
        
        
            
                
                
                <!-- mimir_solr_yesindex -->
                <meta name="mimir_solr_yesindex" content="true" />
            
        
    </head>

    <body class="mimir-body">

        
        

        
        <div id="page-wrap" class="page-wrap">
            <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">
                <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
                <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

                <header class="masthead" id="masthead">

                    
                    <!--#include virtual="/includes/header/index.html" -->

                    
                    
                    
                        
                    
                    
                        <div class="breadcrumbs">
                            <div id="breadcrumbs" class="container">
                                
                                <a href="/">Home</a>
                                
                                <a href="/products/">Product Documentation</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/7.2.3/">JBoss Enterprise Application Platform Common Criteria Certification</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_common_criteria_certification/5/">5</a>
                                
                                
                                Hibernate Entity Manager Reference Guide
                                
                            </div>
                        </div>
                    
                </header>

                <main id="cp-main" class="portal-content-area">
                    <div id="cp-content" class="main-content">
                        
                        <main class="container mimir-docs">
                            
                            <bdo>
                                

<script type="module" src="/mimir/scripts/mimir-doc-toc.min.js"></script>






<div class="docs-grid">

    <nav id="mimir-doc-toc" class="mimir-doc-toc">
      <div class="mimir-doc-toc-inner">
          <!-- single-page -->
        
            
              <ol>
                <li>
                        
                        <a href="#">Hibernate Entity Manager Reference Guide</a>
                    </li><li>
                        <a href="#idm140350352760320">
                            Introducing EJB3 Persistence
                        </a>
                    </li><li>
                        <a href="#architecture">
                            1. Architecture
                        </a><ol>
                <li>
                        <a href="#idm140350352490848">
                            1.1. Definitions
                        </a>
                    </li><li>
                        <a href="#idm140350353586960">
                            1.2. EJB container environment
                        </a><ol>
                <li>
                        <a href="#idm140350353586192">
                            1.2.1. Container-managed entity manager
                        </a>
                    </li><li>
                        <a href="#idm140350353584304">
                            1.2.2. Application-managed entity manager
                        </a>
                    </li><li>
                        <a href="#architecture-ejb-persistctxscope">
                            1.2.3. Persistence context scope
                        </a>
                    </li><li>
                        <a href="#architecture-ejb-persistctxpropagation">
                            1.2.4. Persistence context propagation
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#architecture-javase">
                            1.3. Java SE environments
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration">
                            2. Setup and configuration
                        </a><ol>
                <li>
                        <a href="#idm140350358861072">
                            2.1. Setup
                        </a>
                    </li><li>
                        <a href="#setup-configuration">
                            2.2. Configuration and bootstrapping
                        </a><ol>
                <li>
                        <a href="#setup-configuration-packaging">
                            2.2.1. Packaging
                        </a>
                    </li><li>
                        <a href="#setup-configuration-bootstrapping">
                            2.2.2. Bootstrapping
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140350358583888">
                            2.3. Event listeners
                        </a>
                    </li><li>
                        <a href="#idm140350358550864">
                            2.4. Obtaining an EntityManager in a Java SE environment
                        </a>
                    </li><li>
                        <a href="#idm140350358545392">
                            2.5. Various
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#objectstate">
                            3. Working with objects
                        </a><ol>
                <li>
                        <a href="#idm140350355267968">
                            3.1. Entity states
                        </a>
                    </li><li>
                        <a href="#idm140350356193760">
                            3.2. Making objects persistent
                        </a>
                    </li><li>
                        <a href="#idm140350354521984">
                            3.3. Loading an object
                        </a>
                    </li><li>
                        <a href="#idm140350354406656">
                            3.4. Querying objects
                        </a><ol>
                <li>
                        <a href="#idm140350361333424">
                            3.4.1. Executing queries
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140350361032560">
                            3.5. Modifying persistent objects
                        </a>
                    </li><li>
                        <a href="#idm140350361028976">
                            3.6. Modifying detached objects
                        </a>
                    </li><li>
                        <a href="#idm140350361022800">
                            3.7. Automatic state detection
                        </a>
                    </li><li>
                        <a href="#idm140350358485248">
                            3.8. Deleting managed objects
                        </a>
                    </li><li>
                        <a href="#idm140350358482640">
                            3.9. Flush the persistence context
                        </a><ol>
                <li>
                        <a href="#idm140350358481872">
                            3.9.1. In a transaction
                        </a>
                    </li><li>
                        <a href="#idm140350358461376">
                            3.9.2. Outside a transaction
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#objectstate-transitive">
                            3.10. Transitive persistence
                        </a>
                    </li><li>
                        <a href="#idm140350358438128">
                            3.11. Locking
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transactions">
                            4. Transactions and Concurrency
                        </a><ol>
                <li>
                        <a href="#transactions-basics">
                            4.1. Entity manager and transaction scopes
                        </a><ol>
                <li>
                        <a href="#transactions-basics-uow">
                            4.1.1. Unit of work
                        </a>
                    </li><li>
                        <a href="#transactions-basics-apptx">
                            4.1.2. Long units of work
                        </a>
                    </li><li>
                        <a href="#transactions-basics-identity">
                            4.1.3. Considering object identity
                        </a>
                    </li><li>
                        <a href="#transactions-basics-issues">
                            4.1.4. Common concurrency control issues
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transactions-demarcation">
                            4.2. Database transaction demarcation
                        </a><ol>
                <li>
                        <a href="#transactions-demarcation-nonmanaged">
                            4.2.1. Non-managed environment
                        </a>
                    </li><li>
                        <a href="#transactions-demarcation-jta">
                            4.2.2. Using JTA
                        </a>
                    </li><li>
                        <a href="#transactions-demarcation-exceptions">
                            4.2.3. Exception handling
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140350343882912">
                            4.3. EXTENDED Persistence Context
                        </a><ol>
                <li>
                        <a href="#idm140350345434880">
                            4.3.1. Container Managed Entity Manager
                        </a>
                    </li><li>
                        <a href="#idm140350345430560">
                            4.3.2. Application Managed Entity Manager
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#transactions-optimistic">
                            4.4. Optimistic concurrency control
                        </a><ol>
                <li>
                        <a href="#transactions-optimistic-manual">
                            4.4.1. Application version checking
                        </a>
                    </li><li>
                        <a href="#transactions-optimistic-longsession">
                            4.4.2. Extended entity manager and automatic versioning
                        </a>
                    </li><li>
                        <a href="#transactions-optimistic-detached">
                            4.4.3. Detached objects and automatic versioning
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#listeners">
                            5. Entity listeners and Callback methods
                        </a><ol>
                <li>
                        <a href="#idm140350351802144">
                            5.1. Definition
                        </a>
                    </li><li>
                        <a href="#idm140350344872576">
                            5.2. Callbacks and listeners inheritance
                        </a>
                    </li><li>
                        <a href="#idm140350360949840">
                            5.3. XML definition
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#batch">
                            6. Batch processing
                        </a><ol>
                <li>
                        <a href="#batch-direct">
                            6.1. Bulk update/delete
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#queryhql">
                            7. EJB-QL: The Object Query Language
                        </a><ol>
                <li>
                        <a href="#queryhql-casesensitivity">
                            7.1. Case Sensitivity
                        </a>
                    </li><li>
                        <a href="#queryhql-from">
                            7.2. The from clause
                        </a>
                    </li><li>
                        <a href="#queryhql-joins">
                            7.3. Associations and joins
                        </a>
                    </li><li>
                        <a href="#queryhql-select">
                            7.4. The select clause
                        </a>
                    </li><li>
                        <a href="#queryhql-aggregation">
                            7.5. Aggregate functions
                        </a>
                    </li><li>
                        <a href="#queryhql-polymorphism">
                            7.6. Polymorphic queries
                        </a>
                    </li><li>
                        <a href="#queryhql-where">
                            7.7. The where clause
                        </a>
                    </li><li>
                        <a href="#queryhql-expressions">
                            7.8. Expressions
                        </a>
                    </li><li>
                        <a href="#queryhql-ordering">
                            7.9. The order by clause
                        </a>
                    </li><li>
                        <a href="#queryhql-grouping">
                            7.10. The group by clause
                        </a>
                    </li><li>
                        <a href="#queryhql-subqueries">
                            7.11. Subqueries
                        </a>
                    </li><li>
                        <a href="#queryhql-examples">
                            7.12. EJB-QL examples
                        </a>
                    </li><li>
                        <a href="#queryhql-bulk">
                            7.13. Bulk UPDATE & DELETE Statements
                        </a>
                    </li><li>
                        <a href="#queryhql-tipstricks">
                            7.14. Tips & Tricks
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#query_native">
                            8. Native query
                        </a><ol>
                <li>
                        <a href="#idm140350356183168">
                            8.1. Expressing the resultset
                        </a>
                    </li><li>
                        <a href="#idm140350355422800">
                            8.2. Using native SQL Queries
                        </a>
                    </li><li>
                        <a href="#idm140350344126448">
                            8.3. Named queries
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#appe-Publican-Revision_History">
                            A. Revision History
                        </a>
                    </li><li>
                        <a href="#idm140350358378800">
                            Legal Notice
                        </a>
                    </li>
            </ol>
            
        
      </div>
    </nav>

    
    <div class="pvof-doc__wrapper" id="doc-wrapper">
        <section class="mimir-doc-title" id="mimir-doc--hibernate_entity_manager_reference_guide">
            <h1 class="title">Hibernate Entity Manager Reference Guide</h1>
        </section>
        <body><div xml:lang="en-US" class="book" id="idm140350361048176" lang="en-US"><div class="titlepage"><div><div class="producttitle"><span class="productname">JBoss Enterprise Application Platform Common Criteria Certification</span> <span class="productnumber">5</span></div><div><h2 class="subtitle">for use with JBoss Enterprise Application Platform 5 Common Criteria Certification</h2></div><p class="edition">Edition 5.1.0</p><div><h3 class="corpauthor">
		<span class="inlinemediaobject"><object data="https://access.redhat.com/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Entity_Manager_Reference_Guide-en-US/images/a78399a6916bd5b945caa082f6c4fa4e/title_logo.svg" type="image/svg+xml"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Common_Criteria_Certification-5-Hibernate_Entity_Manager_Reference_Guide-en-US/images/20c014cff25dbc2aeb4126383228ede4/title_logo.png" alt="" /></object></span>

	</h3></div><div><div xml:lang="en-US" class="authorgroup" lang="en-US"><div class="author"><h3 class="author"><span class="firstname">Red Hat Documentation Group</span> <span class="surname"><!--Empty--></span></h3></div></div></div><div><p class="copyright">Copyright © 2011 Red Hat, Inc</p></div><div><a href="#idm140350358378800">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
			The Hibernate Entity Manager Reference Guide for JBoss Enterprise Application Platform 5.1.0.
		</div></div></div></div></div><div xml:lang="en-US" class="preface" id="idm140350352760320" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Introducing EJB3 Persistence</h1></div></div></div><div class="para">
		The EJB3 specification recognizes the interest and the success of the transparent object/relational mapping paradigm. The EJB3 specification standardizes the basic APIs and the metadata needed for any object/relational persistence mechanism. <span class="emphasis"><em>Hibernate EntityManager</em></span> implements the programming interfaces and lifecycle rules as defined by the EJB3 persistence specification. Together with <span class="emphasis"><em>Hibernate Annotations</em></span>, this wrapper implements a complete (and standalone) EJB3 persistence solution on top of the mature Hibernate core. You may use a combination of all three together, annotations without EJB3 programming interfaces and lifecycle, or even pure native Hibernate, depending on the business and technical needs of your project. You can at all times fall back to Hibernate native APIs, or if required, even to native JDBC and SQL.
	</div></div><div xml:lang="en-US" class="chapter" id="architecture" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Architecture</h1></div></div></div><div class="section" id="idm140350352490848"><div class="titlepage"><div><div><h2 class="title">1.1. Definitions</h2></div></div></div><div class="para">
			EJB3 is part of the Java EE 5.0 platform. Persistence in EJB3 is available in EJB3 containers, as well as for standalone J2SE applications that execute outside of a particular container. The following programming interfaces and artifacts are available in both environments.
		</div><div class="variablelist"><dl class="variablelist compact"><dt><span class="term"> <code class="literal">EntityManagerFactory</code> </span></dt><dd><div class="para">
						An entity manager factory provides entity manager instances, all instances are configured to connect to the same database, to use the same default settings as defined by the particular implementation, etc. You can prepare several entity manager factories to access several data stores. This interface is similar to the <code class="literal">SessionFactory</code> in native Hibernate.
					</div></dd><dt><span class="term"> <code class="literal">EntityManager</code> </span></dt><dd><div class="para">
						The <code class="literal">EntityManager</code> API is used to access a database in a particular unit of work. It is used to create and remove persistent entity instances, to find entities by their primary key identity, and to query over all entities. This interface is similar to the <code class="literal">Session</code> in Hibernate.
					</div></dd><dt><span class="term">Persistence context</span></dt><dd><div class="para">
						A persistence context is a set of entity instances in which for any persistent entity identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle is managed by a particular entity manager. The scope of this context can either be the transaction, or an extended unit of work.
					</div></dd><dt><span class="term">Persistence unit</span></dt><dd><div class="para">
						The set of entity types that can be managed by a given entity manager is defined by a persistence unit. A persistence unit defines the set of all classes that are related or grouped by the application, and which must be collocated in their mapping to a single data store.
					</div></dd><dt><span class="term">Container-managed entity manager</span></dt><dd><div class="para">
						An Entity Manager whose lifecycle is managed by the container
					</div></dd><dt><span class="term">Application-managed entity manager</span></dt><dd><div class="para">
						An Entity Manager whose lifecycle is managed by the application.
					</div></dd><dt><span class="term">JTA entity manager</span></dt><dd><div class="para">
						Entity manager involved in a JTA transaction
					</div></dd><dt><span class="term">Resource-local entity manager</span></dt><dd><div class="para">
						Entity manager using a resource transaction (not a JTA transaction).
					</div></dd></dl></div></div><div class="section" id="idm140350353586960"><div class="titlepage"><div><div><h2 class="title">1.2. EJB container environment</h2></div></div></div><div class="section" id="idm140350353586192"><div class="titlepage"><div><div><h3 class="title">1.2.1. Container-managed entity manager</h3></div></div></div><div class="para">
				The most common and widely used entity manager in a Java EE environment is the container-managed entity manager. In this mode, the container is responsible for the opening and closing of the entity manager (this is transparent to the application). It is also responsible for transaction boundaries. A container-managed entity manager is obtained in an application through dependency injection or through JNDI lookup. A container-managed entity manger requires the use of a JTA transaction.
			</div></div><div class="section" id="idm140350353584304"><div class="titlepage"><div><div><h3 class="title">1.2.2. Application-managed entity manager</h3></div></div></div><div class="para">
				An application-managed entity manager allows you to control the entity manager in application code. This entity manager is retrieved through the <code class="literal">EntityManagerFactory</code> API. An application managed entity manager can be either involved in the current JTA transaction (a JTA entity manager), or the transaction may be controlled through the <code class="literal">EntityTransaction</code> API (a resource-local entity manager). The resource-local entity manager transaction maps to a direct resource transaction (i. e. in Hibernate's case a JDBC transaction). The entity manager type (JTA or resource-local) is defined at configuration time, when setting up the entity manager factory.
			</div></div><div class="section" id="architecture-ejb-persistctxscope"><div class="titlepage"><div><div><h3 class="title">1.2.3. Persistence context scope</h3></div></div></div><div class="para">
				An entity manager is the API to interact with the persistence context. Two common strategies can be used: binding the persistence context to the transaction boundaries, or keeping the persistence context available across several transactions.
			</div><div class="para">
				The most common case is to bind the persistence context scope to the current transaction scope. This is only doable when JTA transactions are used: the persistence context is associated with the JTA transaction life cycle. When a entity manager is invoked, the persistence context is also opened, if there is no persistence context associated with the current JTA transaction. Otherwise, the associated persistence context is used. The persistence context ends when the JTA transaction completes. This means that during the JTA transaction, an application will be able to work on managed entities of the same persistence context. In other words, you don't have to pass the entity manager's persistence context across your EJB method calls, but simply use dependency injection or lookup whenever you need an entity manager.
			</div><div class="para">
				You can also use an extended persistence context. This can be combined with stateful session beans, if you use a container-managed entity manager: the persistence context is created when an entity manager is retrieved from dependency injection or JNDI lookup, and is kept until the container closes it after the completion of the <code class="literal">Remove</code> stateful session bean method. This is a perfect mechanism for implementing a "long" unit of work pattern. For example, if you have to deal with multiple user interaction cycles as a single unit of work (e.g. a wizard dialog that has to be fully completed), you usually model this as a unit of work from the point of view of the application user, and implement it using an extended persistence context. Please refer to the Hibernate reference manual or the book Hibernate In Action for more information about this pattern. JBoss Seam is a framework that link together JSF and EJB3 around the notion of conversation and unit of work. For an application-managed entity manager the persistence context is created when the entity manager is created and kept until the entity manager is closed. In an extended persistence context, all modification operations (persist, merge, remove) executed outside a transaction are queued until the persistence context is attached to a transaction. The transaction typically occurs at the user process end, allowing the whole process to be commited or rollbacked. For application-managed entity manager only support the extended persistence context.
			</div><div class="para">
				A resource-local entity manager or an entity manager created with <code class="literal">EntityManagerFactory.createEntityManager()</code> (application-managed) has a one-to-one relationship with a persistence context. In other situations <span class="emphasis"><em>persistence context propagation</em></span> occurs.
			</div></div><div class="section" id="architecture-ejb-persistctxpropagation"><div class="titlepage"><div><div><h3 class="title">1.2.4. Persistence context propagation</h3></div></div></div><div class="para">
				Persistence context propagation occurs for container-managed entity managers.
			</div><div class="para">
				In a transaction-scoped container managed entity manager (common case in a Java EE environment), the JTA transaction propagation is the same as the persistence context resource propagation. In other words, container-managed transaction-scoped entity managers retrieved within a given JTA transaction all share the same persistence context. In Hibernate terms, this means all managers share the same session.
			</div><div class="para">
				Important: persistence context are never shared between different JTA transactions or between entity manager that do not came from the same entity manager factory. There are some noteworthy exceptions for context propagation when using extended persistence contexts:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						If a stateless session bean, message-driven bean, or stateful session bean with a transaction-scoped persistence context calls a stateful session bean with an extended persistence context in the same JTA transaction, an IllegalStateException is thrown.
					</div></li><li class="listitem"><div class="para">
						If a stateful session bean with an extended persistence context calls a stateless session bean or a stateful session bean with a transaction-scoped persistence context in the same JTA transaction, the persistence context is propagated.
					</div></li><li class="listitem"><div class="para">
						If a stateful session bean with an extended persistence context calls a stateless or stateful session bean in a different JTA transaction context, the persistence context is not propagated.
					</div></li><li class="listitem"><div class="para">
						If a stateful session bean with an extended persistence context instantiates another stateful session bean with an extended persistence context, the extended persistence context is inherited by the second stateful session bean. If the second stateful session bean is called with a different transaction context than the first, an IllegalStateException is thrown.
					</div></li><li class="listitem"><div class="para">
						If a stateful session bean with an extended persistence context calls a stateful session bean with a different extended persistence context in the same transaction, an IllegalStateException is thrown.
					</div></li></ul></div></div></div><div class="section" id="architecture-javase"><div class="titlepage"><div><div><h2 class="title">1.3. Java SE environments</h2></div></div></div><div class="para">
			In a Java SE environment only extended context application-managed entity managers are available. You can retrieve an entity manger using the <code class="literal">EntityManagerFactory</code> API. Only resource-local entity managers are available. In other words, JTA transactions and persistence context propagation are not supported in Java SE (you will have to propagate the persistence context yourself, e.g. using the thread local session pattern popular in the Hibernate community).
		</div><div class="para">
			Extended context means that a persistence context is created when the entity manager is retrieved (using <code class="literal">EntityManagerFactory.createEntityManager(...)</code> ) and closed when the entity manager is closed. Many resource-local transaction share the same persistence context, in this case.
		</div></div></div><div xml:lang="en-US" class="chapter" id="configuration" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Setup and configuration</h1></div></div></div><div class="section" id="idm140350358861072"><div class="titlepage"><div><div><h2 class="title">2.1. Setup</h2></div></div></div><div class="para">
			The EJB 3.0 / JPA compatible Hibernate EntityManager is built on top of Hibernate core and Hibernate Annotations. You have to use compatible versions of each module. Please consult the compatibility matrix in the hibernate.org download section. The following libraries have to be in your classpath: hibernate3.jar, hibernate-annotations.jar, hibernate-commons-annotations.jar, hibernate-entitymanager.jar and all needed third party libraries for each package (incl. ejb-persistence.jar).
		</div></div><div class="section" id="setup-configuration"><div class="titlepage"><div><div><h2 class="title">2.2. Configuration and bootstrapping</h2></div></div></div><div class="section" id="setup-configuration-packaging"><div class="titlepage"><div><div><h3 class="title">2.2.1. Packaging</h3></div></div></div><div class="para">
				The configuration for entity managers both inside an application server and in a standalone application reside in a persistence archive. A persistence archive is a JAR file which must define a <code class="literal">persistence.xml</code> file that resides in the <code class="filename">META-INF</code> folder. All properly annotated classes included in the archive (ie having an <code class="literal">@Entity</code> annotation), all annotated packages and all Hibernate hbm.xml files included in the archive will be added to the persistence unit configuration, so by default, your persistence.xml will be quite minimalist:
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;
   &lt;persistence-unit name="sample"&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="para">
				Here's a more complete example of a <code class="filename"><code class="literal">persistence.xml</code></code> file
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;
   &lt;persistence-unit name="manager1" transaction-type="JTA"&gt;
      &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
      &lt;jta-data-source&gt;java:/DefaultDS&lt;/jta-data-source&gt;
      &lt;mapping-file&gt;ormap.xml&lt;/mapping-file&gt;
      &lt;jar-file&gt;MyApp.jar&lt;/jar-file&gt;
      &lt;class&gt;org.acme.Employee&lt;/class&gt;
      &lt;class&gt;org.acme.Person&lt;/class&gt;
      &lt;class&gt;org.acme.Address&lt;/class&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.hbm2ddl.auto" value="create-drop"/&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="variablelist"><dl class="variablelist compact"><dt><span class="term"><code class="code">name</code></span></dt><dd><div class="para">
							(attribute) Every entity manager must have a name.
						</div></dd><dt><span class="term"><code class="code">transaction-type</code></span></dt><dd><div class="para">
							(attribute) Transaction type used. Either JTA or RESOURCE_LOCAL (default to JTA in a JavaEE environment and to RESOURCE_LOCAL in a JavaSE environment). When a jta-datasource is used, the default is JTA, if non-jta-datasource is used, RESOURCE_LOCAL is used.
						</div></dd><dt><span class="term"><code class="code">provider</code></span></dt><dd><div class="para">
							The provider is a fully-qualified class name of the EJB Persistence provider. You do not have to define it if you don't work with several EJB3 implementations. This is needed when you are using multiple vendor implementations of EJB Persistence.
						</div></dd><dt><span class="term"><code class="code">jta-data-source</code>, <code class="code">non-jta-data-source</code></span></dt><dd><div class="para">
							This is the JNDI name of where the javax.sql.DataSource is located. When running without a JNDI available Datasource, you must specify JDBC connections with Hibernate specific properties (see below).
						</div></dd><dt><span class="term"><code class="code">mapping-file</code></span></dt><dd><div class="para">
							The class element specifies a EJB3 compliant XML mapping file that you will map. The file has to be in the classpath. As per the EJB3 specification, Hibernate EntityManager will try to load the mapping file located in the jar file at <code class="literal">META_INF/orm.xml</code>. Of course any explicit mapping file will be loaded too. As a matter of fact, you can provide any XML file in the mapping file element ie. either hbm files or EJB3 deployment descriptor.
						</div></dd><dt><span class="term"><code class="code">jar-file</code></span></dt><dd><div class="para">
							The jar-file elements specifies a jar to analyse. All properly annotated classes, annotated packages and all hbm.xml files part of this jar file will be added to the persistence unit configuration. This element is mainly used in Java EE environment. Use of this one in Java SE should be considered as non portable, in this case a absolute url is needed. You can alternatively point to a directory (This is especially useful when in your test environment, the persistence.xml file is not under the same root directory or jar than your domain model).
						</div><pre class="programlisting">        &lt;jar-file&gt;file:/home/turin/work/local/lab8/build/classes&lt;/jar-file&gt;</pre></dd><dt><span class="term"><code class="code">exclude-unlisted-classes</code></span></dt><dd><div class="para">
							Do not check the main jar file for annotated classes. Only explicit classes will be part of the persistence unit.
						</div></dd><dt><span class="term"><code class="code">class</code></span></dt><dd><div class="para">
							The class element specifies a fully qualified class name that you will map. By default all properly annotated classes and all hbm.xml files found inside the archive are added to the persistence unit configuration. You can add some external entity through the class element though. As an extension to the specification, you can add a package name in the <code class="literal">&lt;class&gt;</code> element (eg <code class="code">&lt;class&gt;org.hibernate.eg&lt;/class&gt;</code>). Specifying a package in the <code class="literal">&lt;class&gt;</code> element will include only the annotated classes.
						</div></dd><dt><span class="term"><code class="code">properties</code></span></dt><dd><div class="para">
							The properties element is used to specify vendor specific properties. This is where you will define your Hibernate specific configurations. This is also where you will have to specify JDBC connection information as well.
						</div></dd></dl></div><div class="para">
				Be sure to define the grammar definition in the <code class="literal">persistence</code> element since the EJB3 specification requires the schema validation. If the systemId ends with <code class="literal">persistence_1_0.xsd</code>, Hibernate entityManager will use the version embedded in the hibernate-entitymanager.jar. No internet access will be performed.
			</div><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
   version="1.0"&gt;</pre></div><div class="section" id="setup-configuration-bootstrapping"><div class="titlepage"><div><div><h3 class="title">2.2.2. Bootstrapping</h3></div></div></div><div class="para">
				The EJB3 specification defines a bootstrap procedure to access the <code class="classname">EntityManagerFactory</code> and the <code class="classname">EntityManager</code>. The bootstrap class is <code class="classname">javax.persistence.Persistence</code>, e.g.
			</div><pre class="programlisting">EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1");
//or
Map configOverrides = new HashMap();
configOverrides.put("hibernate.hbm2ddl.auto", "create-drop");
EntityManagerFactory programmaticEmf =
    Persistence.createEntityManagerFactory("manager1", configOverrides);</pre><div class="para">
				The first version is equivalent to the second with an empty map. The map version is a set of overrides that will take precedence over any properties defined in your persistence.xml files. There are a couple of EJB3 properties usable in the map:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						javax.persistence.provider to define the provider class used
					</div></li><li class="listitem"><div class="para">
						javax.persistence.transactionType to define the transaction type used (either JTA or RESOURCE_LOCAL)
					</div></li><li class="listitem"><div class="para">
						javax.persistence.jtaDataSource to define the JTA datasource name in JNDI
					</div></li><li class="listitem"><div class="para">
						javax.persistence.nonJtaDataSource to define the non JTA datasource name in JNDI
					</div></li></ul></div><div class="para">
				When <code class="code">Persistence.createEntityManagerFactory()</code> is called, the persistence implementation will search your classpath for any <code class="code">META-INF/persistence.xml</code> files using the <code class="code">ClassLoader.getResource("META-INF/persistence.xml")</code> method. Actually the <code class="classname">Persistence</code> class will look at all the Persistence Providers available in the classpath and ask each of them if they are responsible for the creation of the entity manager factory <code class="literal">manager1</code>. From the list of resources available from each provider, the persistence implementation will search for an entity manager that whose name in <code class="filename">persistence.xml</code> matches the name specified at the command line. (The provider <code class="literal">element</code> must match the current persistence provider.) If no persistence.xml with the correct name is found or if the expected persistence provider is not found, a <code class="classname">PersistenceException</code> is raised.
			</div><div class="para">
				Apart from Hibernate system-level settings, all the properties available in Hibernate can be set in <code class="code">properties</code> element of the persistence.xml file or as an override in the map you pass to <code class="code">createEntityManagerFactory()</code>. Please refer to the Hibernate reference documentation for a complete listing. There are however a couple of properties available in the EJB3 provider only.
			</div><div class="para">

			</div><div class="table" id="idm140350358181680"><p class="title"><strong>Table 2.1. Hibernate Entity Manager specific properties</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="Hibernate Entity Manager specific properties"><colgroup><col align="left" class="c1" width="33%"><!--Empty--></col><col width="67%" class="c2"><!--Empty--></col></colgroup><thead><tr><th align="left" id="idm140350358178352" scope="col"> Property name </th><th id="idm140350358177872" scope="col"> Description </th></tr></thead><tbody><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.classcache. &lt;classname&gt; </td><td headers="idm140350358177872"> class cache strategy [comma cache region] of the class Default to no cache, and default region cache to fully.qualified.classname (eg. hibernate.ejb.classcache.com.acme.Cat read-write or hibernate.ejb.classcache.com.acme.Cat read-write, MyRegion). </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.collectioncache. &lt;collectionrole&gt; </td><td headers="idm140350358177872"> collection cache strategy [comma cache region] of the class Default to no cache, and default region cache to fully.qualified.classname.role (eg. hibernate.ejb.classcache.com.acme.Cat read-write or hibernate.ejb.classcache.com.acme.Cat read-write, MyRegion). </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.cfgfile </td><td headers="idm140350358177872"> XML configuration file to use to configure Hibernate (eg. <code class="filename">/hibernate.cfg.xml</code>). </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.archive. autodetection </td><td headers="idm140350358177872"> Determine which element is auto discovered by Hibernate Entity Manager while parsing the .par archive. (default to <code class="literal">class,hbm</code>). </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb. interceptor </td><td headers="idm140350358177872"> An optional Hibernate interceptor. The interceptor instance is shared by all <code class="classname">Session</code> instances. This interceptor has to implement <code class="classname">org.hibernate.Interceptor</code> and have a no-arg constructor. This property can not be combined with <code class="literal">hibernate.ejb.interceptor.session_scoped</code>. </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.interceptor. session_scoped </td><td headers="idm140350358177872"> An optional Hibernate interceptor. The interceptor instance is specific to a given <code class="classname">Session</code> instance (and hence can be non thread-safe). This interceptor has to implement <code class="classname">org.hibernate.Interceptor</code> and have a no-arg constructor. This property can not be combined with <code class="literal">hibernate.ejb.interceptor</code>. </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.naming_strategy </td><td headers="idm140350358177872"> An optional naming strategy. The default naming strategy used is <code class="classname">EJB3NamingStrategy</code>. You also might want to consider the <code class="classname">DefaultComponentSafeNamingStrategy</code>. </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb.event. &lt;eventtype&gt; </td><td headers="idm140350358177872"> Event listener list for a given eventtype. The list of event listeners is a comma separated fully qualified class name list (eg. hibernate.ejb.event.pre-load com.acme.SecurityListener, com.acme.AuditListener) </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb. use_class_enhancer </td><td headers="idm140350358177872"> Whether or not use Application server class enhancement at deployment time (default to false) </td></tr><tr><td align="left" headers="idm140350358178352"> hibernate.ejb. discard_pc_on_close </td><td headers="idm140350358177872"> If true, the persistence context will be discarded (think clear() when the method is called. Otherwise the persistence context will stay alive till the transaction completion: all objects will remain managed, and any change will be synchronized with the database (default to false, ie wait the transaction completion) </td></tr></tbody></table></div></div><div class="para">
				Note that you can mix XML <code class="literal">&lt;class&gt;</code> declaration and <code class="literal">hibernate.ejb.cfgfile</code> usage in the same configuration. Be aware of the potential clashes. The properties set in <code class="filename">persistence.xml</code> will override the one in the defined <code class="filename">hibernate.cfg.xml</code>.
			</div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
					It is important that you do not override <code class="literal">hibernate.transaction.factory_class</code>, Hibernate EntityManager automatically set the appropriate transaction factory depending on the EntityManager type (ie <code class="literal">JTA</code> versus <code class="literal">RESOURSE_LOCAL</code>). If you are working in a Java EE environment, you might want to set the <code class="literal">hibernate.transaction.manager_lookup_class</code> though.
				</div></div></div><div class="para">
				Here is a typical configuration in a J2SE environment
			</div><pre class="programlisting">&lt;persistence&gt;
   &lt;persistence-unit name="manager1" transaction-type="RESOURCE_LOCAL"&gt;
      &lt;class&gt;org.hibernate.ejb.test.Cat&lt;/class&gt;
      &lt;class&gt;org.hibernate.ejb.test.Distributor&lt;/class&gt;
      &lt;class&gt;org.hibernate.ejb.test.Item&lt;/class&gt;
      &lt;properties&gt;
         &lt;property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect"/&gt;
         &lt;property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver"/&gt;
         &lt;property name="hibernate.connection.username" value="sa"/&gt;
         &lt;property name="hibernate.connection.password" value=""/&gt;
         &lt;property name="hibernate.connection.url" value="jdbc:hsqldb:."/&gt;
         &lt;property name="hibernate.max_fetch_depth" value="3"/&gt;
       
         &lt;!-- cache configuration --&gt;
         &lt;property name="hibernate.ejb.classcache.org.hibernate.ejb.test.Item" value="read-write"/&gt;
         &lt;property name="hibernate.ejb.collectioncache.org.hibernate.ejb.test.Item.distributors" value="read-write, RegionName"/&gt;

         &lt;!-- alternatively to &lt;class&gt; and &lt;property&gt; declarations, you can use a regular hibernate.cfg.xml file --&gt;
         &lt;!-- property name="hibernate.ejb.cfgfile" value="/org/hibernate/ejb/test/hibernate.cfg.xml"/ --&gt;
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre><div class="para">
				To ease the programmatic configuration, Hibernate Entity Manager provide a proprietary API. This API is very similar to the <code class="classname">Configuration</code> API and share the same concepts: <code class="classname">Ejb3Configuration</code>. Refer to the JavaDoc and the Hibernate reference guide for more detailed informations on how to use it.
			</div><pre class="programlisting">Ejb3Configuration cfg = new Ejb3Configuration();
EntityManagerFactory emf = 
  cfg.addProperties( properties ) //add some properties
     .setInterceptor( myInterceptorImpl ) // set an interceptor
     .addAnnotatedClass( MyAnnotatedClass.class ) //add a class to be mapped
     .addClass( NonAnnotatedClass.class ) //add an hbm.xml file using the Hibernate convention
     .addResource( "mypath/MyOtherCLass.hbm.xml" ) //add an hbm.xml file
     .addResource( "mypath/orm.xml" ) //add an EJB3 deployment descriptor
     .configure("/mypath/hibernate.cfg.xml") //add a regular hibernate.cfg.xml
     .buildEntityManagerFactory(); //Create the entity manager factory</pre></div></div><div class="section" id="idm140350358583888"><div class="titlepage"><div><div><h2 class="title">2.3. Event listeners</h2></div></div></div><div class="para">
			Hibernate Entity Manager needs to enhance Hibernate core to implements all the EJB3 semantics. It does that through the event listener system of Hibernate. Be careful when you use the event system yourself, you might override some of the EJB3 semantics. A safe way is to add your event listeners to the list given below.
		</div><div class="table" id="idm140350358582304"><p class="title"><strong>Table 2.2. Hibernate Entity Manager default event listeners</strong></p><div class="table-contents"><table class="lt-4-cols gt-14-rows" summary="Hibernate Entity Manager default event listeners"><colgroup><col align="left" class="c1" width="33%"><!--Empty--></col><col width="67%" class="c2"><!--Empty--></col></colgroup><thead><tr><th align="left" id="idm140350358578976" scope="col"> Event </th><th id="idm140350358578496" scope="col"> Listeners </th></tr></thead><tbody><tr><td align="left" headers="idm140350358578976"> flush </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3FlushEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> auto-flush </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3AutoFlushEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> delete </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3DeleteEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> flush-entity </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3FlushEntityEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> merge </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3MergeEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> create </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PersistEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> create-onflush </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PersistOnFlushEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> save </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3SaveEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> save-update </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3SaveOrUpdateEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> pre-insert </td><td headers="idm140350358578496"> org.hibernate.secure.JACCPreInsertEventListener, org.hibernate.valitator.event.ValidateEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> pre-insert </td><td headers="idm140350358578496"> org.hibernate.secure.JACCPreUpdateEventListener, org.hibernate.valitator.event.ValidateEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> pre-delete </td><td headers="idm140350358578496"> org.hibernate.secure.JACCPreDeleteEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> pre-load </td><td headers="idm140350358578496"> org.hibernate.secure.JACCPreLoadEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> post-delete </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PostDeleteEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> post-insert </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PostInsertEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> post-load </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PostLoadEventListener </td></tr><tr><td align="left" headers="idm140350358578976"> post-update </td><td headers="idm140350358578496"> org.hibernate.ejb.event.EJB3PostUpdateEventListener </td></tr></tbody></table></div></div><div class="para">
			Note that the JACC*EventListeners are removed if the security is not enabled.
		</div><div class="para">
			You can configure the event listeners either through the properties (see <a class="xref" href="#setup-configuration">Section 2.2, “Configuration and bootstrapping”</a>) or through the <code class="methodname">Ejb3Configuration.getEventListeners()</code> API.
		</div></div><div class="section" id="idm140350358550864"><div class="titlepage"><div><div><h2 class="title">2.4. Obtaining an EntityManager in a Java SE environment</h2></div></div></div><div class="para">
			An entity manager factory should be considered as an immutable configuration holder, it is defined to point to a single datasource and to map a defined set of entities. This is the entry point to create and manage <code class="classname">EntityManager</code>s. The <code class="classname">Persistence</code> class is bootstrap class to create an entity manager factory.
		</div><pre class="programlisting">// Use persistence.xml configuration
EntityManagerFactory emf = Persistence.createEntityManagerFactory("manager1");
EntityManager em = emf.createEntityManager(); // Retrieve an application managed entity manager
// Work with the EM
em.close();
...
emf.close(); //close at application end</pre><div class="para">
			An entity manager factory is typically created at application initialization time and closed at application end. It's creation is an expensive process. For those who are familiar with Hibernate, an entity manager factory is very much like a session factory. Actually, an entity manager factory is a wrapper on top of a session factory. Calls to the entityManagerFactory are thread safe.
		</div><div class="para">
			Thanks to the EntityManagerFactory, you can retrieve an extended entity manager. The extended entity manager keep the same persistence context for the lifetime of the entity manager: in other words, the entities are still managed between two transactions (unless you call entityManager.clear() in between). You can see an entity manager as a small wrapper on top of an Hibernate session.
		</div></div><div class="section" id="idm140350358545392"><div class="titlepage"><div><div><h2 class="title">2.5. Various</h2></div></div></div><div class="para">
			Hibernate Entity Manager comes with Hibernate Validator configured out of the box. You don't have to override any event yourself. If you do not use Hibernate Validator annotations in your domain model, there will be no performance cost. For more information on Hibernate Validator, please refer to the Hibernate Annotations reference guide.
		</div></div></div><div xml:lang="en-US" class="chapter" id="objectstate" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Working with objects</h1></div></div></div><div class="section" id="idm140350355267968"><div class="titlepage"><div><div><h2 class="title">3.1. Entity states</h2></div></div></div><div class="para">
			Like in Hibernate (comparable terms in parentheses), an entity instance is in one of the following states:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					New (transient): an entity is new if it has just been instantiated using the <code class="literal">new</code> operator, and it is not associated with a persistence context. It has no persistent representation in the database and no identifier value has been assigned.
				</div></li><li class="listitem"><div class="para">
					Managed (persistent): a managed entity instance is an instance with a persistent identity that is currently associated with a persistence context.
				</div></li><li class="listitem"><div class="para">
					Detached: the entity instance is an instance with a persistent identity that is no longer associated with a persistence context, usually because the persistence context was closed or the instance was evicted from the context.
				</div></li><li class="listitem"><div class="para">
					Removed: a removed entity instance is an instance with a persistent identity, associated with a persistence context, but scheduled for removal from the database.
				</div></li></ul></div><div class="para">
			The <code class="classname">EntityManager</code> API allows you to change the state of an entity, or in other words, to load and store objects. You will find persistence with EJB3 easier to understand if you think about object state management, not managing of SQL statements.
		</div></div><div class="section" id="idm140350356193760"><div class="titlepage"><div><div><h2 class="title">3.2. Making objects persistent</h2></div></div></div><div class="para">
			Once you've created a new entity instance (using the common <code class="literal">new</code> operator) it is in the <span class="emphasis"><em>new</em></span> state. You can make it persistent by associating it to an entity manager:
		</div><pre class="programlisting">DomesticCat fritz = new DomesticCat();
fritz.setColor(Color.GINGER);
fritz.setSex('M');
fritz.setName("Fritz");
em.persist(fritz);</pre><div class="para">
			If the <code class="literal">DomesticCat</code> entity type has a generated identifier, the value is associated to the instance when <code class="code">persist()</code> is called. If the identifier is not automatically generated, the application-assigned (usually natural) key value has to be set on the instance before <code class="code">persist()</code> is called.
		</div></div><div class="section" id="idm140350354521984"><div class="titlepage"><div><div><h2 class="title">3.3. Loading an object</h2></div></div></div><div class="para">
			Load an entity instance by its identifier value with the entity manager's <code class="code">find()</code> method:
		</div><pre class="programlisting">cat = em.find(Cat.class, catId);

// You may need to wrap the primitive identifiers
long catId = 1234;
em.find( Cat.class, new Long(catId) );</pre><div class="para">
			In some cases, you don't really want to load the object state, but just having a reference to it (ie a proxy). You can get this reference using the <code class="literal">getReference()</code> method. This is especially useful to link a child to its parent without having to load the parent.
		</div><pre class="programlisting">child = new Child();
child.SetName("Henry");
Parent parent = em.getReference(Parent.class, parentId); //no query to the DB
child.setParent(parent);
em.persist(child);</pre><div class="para">
			You can reload an entity instance and its collections at any time using the <code class="code">em.refresh()</code> operation. This is useful when database triggers are used to initialize some of the properties of the entity. Note that only the entity instance and its collections are refreshed unless you specify <code class="literal">REFRESH</code> as a cascade style of any associations:
		</div><pre class="programlisting">em.persist(cat);
em.flush(); // force the SQL insert and triggers to run
em.refresh(cat); //re-read the state (after the trigger executes)</pre></div><div class="section" id="idm140350354406656"><div class="titlepage"><div><div><h2 class="title">3.4. Querying objects</h2></div></div></div><div class="para">
			If you don't know the identifier values of the objects you are looking for, you need a query. The Hibernate EntityManager implementation supports an easy-to-use but powerful object-oriented query language (EJB3-QL) which has been inspired by HQL (and vice-versa). Both query languages are portable across databases, they use entity and property names as identifiers (instead of table and column names). You may also express your query in the native SQL of your database, with optional support from EJB3 for result set conversion into Java business objects.
		</div><div class="section" id="idm140350361333424"><div class="titlepage"><div><div><h3 class="title">3.4.1. Executing queries</h3></div></div></div><div class="para">
				EJB3QL and SQL queries are represented by an instance of <code class="classname">javax.persistence.Query</code>. This interface offers methods for parameter binding, result set handling, and for execution of the query. Queries are always created using the current entity manager.
			</div><div class="para">
				A query is usually executed by invoking <code class="methodname">getResultList()</code>. This method loads the resulting instances of the query completly into memory. Entity instances retrieved by a query are in persistent state. The <code class="methodname">getSingleResult() </code>method offers a shortcut if you know your query will only return a single object.
			</div><div class="section" id="idm140350361329104"><div class="titlepage"><div><div><h4 class="title">3.4.1.1. Projection</h4></div></div></div><div class="para">
					An EJB3QL query queries can return tuples of objects if projection is used. Each result tuple is returned as an object array:
				</div><pre class="programlisting">Iterator&lt;Cat[]&gt; kittensAndMothers = 
  em.createQuery("select kitten, mother from Cat kitten join kitten.mother mother").getResultList().iterator();
  while (kittensAndMothers.hasNext()) {
     Cat[] tuple = kittensAndMothers.next();
     Cat kitten = tuple[0];
     Cat mother = tuple[1];
  } 
    ....
}</pre></div><div class="section" id="idm140350355996048"><div class="titlepage"><div><div><h4 class="title">3.4.1.2. Scalar results</h4></div></div></div><div class="para">
					Queries may specify a particular property of an entity in the select clause, instead of an entity alias. You may call SQL aggregate functions as well. Returned non-transactional objects or aggregation results are considered "scalar" results and are not entities in persistent state (in other words, they are considered "read only"):
				</div><pre class="programlisting">Iterator&lt;Object[]&gt; results = em.createQuery(
        "select cat.color, min(cat.birthdate), count(cat) from Cat cat " +
        "group by cat.color")
        .getResultList()
        .iterator();

while ( results.hasNext() ) {
    Object[] row = results.next();
    Color type = (Color) row[0];
    Date oldest = (Date) row[1];
    Integer count = (Integer) row[2];
    .....
}</pre></div><div class="section" id="idm140350355993440"><div class="titlepage"><div><div><h4 class="title">3.4.1.3. Bind parameters</h4></div></div></div><div class="para">
					Both named and positional query parameters are supported, the <code class="literal">Query</code> API offers several methods to bind arguments. The EJB3 specification numbers positional parameters from one. Named parameters are identifiers of the form <code class="literal">:paramname</code> in the query string. Named parameters should be preferred, they are more robust and easier to read and understand:
				</div><pre class="programlisting">// Named parameter (preferred)
Query q = em.createQuery("select cat from DomesticCat cat where cat.name = :name");
q.setParameter("name", "Fritz");
List cats = q.getResultList();

// Positional parameter
Query q = em.createQuery("select cat from DomesticCat cat where cat.name = ?1");
q.setParameter(1, "Izi");
List cats = q.getResultList();

// Named parameter list
List names = new ArrayList();
names.add("Izi");
names.add("Fritz");
Query q = em.createQuery("select cat from DomesticCat cat where cat.name in (:namesList)");
q.setParameter("namesList", names);
List cats = q.getResultList();</pre></div><div class="section" id="idm140350355989760"><div class="titlepage"><div><div><h4 class="title">3.4.1.4. Pagination</h4></div></div></div><div class="para">
					If you need to specify bounds upon your result set (the maximum number of rows you want to retrieve and/or the first row you want to retrieve), use the following methods:
				</div><pre class="programlisting">Query q = em.createQuery("select cat from DomesticCat cat");
q.setFirstResult(20);
q.setMaxResults(10);
List cats = q.getResultList(); //return cats from the 20th position to 29th</pre><div class="para">
					Hibernate knows how to translate this limit query into the native SQL of your DBMS.
				</div></div><div class="section" id="idm140350353930640"><div class="titlepage"><div><div><h4 class="title">3.4.1.5. Externalizing named queries</h4></div></div></div><div class="para">
					You may also define named queries through annotations:
				</div><pre class="programlisting">@javax.persistence.NamedQuery(name="eg.DomesticCat.by.name.and.minimum.weight", 
  query="select cat from eg.DomesticCat as cat  where cat.name = ?1 and cat.weight &gt; ?2")</pre><div class="para">
					Parameters are bound programatically to the named query, before it is executed:
				</div><pre class="programlisting">Query q = em.createNamedQuery("eg.DomesticCat.by.name.and.minimum.weight");
q.setParameter(1, name);
q.setParameter(2, minWeight);
List cats = q.getResultList();</pre><div class="para">
					Note that the actual program code is independent of the query language that is used, you may also define native SQL queries in metadata, or use Hibernate's native facilities by placing them in XML mapping files.
				</div></div><div class="section" id="idm140350353926864"><div class="titlepage"><div><div><h4 class="title">3.4.1.6. Native queries</h4></div></div></div><div class="para">
					You may express a query in SQL, using <code class="methodname">createNativeQuery()</code> and let Hibernate take care mapping from JDBC result sets to business objects. Use the <code class="literal">@SqlResultSetMapping</code> (please see the Hibernate Annotations reference documentation on how to map a SQL resultset mapping) or the entity mapping (if the column names of the query result are the same as the names declared in the entity mapping; remember that all entity columns have to be returned for this mechanism to work):
				</div><pre class="programlisting">@SqlResultSetMapping(name="getItem", entities = 
        @EntityResult(entityClass=org.hibernate.ejb.test.Item.class, fields= {
            @FieldResult(name="name", column="itemname"),
            @FieldResult(name="descr", column="itemdescription")
        })
)

Query q = em.createNativeQuery("select name as itemname, descr as itemdescription from Item", "getItem");
item = (Item) q.getSingleResult(); //from a resultset

Query q = em.createNativeQuery("select * from Item", Item.class);
item = (Item) q.getSingleResult(); //from a class columns names match the mapping</pre><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
						For more information about scalar support in named queries, please refers to the Hibernate Annotations documentation
					</div></div></div></div><div class="section" id="idm140350353922128"><div class="titlepage"><div><div><h4 class="title">3.4.1.7. Query hints</h4></div></div></div><div class="para">
					Query hints (for performance optimization, usually) are implementation specific. Hints are declared using the <code class="methodname">query.setHint(String name, Object value)</code> method, or through the <code class="literal">@Named(Native)Query(hints)</code> annotation Note that these are not SQL query hints! The Hibernate EJB3 implementation offers the following query hints:
				</div><div class="table" id="idm140350353919776"><p class="title"><strong>Table 3.1. Hibernate query hints</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="Hibernate query hints"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm140350352443760" scope="col"> Hint </th><th align="center" id="idm140350352443088" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm140350352443760"> org.hibernate.timeout </td><td headers="idm140350352443088"> Query timeout in seconds ( eg. new Integer(10) ) </td></tr><tr><td headers="idm140350352443760"> org.hibernate.fetchSize </td><td headers="idm140350352443088"> Number of rows fetched by the JDBC driver per roundtrip ( eg. new Integer(50) ) </td></tr><tr><td headers="idm140350352443760"> org.hibernate.comment </td><td headers="idm140350352443088"> Add a comment to the SQL query, useful for the DBA ( e.g. new String("fetch all orders in 1 statement") ) </td></tr><tr><td headers="idm140350352443760"> org.hibernate.cacheable </td><td headers="idm140350352443088"> Whether or not a query is cacheable ( eg. new Boolean(true) ), defaults to false </td></tr><tr><td headers="idm140350352443760"> org.hibernate.cacheMode </td><td headers="idm140350352443088"> Override the cache mode for this query ( eg. CacheMode.REFRESH ) </td></tr><tr><td headers="idm140350352443760"> org.hibernate.cacheRegion </td><td headers="idm140350352443088"> Cache region of this query ( eg. new String("regionName") ) </td></tr><tr><td headers="idm140350352443760"> org.hibernate.readOnly </td><td headers="idm140350352443088"> Entities retrieved by this query will be loaded in a read-only mode where Hibernate will never dirty-check them or make changes persistent ( eg. new Boolean(true) ), default to false </td></tr><tr><td headers="idm140350352443760"> org.hibernate.flushMode </td><td headers="idm140350352443088"> Flush mode used for this query </td></tr><tr><td headers="idm140350352443760"> org.hibernate.cacheMode </td><td headers="idm140350352443088"> Cache mode used for this query </td></tr></tbody></table></div></div><div class="para">
					The value object accept both the native type or its string equivalent (eg. <code class="literal">CaheMode.REFRESH</code> or <span class="quote">“<span class="quote"><code class="literal">REFRESH</code></span>”</span>). Please refer to the Hibernate reference documentation for more information.
				</div></div></div></div><div class="section" id="idm140350361032560"><div class="titlepage"><div><div><h2 class="title">3.5. Modifying persistent objects</h2></div></div></div><div class="para">
			Transactional managed instances (ie. objects loaded, saved, created or queried by the entity manager) may be manipulated by the application and any changes to persistent state will be persisted when the Entity manager is flushed (discussed later in this chapter). There is no need to call a particular method to make your modifications persistent. A straightforward way to update the state of an entity instance is to <code class="methodname">find()</code> it, and then manipulate it directly, while the persistence context is open:
		</div><pre class="programlisting">Cat cat = em.find( Cat.class, new Long(69) );
cat.setName("PK");
em.flush();  // changes to cat are automatically detected and persisted</pre><div class="para">
			Sometimes this programming model is inefficient since it would require both an SQL SELECT (to load an object) and an SQL UPDATE (to persist its updated state) in the same session. Therefore Hibernate offers an alternate approach, using detached instances.
		</div></div><div class="section" id="idm140350361028976"><div class="titlepage"><div><div><h2 class="title">3.6. Modifying detached objects</h2></div></div></div><div class="para">
			Many applications need to retrieve an object in one transaction, send it to the presentation layer for manipulation, and later save the changes in a new transaction. There can be significant user think and waiting time between both transactions. Applications that use this kind of approach in a high-concurrency environment usually use versioned data to ensure isolation for the "long" unit of work.
		</div><div class="para">
			The EJB3 specifications supports this development model by providing for persistence of modifications made to detached instances using the <code class="methodname">EntityManager.merge()</code> method:
		</div><pre class="programlisting">// in the first entity manager
Cat cat = firstEntityManager.find(Cat.class, catId);
Cat potentialMate = new Cat();
firstEntityManager.persist(potentialMate);

// in a higher layer of the application
cat.setMate(potentialMate);

// later, in a new entity manager
secondEntityManager.merge(cat);  // update cat
secondEntityManager.merge(mate); // update mate</pre><div class="para">
			The <code class="literal">merge()</code> method merges modifications made to the detached instance into the corresponding managed instance, if any, without consideration of the state of the persistence context. In other words, the merged objects state overrides the persistent entity state in the persistence context, if one is already present. The application should individually <code class="methodname">merge()</code> detached instances reachable from the given detached instance if and only if it wants their state also to be persistent. This can be cascaded to associated entities and collections, using transitive persistence, see <a class="xref" href="#objectstate-transitive">Section 3.10, “Transitive persistence”</a>.
		</div></div><div class="section" id="idm140350361022800"><div class="titlepage"><div><div><h2 class="title">3.7. Automatic state detection</h2></div></div></div><div class="para">
			The merge operation is clever enough to automatically detect whether the merging of the detached instance has to result in an insert or update. In other words, you don't have to worry about passing a new instance (and not a detached instance) to <code class="literal">merge()</code>, the entity manager will figure this out for you:
		</div><pre class="programlisting">// In the first entity manager
Cat cat = firstEntityManager.find(Cat.class, catID);

// In a higher layer of the application, detached
Cat mate = new Cat();
cat.setMate(mate);

// Later, in a new entity manager
secondEntityManager.merge(cat);   // update existing state
secondEntityManager.merge(mate);  // save the new instance</pre><div class="para">
			The usage and semantics of <code class="literal">merge()</code> seems to be confusing for new users. Firstly, as long as you are not trying to use object state loaded in one entity manager in another new entity manager, you should not need to use <code class="methodname">merge()</code> at all. Some whole applications will never use this method.
		</div><div class="para">
			Usually <code class="methodname">merge()</code> is used in the following scenario:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					the application loads an object in the first entity manager
				</div></li><li class="listitem"><div class="para">
					the object is passed up to the presentation layer
				</div></li><li class="listitem"><div class="para">
					some modifications are made to the object
				</div></li><li class="listitem"><div class="para">
					the object is passed back down to the business logic layer
				</div></li><li class="listitem"><div class="para">
					the application persists these modifications by calling <code class="methodname">merge()</code> in a second entity manager
				</div></li></ul></div><div class="para">
			Here is the exact semantic of <code class="methodname">merge()</code>:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					if there is a managed instance with the same identifier currently associated with the persistence context, copy the state of the given object onto the managed instance
				</div></li><li class="listitem"><div class="para">
					if there is no managed instance currently associated with the persistence context, try to load it from the database, or create a new managed instance
				</div></li><li class="listitem"><div class="para">
					the managed instance is returned
				</div></li><li class="listitem"><div class="para">
					the given instance does not become associated with the persistence context, it remains detached and is usually discarded
				</div></li></ul></div><div class="note"><div class="admonition_header"><p><strong>Note</strong></p></div><div class="admonition"><div class="para">
				Merging in EJB3 is similar to the <code class="literal">saveOrUpdateCopy()</code> method in native Hibernate. However, it is not the same as the <code class="literal">saveOrUpdate()</code> method, the given instance is not reattached with the persistence context, but a managed instance is returned by the <code class="methodname">merge()</code> method.
			</div></div></div></div><div class="section" id="idm140350358485248"><div class="titlepage"><div><div><h2 class="title">3.8. Deleting managed objects</h2></div></div></div><div class="para">
			<code class="methodname">EntityManager.remove()</code> will remove an objects state from the database. Of course, your application might still hold a reference to a deleted object. You can think of <code class="methodname">remove()</code> as making a persistent instance new (aka transient) again. It is not detached, and a merge would result in an insertion.
		</div></div><div class="section" id="idm140350358482640"><div class="titlepage"><div><div><h2 class="title">3.9. Flush the persistence context</h2></div></div></div><div class="section" id="idm140350358481872"><div class="titlepage"><div><div><h3 class="title">3.9.1. In a transaction</h3></div></div></div><div class="para">
				From time to time the entity manager will execute the SQL DML statements needed to synchronize the data store with the state of objects held in memory. This process, flush, occurs by default (this is Hibernate specific and not defined by the specification) at the following points:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						before query execution*
					</div></li><li class="listitem"><div class="para">
						from <code class="methodname">javax.persistence.EntityTransaction.commit()*</code>
					</div></li><li class="listitem"><div class="para">
						when <code class="methodname">EntityManager.flush()</code> is called*
					</div></li></ul></div><div class="para">
				(*) if a transaction is active
			</div><div class="para">
				The SQL statements are issued in the following order
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						all entity insertions, in the same order the corresponding objects were saved using <code class="methodname">EntityManager.persist()</code>
					</div></li><li class="listitem"><div class="para">
						all entity updates
					</div></li><li class="listitem"><div class="para">
						all collection deletions
					</div></li><li class="listitem"><div class="para">
						all collection element deletions, updates and insertions
					</div></li><li class="listitem"><div class="para">
						all collection insertions
					</div></li><li class="listitem"><div class="para">
						all entity deletions, in the same order the corresponding objects were deleted using <code class="methodname">EntityManager.remove()</code>
					</div></li></ul></div><div class="para">
				(Exception: entity instances using application-assigned identifiers are inserted when they are saved.)
			</div><div class="para">
				Except when you explicity <code class="methodname">flush()</code>, there are absolutely no guarantees about when the entity manager executes the JDBC calls, only the order in which they are executed. However, Hibernate does guarantee that the <code class="methodname">Query.getResultList()</code>/<code class="methodname">Query.getSingleResult()</code> will never return stale data; nor will they return wrong data if executed in an active transaction.
			</div><div class="para">
				It is possible to change the default behavior so that flush occurs less frequently. The <code class="classname">FlushModeType</code> for an entity manager defines two different modes: only flush at commit time or flush automatically using the explained routine unless <code class="methodname">flush()</code> is called explicitly.
			</div><pre class="programlisting">em = emf.createEntityManager();
em.getTransaction().begin();
em.setFlushMode(FlushModeType.COMMIT); // allow queries to return stale state

Cat izi = em.find(Cat.class, id);
izi.setName(iznizi);

// might return stale data
em.createQuery("from Cat as cat left outer join cat.kittens kitten").getResultList();

// change to izi is not flushed!
...
em.getTransaction().commit(); // flush occurs</pre><div class="para">
				During flush, an exception might happen (e.g. if a DML operation violates a constraint). 
			</div><div class="para">
				Hibernate provides more flush modes than the one described in the EJB3 specification. Please refer to the Hibernate core reference documentation for more informations.
			</div></div><div class="section" id="idm140350358461376"><div class="titlepage"><div><div><h3 class="title">3.9.2. Outside a transaction</h3></div></div></div><div class="para">
				In an <code class="literal">EXTENDED</code> persistence context, all read only operations of the entity manager can be executed outside a transaction (<code class="literal">find()</code>, <code class="literal">getReference()</code>, <code class="literal">refresh()</code>, and read queries). Some modifications operations can be executed outside a transaction, but they are queued until the persistence context join a transaction. This is the case of <code class="literal">persist()</code>, <code class="literal"><code class="literal">merge()</code></code>, <code class="literal">remove()</code>. Some operations cannot be called outside a transaction: <code class="literal">flush()</code>, <code class="literal">lock()</code>, and update/delete queries.
			</div></div></div><div class="section" id="objectstate-transitive"><div class="titlepage"><div><div><h2 class="title">3.10. Transitive persistence</h2></div></div></div><div class="para">
			It is quite cumbersome to save, delete, or reattach individual objects, especially if you deal with a graph of associated objects. A common case is a parent/child relationship. Consider the following example:
		</div><div class="para">
			If the children in a parent/child relationship would be value typed (e.g. a collection of addresses or strings), their lifecycle would depend on the parent and no further action would be required for convenient "cascading" of state changes. When the parent is persisted, the value-typed child objects are persisted as well, when the parent is removed, the children will be removed, etc. This even works for operations such as the removal of a child from the collection; Hibernate will detect this and, since value-typed objects can't have shared references, remove the child from the database.
		</div><div class="para">
			Now consider the same scenario with parent and child objects being entities, not value-types (e.g. categories and items, or parent and child cats). Entities have their own lifecycle, support shared references (so removing an entity from the collection does not mean it can be deleted), and there is by default no cascading of state from one entity to any other associated entities. The EJB3 specification does not require persistence by reachability. It supports a more flexible model of transitive persistence, as first seen in Hibernate.
		</div><div class="para">
			For each basic operation of the entity manager - including <code class="methodname">persist()</code>, <code class="methodname">merge()</code>, <code class="methodname">remove()</code>, <code class="methodname">refresh()</code> - there is a corresponding cascade style. Respectively, the cascade styles are named PERSIST, MERGE, REMOVE, REFRESH. If you want an operation to be cascaded to associated entity (or collection of entities), you must indicate that in the association annotation:
		</div><pre class="programlisting">@OneToOne(cascade=CascadeType.PERSIST)</pre><div class="para">
			Cascading options can be combined:
		</div><pre class="programlisting">@OneToOne(cascade= { CascadeType.PERSIST, CascadeType.REMOVE, CascadeType.REFRESH } )</pre><div class="para">
			You may even use CascadeType.ALL to specify that all operations should be cascaded for a particular association. Remember that by default, no operation is cascaded.
		</div><div class="para">
			Hibernate offers more native cascading options, please refer to the Hibernate Annotations manual and the Hibernate reference guide for more informations.
		</div><div class="para">
			Recommendations:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					It doesn't usually make sense to enable cascade on a <code class="literal">@ManyToOne</code> or <code class="literal">@ManyToMany</code> association. Cascade is often useful for <code class="literal">@OneToOne</code> and <code class="literal">@OneToMany</code> associations.
				</div></li><li class="listitem"><div class="para">
					If the child object's lifespan is bounded by the lifespan of the parent object, make the parent a full lifecycle object by specifying <code class="literal">CascadeType.ALL</code> and <code class="literal">org.hibernate.annotations.CascadeType.DELETE_ORPHAN</code> (please refer to the Hibernate reference guide for the semantics of orphan delete)
				</div></li><li class="listitem"><div class="para">
					Otherwise, you might not need cascade at all. But if you think that you will often be working with the parent and children together in the same transaction, and you want to save yourself some typing, consider using <code class="code">cascade={PERSIST, MERGE}</code>. These options can even make sense for a many-to-many association.
				</div></li></ul></div></div><div class="section" id="idm140350358438128"><div class="titlepage"><div><div><h2 class="title">3.11. Locking</h2></div></div></div><div class="para">
			The default locking system in EJB3 is mostly based on optimistic locking (ie using a version column to check any concurrency issues). EJB3 has defined an additional mechanism to increase the concurrency guaranties. You can apply a lock on a given entity (and it's associated entities if <code class="literal">LOCK</code> is cascaded) through the <code class="methodname">lock(Object entity)</code> method. Depending on the concurrency guaranties you requires, you choose a lock mode:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">LockMode.READ</code> prevents dirty-reads and non repeatable read on a given entity.
				</div></li><li class="listitem"><div class="para">
					<code class="literal">LockMode.WRITE</code> prevents dirty-reads and non repeatable read on a given entity and force an increase of the version number if any.
				</div></li></ul></div></div></div><div xml:lang="en-US" class="chapter" id="transactions" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Transactions and Concurrency</h1></div></div></div><div class="para">
		The most important point about Hibernate Entity Manager and concurrency control is that it is very easy to understand. Hibernate Entity Manager directly uses JDBC connections and JTA resources without adding any additional locking behavior. We highly recommend you spend some time with the JDBC, ANSI, and transaction isolation specification of your database management system. Hibernate Entity Manager only adds automatic versioning but does not lock objects in memory or change the isolation level of your database transactions. Basically, use Hibernate Entity Manager like you would use direct JDBC (or JTA/CMT) with your database resources.
	</div><div class="para">
		We start the discussion of concurrency control in Hibernate with the granularity of <code class="literal">EntityManagerFactory</code>, and <code class="literal">EntityManager</code>, as well as database transactions and long units of work.
	</div><div class="para">
		In this chapter, and unless explicitly expressed, we will mix and match the concept of entity manager and persistence context. One is an API and programming object, the other a definition of scope. However, keep in mind the essential difference. A persistence context is usually bound to a JTA transaction in Java EE, and a persistence context starts and ends at transaction boundaries (transaction-scoped) unless you use an extended entity manager. Please refer to <a class="xref" href="#architecture-ejb-persistctxscope">Section 1.2.3, “Persistence context scope”</a> for more information.
	</div><div class="section" id="transactions-basics"><div class="titlepage"><div><div><h2 class="title">4.1. Entity manager and transaction scopes</h2></div></div></div><div class="para">
			A <code class="literal">EntityManagerFactory</code> is an expensive-to-create, threadsafe object intended to be shared by all application threads. It is created once, usually on application startup.
		</div><div class="para">
			An <code class="literal">EntityManager</code> is an inexpensive, non-threadsafe object that should be used once, for a single business process, a single unit of work, and then discarded. An <code class="literal">EntityManager</code> will not obtain a JDBC <code class="literal">Connection</code> (or a <code class="literal">Datasource</code>) unless it is needed, so you may safely open and close an <code class="literal">EntityManager</code> even if you are not sure that data access will be needed to serve a particular request. (This becomes important as soon as you are implementing some of the following patterns using request interception.)
		</div><div class="para">
			To complete this picture you also have to think about database transactions. A database transaction has to be as short as possible, to reduce lock contention in the database. Long database transactions will prevent your application from scaling to highly concurrent load.
		</div><div class="para">
			What is the scope of a unit of work? Can a single Hibernate <code class="literal">EntityManager</code> span several database transactions or is this a one-to-one relationship of scopes? When should you open and close a <code class="literal">Session</code> and how do you demarcate the database transaction boundaries?
		</div><div class="section" id="transactions-basics-uow"><div class="titlepage"><div><div><h3 class="title">4.1.1. Unit of work</h3></div></div></div><div class="para">
				First, don't use the <span class="emphasis"><em>entitymanager-per-operation</em></span> antipattern, that is, don't open and close an <code class="literal">EntityManager</code> for every simple database call in a single thread! Of course, the same is true for database transactions. Database calls in an application are made using a planned sequence, they are grouped into atomic units of work. (Note that this also means that auto-commit after every single SQL statement is useless in an application, this mode is intended for ad-hoc SQL console work.)
			</div><div class="para">
				The most common pattern in a multi-user client/server application is <span class="emphasis"><em>entitymanager-per-request</em></span>. In this model, a request from the client is send to the server (where the EJB3 persistence layer runs), a new <code class="literal">EntityManager</code> is opened, and all database operations are executed in this unit of work. Once the work has been completed (and the response for the client has been prepared), the persistence context is flushed and closed, as well as the entity manager object. You would also use a single database transaction to serve the clients request. The relationship between the two is one-to-one and this model is a perfect fit for many applications.
			</div><div class="para">
				This is the default EJB3 persistence model in a Java EE environment (JTA bounded, transaction-scoped persistence context); injected (or looked up) entity managers share the same persistence context for a particular JTA transaction. The beauty of EJB3 is that you don't have to care about that anymore and just see data access through entity manager and demaraction of transaction scope on session beans as completely orthogonal.
			</div><div class="para">
				The challenge is the implementation of this (and other) behavior outside an EJB3 container: not only has the <code class="literal">EntityManager</code> and resource-local transaction to be started and ended correctly, but they also have to be accessible for data access operations. The demarcation of a unit of work is ideally implemented using an interceptor that runs when a request hits the non-EJB3 container server and before the response will be send (i.e. a <code class="literal">ServletFilter</code> if you are using a standalone servlet container). We recommend to bind the <code class="literal">EntityManager</code> to the thread that serves the request, using a <code class="literal">ThreadLocal</code> variable. This allows easy access (like accessing a static variable) in all code that runs in this thread. Depending on the database transaction demarcation mechanism you chose, you might also keep the transaction context in a <code class="literal">ThreadLocal</code> variable. The implementation patterns for this are known as <span class="emphasis"><em>ThreadLocal Session</em></span> and <span class="emphasis"><em>Open Session in View</em></span> in the Hibernate community. You can easily extend the <code class="literal">HibernateUtil</code> shown in the Hibernate reference documentation to implement this pattern, you don't need any external software (it's in fact very trivial). Of course, you'd have to find a way to implement an interceptor and set it up in your environment. See the Hibernate website for tips and examples. Once again, remember that your first choice is naturally an EJB3 container - preferably a light and modular one such as JBoss application server.
			</div></div><div class="section" id="transactions-basics-apptx"><div class="titlepage"><div><div><h3 class="title">4.1.2. Long units of work</h3></div></div></div><div class="para">
				The entitymanager-per-request pattern is not the only useful concept you can use to design units of work. Many business processes require a whole series of interactions with the user interleaved with database accesses. In web and enterprise applications it is not acceptable for a database transaction to span a user interaction with possibly long waiting time between requests. Consider the following example:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						The first screen of a dialog opens, the data seen by the user has been loaded in a particular <code class="literal">EntityManager</code> and resource-local transaction. The user is free to modify the detached objects.
					</div></li><li class="listitem"><div class="para">
						The user clicks "Save" after 5 minutes and expects his modifications to be made persistent; he also expects that he was the only person editing this information and that no conflicting modification can occur.
					</div></li></ul></div><div class="para">
				We call this unit of work, from the point of view of the user, a long running <span class="emphasis"><em>application transaction</em></span>. There are many ways how you can implement this in your application.
			</div><div class="para">
				A first naive implementation might keep the <code class="literal">EntityManager</code> and database transaction open during user think time, with locks held in the database to prevent concurrent modification, and to guarantee isolation and atomicity. This is of course an anti-pattern, a pessimistic approach, since lock contention would not allow the application to scale with the number of concurrent users.
			</div><div class="para">
				Clearly, we have to use several database transactions to implement the application transaction. In this case, maintaining isolation of business processes becomes the partial responsibility of the application tier. A single application transaction usually spans several database transactions. It will be atomic if only one of these database transactions (the last one) stores the updated data, all others simply read data (e.g. in a wizard-style dialog spanning several request/response cycles). This is easier to implement than it might sound, especially if you use EJB3 entity manager and persistence context features:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<span class="emphasis"><em>Automatic Versioning</em></span> - An entity manager can do automatic optimistic concurrency control for you, it can automatically detect if a concurrent modification occured during user think time (usually by comparing version numbers or timestamps when updating the data in the final resource-local transaction).
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>Detached Entities</em></span> - If you decide to use the already discussed <span class="emphasis"><em>entity-per-request</em></span> pattern, all loaded instances will be in detached state during user think time. The entity manager allows you to merge the detached (modified) state and persist the modifications, the pattern is called <span class="emphasis"><em>entitymanager-per-request-with-detached-entities</em></span>. Automatic versioning is used to isolate concurrent modifications.
					</div></li><li class="listitem"><div class="para">
						<span class="emphasis"><em>Extended Entity Manager</em></span> - The Hibernate Entity Manager may be disconnected from the underlying JDBC connection between two client calls and reconnected when a new client request occurs. This pattern is known as <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> and makes even merging unnecessary. An extend persistence context is responsible to collect and retain any modification (persist, merge, remove) made outside a transaction. The next client call made inside an active transaction (typically the last operation of a user conversation) will execute all queued modifications. Automatic versioning is used to isolate concurrent modifications.
					</div></li></ul></div><div class="para">
				Both <span class="emphasis"><em>entitymanager-per-request-with-detached-objects</em></span> and <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> have advantages and disadvantages, we discuss them later in this chapter in the context of optimistic concurrency control.
			</div><div class="para">
				
			</div></div><div class="section" id="transactions-basics-identity"><div class="titlepage"><div><div><h3 class="title">4.1.3. Considering object identity</h3></div></div></div><div class="para">
				An application may concurrently access the same persistent state in two different persistence contexts. However, an instance of a managed class is never shared between two persistence contexts. Hence there are two different notions of identity:
			</div><div class="variablelist"><dl class="variablelist compact"><dt><span class="term">Database Identity</span></dt><dd><div class="para">
							<code class="literal">foo.getId().equals( bar.getId() )</code>
						</div></dd><dt><span class="term">JVM Identity</span></dt><dd><div class="para">
							<code class="literal">foo==bar</code>
						</div></dd></dl></div><div class="para">
				Then for objects attached to a <span class="emphasis"><em>particular</em></span> persistence context (i.e. in the scope of an <code class="literal">EntityManager</code>) the two notions are equivalent, and JVM identity for database identity is guaranteed by the Hibernate Entity Manager. However, while the application might concurrently access the "same" (persistent identity) business object in two different persistence contexts, the two instances will actually be "different" (JVM identity). Conflicts are resolved using (automatic versioning) at flush/commit time, using an optimistic approach.
			</div><div class="para">
				This approach leaves Hibernate and the database to worry about concurrency; it also provides the best scalability, since guaranteeing identity in single-threaded units of work only doesn't need expensive locking or other means of synchronization. The application never needs to synchronize on any business object, as long as it sticks to a single thread per <code class="literal">EntityManager</code>. Within a persistence context, the application may safely use <code class="literal">==</code> to compare entities.
			</div><div class="para">
				However, an application that uses <code class="literal">==</code> outside of a persistence context might see unexpected results. This might occur even in some unexpected places, for example, if you put two detached instances into the same <code class="literal">Set</code>. Both might have the same database identity (i.e. they represent the same row), but JVM identity is by definition not guaranteed for instances in detached state. The developer has to override the <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods in persistent classes and implement his own notion of object equality. There is one caveat: Never use the database identifier to implement equality, use a business key, a combination of unique, usually immutable, attributes. The database identifier will change if a transient entity is made persistent (see the contract of the <code class="literal">persist()</code> operation). If the transient instance (usually together with detached instances) is held in a <code class="literal">Set</code>, changing the hashcode breaks the contract of the <code class="literal">Set</code>. Attributes for good business keys don't have to be as stable as database primary keys, you only have to guarantee stability as long as the objects are in the same <code class="literal">Set</code>. See the Hibernate website for a more thorough discussion of this issue. Also note that this is not a Hibernate issue, but simply how Java object identity and equality has to be implemented.
			</div></div><div class="section" id="transactions-basics-issues"><div class="titlepage"><div><div><h3 class="title">4.1.4. Common concurrency control issues</h3></div></div></div><div class="para">
				Never use the anti-patterns <span class="emphasis"><em>entitymanager-per-user-session</em></span> or <span class="emphasis"><em>entitymanager-per-application</em></span> (of course, there are rare exceptions to this rule, e.g. entitymanager-per-application might be acceptable in a desktop application, with manual flushing of the persistence context). Note that some of the following issues might also appear with the recommended patterns, make sure you understand the implications before making a design decision:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						An entity manager is not thread-safe. Things which are supposed to work concurrently, like HTTP requests, session beans, or Swing workers, will cause race conditions if an <code class="literal">EntityManager</code> instance would be shared. If you keep your Hibernate <code class="literal">EntityManager</code> in your <code class="literal">HttpSession</code> (discussed later), you should consider synchronizing access to your Http session. Otherwise, a user that clicks reload fast enough may use the same <code class="literal">EntityManager</code> in two concurrently running threads. You will very likely have provisions for this case already in place, for other non-threadsafe but session-scoped objects.
					</div></li><li class="listitem"><div class="para">
						An exception thrown by the Entity Manager means you have to rollback your database transaction and close the <code class="literal">EntityManager</code> immediately (discussed later in more detail). If your <code class="literal">EntityManager</code> is bound to the application, you have to stop the application. Rolling back the database transaction doesn't put your business objects back into the state they were at the start of the transaction. This means the database state and the business objects do get out of sync. Usually this is not a problem, because exceptions are not recoverable and you have to start over your unit of work after rollback anyway.
					</div></li><li class="listitem"><div class="para">
						The persistence context caches every object that is in managed state (watched and checked for dirty state by Hibernate). This means it grows endlessly until you get an <code class="classname">OutOfMemoryException</code>, if you keep it open for a long time or simply load too much data. One solution for this is some kind batch processing with regular flushing of the persistence context, but you should consider using a database stored procedure if you need mass data operations. Some solutions for this problem are shown in <a class="xref" href="#batch">Chapter 6, <em>Batch processing</em></a>. Keeping a persistence context open for the duration of a user session also means a high probability of stale data, which you have to know about and control appropriately.
					</div></li></ul></div></div></div><div class="section" id="transactions-demarcation"><div class="titlepage"><div><div><h2 class="title">4.2. Database transaction demarcation</h2></div></div></div><div class="para">
			Datatabase (or system) transaction boundaries are always necessary. No communication with the database can occur outside of a database transaction (this seems to confuse many developers who are used to the auto-commit mode). Always use clear transaction boundaries, even for read-only operations. Depending on your isolation level and database capabilities this might not be required but there is no downside if you always demarcate transactions explicitly. You'll have to do operations outside a transaction, though, when you'll need to retain modifications in an <code class="literal">EXTENDED</code> persistence context.
		</div><div class="para">
			An EJB3 application can run in non-managed (i.e. standalone, simple Web- or Swing applications) and managed J2EE environments. In a non-managed environment, an <code class="literal">EntityManagerFactory</code> is usually responsible for its own database connection pool. The application developer has to manually set transaction boundaries, in other words, begin, commit, or rollback database transactions itself. A managed environment usually provides container-managed transactions, with the transaction assembly defined declaratively through annotations of EJB session beans, for example. Programmatic transaction demarcation is then no longer necessary, even flushing the <code class="literal">EntityManager</code> is done automatically.
		</div><div class="para">
			Usually, ending a unit of work involves four distinct phases:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					commit the (resource-local or JTA) transaction (this automatically flushes the entity manager and persistence context)
				</div></li><li class="listitem"><div class="para">
					close the entity manager (if using an application-managed entity manager)
				</div></li><li class="listitem"><div class="para">
					handle exceptions
				</div></li></ul></div><div class="para">
			We'll now have a closer look at transaction demarcation and exception handling in both managed- and non-managed environments.
		</div><div class="section" id="transactions-demarcation-nonmanaged"><div class="titlepage"><div><div><h3 class="title">4.2.1. Non-managed environment</h3></div></div></div><div class="para">
				If an EJB3 persistence layer runs in a non-managed environment, database connections are usually handled by Hibernate's pooling mechanism behind the scenes. The common entity manager and transaction handling idiom looks like this:
			</div><pre class="programlisting">// Non-managed environment idiom
EntityManager em = emf.createEntityManager();
EntityTransaction tx = null;
try {
    tx = em.getTransaction();
    tx.begin();

    // do some work
    ...

    tx.commit();
}
catch (RuntimeException e) {
    if ( tx != null &amp;&amp; tx.isActive() ) tx.rollback();
    throw e; // or display error message
}
finally {
    em.close();
}</pre><div class="para">
				You don't have to <code class="literal">flush()</code> the <code class="literal">EntityManager</code> explicitly - the call to <code class="literal">commit()</code> automatically triggers the synchronization.
			</div><div class="para">
				A call to <code class="literal">close()</code> marks the end of an <code class="literal">EntityManager</code>. The main implication of <code class="literal">close()</code> is the release of resources - make sure you always close and never outside of guaranteed finally block.
			</div><div class="para">
				You will very likely never see this idiom in business code in a normal application; fatal (system) exceptions should always be caught at the "top". In other words, the code that executes entity manager calls (in the persistence layer) and the code that handles <code class="literal">RuntimeException</code> (and usually can only clean up and exit) are in different layers. This can be a challenge to design yourself and you should use J2EE/EJB container services whenever they are available. Exception handling is discussed later in this chapter.
			</div><div class="section" id="idm140350343939744"><div class="titlepage"><div><div><h4 class="title">4.2.1.1. EntityTransaction</h4></div></div></div><div class="para">
					In a JTA environment, you don't need any extra API to interact with the transaction in your environment. Simply use transaction declaration or the JTA APIs.
				</div><div class="para">
					If you are using a <code class="literal">RESOURCE_LOCAL</code> entity manager, you need to demarcate your transaction boundaries through the <code class="literal">EntityTransaction</code> API. You can get an <code class="literal">EntityTransaction</code> through <code class="literal">entityManager.getTransaction()</code>. This <code class="literal">EntityTransaction</code> API provides the regular <code class="methodname">begin()</code>, <code class="methodname">commit()</code>, <code class="methodname">rollback()</code> and <code class="methodname">isActive()</code> methods. It also provide a way to mark a transaction as rollback only, ie force the transaction to rollback. This is very similar to the JTA operation <code class="methodname">setRollbackOnly()</code>. When a <code class="literal">commit()</code> operation fail and/or if the transaction is marked as <code class="literal">setRollbackOnly()</code>, the <code class="literal">commit()</code> method will try to rollback the transaction and raise a <code class="literal">javax.transaction.RollbackException</code>.
				</div><div class="para">
					In a <code class="literal">JTA</code> entity manager, <code class="literal">entityManager.getTransaction()</code> calls are not permitted.
				</div></div></div><div class="section" id="transactions-demarcation-jta"><div class="titlepage"><div><div><h3 class="title">4.2.2. Using JTA</h3></div></div></div><div class="para">
				If your persistence layer runs in an application server (e.g. behind EJB3 session beans), every datasource connection obtained internally by the entity manager will automatically be part of the global JTA transaction. Hibernate offers two strategies for this integration.
			</div><div class="para">
				If you use bean-managed transactions (BMT), the code will look like this:
			</div><pre class="programlisting">// BMT idiom
@Resource public UserTransaction utx;
@Resource public EntityManagerFactory factory;

public void doBusiness() {
    EntityManager em = factory.createEntityManager();
    try {

    // do some work
    ...

    utx.commit();
}
catch (RuntimeException e) {
    if (utx != null) utx.rollback();
    throw e; // or display error message
}
finally {
    em.close();
}</pre><div class="para">
				With Container Managed Transactions (CMT) in an EJB3 container, transaction demarcation is done in session bean annotations or deployment descriptors, not programatically. The <code class="literal">EntityManager</code> will automatically be flushed on transaction completion (and if you have injected or lookup the <code class="literal">EntityManager</code>, it will be also closed automatically). If an exception occurs during the <code class="literal">EntityManager</code> use, transaction rollback occurs automatically if you don't catch the exception. Since <code class="literal">EntityManager</code> exceptions are <code class="literal">RuntimeException</code>s they will rollback the transaction as per the EJB specification (system exception vs. application exception).
			</div><div class="para">
				It is important to let Hibernate EntityManager define the <code class="literal">hibernate.transaction.factory_class</code> (ie not overriding this value). Remember to also set <code class="literal">org.hibernate.transaction.manager_lookup_class</code>.
			</div><div class="para">
				If you work in a CMT environment, you might also want to use the same entity manager in different parts of your code. Typically, in a non-managed environment you would use a <code class="literal">ThreadLocal</code> variable to hold the entity manager, but a single EJB request might execute in different threads (e.g. session bean calling another session bean). The EJB3 container takes care of the persistence context propagation for you. Either using injection or lookup, the EJB3 container will return an entity manager with the same persistence context bound to the JTA context if any, or create a new one and bind it (see <a class="xref" href="#architecture-ejb-persistctxpropagation">Section 1.2.4, “Persistence context propagation”</a> .)
			</div><div class="para">
				Our entity manager/transaction management idiom for CMT and EJB3 container-use is reduced to this:
			</div><pre class="programlisting">//CMT idiom through injection
@PersistenceContext(name="sample") EntityManager em;</pre><div class="para">
				In other words, all you have to do in a managed environment is to inject the <code class="literal">EntityManager</code>, do your data access work, and leave the rest to the container. Transaction boundaries are set declaratively in the annotations or deployment descriptors of your session beans. The lifecycle of the entity manager and persistence context is completely managed by the container.
			</div><div class="para">
				
			</div><div class="para">
				When using particular Hibernate native APIs, one caveat has to be remembered: <code class="literal">after_statement</code> connection release mode. Due to a silly limitation of the JTA spec, it is not possible for Hibernate to automatically clean up any unclosed <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code> instances returned by <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the underlying database cursor by calling <code class="literal">ScrollableResults.close()</code> or <code class="literal">Hibernate.close(Iterator)</code> explicity from a <code class="literal">finally</code> block. (Of course, most applications can easily avoid using <code class="literal">scroll()</code> or <code class="literal">iterate()</code> at all from the CMT code.)
			</div></div><div class="section" id="transactions-demarcation-exceptions"><div class="titlepage"><div><div><h3 class="title">4.2.3. Exception handling</h3></div></div></div><div class="para">
				If the <code class="literal">EntityManager</code> throws an exception (including any <code class="literal">SQLException</code>), you should immediately rollback the database transaction, call <code class="literal">EntityManager.close()</code> (if <code class="methodname">createEntityManager()</code> has been called) and discard the <code class="literal">EntityManager</code> instance. Certain methods of <code class="literal">EntityManager</code> will <span class="emphasis"><em>not</em></span> leave the persistence context in a consistent state. No exception thrown by an entity manager can be treated as recoverable. Ensure that the <code class="literal">EntityManager</code> will be closed by calling <code class="literal">close()</code> in a <code class="literal">finally</code> block. Note that a container managed entity manager will do that for you. You just have to let the RuntimeException propagate up to the container.
			</div><div class="para">
				The Hibernate entity manager generally raises exceptions which encapsulate the Hibernate core exception. Common exceptions raised by the <code class="literal">EntityManager</code> API are
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						IllegalArgumentException: an argument is not permitted, not recognized, or in an incorrect format (or similar).
					</div></li><li class="listitem"><div class="para">
						EntityNotFoundException: an entity was expected but none match the requirement
					</div></li><li class="listitem"><div class="para">
						TransactionRequiredException: this operation has to be in a transaction
					</div></li><li class="listitem"><div class="para">
						IllegalStateException: the entity manager is used in a wrong way
					</div></li></ul></div><div class="para">
				The <code class="literal">HibernateException</code>, which wraps most of the errors that can occur in a Hibernate persistence layer, is an unchecked exception. Note that Hibernate might also throw other unchecked exceptions which are not a <code class="literal">HibernateException</code>. These are, again, not recoverable and appropriate action should be taken.
			</div><div class="para">
				Hibernate wraps <code class="literal">SQLException</code>s thrown while interacting with the database in a <code class="literal">JDBCException</code>. In fact, Hibernate will attempt to convert the exception into a more meningful subclass of <code class="literal">JDBCException</code>. The underlying <code class="literal">SQLException</code> is always available via <code class="literal">JDBCException.getCause()</code>. Hibernate converts the <code class="literal">SQLException</code> into an appropriate <code class="literal">JDBCException</code> subclass using the <code class="literal">SQLExceptionConverter</code> attached to the <code class="literal">SessionFactory</code>. By default, the <code class="literal">SQLExceptionConverter</code> is defined by the configured dialect; however, it is also possible to plug in a custom implementation (see the javadocs for the <code class="literal">SQLExceptionConverterFactory</code> class for details). The standard <code class="literal">JDBCException</code> subtypes are:
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="literal">JDBCConnectionException</code> - indicates an error with the underlying JDBC communication.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">SQLGrammarException</code> - indicates a grammar or syntax problem with the issued SQL.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">ConstraintViolationException</code> - indicates some form of integrity constraint violation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">LockAcquisitionException</code> - indicates an error acquiring a lock level necessary to perform the requested operation.
					</div></li><li class="listitem"><div class="para">
						<code class="literal">GenericJDBCException</code> - a generic exception which did not fall into any of the other categories.
					</div></li></ul></div></div></div><div class="section" id="idm140350343882912"><div class="titlepage"><div><div><h2 class="title">4.3. EXTENDED Persistence Context</h2></div></div></div><div class="para">
			All application managed entity manager and container managed persistence contexts defined as such are <code class="literal">EXTENDED</code>. This means that the persistence context type goes beyond the transaction life cycle. We should then understand what happens to operations made outside the scope of a transaction.
		</div><div class="para">
			In an <code class="literal">EXTENDED</code> persistence context, all read only operations of the entity manager can be executed outside a transaction (<code class="literal">find()</code>, <code class="literal">getReference()</code>, <code class="literal">refresh()</code>, and read queries). Some modifications operations can be executed outside a transaction, but they are queued until the persistence context join a transaction: this is the case of <code class="literal">persist()</code>, <code class="literal"><code class="literal">merge()</code></code>, <code class="literal">remove()</code>. Some operations cannot be called outside a transaction: <code class="literal">flush()</code>, <code class="literal">lock()</code>, and update/delete queries.
		</div><div class="section" id="idm140350345434880"><div class="titlepage"><div><div><h3 class="title">4.3.1. Container Managed Entity Manager</h3></div></div></div><div class="para">
				When using an EXTENDED persistence context with a container managed entity manager, the lifecycle of the persistence context is binded to the lifecycle of the Stateful Session Bean. Plus if the entity manager is created outside a transaction, modifications operations (persist, merge, remove) are queued in the persistence context and not executed to the database.
			</div><div class="para">
				When a method of the stateful session bean involved or starting a transaction is later called, the entity manager join the transaction. All queued operation will then be executed to synchronize the persistence context.
			</div><div class="para">
				This is perfect to implement the <code class="literal">entitymanager-per-conversation</code> pattern. A stateful session bean represents the conversation implementation. All intermediate conversation work will be processed in methods not involving transaction. The end of the conversation will be processed inside a <code class="literal">JTA</code> transaction. Hence all queued operations will be executed to the database and commited. If you are interested in the notion of conversation inside your application, have a look at JBoss Seam. Jboss Seam emphasizes the concept of conversation and entity manager lifecycle and bind EJB3 and JSF together.
			</div></div><div class="section" id="idm140350345430560"><div class="titlepage"><div><div><h3 class="title">4.3.2. Application Managed Entity Manager</h3></div></div></div><div class="para">
				Application-managed entity manager are always <code class="literal">EXTENDED</code>. When you create an entity manager inside a transaction, the entity manager automatically join the current transaction. If the entity manager is created outside a transaction, the entity manager will queue the modification operations. When
			</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
						<code class="methodname">entityManager.joinTransaction()</code> is called when a JTA transaction is active for a <code class="literal">JTA</code> entity manager
					</div></li><li class="listitem"><div class="para">
						<code class="literal">entityManager.getTransaction().begin()</code> is called for a <code class="literal">RESOURCE_LOCAL</code> entity manager
					</div></li></ul></div><div class="para">
				the entity manager join the transaction and all the queued operations will then be executed to synchronize the persistence context.
			</div><div class="para">
				It is not legal to call <code class="methodname">entityManager.joinTransaction()</code> if no JTA transaction is involved.
			</div></div></div><div class="section" id="transactions-optimistic"><div class="titlepage"><div><div><h2 class="title">4.4. Optimistic concurrency control</h2></div></div></div><div class="para">
			The only approach that is consistent with high concurrency and high scalability is optimistic concurrency control with versioning. Version checking uses version numbers, or timestamps, to detect conflicting updates (and to prevent lost updates). Hibernate provides for three possible approaches to writing application code that uses optimistic concurrency. The use cases we show are in the context of long application transactions but version checking also has the benefit of preventing lost updates in single database transactions.
		</div><div class="section" id="transactions-optimistic-manual"><div class="titlepage"><div><div><h3 class="title">4.4.1. Application version checking</h3></div></div></div><div class="para">
				In an implementation without much help from the persistence mechanism, each interaction with the database occurs in a new <code class="literal">EntityManager</code> and the developer is responsible for reloading all persistent instances from the database before manipulating them. This approach forces the application to carry out its own version checking to ensure application transaction isolation. This approach is the least efficient in terms of database access. It is the approach most similar to EJB2 entities:
			</div><pre class="programlisting">// foo is an instance loaded by a previous entity manager
em = factory.createEntityManager();
EntityTransaction t = em.getTransaction();
t.begin();
int oldVersion = foo.getVersion();
Foo dbFoo = em.find( foo.getClass(), foo.getKey() ); // load the current state
if ( dbFoo.getVersion()!=foo.getVersion() ) 
    throw new StaleObjectStateException("Message", oldVersion); 
dbFoo.setProperty("bar");
t.commit();
em.close();</pre><div class="para">
				The <code class="literal">version</code> property is mapped using <code class="literal">@Version</code>, and the entity manager will automatically increment it during flush if the entity is dirty.
			</div><div class="para">
				Of course, if you are operating in a low-data-concurrency environment and don't require version checking, you may use this approach and just skip the version check. In that case, <span class="emphasis"><em>last commit wins</em></span> will be the default strategy for your long application transactions. Keep in mind that this might confuse the users of the application, as they might experience lost updates without error messages or a chance to merge conflicting changes.
			</div><div class="para">
				Clearly, manual version checking is only feasible in very trivial circumstances and not practical for most applications. Often not only single instances, but complete graphs of modified ojects have to be checked. Hibernate offers automatic version checking with either detached instances or an extended entity manager and persistence context as the design paradigm.
			</div></div><div class="section" id="transactions-optimistic-longsession"><div class="titlepage"><div><div><h3 class="title">4.4.2. Extended entity manager and automatic versioning</h3></div></div></div><div class="para">
				A single persistence context is used for the whole application transaction. The entity manager checks instance versions at flush time, throwing an exception if concurrent modification is detected. It's up to the developer to catch and handle this exception (common options are the opportunity for the user to merge his changes or to restart the business process with non-stale data).
			</div><div class="para">
				In an <code class="literal">EXTENDED</code> persistence context, all operations made outside an active transaction are queued. The <code class="literal">EXTENDED</code> persistence context is flushed when executed in an active transaction (at worse at commit time).
			</div><div class="para">
				The <code class="literal">Entity Manager</code> is disconnected from any underlying JDBC connection when waiting for user interaction. In an application-managed extended entity manager, this occurs automatically at transaction completion. In a stateful session bean holding a container-managed extended entity manager (i.e. a SFSB annotated with <code class="literal">@PersistenceContext(EXTENDED)</code>), this occurs transparently as well. This approach is the most efficient in terms of database access. The application need not concern itself with version checking or with merging detached instances, nor does it have to reload instances in every database transaction. For those who might be concerned by the number of connections opened and closed, remember that the connection provider should be a connection pool, so there is no performance impact. The following examples show the idiom in a non-managed environment:
			</div><pre class="programlisting">// foo is an instance loaded earlier by the extended entity manager
em.getTransaction().begin(); // new connection to data store is obtained and tx started
foo.setProperty("bar");
em.getTransaction().commit();  // End tx, flush and check version, disconnect</pre><div class="para">
				The <code class="literal">foo</code> object still knows which <code class="literal">persistence context</code> it was loaded in. With <code class="literal">getTransaction.begin();</code> the entity manager obtains a new connection and resumes the persistence context. The method <code class="literal">getTransaction().commit()</code> will not only flush and check versions, but also disconnects the entity manager from the JDBC connection and return the connection to the pool.
			</div><div class="para">
				This pattern is problematic if the persistence context is too big to be stored during user think time, and if you don't know where to store it. E.g. the <code class="literal">HttpSession</code> should be kept as small as possible. As the persistence context is also the (mandatory) first-level cache and contains all loaded objects, we can probably use this strategy only for a few request/response cycles. This is indeed recommended, as the persistence context will soon also have stale data.
			</div><div class="para">
				It is up to you where you store the extended entity manager during requests, inside an EJB3 container you simply use a stateful session bean as described above. Don't transfer it to the web layer (or even serialize it to a separate tier) to store it in the <code class="literal">HttpSession</code>. In a non-managed, two-tiered environment the <code class="literal">HttpSession</code> might indeed be the right place to store it.
			</div></div><div class="section" id="transactions-optimistic-detached"><div class="titlepage"><div><div><h3 class="title">4.4.3. Detached objects and automatic versioning</h3></div></div></div><div class="para">
				With this paradigm, each interaction with the data store occurs in a new persistence context. However, the same persistent instances are reused for each interaction with the database. The application manipulates the state of detached instances originally loaded in another persistence context and then merges the changes using <code class="literal">EntityManager.merge()</code>:
			</div><pre class="programlisting">// foo is an instance loaded by a non-extended entity manager
foo.setProperty("bar");
entityManager = factory.createEntityManager();
entityManager.getTransaction().begin();
managedFoo = entityManager.merge(foo);  // discard foo and from now on use managedFoo
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
				Again, the entity manager will check instance versions during flush, throwing an exception if conflicting updates occured.
			</div></div></div></div><div xml:lang="en-US" class="chapter" id="listeners" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Entity listeners and Callback methods</h1></div></div></div><div class="section" id="idm140350351802144"><div class="titlepage"><div><div><h2 class="title">5.1. Definition</h2></div></div></div><div class="para">
			It is often useful for the application to react to certain events that occur inside the persistence mechanism. This allows the implementation of certain kinds of generic functionality, and extension of built-in functionality. The EJB3 specification provides two related mechanisms for this purpose.
		</div><div class="para">
			A method of the entity may be designated as a callback method to receive notification of a particular entity life cycle event. Callbacks methods are annotated by a callback annotation. You can also define an entity listener class to be used instead of the callback methods defined directly inside the entity class. An entity listener is a stateless class with a no-arg constructor. An entity listener is defined by annotating the entity class with the <code class="literal">@EntityListeners</code> annotation:
		</div><pre class="programlisting">@Entity 
@EntityListeners(class=Audit.value)
public class Cat {
    @Id private Integer id;
    private String name;
    private Date dateOfBirth;
    @Transient private int age;
    private Date lastUpdate;
    //getters and setters

    /**
     * Set my transient property at load time based on a calculation,
     * note that a native Hibernate formula mapping is better for this purpose.
     */
    @PostLoad
    public void calculateAge() {
        Calendar birth = new GregorianCalendar();
        birth.setTime(dateOfBirth);
        Calendar now = new GregorianCalendar();
        now.setTime( new Date() );
        int adjust = 0;
        if ( now.get(Calendar.DAY_OF_YEAR) - birth.get(Calendar.DAY_OF_YEAR) &lt; 0) {
            adjust = -1;
        }
        age = now.get(Calendar.YEAR) - birth.get(Calendar.YEAR) + adjust;
    }
}

public class LastUpdateListener {
    /**
     * automatic property set before any database persistence
     */
    @PreUpdate
    @PrePersist
    public void setLastUpdate(Cat o) {
        o.setLastUpdate( new Date() );
    }
}</pre><div class="para">
			The same callback method or entity listener method can be annotated with more than one callback annotation. For a given entity, you cannot have two methods being annotated by the same callback annotation whether it is a callback method or an entity listener method. A callback method is a no-arg method with no return type and any arbitrary name. An entity listener has the signature <code class="code">void &lt;METHOD&gt;(Object)</code> where Object is of the actual entity type (note that Hibernate Entity Manager relaxed this constraint and allows <code class="literal">Object</code> of <code class="literal">java.lang.Object</code> type (allowing sharing of listeners accross several entities.)
		</div><div class="para">
			A callback method can raise a <code class="classname">RuntimeException</code>. The current transaction, if any, must be rolled back. The following callbacks are defined:
		</div><div class="table" id="idm140350357170944"><p class="title"><strong>Table 5.1. Callbacks</strong></p><div class="table-contents"><table class="lt-4-cols gt-7-rows" summary="Callbacks"><colgroup><col><!--Empty--></col><col><!--Empty--></col></colgroup><thead><tr><th align="center" id="idm140350352394688" scope="col"> Type </th><th align="center" id="idm140350355784272" scope="col"> Description </th></tr></thead><tbody><tr><td headers="idm140350352394688"> @PrePersist </td><td headers="idm140350355784272"> Executed before the entity manager persist operation is actually executed or cascaded. This call is synchronous with the persist operation. </td></tr><tr><td headers="idm140350352394688"> @PreRemove </td><td headers="idm140350355784272"> Executed before the entity manager remove operation is actually executed or cascaded. This call is synchronous with the remove operation. </td></tr><tr><td headers="idm140350352394688"> @PostPersist </td><td headers="idm140350355784272"> Executed after the entity manager persist operation is actually executed or cascaded. This call is invoked after the database INSERT is executed. </td></tr><tr><td headers="idm140350352394688"> @PostRemove </td><td headers="idm140350355784272"> Executed after the entity manager remove operation is actually executed or cascaded. This call is synchronous with the remove operation. </td></tr><tr><td headers="idm140350352394688"> @PreUpdate </td><td headers="idm140350355784272"> Executed before the database UPDATE operation. </td></tr><tr><td headers="idm140350352394688"> @PostUpdate </td><td headers="idm140350355784272"> Executed after the database UPDATE operation. </td></tr><tr><td headers="idm140350352394688"> @PostLoad </td><td headers="idm140350355784272"> Eexecuted after an entity has been loaded into the current persistence context or an entity has been refreshed. </td></tr></tbody></table></div></div><div class="para">
			A callback method must not invoke <code class="classname">EntityManager</code> or <code class="classname">Query</code> methods!
		</div></div><div class="section" id="idm140350344872576"><div class="titlepage"><div><div><h2 class="title">5.2. Callbacks and listeners inheritance</h2></div></div></div><div class="para">
			You can define several entity listeners per entity at different level of the hierarchy.You can also define several callbacks at different level of the hierarchy. But you cannot define two listeners for the same event in the same entity or the same entity listener.
		</div><div class="para">
			When an event is raised, the listeners are executed in this order:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">@EntityListeners</code> for a given entity or superclass in the array order
				</div></li><li class="listitem"><div class="para">
					Entity listeners for the superclasses (highest first)
				</div></li><li class="listitem"><div class="para">
					Entity Listeners for the entity
				</div></li><li class="listitem"><div class="para">
					Callbacks of the superclasses (highest first)
				</div></li><li class="listitem"><div class="para">
					Callbacks of the entity
				</div></li></ul></div><div class="para">
			You can stop the entity listeners inheritance by using the <code class="literal">@ExcludeSuperclassListeners</code>, all superclasses <code class="literal">@EntityListeners</code> will then be ignored.
		</div></div><div class="section" id="idm140350360949840"><div class="titlepage"><div><div><h2 class="title">5.3. XML definition</h2></div></div></div><div class="para">
			The EJB3 specification allows annotation overriding through EJB3 deployment descriptor. There is also an additional feature that can be useful: default event listeners.
		</div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
                 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                 xsi:schemaLocation="http://java.sun.com/xml/ns/persistence/orm orm_1_0.xsd"
                 version="1.0"
        &gt;
    &lt;persistence-unit-metadata&gt;
        &lt;persistence-unit-defaults&gt;
            &lt;entity-listeners&gt;
                &lt;entity-listener class="org.hibernate.ejb.test.pack.defaultpar.IncrementListener"&gt;
                    &lt;pre-persist method-name="increment"/&gt;
                &lt;/entity-listener&gt;
            &lt;/entity-listeners&gt;
        &lt;/persistence-unit-defaults&gt;
    &lt;/persistence-unit-metadata&gt;
    &lt;package&gt;org.hibernate.ejb.test.pack.defaultpar&lt;/package&gt;
    &lt;entity class="ApplicationServer"&gt;
        &lt;entity-listeners&gt;
            &lt;entity-listener class="OtherIncrementListener"&gt;
                &lt;pre-persist method-name="increment"/&gt;
            &lt;/entity-listener&gt;
        &lt;/entity-listeners&gt;


        &lt;pre-persist method-name="calculate"/&gt;
    &lt;/entity&gt;
&lt;/entity-mappings&gt;</pre><div class="para">
			You can override entity listeners on a given entity. An entity listener correspond to a given class and one or several event fire a given method call. You can also define event on the entity itself to describe the callbacks.
		</div><div class="para">
			Last but not least, you can define some default entity listeners that will apply first on the entity listener stack of all the mapped entities of a given persistence unit. If you don't want an entity to inherit the default listeners, you can use @ExcludeDefaultListeners (or &lt;exclude-default-listeners/&gt;).
		</div></div></div><div xml:lang="en-US" class="chapter" id="batch" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Batch processing</h1></div></div></div><div class="para">
		Batch processing has traditionally been difficult in full object/relational mapping. ORM is all about object state management, which implies that object state is available in memory. However, Hibernate has some features to optimize batch processing which are discussed in the Hibernate reference guide, however, EJB3 persistence differs slightly.
	</div><div class="section" id="batch-direct"><div class="titlepage"><div><div><h2 class="title">6.1. Bulk update/delete</h2></div></div></div><div class="para">
			As already discussed, automatic and transparent object/relational mapping is concerned with the management of object state. This implies that the object state is available in memory, hence updating or deleting (using SQL <code class="literal">UPDATE</code> and <code class="literal">DELETE</code>) data directly in the database will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statement execution which are performed through EJB-QL (<a class="xref" href="#queryhql">Chapter 7, <em>EJB-QL: The Object Query Language</em></a>).
		</div><div class="para">
			The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is: <code class="literal">( UPDATE | DELETE ) FROM? ClassName (WHERE WHERE_CONDITIONS)?</code>. Note that:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					In the from-clause, the FROM keyword is optional.
				</div></li><li class="listitem"><div class="para">
					There can only be a single class named in the from-clause, and it <span class="emphasis"><em>cannot</em></span> have an alias (this is a current Hibernate limitation and will be removed soon).
				</div></li><li class="listitem"><div class="para">
					No joins (either implicit or explicit) can be specified in a bulk EJB-QL query. Sub-queries may be used in the where-clause.
				</div></li><li class="listitem"><div class="para">
					The where-clause is also optional.
				</div></li></ul></div><div class="para">
			As an example, to execute an EJB-QL <code class="literal">UPDATE</code>, use the <code class="literal">Query.executeUpdate()</code> method:
		</div><pre class="programlisting">EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();

String ejbqlUpdate = "update Customer set name = :newName where name = :oldName";
int updatedEntities = entityManager.createQuery( ejbqlUpdate )
                            .setParameter( "newName", newName )
                            .setParameter( "oldName", oldName )
                            .executeUpdate();
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
			To execute an EJB-QL <code class="literal">DELETE</code>, use the same <code class="literal">Query.executeUpdate()</code> method (the method is named for those familiar with JDBC's <code class="literal">PreparedStatement.executeUpdate()</code>):
		</div><pre class="programlisting">EntityManager entityManager = entityManagerFactory.createEntityManager();
entityManager.getTransaction().begin();

String hqlDelete = "delete Customer where name = :oldName";
int deletedEntities = entityManager.createQuery( hqlDelete )
                            .setParameter( "oldName", oldName )
                            .executeUpdate();
entityManager.getTransaction().commit();
entityManager.close();</pre><div class="para">
			The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicate the number of entities affected by the operation. This may or may not correlate with the number of rows affected in the database. An EJB-QL bulk operation might result in multiple actual SQL statements being executed, for joined-subclass, for example. The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the "root" table and potentially joined-subclass tables further down the inheritence hierarchy.
		</div></div></div><div xml:lang="en-US" class="chapter" id="queryhql" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 7. EJB-QL: The Object Query Language</h1></div></div></div><div class="para">
		EJB3-QL has been heavily inspired by HQL, the native Hibernate Query Language. Both are therefore very close to SQL, but portable and independent of the database schema. People familiar with HQL shouldn't have any problem using EJB-QL. Actually, you use the same query API for EJB-QL and HQL queries. For an EJB3 application to remain portable, it should use EJB-QL without vendor-specific extensions.
	</div><div class="section" id="queryhql-casesensitivity"><div class="titlepage"><div><div><h2 class="title">7.1. Case Sensitivity</h2></div></div></div><div class="para">
			Queries are case-insensitive, except for names of Java classes and properties. So <code class="literal">SeLeCT</code> is the same as <code class="literal">sELEct</code> is the same as <code class="literal">SELECT</code> but <code class="literal">org.hibernate.eg.FOO</code> is not <code class="literal">org.hibernate.eg.Foo</code> and <code class="literal">foo.barSet</code> is not <code class="literal">foo.BARSET</code>.
		</div><div class="para">
			This manual uses lowercase EJBQL keywords. Some users find queries with uppercase keywords more readable, but we find this convention ugly when embedded in Java code.
		</div></div><div class="section" id="queryhql-from"><div class="titlepage"><div><div><h2 class="title">7.2. The from clause</h2></div></div></div><div class="para">
			The simplest possible EJB-QL query is of the form:
		</div><pre class="programlisting">select c from eg.Cat c</pre><div class="para">
			which simply returns all instances of the class <code class="literal">eg.Cat</code>. Unlike HQL, the select clause is not optional in EJB-QL. We don't usually need to qualify the class name, since the entity name defaults to the unqualified class name (<code class="literal">@Entity</code>). So we almost always just write:
		</div><pre class="programlisting">select c from Cat c</pre><div class="para">
			As you may have noticed you can assign aliases to classes, the <code class="literal">as</code> keywork is optional. An alias allows you to refer to <code class="literal">Cat</code> in other parts of the query.
		</div><pre class="programlisting">select cat from Cat as cat</pre><div class="para">
			Multiple classes may appear, resulting in a cartesian product or "cross" join.
		</div><pre class="programlisting">select form, param from Formula as form, Parameter as param</pre><div class="para">
			It is considered good practice to name query aliases using an initial lowercase, consistent with Java naming standards for local variables (eg. <code class="literal">domesticCat</code>).
		</div></div><div class="section" id="queryhql-joins"><div class="titlepage"><div><div><h2 class="title">7.3. Associations and joins</h2></div></div></div><div class="para">
			You may also assign aliases to associated entities, or even to elements of a collection of values, using a <code class="literal">join</code>.
		</div><pre class="programlisting">select cat, mate, kitten from Cat as cat 
    inner join cat.mate as mate
    left outer join cat.kittens as kitten</pre><pre class="programlisting">select cat from Cat as cat left join cat.mate.kittens as kittens</pre><div class="para">
			The supported join types are borrowed from ANSI SQL
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">inner join</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">left outer join</code>
				</div></li></ul></div><div class="para">
			The <code class="literal">inner join</code>, <code class="literal">left outer join</code> constructs may be abbreviated.
		</div><pre class="programlisting">select cat, mate, kitten from Cat as cat 
    join cat.mate as mate
    left join cat.kittens as kitten</pre><div class="para">
			In addition, a "fetch" join allows associations or collections of values to be initialized along with their parent objects, using a single select. This is particularly useful in the case of a collection. It effectively overrides the fetching options in the associations and collection mapping metadata. See the Performance chapter of the Hibernate reference guide for more information.
		</div><pre class="programlisting">select cat from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens</pre><div class="para">
			A fetch join does not usually need to assign an alias, because the associated objects should not be used in the <code class="literal">where</code> clause (or any other clause). Also, the associated objects are not returned directly in the query results. Instead, they may be accessed via the parent object. The only reason we might need an alias is if we are recursively join fetching a further collection:
		</div><pre class="programlisting">select cat from Cat as cat 
    inner join fetch cat.mate
    left join fetch cat.kittens child
    left join fetch child.kittens</pre><div class="para">
			Note that the <code class="literal">fetch</code> construct may not be used in queries called using <code class="literal">scroll()</code> or <code class="literal">iterate()</code>. Nor should <code class="literal">fetch</code> be used together with <code class="literal">setMaxResults()</code> or <code class="literal">setFirstResult()</code>. It is possible to create a cartesian product by join fetching more than one collection in a query (as in the example above), be careful the result of this product isn't bigger than you expect. Join fetching multiple collection roles also sometimes gives unexpected results for bag mappings, so be careful about how you formulate your queries in this case.
		</div><div class="para">
			If you are using property-level lazy fetching (with bytecode instrumentation), it is possible to force Hibernate to fetch the lazy properties immediately (in the first query) using <code class="literal">fetch all properties</code>. This is Hibernate specific option:
		</div><pre class="programlisting">select doc from Document doc fetch all properties order by doc.name</pre><pre class="programlisting">select doc from Document doc fetch all properties where lower(doc.name) like '%cats%'</pre></div><div class="section" id="queryhql-select"><div class="titlepage"><div><div><h2 class="title">7.4. The select clause</h2></div></div></div><div class="para">
			The <code class="literal">select</code> clause picks which objects and properties to return in the query result set. Consider:
		</div><pre class="programlisting">select mate 
from Cat as cat 
    inner join cat.mate as mate</pre><div class="para">
			The query will select <code class="literal">mate</code>s of other <code class="literal">Cat</code>s. Actually, you may express this query more compactly as:
		</div><pre class="programlisting">select cat.mate from Cat cat</pre><div class="para">
			Queries may return properties of any value type including properties of component type:
		</div><pre class="programlisting">select cat.name from DomesticCat cat
where cat.name like 'fri%'</pre><pre class="programlisting">select cust.name.firstName from Customer as cust</pre><div class="para">
			Queries may return multiple objects and/or properties as an array of type <code class="literal">Object[]</code>,
		</div><pre class="programlisting">select mother, offspr, mate.name 
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><div class="para">
			or as a <code class="literal">List</code> (HQL specific feature)
		</div><pre class="programlisting">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre><div class="para">
			or as an actual typesafe Java object,
		</div><pre class="programlisting">select new Family(mother, mate, offspr)
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre><div class="para">
			assuming that the class <code class="literal">Family</code> has an appropriate constructor.
		</div><div class="para">
			You may assign aliases to selected expressions using <code class="literal">as</code>:
		</div><pre class="programlisting">select max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n
from Cat cat</pre><div class="para">
			This is most useful when used together with <code class="literal">select new map</code> (HQL specific feature):
		</div><pre class="programlisting">select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n )
from Cat cat</pre><div class="para">
			This query returns a <code class="literal">Map</code> from aliases to selected values.
		</div></div><div class="section" id="queryhql-aggregation"><div class="titlepage"><div><div><h2 class="title">7.5. Aggregate functions</h2></div></div></div><div class="para">
			HQL queries may even return the results of aggregate functions on properties:
		</div><pre class="programlisting">select avg(cat.weight), sum(cat.weight), max(cat.weight), count(cat)
from Cat cat</pre><div class="para">
			The supported aggregate functions are
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<code class="literal">avg(...), avg(distinct ...), sum(...), sum(distinct ...), min(...), max(...)</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">count(*)</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">count(...), count(distinct ...), count(all...)</code>
				</div></li></ul></div><div class="para">
			You may use arithmetic operators, concatenation, and recognized SQL functions in the select clause (depending on configured dialect, HQL specific feature):
		</div><pre class="programlisting">select cat.weight + sum(kitten.weight) 
from Cat cat 
    join cat.kittens kitten
group by cat.id, cat.weight</pre><pre class="programlisting">select firstName||' '||initial||' '||upper(lastName) from Person</pre><div class="para">
			The <code class="literal">distinct</code> and <code class="literal">all</code> keywords may be used and have the same semantics as in SQL.
		</div><pre class="programlisting">select distinct cat.name from Cat cat

select count(distinct cat.name), count(cat) from Cat cat</pre></div><div class="section" id="queryhql-polymorphism"><div class="titlepage"><div><div><h2 class="title">7.6. Polymorphic queries</h2></div></div></div><div class="para">
			A query like:
		</div><pre class="programlisting">select cat from Cat as cat</pre><div class="para">
			returns instances not only of <code class="literal">Cat</code>, but also of subclasses like <code class="literal">DomesticCat</code>. Hibernate queries may name <span class="emphasis"><em>any</em></span> Java class or interface in the <code class="literal">from</code> clause (portable EJB-QL queries should only name mapped entities). The query will return instances of all persistent classes that extend that class or implement the interface. The following query would return all persistent objects:
		</div><pre class="programlisting">from java.lang.Object o // HQL only</pre><div class="para">
			The interface <code class="literal">Named</code> might be implemented by various persistent classes:
		</div><pre class="programlisting">from Named n, Named m where n.name = m.name // HQL only</pre><div class="para">
			Note that these last two queries will require more than one SQL <code class="literal">SELECT</code>. This means that the <code class="literal">order by</code> clause does not correctly order the whole result set. (It also means you can't call these queries using <code class="literal">Query.scroll()</code>.)
		</div></div><div class="section" id="queryhql-where"><div class="titlepage"><div><div><h2 class="title">7.7. The where clause</h2></div></div></div><div class="para">
			The <code class="literal">where</code> clause allows you to narrow the list of instances returned. If no alias exists, you may refer to properties by name:
		</div><pre class="programlisting">select cat from Cat cat where cat.name='Fritz'</pre><div class="para">
			returns instances of <code class="literal">Cat</code> named 'Fritz'.
		</div><pre class="programlisting">select foo 
from Foo foo, Bar bar
where foo.startDate = bar.date</pre><div class="para">
			will return all instances of <code class="literal">Foo</code> for which there exists an instance of <code class="literal">bar</code> with a <code class="literal">date</code> property equal to the <code class="literal">startDate</code> property of the <code class="literal">Foo</code>. Compound path expressions make the <code class="literal">where</code> clause extremely powerful. Consider:
		</div><pre class="programlisting">select cat from Cat cat where cat.mate.name is not null</pre><div class="para">
			This query translates to an SQL query with a table (inner) join. If you were to write something like
		</div><pre class="programlisting">select foo from Foo foo  
where foo.bar.baz.customer.address.city is not null</pre><div class="para">
			you would end up with a query that would require four table joins in SQL.
		</div><div class="para">
			The <code class="literal">=</code> operator may be used to compare not only properties, but also instances:
		</div><pre class="programlisting">select cat, rival from Cat cat, Cat rival where cat.mate = rival.mate</pre><pre class="programlisting">select cat, mate 
from Cat cat, Cat mate
where cat.mate = mate</pre><div class="para">
			The special property (lowercase) <code class="literal">id</code> may be used to reference the unique identifier of an object. (You may also use its mapped identifer property name.). Note that this keyword is specific to HQL.
		</div><pre class="programlisting">select cat from Cat as cat where cat.id = 123

select cat from Cat as cat where cat.mate.id = 69</pre><div class="para">
			The second query is efficient. No table join is required!
		</div><div class="para">
			Properties of composite identifiers may also be used. Suppose <code class="literal">Person</code> has a composite identifier consisting of <code class="literal">country</code> and <code class="literal">medicareNumber</code>.
		</div><pre class="programlisting">select person from bank.Person person
where person.id.country = 'AU' 
    and person.id.medicareNumber = 123456</pre><pre class="programlisting">select account from bank.Account account
where account.owner.id.country = 'AU' 
    and account.owner.id.medicareNumber = 123456</pre><div class="para">
			Once again, the second query requires no table join.
		</div><div class="para">
			Likewise, the special property <code class="literal">class</code> accesses the discriminator value of an instance in the case of polymorphic persistence. A Java class name embedded in the where clause will be translated to its discriminator value. Once again, this is specific to HQL.
		</div><pre class="programlisting">select cat from Cat cat where cat.class = DomesticCat</pre><div class="para">
			You may also specify properties of components or composite user types (and of components of components, etc). Never try to use a path-expression that ends in a property of component type (as opposed to a property of a component). For example, if <code class="literal">store.owner</code> is an entity with a component <code class="literal">address</code>
		</div><pre class="programlisting">store.owner.address.city    // okay
store.owner.address         // error!</pre><div class="para">
			An "any" type has the special properties <code class="literal">id</code> and <code class="literal">class</code>, allowing us to express a join in the following way (where <code class="literal">AuditLog.item</code> is a property mapped with <code class="literal">&lt;any&gt;</code>). <code class="literal">Any</code> is specific to Hibernate
		</div><pre class="programlisting">from AuditLog log, Payment payment 
where log.item.class = 'Payment' and log.item.id = payment.id</pre><div class="para">
			Notice that <code class="literal">log.item.class</code> and <code class="literal">payment.class</code> would refer to the values of completely different database columns in the above query.
		</div></div><div class="section" id="queryhql-expressions"><div class="titlepage"><div><div><h2 class="title">7.8. Expressions</h2></div></div></div><div class="para">
			Expressions allowed in the <code class="literal">where</code> clause include most of the kind of things you could write in SQL:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					mathematical operators <code class="literal">+, -, *, /</code>
				</div></li><li class="listitem"><div class="para">
					binary comparison operators <code class="literal">=, &gt;=, &lt;=, &lt;&gt;, !=, like</code>
				</div></li><li class="listitem"><div class="para">
					logical operations <code class="literal">and, or, not</code>
				</div></li><li class="listitem"><div class="para">
					Parentheses <code class="literal">( )</code>, indicating grouping
				</div></li><li class="listitem"><div class="para">
					<code class="literal">in</code>, <code class="literal">not in</code>, <code class="literal">between</code>, <code class="literal">is null</code>, <code class="literal">is not null</code>, <code class="literal">is empty</code>, <code class="literal">is not empty</code>, <code class="literal">member of</code> and <code class="literal">not member of</code>
				</div></li><li class="listitem"><div class="para">
					"Simple" case, <code class="literal">case ... when ... then ... else ... end</code>, and "searched" case, <code class="literal">case when ... then ... else ... end (specific to HQL)</code>
				</div></li><li class="listitem"><div class="para">
					string concatenation <code class="literal">...||...</code> or <code class="literal">concat(...,...) (use concat() for portable EJB-QL queries)</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">current_date()</code>, <code class="literal">current_time()</code>, <code class="literal">current_timestamp()</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">second(...)</code>, <code class="literal">minute(...)</code>, <code class="literal">hour(...)</code>, <code class="literal">day(...)</code>, <code class="literal">month(...)</code>, <code class="literal">year(...)</code>, (specific to HQL)
				</div></li><li class="listitem"><div class="para">
					Any function or operator defined by EJB-QL 3.0: <code class="literal">substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">coalesce()</code> and <code class="literal">nullif()</code>
				</div></li><li class="listitem"><div class="para">
					<code class="literal">cast(... as ...)</code>, where the second argument is the name of a Hibernate type, and <code class="literal">extract(... from ...)</code> if ANSI <code class="literal">cast()</code> and <code class="literal">extract()</code> is supported by the underlying database
				</div></li><li class="listitem"><div class="para">
					Any database-supported SQL scalar function like <code class="literal">sign()</code>, <code class="literal">trunc()</code>, <code class="literal">rtrim()</code>, <code class="literal">sin()</code>
				</div></li><li class="listitem"><div class="para">
					JDBC IN parameters <code class="literal">?</code>
				</div></li><li class="listitem"><div class="para">
					named parameters <code class="literal">:name</code>, <code class="literal">:start_date</code>, <code class="literal">:x1</code>
				</div></li><li class="listitem"><div class="para">
					SQL literals <code class="literal">'foo'</code>, <code class="literal">69</code>, <code class="literal">'1970-01-01 10:00:01.0'</code>
				</div></li><li class="listitem"><div class="para">
					Java <code class="literal">public static final</code> constants <code class="literal">eg.Color.TABBY</code>
				</div></li></ul></div><div class="para">
			<code class="literal">in</code> and <code class="literal">between</code> may be used as follows:
		</div><pre class="programlisting">select cat from DomesticCat cat where cat.name between 'A' and 'B'</pre><pre class="programlisting">select cat from DomesticCat cat where cat.name in ( 'Foo', 'Bar', 'Baz' )</pre><div class="para">
			and the negated forms may be written
		</div><pre class="programlisting">select cat from DomesticCat cat where cat.name not between 'A' and 'B'</pre><pre class="programlisting">select cat from DomesticCat cat where cat.name not in ( 'Foo', 'Bar', 'Baz' )</pre><div class="para">
			Likewise, <code class="literal">is null</code> and <code class="literal">is not null</code> may be used to test for null values.
		</div><div class="para">
			Booleans may be easily used in expressions by declaring HQL query substitutions in Hibernate configuration:
		</div><pre class="programlisting">hibernate.query.substitutions true 1, false 0</pre><div class="para">
			This will replace the keywords <code class="literal">true</code> and <code class="literal">false</code> with the literals <code class="literal">1</code> and <code class="literal">0</code> in the translated SQL from this HQL:
		</div><pre class="programlisting">select cat from Cat cat where cat.alive = true</pre><div class="para">
			You may test the size of a collection with the special property <code class="literal">size</code>, or the special <code class="literal">size()</code> function (HQL specific feature).
		</div><pre class="programlisting">select cat from Cat cat where cat.kittens.size &gt; 0</pre><pre class="programlisting">select cat from Cat cat where size(cat.kittens) &gt; 0</pre><div class="para">
			For indexed collections, you may refer to the minimum and maximum indices using <code class="literal">minindex</code> and <code class="literal">maxindex</code> functions. Similarly, you may refer to the minimum and maximum elements of a collection of basic type using the <code class="literal">minelement</code> and <code class="literal">maxelement</code> functions. These are HQL specific features.
		</div><pre class="programlisting">select cal from Calendar cal where maxelement(cal.holidays) &gt; current date</pre><pre class="programlisting">select order from Order order where maxindex(order.items) &gt; 100</pre><pre class="programlisting">select order from Order order where minelement(order.items) &gt; 10000</pre><div class="para">
			The SQL functions <code class="literal">any, some, all, exists, in</code> are supported when passed the element or index set of a collection (<code class="literal">elements</code> and <code class="literal">indices</code> functions) or the result of a subquery (see below). While subqueries are supported by EJB-QL, <code class="literal">elements</code> and <code class="literal">indices</code> are specific HQL features.
		</div><pre class="programlisting">select mother from Cat as mother, Cat as kit
where kit in elements(foo.kittens)</pre><pre class="programlisting">select p from NameList list, Person p
where p.name = some elements(list.names)</pre><pre class="programlisting">select cat from Cat cat where exists elements(cat.kittens)</pre><pre class="programlisting">select cat from Player p where 3 &gt; all elements(p.scores)</pre><pre class="programlisting">select cat from Show show where 'fizard' in indices(show.acts)</pre><div class="para">
			Note that these constructs - <code class="literal">size</code>, <code class="literal">elements</code>, <code class="literal">indices</code>, <code class="literal">minindex</code>, <code class="literal">maxindex</code>, <code class="literal">minelement</code>, <code class="literal">maxelement</code> - may only be used in the where clause in Hibernate.
		</div><div class="para">
			In HQL, elements of indexed collections (arrays, lists, maps) may be referred to by index (in a where clause only):
		</div><pre class="programlisting">select order from Order order where order.items[0].id = 1234</pre><pre class="programlisting">select person from Person person, Calendar calendar
where calendar.holidays['national day'] = person.birthDay
    and person.nationality.calendar = calendar</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ order.deliveredItemIndices[0] ] = item and order.id = 11</pre><pre class="programlisting">select item from Item item, Order order
where order.items[ maxindex(order.items) ] = item and order.id = 11</pre><div class="para">
			The expression inside <code class="literal">[]</code> may even be an arithmetic expression.
		</div><pre class="programlisting">select item from Item item, Order order
where order.items[ size(order.items) - 1 ] = item</pre><div class="para">
			HQL also provides the built-in <code class="literal">index()</code> function, for elements of a one-to-many association or collection of values.
		</div><pre class="programlisting">select item, index(item) from Order order 
    join order.items item
where index(item) &lt; 5</pre><div class="para">
			Scalar SQL functions supported by the underlying database may be used
		</div><pre class="programlisting">select cat from DomesticCat cat where upper(cat.name) like 'FRI%'</pre><div class="para">
			If you are not yet convinced by all this, think how much longer and less readable the following query would be in SQL:
		</div><pre class="programlisting">select cust
from Product prod,
    Store store
    inner join store.customers cust
where prod.name = 'widget'
    and store.location.name in ( 'Melbourne', 'Sydney' )
    and prod = all elements(cust.currentOrder.lineItems)</pre><div class="para">
			<span class="emphasis"><em>Hint:</em></span> something like
		</div><pre class="programlisting">SELECT cust.name, cust.address, cust.phone, cust.id, cust.current_order
FROM customers cust,
    stores store,
    locations loc,
    store_customers sc,
    product prod
WHERE prod.name = 'widget'
    AND store.loc_id = loc.id
    AND loc.name IN ( 'Melbourne', 'Sydney' )
    AND sc.store_id = store.id
    AND sc.cust_id = cust.id
    AND prod.id = ALL(
        SELECT item.prod_id
        FROM line_items item, orders o
        WHERE item.order_id = o.id
            AND cust.current_order = o.id
    )</pre></div><div class="section" id="queryhql-ordering"><div class="titlepage"><div><div><h2 class="title">7.9. The order by clause</h2></div></div></div><div class="para">
			The list returned by a query may be ordered by any property of a returned class or components:
		</div><pre class="programlisting">select cat from DomesticCat cat
order by cat.name asc, cat.weight desc, cat.birthdate</pre><div class="para">
			The optional <code class="literal">asc</code> or <code class="literal">desc</code> indicate ascending or descending order respectively.
		</div></div><div class="section" id="queryhql-grouping"><div class="titlepage"><div><div><h2 class="title">7.10. The group by clause</h2></div></div></div><div class="para">
			A query that returns aggregate values may be grouped by any property of a returned class or components:
		</div><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color</pre><pre class="programlisting">select foo.id, avg(name), max(name) 
from Foo foo join foo.names name
group by foo.id</pre><div class="para">
			A <code class="literal">having</code> clause is also allowed.
		</div><pre class="programlisting">select cat.color, sum(cat.weight), count(cat) 
from Cat cat
group by cat.color 
having cat.color in (eg.Color.TABBY, eg.Color.BLACK)</pre><div class="para">
			SQL functions and aggregate functions are allowed in the <code class="literal">having</code> and <code class="literal">order by</code> clauses, if supported by the underlying database (eg. not in MySQL).
		</div><pre class="programlisting">select cat
from Cat cat
    join cat.kittens kitten
group by cat
having avg(kitten.weight) &gt; 100
order by count(kitten) asc, sum(kitten.weight) desc</pre><div class="para">
			Note that neither the <code class="literal">group by</code> clause nor the <code class="literal">order by</code> clause may contain arithmetic expressions.
		</div></div><div class="section" id="queryhql-subqueries"><div class="titlepage"><div><div><h2 class="title">7.11. Subqueries</h2></div></div></div><div class="para">
			For databases that support subselects, EJB-QL supports subqueries within queries. A subquery must be surrounded by parentheses (often by an SQL aggregate function call). Even correlated subqueries (subqueries that refer to an alias in the outer query) are allowed.
		</div><pre class="programlisting">select fatcat from Cat as fatcat 
where fatcat.weight &gt; ( 
    select avg(cat.weight) from DomesticCat cat 
)</pre><pre class="programlisting">select cat from DomesticCat as cat 
where cat.name = some ( 
    select name.nickName from Name as name 
)</pre><pre class="programlisting">select cat from Cat as cat 
where not exists ( 
    from Cat as mate where mate.mate = cat 
)</pre><pre class="programlisting">select cat from DomesticCat as cat 
where cat.name not in ( 
    select name.nickName from Name as name 
)</pre><div class="para">
			For subqueries with more than one expression in the select list, you can use a tuple constructor:
		</div><pre class="programlisting">select cat from Cat as cat 
where not ( cat.name, cat.color ) in ( 
    select cat.name, cat.color from DomesticCat cat 
)</pre><div class="para">
			Note that on some databases (but not Oracle or HSQLDB), you can use tuple constructors in other contexts, for example when querying components or composite user types:
		</div><pre class="programlisting">select cat from Person where name = ('Gavin', 'A', 'King')</pre><div class="para">
			Which is equivalent to the more verbose:
		</div><pre class="programlisting">select cat from Person where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')</pre><div class="para">
			There are two good reasons you might not want to do this kind of thing: first, it is not completely portable between database platforms; second, the query is now dependent upon the ordering of properties in the mapping document.
		</div></div><div class="section" id="queryhql-examples"><div class="titlepage"><div><div><h2 class="title">7.12. EJB-QL examples</h2></div></div></div><div class="para">
			Hibernate queries can be quite powerful and complex. In fact, the power of the query language is one of Hibernate's main selling points (and now EJB-QL). This section includes examples of queries in Hibernate.
		</div><div class="para">
			The following query returns the order id, number of items and total value of the order for all unpaid orders for a particular customer and given minimum total value, ordering the results by total value. In determining the prices, it uses the current catalog. The resulting SQL query, against the <code class="literal">ORDER</code>, <code class="literal">ORDER_LINE</code>, <code class="literal">PRODUCT</code>, <code class="literal">CATALOG</code> and <code class="literal">PRICE</code> tables has four inner joins and an (uncorrelated) subselect.
		</div><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog.effectiveDate &lt; current_date()
    and catalog.effectiveDate &gt;= all (
        select cat.effectiveDate 
        from Catalog as cat
        where cat.effectiveDate &lt; current_date()
    )
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><div class="para">
			To avoid using subqueries, you could write something like this:
		</div><pre class="programlisting">select order.id, sum(price.amount), count(item)
from Order as order
    join order.lineItems as item
    join item.product as product,
    Catalog as catalog
    join catalog.prices as price
where order.paid = false
    and order.customer = :customer
    and price.product = product
    and catalog = :currentCatalog
group by order
having sum(price.amount) &gt; :minAmount
order by sum(price.amount) desc</pre><div class="para">
			The next query counts the number of payments in each status, excluding all payments in the <code class="literal">AWAITING_APPROVAL</code> status where the most recent status change was made by the current user. It translates to an SQL query with two inner joins and a correlated subselect against the <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code> and <code class="literal">PAYMENT_STATUS_CHANGE</code> tables.
		</div><pre class="programlisting">select count(payment), status.name 
from Payment as payment 
    join payment.currentStatus as status
    join payment.statusChanges as statusChange
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or (
        statusChange.timeStamp = ( 
            select max(change.timeStamp) 
            from PaymentStatusChange change 
            where change.payment = payment
        )
        and statusChange.user &lt;&gt; :currentUser
    )
group by status.name, status.sortOrder
order by status.sortOrder</pre><div class="para">
			If the <code class="literal">statusChanges</code> collection were mapped as a list instead of a set, the query would be far simpler.
		</div><pre class="programlisting">select count(payment), status.name 
from Payment as payment
    join payment.currentStatus as status
where payment.status.name &lt;&gt; PaymentStatus.AWAITING_APPROVAL
    or payment.statusChanges[ maxIndex(payment.statusChanges) ].user &lt;&gt; :currentUser
group by status.name, status.sortOrder
order by status.sortOrder</pre><div class="para">
			However the query would have been HQL specific.
		</div><div class="para">
			The next query uses the MS SQL Server <code class="literal">isNull()</code> function to return all the accounts and unpaid payments for the organization to which the current user belongs. It translates to an SQL query with three inner joins, an outer join and a subselect against the <code class="literal">ACCOUNT</code>, <code class="literal">PAYMENT</code>, <code class="literal">PAYMENT_STATUS</code>, <code class="literal">ACCOUNT_TYPE</code>, <code class="literal">ORGANIZATION</code> and <code class="literal">ORG_USER</code> tables.
		</div><pre class="programlisting">select account, payment
from Account as account
    join account.holder.users as user
    left outer join account.payments as payment
where :currentUser = user
    and PaymentStatus.UNPAID = isNull(payment.currentStatus.name, PaymentStatus.UNPAID)
order by account.type.sortOrder, account.accountNumber, payment.dueDate</pre></div><div class="section" id="queryhql-bulk"><div class="titlepage"><div><div><h2 class="title">7.13. Bulk UPDATE &amp; DELETE Statements</h2></div></div></div><div class="para">
			Hibernate now supports UPDATE and DELETE statements in HQL/EJB-QL. See <a class="xref" href="#batch-direct">Section 6.1, “Bulk update/delete”</a> for details.
		</div></div><div class="section" id="queryhql-tipstricks"><div class="titlepage"><div><div><h2 class="title">7.14. Tips &amp; Tricks</h2></div></div></div><div class="para">
			To order a result by the size of a collection, use the following query:
		</div><pre class="programlisting">select usr.id, usr.name
from User as usr 
    left join usr.messages as msg
group by usr.id, usr.name
order by count(msg)</pre><div class="para">
			If your database supports subselects, you can place a condition upon selection size in the where clause of your query:
		</div><pre class="programlisting">from User usr where size(usr.messages) &gt;= 1</pre><div class="para">
			If your database doesn't support subselects, use the following query:
		</div><pre class="programlisting">select usr.id, usr.name
from User usr.name
    join usr.messages msg
group by usr.id, usr.name
having count(msg) &gt;= 1</pre><div class="para">
			As this solution can't return a <code class="literal">User</code> with zero messages because of the inner join, the following form is also useful:
		</div><pre class="programlisting">select usr.id, usr.name
from User as usr
    left join usr.messages as msg
group by usr.id, usr.name
having count(msg) = 0</pre></div></div><div xml:lang="en-US" class="chapter" id="query_native" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Native query</h1></div></div></div><div class="para">
		You may also express queries in the native SQL dialect of your database. This is useful if you want to utilize database specific features such as query hints or the CONNECT BY option in Oracle. It also provides a clean migration path from a direct SQL/JDBC based application to Hibernate. Note that Hibernate allows you to specify handwritten SQL (including stored procedures) for all create, update, delete, and load operations (please refer to the reference guide for more information.)
	</div><div class="section" id="idm140350356183168"><div class="titlepage"><div><div><h2 class="title">8.1. Expressing the resultset</h2></div></div></div><div class="para">
			To use a SQL query, you need to describe the SQL resultset. This description will help the <code class="literal">EntityManager</code> to map your columns onto entity properties. This is done using the <code class="literal">@SqlResultSetMapping</code> annotation. Each <code class="literal">@SqlResultSetMapping </code>has a name wich is used when creating a SQL query on <code class="literal">EntityManager</code>.
		</div><pre class="programlisting">@SqlResultSetMapping(name="GetNightAndArea", 
    entities={
        @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class, fields
        = {
          @FieldResult(name="id", column="nid"),
          @FieldResult(name="duration", column="night_duration"),
          @FieldResult(name="date", column="night_date"),
          @FieldResult(name="area", column="area_id")
        }),
        @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields
        = {
          @FieldResult(name="id", column="aid"),
          @FieldResult(name="name", column="name")
        })
    }
)

@SqlResultSetMapping(name="defaultSpaceShip",
entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class))</pre><div class="para">
			You can also define scalar results and even mix entity results and scalar results
		</div><pre class="programlisting">@SqlResultSetMapping(name="ScalarAndEntities",
  entities={
      @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class,
      fields = {
          @FieldResult(name="id", column="nid"),
          @FieldResult(name="duration", column="night_duration"),
          @FieldResult(name="date", column="night_date"),
          @FieldResult(name="area", column="area_id")
      }),
      @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class,
      fields = {
          @FieldResult(name="id", column="aid"),
          @FieldResult(name="name", column="name")
      })
  },
  columns={
      @ColumnResult(name="durationInSec")
  }
)</pre><div class="para">
			The SQL query will then have to return a column alias <code class="literal">durationInSec</code>.
		</div><div class="para">
			Please refer to the Hibernate Annotations reference guide for more information about <code class="literal">@SqlResultSetMapping.</code>
		</div></div><div class="section" id="idm140350355422800"><div class="titlepage"><div><div><h2 class="title">8.2. Using native SQL Queries</h2></div></div></div><div class="para">
			Now that the result set is described, we are capable of executing the native SQL query. <code class="literal">EntityManager</code> provides all the needed APIs. The first method is to use a SQL resultset name to do the binding, the second one uses the entity default mapping (the column returned has to have the same names as the one used in the mapping). A third one (not yet supported by Hibernate entity manager), returns pure scalar results.
		</div><pre class="programlisting">String sqlQuery = "select night.id nid, night.night_duration, night.night_date, area.id aid, "
    + "night.area_id, area.name from Night night, Area area where night.area_id = area.id "
    + "and night.night_duration &gt;= ?";
Query q = entityManager.createNativeQuery(sqlQuery, "GetNightAndArea");
q.setParameter( 1, expectedDuration );
q.getResultList();</pre><div class="para">
			This native query returns nights and area based on the <code class="literal">GetNightAndArea</code> result set.
		</div><pre class="programlisting">String sqlQuery = "select * from tbl_spaceship where owner = ?";
Query q = entityManager.createNativeQuery(sqlQuery, SpaceShip.class);
q.setParameter( 1, "Han" );
q.getResultList();</pre><div class="para">
			The second version is useful when your SQL query returns one entity reusing the same columns as the ones mapped in metadata.
		</div></div><div class="section" id="idm140350344126448"><div class="titlepage"><div><div><h2 class="title">8.3. Named queries</h2></div></div></div><div class="para">
			Native named queries share the same calling API than EJB-QL named queries. Your code doesn't need to know the difference between the two. This is very useful for migration from SQL to EJB-QL:
		</div><pre class="programlisting">Query q = entityManager.createNamedQuery("getSeasonByNativeQuery");
q.setParameter( 1, name );
Season season = (Season) q.getSingleResult();</pre></div></div><div xml:lang="en-US" class="appendix" id="appe-Publican-Revision_History" lang="en-US"><div class="titlepage"><div><div><h1 class="title">Appendix A. Revision History</h1></div></div></div><div class="para"><p><!--Empty--></p>
		<div class="revhistory"><table summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 5.1.0-110.33.400</td><td align="left">2013-10-31</td><td align="left"><span class="author"><span class="firstname">Rüdiger</span> <span class="surname">Landmann</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Rebuild with publican 4.0.0</td></tr></table>

				</td></tr><tr><td align="left">Revision 5.1.0-110.33</td><td align="left">July 24 2012</td><td align="left"><span class="author"><span class="firstname">Ruediger</span> <span class="surname">Landmann</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Rebuild for Publican 3.0</td></tr></table>

				</td></tr><tr><td align="left">Revision 5.1-0</td><td align="left">Wed Sep 15 2010</td><td align="left"><span class="author"><span class="firstname">Laura</span> <span class="surname">Bailey</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Changed version number in line with new versioning requirements.</td></tr><tr><td>Revised for JBoss Enterprise Application Platform 5.1.0.GA.</td></tr></table>

				</td></tr></table></div>

	</div></div><div><div class="legalnotice"><a id="idm140350358378800"><!--Empty--></a><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span>© 2011 Red Hat, Inc.
	</div><div class="para">
		This document is licensed by Red Hat under the <a href="http://creativecommons.org/licenses/by-sa/3.0/" class="mimir-link-warn" title="Mimir does not include content from: creativecommons.org">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>. If you distribute this document, or a modified version of it, you must provide attribution to Red Hat, Inc. and provide a link to the original. If the document is modified, all Red Hat trademarks must be removed.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat Software Collections is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></body>

        
        
    </div>
    

</div> 


                            </bdo>
                        </main>
                    </div>
                </main>
            </div>
        
            <!--#include virtual="/includes/footer/index.html" -->
        </div>
    </body>
</html>
