<!DOCTYPE html>
<html>
    <head>
        
        <link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir.min.css">
        




    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />

    <link rel="stylesheet" type="text/css" media="screen" href="/sites/dxp-docs/files/css/css_Bwzy34i9pSdDlzGALvqVwG4fpgGp08KLMAkClGNY9M4.css" />



<link rel="stylesheet" type="text/css" media="screen" href="/mimir/styles/mimir-doc-toc.min.css" />



        
        <!--#include virtual="/includes/head/index.html" -->

        
        <title>
Developing Hibernate Applications - JBoss Enterprise Application Platform Continuous Delivery 18
</title>
        
<meta name="product" content="JBoss Enterprise Application Platform Continuous Delivery" />
<meta name="documentation_version" content="18" />
<meta name="documentKind" content="documentation" />
<meta name="portal_content_subtype" content="title" />
<meta name="lastModifiedDate" content="2019-12-06T22:33:06.000Z" />


        
            
        
        
            
                
                
                <!-- mimir_solr_yesindex -->
                <meta name="mimir_solr_yesindex" content="true" />
            
        
    </head>

    <body class="mimir-body">

        
        

        
        <div id="page-wrap" class="page-wrap">
            <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">
                <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
                <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

                <header class="masthead" id="masthead">

                    
                    <!--#include virtual="/includes/header/index.html" -->

                    
                    
                    
                        
                    
                    
                        <div class="breadcrumbs">
                            <div id="breadcrumbs" class="container">
                                
                                <a href="/">Home</a>
                                
                                <a href="/products/">Product Documentation</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/20/">JBoss Enterprise Application Platform Continuous Delivery</a>
                                
                                <a href="/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/18/">18</a>
                                
                                
                                Developing Hibernate Applications
                                
                            </div>
                        </div>
                    
                </header>

                <main id="cp-main" class="portal-content-area">
                    <div id="cp-content" class="main-content">
                        
                        <main class="container mimir-docs">
                            
                            <bdo>
                                

<script type="module" src="/mimir/scripts/mimir-doc-toc.min.js"></script>






<div class="docs-grid">

    <nav id="mimir-doc-toc" class="mimir-doc-toc">
      <div class="mimir-doc-toc-inner">
          <!-- single-page -->
        
            
              <ol>
                <li>
                        
                        <a href="#">Developing Hibernate Applications</a>
                    </li><li>
                        <a href="#idm140159953989120">
                            Preface
                        </a>
                    </li><li>
                        <a href="#introduction">
                            1. Introduction
                        </a><ol>
                <li>
                        <a href="#about_hibernate_core">
                            1.1. About Hibernate Core
                        </a>
                    </li><li>
                        <a href="#hibernate_entitymanager">
                            1.2. Hibernate EntityManager
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_configuration">
                            2. Hibernate Configuration
                        </a><ol>
                <li>
                        <a href="#configuration">
                            2.1. Hibernate Configuration
                        </a>
                    </li><li>
                        <a href="#second_level_caches">
                            2.2. Second-Level Caches
                        </a><ol>
                <li>
                        <a href="#about_second_level_caches">
                            2.2.1. About Second-level Caches
                        </a>
                    </li><li>
                        <a href="#configure_a_second_level_cache_for_hibernate">
                            2.2.2. Configure a Second-level Cache for Hibernate
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_annotations-1">
                            3. Hibernate Annotations
                        </a><ol>
                <li>
                        <a href="#hibernate_annotations">
                            3.1. Hibernate Annotations
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_query_language">
                            4. Hibernate Query Language
                        </a><ol>
                <li>
                        <a href="#about_hibernate_query_language">
                            4.1. About Hibernate Query Language
                        </a>
                    </li><li>
                        <a href="#HQL_statements">
                            4.2. About HQL Statements
                        </a>
                    </li><li>
                        <a href="#about_hql_ordering">
                            4.3. About HQL Ordering
                        </a>
                    </li><li>
                        <a href="#about_collection_memeber_references">
                            4.4. About Collection Member References
                        </a>
                    </li><li>
                        <a href="#about_qualified_path_expressions">
                            4.5. About Qualified Path Expressions
                        </a>
                    </li><li>
                        <a href="#about_hql_functions">
                            4.6. About HQL Functions
                        </a><ol>
                <li>
                        <a href="#hql_standardized_functions">
                            4.6.1. About HQL Standardized Functions
                        </a>
                    </li><li>
                        <a href="#about_hql_non_standardized_functions">
                            4.6.2. About HQL Non-Standardized Functions
                        </a>
                    </li><li>
                        <a href="#about_the_concatenation_operation">
                            4.6.3. About the Concatenation Operation
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#about_dynamic_instantiation">
                            4.7. About Dynamic Instantiation
                        </a>
                    </li><li>
                        <a href="#about_hql_predicates">
                            4.8. About HQL Predicates
                        </a>
                    </li><li>
                        <a href="#about_relational_comparisons">
                            4.9. About Relational Comparisons
                        </a>
                    </li><li>
                        <a href="#bytecode_enhancement">
                            4.10. Bytecode Enhancement
                        </a><ol>
                <li>
                        <a href="#lazy_attribute_loading">
                            4.10.1. Lazy Attribute Loading
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_services">
                            5. Hibernate Services
                        </a><ol>
                <li>
                        <a href="#about_hibernate_services">
                            5.1. About Hibernate Services
                        </a>
                    </li><li>
                        <a href="#about_service_contracts">
                            5.2. About Service Contracts
                        </a>
                    </li><li>
                        <a href="#types_of_service_dependencies">
                            5.3. Types of Service Dependencies
                        </a><ol>
                <li>
                        <a href="#the_service_registry">
                            5.3.1. The Service Registry
                        </a><ol>
                <li>
                        <a href="#about_the_serviceRegistry">
                            5.3.1.1. About the ServiceRegistry
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#custom_services">
                            5.3.2. Custom Services
                        </a><ol>
                <li>
                        <a href="#about_custom_services">
                            5.3.2.1. About Custom Services
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#the_boot_strap_registry">
                            5.3.3. The Boot-Strap Registry
                        </a><ol>
                <li>
                        <a href="#about_the_boot-strap_registry">
                            5.3.3.1. About the Boot-strap Registry
                        </a>
                    </li><li>
                        <a href="#bootstarpregistry_services">
                            5.3.3.2. BootstrapRegistry Services
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#sessionFactory_registry">
                            5.3.4. SessionFactory Registry
                        </a><ol>
                <li>
                        <a href="#sessionFactory_services">
                            5.3.4.1. SessionFactory Services
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#integrators">
                            5.3.5. Integrators
                        </a><ol>
                <li>
                        <a href="#integrator_use-cases">
                            5.3.5.1. Integrator Use Cases
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_envers">
                            6. Hibernate Envers
                        </a><ol>
                <li>
                        <a href="#about_hibernate_envers">
                            6.1. About Hibernate Envers
                        </a>
                    </li><li>
                        <a href="#about_auditing_persistent_classes">
                            6.2. About Auditing Persistent Classes
                        </a>
                    </li><li>
                        <a href="#auditing_strategies">
                            6.3. Auditing Strategies
                        </a><ol>
                <li>
                        <a href="#about_auditing_strategies">
                            6.3.1. About Auditing Strategies
                        </a>
                    </li><li>
                        <a href="#set_the_auditing_strategy">
                            6.3.2. Set the Auditing Strategy
                        </a>
                    </li><li>
                        <a href="#add_auditing_suppprt_to_a_jpa_entity">
                            6.3.3. Adding Auditing Support to a JPA Entity
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration-1">
                            6.4. Configuration
                        </a><ol>
                <li>
                        <a href="#configure_envres_parameters">
                            6.4.1. Configure Envers Parameters
                        </a>
                    </li><li>
                        <a href="#enable_or_disable_auditing_at_runtime">
                            6.4.2. Enable or Disable Auditing at Runtime
                        </a>
                    </li><li>
                        <a href="#configure_conditional_auditing">
                            6.4.3. Configure Conditional Auditing
                        </a>
                    </li><li>
                        <a href="#envers_configuration_properties">
                            6.4.4. Envers Configuration Properties
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#querying_audit_information">
                            6.5. Querying Audit Information
                        </a><ol>
                <li>
                        <a href="#retrieve_auditing_information">
                            6.5.1. Retrieve Auditing Information Through Queries
                        </a>
                    </li><li>
                        <a href="#hibernate_envers_traversing_entities_using_properties">
                            6.5.2. Traversing Entity Associations Using Properties of Referenced Entities
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#performance_tuning">
                            6.6. Performance Tuning
                        </a><ol>
                <li>
                        <a href="#alternative_batch_loading_algorithms">
                            6.6.1. Alternative Batch Loading Algorithms
                        </a>
                    </li><li>
                        <a href="#second_level_caching_of_object_references_for_non-mutable_data">
                            6.6.2. Second Level Caching of Object References for Non-mutable Data
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_search">
                            7. Hibernate Search
                        </a><ol>
                <li>
                        <a href="#getting_started_with_hibernate_search">
                            7.1. Getting Started with Hibernate Search
                        </a><ol>
                <li>
                        <a href="#about_hibernate_search">
                            7.1.1. About Hibernate Search
                        </a>
                    </li><li>
                        <a href="#overview">
                            7.1.2. Overview
                        </a>
                    </li><li>
                        <a href="#about_directory_provider">
                            7.1.3. About the Directory Provider
                        </a>
                    </li><li>
                        <a href="#about_worker">
                            7.1.4. About the Worker
                        </a>
                    </li><li>
                        <a href="#back_end_setup_and_operations">
                            7.1.5. Back End Setup and Operations
                        </a><ol>
                <li>
                        <a href="#back_end">
                            7.1.5.1. Back End
                        </a>
                    </li><li>
                        <a href="#lucene">
                            7.1.5.2. Lucene
                        </a>
                    </li><li>
                        <a href="#jms">
                            7.1.5.3. JMS
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#reader_strategies">
                            7.1.6. Reader Strategies
                        </a><ol>
                <li>
                        <a href="#the_shared_strategy">
                            7.1.6.1. The Shared Strategy
                        </a>
                    </li><li>
                        <a href="#the_not_shared_strategy">
                            7.1.6.2. The Not-shared Strategy
                        </a>
                    </li><li>
                        <a href="#custom_reader_strategies">
                            7.1.6.3. Custom Reader Strategies
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#configuration_2">
                            7.2. Configuration
                        </a><ol>
                <li>
                        <a href="#minimum_configuration">
                            7.2.1. Minimum Configuration
                        </a>
                    </li><li>
                        <a href="#configuring_indexmanager">
                            7.2.2. Configuring the IndexManager
                        </a><ol>
                <li>
                        <a href="#directory_based">
                            7.2.2.1. Directory-based
                        </a>
                    </li><li>
                        <a href="#near_real_time">
                            7.2.2.2. Near Real Time
                        </a>
                    </li><li>
                        <a href="#custom">
                            7.2.2.3. Custom
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#directory_provider_configuration">
                            7.2.3. DirectoryProvider Configuration
                        </a>
                    </li><li>
                        <a href="#worker_configuration">
                            7.2.4. Worker Configuration
                        </a><ol>
                <li>
                        <a href="#jms_master_slave_back_end">
                            7.2.4.1. JMS Master/Slave Back End
                        </a>
                    </li><li>
                        <a href="#slave_nodes">
                            7.2.4.2. Slave Nodes
                        </a>
                    </li><li>
                        <a href="#master_node">
                            7.2.4.3. Master Node
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#tuning_lucene_indexing">
                            7.2.5. Tuning Lucene Indexing
                        </a><ol>
                <li>
                        <a href="#tuning_lucene_indexing_performance">
                            7.2.5.1. Tuning Lucene Indexing Performance
                        </a>
                    </li><li>
                        <a href="#the_lucene_indexwriter">
                            7.2.5.2. The Lucene IndexWriter
                        </a>
                    </li><li>
                        <a href="#performance_option_configuration">
                            7.2.5.3. Performance Option Configuration
                        </a>
                    </li><li>
                        <a href="#tuning_the_indexing_speed">
                            7.2.5.4. Tuning the Indexing Speed
                        </a>
                    </li><li>
                        <a href="#control_segment_size">
                            7.2.5.5. Control Segment Size
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#lockfactory_configuration">
                            7.2.6. LockFactory Configuration
                        </a>
                    </li><li>
                        <a href="#index_format_compatibility">
                            7.2.7. Index Format Compatibility
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#hibernate_search_for_your_application">
                            7.3. Hibernate Search for Your Application
                        </a><ol>
                <li>
                        <a href="#first_steps_with_hibernate_search">
                            7.3.1. First Steps with Hibernate Search
                        </a>
                    </li><li>
                        <a href="#enable_hibernate_search_using_maven">
                            7.3.2. Enable Hibernate Search Using Maven
                        </a>
                    </li><li>
                        <a href="#add_annotations">
                            7.3.3. Add Annotations
                        </a>
                    </li><li>
                        <a href="#indexing">
                            7.3.4. Indexing
                        </a>
                    </li><li>
                        <a href="#searching">
                            7.3.5. Searching
                        </a>
                    </li><li>
                        <a href="#analyzer">
                            7.3.6. Analyzer
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#mapping_entities_to_the_index_structure">
                            7.4. Mapping Entities to the Index Structure
                        </a><ol>
                <li>
                        <a href="#mapping_an_entity">
                            7.4.1. Mapping an Entity
                        </a><ol>
                <li>
                        <a href="#basic_mapping">
                            7.4.1.1. Basic Mapping
                        </a>
                    </li><li>
                        <a href="#indexed">
                            7.4.1.2. @Indexed
                        </a>
                    </li><li>
                        <a href="#field">
                            7.4.1.3. @Field
                        </a>
                    </li><li>
                        <a href="#numericfield">
                            7.4.1.4. @NumericField
                        </a>
                    </li><li>
                        <a href="#id">
                            7.4.1.5. @Id
                        </a>
                    </li><li>
                        <a href="#mapping_properties_multiple_times">
                            7.4.1.6. Mapping Properties Multiple Times
                        </a>
                    </li><li>
                        <a href="#embedded_and_associated_objects">
                            7.4.1.7. Embedded and Associated Objects
                        </a>
                    </li><li>
                        <a href="#limiting_object_embedding_to_specific_paths">
                            7.4.1.8. Limiting Object Embedding to Specific Paths
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#boosting">
                            7.4.2. Boosting
                        </a><ol>
                <li>
                        <a href="#static_index_time_boosting">
                            7.4.2.1. Static Index Time Boosting
                        </a>
                    </li><li>
                        <a href="#dynamic_index_time_boosting">
                            7.4.2.2. Dynamic Index Time Boosting
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#analysis">
                            7.4.3. Analysis
                        </a><ol>
                <li>
                        <a href="#default_analyzer_and_analyzer_by_class">
                            7.4.3.1. Default Analyzer and Analyzer by Class
                        </a>
                    </li><li>
                        <a href="#named_analyzers">
                            7.4.3.2. Named Analyzers
                        </a>
                    </li><li>
                        <a href="#available_analyzers">
                            7.4.3.3. Available Analyzers
                        </a>
                    </li><li>
                        <a href="#dynamic_analyzer_selection">
                            7.4.3.4. Dynamic Analyzer Selection
                        </a>
                    </li><li>
                        <a href="#retrieving_an_analyzer">
                            7.4.3.5. Retrieving an Analyzer
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#bridges">
                            7.4.4. Bridges
                        </a><ol>
                <li>
                        <a href="#built_in_bridges">
                            7.4.4.1. Built-in Bridges
                        </a>
                    </li><li>
                        <a href="#custom_bridges">
                            7.4.4.2. Custom Bridges
                        </a><ol>
                <li>
                        <a href="#stringbridge">
                            7.4.4.2.1. StringBridge
                        </a>
                    </li><li>
                        <a href="#parameterized_bridge">
                            7.4.4.2.2. Parameterized Bridge
                        </a>
                    </li><li>
                        <a href="#type_away_bridge">
                            7.4.4.2.3. Type Aware Bridge
                        </a>
                    </li><li>
                        <a href="#two_way_bridge">
                            7.4.4.2.4. Two-Way Bridge
                        </a>
                    </li><li>
                        <a href="#fieldbridge">
                            7.4.4.2.5. FieldBridge
                        </a>
                    </li><li>
                        <a href="#classbridge">
                            7.4.4.2.6. ClassBridge
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#querying">
                            7.5. Querying
                        </a><ol>
                <li>
                        <a href="#building_queries">
                            7.5.1. Building Queries
                        </a><ol>
                <li>
                        <a href="#building_a_lucene_query_using_the_lucene_api">
                            7.5.1.1. Building a Lucene Query Using the Lucene API
                        </a>
                    </li><li>
                        <a href="#building_a_lucene_query">
                            7.5.1.2. Building a Lucene Query
                        </a>
                    </li><li>
                        <a href="#keyword_queries">
                            7.5.1.3. Keyword Queries
                        </a>
                    </li><li>
                        <a href="#fuzzy_queries">
                            7.5.1.4. Fuzzy Queries
                        </a>
                    </li><li>
                        <a href="#wildcard_queries">
                            7.5.1.5. Wildcard Queries
                        </a>
                    </li><li>
                        <a href="#phase_queries">
                            7.5.1.6. Phrase Queries
                        </a>
                    </li><li>
                        <a href="#range_queries">
                            7.5.1.7. Range Queries
                        </a>
                    </li><li>
                        <a href="#combining_queries">
                            7.5.1.8. Combining Queries
                        </a>
                    </li><li>
                        <a href="#query_options">
                            7.5.1.9. Query Options
                        </a>
                    </li><li>
                        <a href="#build_a_hibernate_search_query">
                            7.5.1.10. Build a Hibernate Search Query
                        </a><ol>
                <li>
                        <a href="#generality">
                            7.5.1.10.1. Generality
                        </a>
                    </li><li>
                        <a href="#pagination">
                            7.5.1.10.2. Pagination
                        </a>
                    </li><li>
                        <a href="#sorting">
                            7.5.1.10.3. Sorting
                        </a>
                    </li><li>
                        <a href="#fetching_strategy">
                            7.5.1.10.4. Fetching Strategy
                        </a>
                    </li><li>
                        <a href="#projection">
                            7.5.1.10.5. Projection
                        </a>
                    </li><li>
                        <a href="#customizing_object_initialization_strategies">
                            7.5.1.10.6. Customizing Object Initialization Strategies
                        </a>
                    </li><li>
                        <a href="#limiting_the_time_of_a_query">
                            7.5.1.10.7. Limiting the Time of a Query
                        </a>
                    </li><li>
                        <a href="#raise_an_exception_on_time_limit">
                            7.5.1.10.8. Raise an Exception on Time Limit
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#retrieving_the_results">
                            7.5.2. Retrieving the Results
                        </a><ol>
                <li>
                        <a href="#performance_considerations">
                            7.5.2.1. Performance Considerations
                        </a>
                    </li><li>
                        <a href="#result_size">
                            7.5.2.2. Result Size
                        </a>
                    </li><li>
                        <a href="#resulttransformer">
                            7.5.2.3. ResultTransformer
                        </a>
                    </li><li>
                        <a href="#understanding_results">
                            7.5.2.4. Understanding Results
                        </a>
                    </li><li>
                        <a href="#filters">
                            7.5.2.5. Filters
                        </a>
                    </li><li>
                        <a href="#using_filters_in_a_sharded_environment">
                            7.5.2.6. Using Filters in a Sharded Environment
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#faceting">
                            7.5.3. Faceting
                        </a><ol>
                <li>
                        <a href="#creating_a_faceting_request">
                            7.5.3.1. Creating a Faceting Request
                        </a>
                    </li><li>
                        <a href="#applying_a_faceting_request">
                            7.5.3.2. Applying a Faceting Request
                        </a>
                    </li><li>
                        <a href="#restricting_query_results">
                            7.5.3.3. Restricting Query Results
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#optimizing_the_query_process">
                            7.5.4. Optimizing the Query Process
                        </a><ol>
                <li>
                        <a href="#caching_index_values_fieldcache">
                            7.5.4.1. Caching Index Values: FieldCache
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#manual_index_changes">
                            7.6. Manual Index Changes
                        </a><ol>
                <li>
                        <a href="#adding_instances_to_the_index">
                            7.6.1. Adding Instances to the Index
                        </a>
                    </li><li>
                        <a href="#deleting_instances_from_the_index">
                            7.6.2. Deleting Instances from the Index
                        </a>
                    </li><li>
                        <a href="#rebuilding_the_index">
                            7.6.3. Rebuilding the Index
                        </a><ol>
                <li>
                        <a href="#using_flushtoindexes">
                            7.6.3.1. Using flushToIndexes()
                        </a>
                    </li><li>
                        <a href="#using_a_massindexer">
                            7.6.3.2. Using a MassIndexer
                        </a>
                    </li>
            </ol>
                    </li>
            </ol>
                    </li><li>
                        <a href="#index_optimization">
                            7.7. Index Optimization
                        </a><ol>
                <li>
                        <a href="#automatic_optimization">
                            7.7.1. Automatic Optimization
                        </a>
                    </li><li>
                        <a href="#manual_optimization">
                            7.7.2. Manual Optimization
                        </a>
                    </li><li>
                        <a href="#adjusting_optimization">
                            7.7.3. Adjusting Optimization
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#advanced_features">
                            7.8. Advanced Features
                        </a><ol>
                <li>
                        <a href="#accessing_the_searchfactory">
                            7.8.1. Accessing the SearchFactory
                        </a>
                    </li><li>
                        <a href="#using_an_indexreader">
                            7.8.2. Using an IndexReader
                        </a>
                    </li><li>
                        <a href="#accessing_a_lucene_directory">
                            7.8.3. Accessing a Lucene Directory
                        </a>
                    </li><li>
                        <a href="#sharding_indexes">
                            7.8.4. Sharding Indexes
                        </a>
                    </li><li>
                        <a href="#customizing_lucenes_scoring_formula">
                            7.8.5. Customizing Lucene’s Scoring Formula
                        </a>
                    </li><li>
                        <a href="#exception_handling_configuration">
                            7.8.6. Exception Handling Configuration
                        </a>
                    </li><li>
                        <a href="#disable_hibernate_search">
                            7.8.7. Disable Hibernate Search
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#monitoring">
                            7.9. Monitoring
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#reference_material">
                            A. Reference Material
                        </a><ol>
                <li>
                        <a href="#hibernate_properties">
                            A.1. Hibernate Properties
                        </a>
                    </li>
            </ol>
                    </li><li>
                        <a href="#idm140159940805952">
                            Legal Notice
                        </a>
                    </li>
            </ol>
            
        
      </div>
    </nav>

    
    <div class="pvof-doc__wrapper" id="doc-wrapper">
        <section class="mimir-doc-title" id="mimir-doc--developing_hibernate_applications">
            <h1 class="title">Developing Hibernate Applications</h1>
        </section>
        <body><div xml:lang="en-US" class="book" id="idm140159952914160"><div class="titlepage"><div><div class="producttitle"><span class="productname">JBoss Enterprise Application Platform Continuous Delivery</span> <span class="productnumber">18</span></div><div><h2 class="subtitle">For Use with JBoss Enterprise Application Platform Continuous Delivery 18</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm140159940805952">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This document provides information for developers and administrators who want to develop and deploy JPA/Hibernate applications with JBoss Enterprise Application Platform Continuous Delivery.
			</div></div></div></div><hr/></div><section class="preface" id="idm140159953989120"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div><p id="preface_cd">
			This document is intended for use with the JBoss Enterprise Application Platform continuous delivery release 18, which is a Technology Preview release available in the cloud only.
		</p><p>
			Some features described in this document might not work or might not be available on Red Hat OpenShift Online and Red Hat OpenShift Container Platform. For specific details about the feature differences in the JBoss EAP CD release, see the <a class="link" href="/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/18/html-single/jboss_eap_continuous_delivery_18_release_notes/index/#cd_release_limitations">Release Limitations</a> section in the <span class="emphasis"><em>JBoss EAP Continuous Delivery 18 Release Notes</em></span>.
		</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
				This continuous delivery release for JBoss EAP is provided as Technology Preview only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs), might not be functionally complete, and Red Hat does not recommend to use them for production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
			</p><p>
				See <a class="link mimir-link-warn" href="https://access.redhat.com/support/offerings/techpreview" title="This content is not included in Mimir.">Technology Preview Features Support Scope</a> on the Red Hat Customer Portal for information about the support scope for Technology Preview features.
			</p></div></div></section><section class="chapter" id="introduction"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Introduction</h1></div></div></div><section class="section" id="about_hibernate_core"><div class="titlepage"><div><div><h2 class="title">1.1. About Hibernate Core</h2></div></div></div><p>
				Hibernate Core is an object-relational mapping framework for the Java language. It provides a framework for mapping an object-oriented domain model to a relational database, allowing applications to avoid direct interaction with the database. Hibernate solves object-relational impedance mismatch problems by replacing direct, persistent database accesses with high-level object handling functions.
			</p></section><section class="section" id="hibernate_entitymanager"><div class="titlepage"><div><div><h2 class="title">1.2. Hibernate EntityManager</h2></div></div></div><p>
				Hibernate EntityManager implements the programming interfaces and lifecycle rules as defined by the <a class="link mimir-link-warn" href="https://www.jcp.org/en/jsr/detail?id=338" title="Mimir does not include content from: www.jcp.org">Java Persistence 2.1 specification</a>. Together with Hibernate Annotations, this wrapper implements a complete (and standalone) JPA persistence solution on top of the mature Hibernate Core. You may use a combination of all three together, annotations without JPA programming interfaces and lifecycle, or even pure native Hibernate Core, depending on the business and technical needs of your project. You can at all times fall back to Hibernate native APIs, or if required, even to native JDBC and SQL. It provides JBoss EAP with a complete Java Persistence solution.
			</p><p>
				JBoss EAP is 100% compliant with the Java Persistence 2.1 specification. Hibernate also provides additional features to the specification. To get started with JPA and JBoss EAP, see the <code class="literal">bean-validation</code>, <code class="literal">greeter</code>, and <code class="literal">kitchensink</code> quickstarts that ship with JBoss EAP. For information about how to download and run the quickstarts, see <a class="link mimir-link-warn" href="https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/18/html-single/getting_started_guide/#using_the_quickstart_examples" title="This content is not included in Mimir.">Using the Quickstart Examples</a> in the JBoss EAP <span class="emphasis"><em>Getting Started Guide</em></span>.
			</p><p>
				Persistence in JPA is available in containers like EJB 3 or the more modern CDI, Java Context and Dependency Injection, as well as in standalone Java SE applications that execute outside of a particular container. The following programming interfaces and artifacts are available in both environments.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					If you plan to use a security manager with Hibernate, be aware that Hibernate supports it only when <code class="literal">EntityManagerFactory</code> is bootstrapped by the JBoss EAP server. It is not supported when the <code class="literal">EntityManagerFactory</code> or <code class="literal">SessionFactory</code> is bootstrapped by the application. See <a class="link mimir-link-warn" href="https://access.redhat.com/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/18/html-single/how_to_configure_server_security/#java_security_manager" title="This content is not included in Mimir.">Java Security Manager</a> in <span class="emphasis"><em>How to Configure Server Security</em></span> for more information about security managers.
				</p></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">EntityManagerFactory </span></dt><dd>
							An entity manager factory provides entity manager instances, all instances are configured to connect to the same database, to use the same default settings as defined by the particular implementation, etc. You can prepare several entity manager factories to access several data stores. This interface is similar to the SessionFactory in native Hibernate.
						</dd><dt><span class="term">EntityManager </span></dt><dd>
							The EntityManager API is used to access a database in a particular unit of work. It is used to create and remove persistent entity instances, to find entities by their primary key identity, and to query over all entities. This interface is similar to the Session in Hibernate.
						</dd><dt><span class="term">Persistence context </span></dt><dd>
							A persistence context is a set of entity instances in which for any persistent entity identity there is a unique entity instance. Within the persistence context, the entity instances and their lifecycle is managed by a particular entity manager. The scope of this context can either be the transaction, or an extended unit of work.
						</dd><dt><span class="term">Persistence unit </span></dt><dd>
							The set of entity types that can be managed by a given entity manager is defined by a persistence unit. A persistence unit defines the set of all classes that are related or grouped by the application, and which must be collocated in their mapping to a single data store.
						</dd><dt><span class="term">Container-managed entity manager </span></dt><dd>
							An entity manager whose lifecycle is managed by the container.
						</dd><dt><span class="term">Application-managed entity manager </span></dt><dd>
							An entity manager whose lifecycle is managed by the application.
						</dd><dt><span class="term">JTA entity manager </span></dt><dd>
							Entity manager involved in a JTA transaction.
						</dd><dt><span class="term">Resource-local entity manager </span></dt><dd>
							Entity manager using a resource transaction (not a JTA transaction).
						</dd></dl></div></section></section><section class="chapter" id="hibernate_configuration"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Hibernate Configuration</h1></div></div></div><section class="section" id="configuration"><div class="titlepage"><div><div><h2 class="title">2.1. Hibernate Configuration</h2></div></div></div><p>
				The configuration for entity managers both inside an application server and in a standalone application reside in a persistence archive. A persistence archive is a JAR file which must define a <code class="literal">persistence.xml</code> file that resides in the <code class="literal">META-INF/</code> folder.
			</p><p>
				You can connect to the database using the <code class="literal">persistence.xml</code> file. There are two ways of doing this:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						Specifying a data source which is configured in the <code class="literal">datasources</code> subsystem in JBoss EAP.
					</p><p class="simpara">
						The <code class="literal">jta-data-source</code> points to the JNDI name of the data source this persistence unit maps to. The <code class="literal">java:jboss/datasources/ExampleDS</code> here points to the <code class="literal">H2 DB</code> embedded in the JBoss EAP.
					</p><div class="formalpara"><p class="title"><strong>Example of <code class="literal">object-relational-mapping</code> in the <code class="literal">persistence.xml</code> File</strong></p><p>
							
<pre class="programlisting language-xml">&lt;persistence&gt;
   &lt;persistence-unit name="myapp"&gt;
      &lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;
      &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;
      &lt;properties&gt;
         ... ...
      &lt;/properties&gt;
   &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre>

						</p></div></li><li class="listitem"><p class="simpara">
						Explicitly configuring the <code class="literal">persistence.xml</code> file by specifying the connection properties.
					</p><div class="formalpara"><p class="title"><strong>Example of Specifying Connection Properties in the <code class="literal">persistence.xml</code> file</strong></p><p>
							
<pre class="programlisting language-xml">&lt;property name="javax.persistence.jdbc.driver" value="org.hsqldb.jdbcDriver"/&gt;
&lt;property name="javax.persistence.jdbc.user" value="sa"/&gt;
&lt;property name="javax.persistence.jdbc.password" value=""/&gt;
&lt;property name="javax.persistence.jdbc.url" value="jdbc:hsqldb:."/&gt;</pre>

						</p></div><p class="simpara">
						For the complete list of connection properties, see <a class="link" href="#configurable_connection_properties" title="Table A.1. Connection Properties Configurable in the persistence.xml File">Connection Properties Configurable in the <code class="literal">persistence.xml</code> File</a>.
					</p></li></ul></div><p>
				There are a number of properties that control the behavior of Hibernate at runtime. All are optional and have reasonable default values. These Hibernate properties are all used in the <code class="literal">persistence.xml</code> file. For the complete list of all configurable Hibernate properties, see <a class="link" href="#hibernate_properties" title="A.1. Hibernate Properties">Hibernate Properties</a>.
			</p></section><section class="section" id="second_level_caches"><div class="titlepage"><div><div><h2 class="title">2.2. Second-Level Caches</h2></div></div></div><section class="section" id="about_second_level_caches"><div class="titlepage"><div><div><h3 class="title">2.2.1. About Second-level Caches</h3></div></div></div><p>
					A second-level cache is a local data store that holds information persisted outside the application session. The cache is managed by the persistence provider, improving runtime by keeping the data separate from the application.
				</p><p>
					JBoss EAP supports caching for the following purposes:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Web Session Clustering
						</li><li class="listitem">
							Stateful Session Bean Clustering
						</li><li class="listitem">
							SSO Clustering
						</li><li class="listitem">
							Hibernate/JPA Second-level Cache
						</li></ul></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Each cache container defines a <code class="literal">repl</code> and a <code class="literal">dist</code> cache. These caches should not be used directly by user applications.
					</p></div></div></section><section class="section" id="configure_a_second_level_cache_for_hibernate"><div class="titlepage"><div><div><h3 class="title">2.2.2. Configure a Second-level Cache for Hibernate</h3></div></div></div><p>
					The configuration of Infinispan to act as the second-level cache for Hibernate can be done in two ways:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							It is recommended to configure the second-level cache <a class="link" href="/documentation/en-us/jboss_enterprise_application_platform_continuous_delivery/18/html-single/development_guide/index/#configure_second_level_cache_persistence_unit">through JPA applications, using the <code class="literal">persistence.xml</code> file</a>, as explained in the JBoss EAP <span class="emphasis"><em>Development Guide</em></span>.
						</li><li class="listitem">
							Alternatively, you can configure the second-level cache through Hibernate native applications, using the <code class="literal">hibernate.cfg.xml</code> file, as explained below.
						</li></ul></div><h5 id="configuring_a_second_level_cache_for_hibernate_using_hibernate_native_applications">Configuring a Second-level Cache for Hibernate Using Hibernate Native Applications</h5><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Create the <code class="literal">hibernate.cfg.xml</code> file in the deployment’s class path.
						</li><li class="listitem"><p class="simpara">
							Add the following XML to the <code class="literal">hibernate.cfg.xml</code> file. The XML needs to be within the <code class="literal">&lt;session-factory&gt;</code> tag:
						</p><pre class="programlisting language-xml">&lt;property name="hibernate.cache.use_second_level_cache"&gt;true&lt;/property&gt;
&lt;property name="hibernate.cache.use_query_cache"&gt;true&lt;/property&gt;
&lt;property name="hibernate.cache.region.factory_class"&gt;org.jboss.as.jpa.hibernate5.infinispan.InfinispanRegionFactory&lt;/property&gt;</pre></li><li class="listitem"><p class="simpara">
							In order to use the Hibernate native APIs within your application, you must add the following dependencies to the <code class="literal">MANIFEST.MF</code> file:
						</p><pre class="screen">Dependencies: org.infinispan,org.hibernate</pre></li></ol></div></section></section></section><section class="chapter" id="hibernate_annotations-1"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Hibernate Annotations</h1></div></div></div><section class="section" id="hibernate_annotations"><div class="titlepage"><div><div><h2 class="title">3.1. Hibernate Annotations</h2></div></div></div><p>
				The <code class="literal">org.hibernate.annotations</code> package contains some annotations which are offered by Hibernate, on top of the standard JPA annotations.
			</p><div class="table" id="idm140159955626176"><p class="title"><strong>Table 3.1. General Annotations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159950675808" scope="col">Annotation</th><th align="left" valign="top" id="idm140159950674720" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159950675808"> <p>
								<code class="literal">Check</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950674720"> <p>
								Arbitrary SQL check constraints which can be defined at the class, property or collection level.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950675808"> <p>
								<code class="literal">Immutable</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950674720"> <p>
								Mark an Entity or a Collection as immutable. No annotation means the element is mutable.
							</p>
							 <p>
								An immutable entity may not be updated by the application. Updates to an immutable entity will be ignored, but no exception is thrown.
							</p>
							 <p>
								<code class="literal">@Immutable</code> placed on a collection makes the collection immutable, meaning additions and deletions to and from the collection are not allowed. A <code class="literal">HibernateException</code> is thrown in this case.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159955403488"><p class="title"><strong>Table 3.2. Caching Entities</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159952555472" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952554384" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159952555472"> <p>
								<code class="literal">Cache</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952554384"> <p>
								Add caching strategy to a root entity or a collection.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159950293376"><p class="title"><strong>Table 3.3. Collection Related Annotations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159951365456" scope="col">Annotation</th><th align="left" valign="top" id="idm140159951364368" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">MapKeyType</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Defines the type of key of a persistent map.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">ManyToAny</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Defines a <code class="literal">ToMany</code> association pointing to different entity types. Matching the entity type is done through a metadata discriminator column. This kind of mapping should be only marginal.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">OrderBy</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Order a collection using SQL ordering (not HQL ordering).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">OnDelete</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Strategy to use on collections, arrays and on joined subclasses delete. <code class="literal">OnDelete</code> of secondary tables is currently not supported.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">Persister</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Specify a custom persister.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">Sort</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Collection sort (Java level sorting).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">Where</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Where clause to add to the element Entity or target entity of a collection. The clause is written in SQL.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951365456"> <p>
								<code class="literal">WhereJoinTable</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951364368"> <p>
								Where clause to add to the collection join table. The clause is written in SQL.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159951351104"><p class="title"><strong>Table 3.4. Custom SQL for CRUD Operations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159951583904" scope="col">Annotation</th><th align="left" valign="top" id="idm140159951582816" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">Loader</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Overwrites Hibernate default <code class="literal">FIND</code> method.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">SQLDelete</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Overwrites the Hibernate default <code class="literal">DELETE</code> method.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">SQLDeleteAll</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Overwrites the Hibernate default <code class="literal">DELETE ALL</code> method.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">SQLInsert</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Overwrites the Hibernate default <code class="literal">INSERT INTO</code> method.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">SQLUpdate</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Overwrites the Hibernate default <code class="literal">UPDATE</code> method.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">Subselect</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Maps an immutable and read-only entity to a given SQL subselect expression.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951583904"> <p>
								<code class="literal">Synchronize</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159951582816"> <p>
								Ensures that auto-flush happens correctly and that queries against the derived entity do not return stale data. Mostly used with <code class="literal">Subselect</code>.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159954033504"><p class="title"><strong>Table 3.5. Entity</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159952352752" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952351664" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Cascade</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Apply a cascade strategy on an association.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Entity</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Adds additional metadata that may be needed beyond what is defined in the standard <code class="literal">@Entity</code>.
							</p>
							 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<code class="literal">mutable</code>: whether this entity is mutable or not
									</li><li class="listitem">
										<code class="literal">dynamicInsert</code>: allow dynamic SQL for inserts
									</li><li class="listitem">
										<code class="literal">dynamicUpdate</code>: allow dynamic SQL for updates
									</li><li class="listitem">
										<code class="literal">selectBeforeUpdate</code>: Specifies that Hibernate should never perform an SQL UPDATE unless it is certain that an object is actually modified.
									</li><li class="listitem">
										<code class="literal">polymorphism</code>: whether the entity polymorphism is of PolymorphismType.IMPLICIT (default) or PolymorphismType.EXPLICIT
									</li><li class="listitem"><p class="simpara">
										<code class="literal">optimisticLock</code>: optimistic locking strategy (OptimisticLockType.VERSION, OptimisticLockType.NONE, OptimisticLockType.DIRTY or OptimisticLockType.ALL)
									</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
											The annotation "Entity" is deprecated and scheduled for removal in future releases. Its individual attributes or values should become annotations.
										</p></div></div></li></ul></div>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Polymorphism</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Used to define the type of polymorphism Hibernate will apply to entity hierarchies.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Proxy</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Lazy and proxy configuration of a particular class.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Table</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Complementary information to a table either primary or secondary.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Tables</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Plural annotation of Table.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Target</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Defines an explicit target, avoiding reflection and generics resolving.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Tuplizer</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Defines a tuplizer for an entity or a component.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952352752"> <p>
								<code class="literal">Tuplizers</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952351664"> <p>
								Defines a set of tuplizers for an entity or a component.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159954360848"><p class="title"><strong>Table 3.6. Fetching</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159953648272" scope="col">Annotation</th><th align="left" valign="top" id="idm140159953647296" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159953648272"> <p>
								<code class="literal">BatchSize</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953647296"> <p>
								Batch size for SQL loading.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953648272"> <p>
								<code class="literal">FetchProfile</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953647296"> <p>
								Defines the fetching strategy profile.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953648272"> <p>
								<code class="literal">FetchProfiles</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953647296"> <p>
								Plural annotation for <code class="literal">@FetchProfile</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953648272"> <p>
								<code class="literal">LazyGroup</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953647296"> <p>
								Specifies that an entity attribute should be fetched along with all the other attributes belonging to the same group. In order to load entity attributes lazily, bytecode enhancement is needed. By default, all non-collection attributes are loaded in one group named <code class="literal">DEFAULT</code>. This annotation allows defining different groups of attributes to be initialized together when accessing one attribute in the group.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159970882800"><p class="title"><strong>Table 3.7. Filters</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159970877232" scope="col">Annotation</th><th align="left" valign="top" id="idm140159970876144" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">Filter</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Adds filters to an entity or a target entity of a collection.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">FilterDef</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Filter definition.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">FilterDefs</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Array of filter definitions.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">FilterJoinTable</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Adds filters to a join table collection.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">FilterJoinTables</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Adds multiple <code class="literal">@FilterJoinTable</code> to a collection.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">Filters</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								Adds multiple <code class="literal">@Filter</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159970877232"> <p>
								<code class="literal">ParamDef</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159970876144"> <p>
								A parameter definition.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159953504720"><p class="title"><strong>Table 3.8. Primary Keys</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159953793712" scope="col">Annotation</th><th align="left" valign="top" id="idm140159953792624" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">Generated</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								This annotated property is generated by the database.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">GenericGenerator</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								Generator annotation describing any kind of Hibernate generator in a detyped manner.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">GenericGenerators</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								Array of generic generator definitions.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">NaturalId</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								Specifies that a property is part of the natural id of the entity.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">Parameter</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								Key/value pattern.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953793712"> <p>
								<code class="literal">RowId</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953792624"> <p>
								Support for <code class="literal">ROWID</code> mapping feature of Hibernate.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159950422592"><p class="title"><strong>Table 3.9. Inheritance</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159953636448" scope="col">Annotation</th><th align="left" valign="top" id="idm140159953635360" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159953636448"> <p>
								<code class="literal">DiscriminatorFormula</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953635360"> <p>
								Discriminator formula to be placed at the root entity.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953636448"> <p>
								<code class="literal">DiscriminatorOptions</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953635360"> <p>
								Optional annotation to express Hibernate specific discriminator properties.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953636448"> <p>
								<code class="literal">MetaValue</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953635360"> <p>
								Maps a given discriminator value to the corresponding entity type.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159955344112"><p class="title"><strong>Table 3.10. Mapping JP-QL/HQL Queries</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159952201888" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952200800" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159952201888"> <p>
								<code class="literal">NamedNativeQueries</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952200800"> <p>
								Extends <code class="literal">NamedNativeQueries</code> to hold Hibernate NamedNativeQuery objects.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952201888"> <p>
								<code class="literal">NamedNativeQuery</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952200800"> <p>
								Extends <code class="literal">NamedNativeQuery</code> with Hibernate features.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952201888"> <p>
								<code class="literal">NamedQueries</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952200800"> <p>
								Extends <code class="literal">NamedQueries</code> to hold Hibernate <code class="literal">NamedQuery</code> objects.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952201888"> <p>
								<code class="literal">NamedQuery</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952200800"> <p>
								Extends <code class="literal">NamedQuery</code> with Hibernate features.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159951484128"><p class="title"><strong>Table 3.11. Mapping Simple Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159951478592" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952539040" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159951478592"> <p>
								<code class="literal">AccessType</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952539040"> <p>
								Property access type.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951478592"> <p>
								<code class="literal">Columns</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952539040"> <p>
								Support an array of columns. Useful for component user type mappings.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951478592"> <p>
								<code class="literal">ColumnTransformer</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952539040"> <p>
								Custom SQL expression used to read the value from and write a value to a column. Use for direct object loading/saving as well as queries. The write expression must contain exactly one '?' placeholder for the value.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159951478592"> <p>
								<code class="literal">ColumnTransformers</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952539040"> <p>
								Plural annotation for <code class="literal">@ColumnTransformer</code>. Useful when more than one column is using this behavior.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159951604976"><p class="title"><strong>Table 3.12. Property</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159952012112" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952011024" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">Formula</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								To be used as a replacement for <code class="literal">@Column</code> in most places. The formula has to be a valid SQL fragment.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">Index</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								Defines a database index.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">JoinFormula</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								To be used as a replacement for <code class="literal">@JoinColumn</code> in most places. The formula has to be a valid SQL fragment.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">Parent</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								Reference the property as a pointer back to the owner (generally the owning entity).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">Type</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								Hibernate type.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">TypeDef</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								Hibernate type definition.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952012112"> <p>
								<code class="literal">TypeDefs</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952011024"> <p>
								Hibernate type definition array.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159950751312"><p class="title"><strong>Table 3.13. Single Association Related Annotations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159950745776" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952178272" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">Any</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines a <span class="strong strong"><strong>ToOne</strong></span> association pointing to several entity types. Matching the according entity type is done through a metadata discriminator column. This kind of mapping should be only marginal.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">AnyMetaDef</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines <code class="literal">@Any</code> and <code class="literal">@ManyToAny</code> metadata.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">AnyMetaDefs</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines <code class="literal">@Any</code> and <code class="literal">@ManyToAny</code> set of metadata. Can be defined at the entity level or the package level.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">Fetch</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines the fetching strategy used for the given association.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">LazyCollection</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines the lazy status of a collection.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">LazyToOne</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Defines the lazy status of a ToOne association (i.e. <code class="literal">OneToOne</code> or <code class="literal">ManyToOne</code>).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950745776"> <p>
								<code class="literal">NotFound</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952178272"> <p>
								Action to do when an element is not found on an association.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="idm140159950363312"><p class="title"><strong>Table 3.14. Optimistic Locking</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159952388896" scope="col">Annotation</th><th align="left" valign="top" id="idm140159952387808" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159952388896"> <p>
								<code class="literal">OptimisticLock</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952387808"> <p>
								Whether or not a change of the annotated property will trigger an entity version increment. If the annotation is not present, the property is involved in the optimistic lock strategy (default).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952388896"> <p>
								<code class="literal">OptimisticLocking</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952387808"> <p>
								Used to define the style of optimistic locking to be applied to an entity. In a hierarchy, only valid on the root entity.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159952388896"> <p>
								<code class="literal">Source</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159952387808"> <p>
								Optional annotation in conjunction with Version and timestamp version properties. The annotation value decides where the timestamp is generated.
							</p>
							 </td></tr></tbody></table></div></div></section></section><section class="chapter" id="hibernate_query_language"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Hibernate Query Language</h1></div></div></div><section class="section" id="about_hibernate_query_language"><div class="titlepage"><div><div><h2 class="title">4.1. About Hibernate Query Language</h2></div></div></div><h4 id="introduction_to_jpql">Introduction to JPQL</h4><p>
				The Java Persistence Query Language (JPQL) is a platform-independent object-oriented query language defined as part of the Java Persistence API (JPA) specification. JPQL is used to make queries against entities stored in a relational database. It is heavily inspired by SQL, and its queries resemble SQL queries in syntax, but operate against JPA entity objects rather than directly with database tables.
			</p><h4 id="introduction_to_hql">Introduction to HQL</h4><p>
				The Hibernate Query Language (HQL) is a powerful query language, similar in appearance to SQL. Compared with SQL, however, HQL is fully object-oriented and understands notions like inheritance, polymorphism and association.
			</p><p>
				HQL is a superset of JPQL. An HQL query is not always a valid JPQL query, but a JPQL query is always a valid HQL query.
			</p><p>
				Both HQL and JPQL are non-type-safe ways to perform query operations. Criteria queries offer a type-safe approach to querying.
			</p></section><section class="section" id="HQL_statements"><div class="titlepage"><div><div><h2 class="title">4.2. About HQL Statements</h2></div></div></div><p>
				Both HQL and JPQL allow <code class="literal">SELECT</code>, <code class="literal">UPDATE</code>, and <code class="literal">DELETE</code> statements. HQL additionally allows <code class="literal">INSERT</code> statements, in a form similar to a <code class="literal">SQL INSERT-SELECT</code>.
			</p><p>
				The following table shows the syntax in Backus-Naur Form (BNF) notation for the various HQL statements.
			</p><div class="table" id="idm140159952230800"><p class="title"><strong>Table 4.1. HQL Statements</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159953710256" scope="col">Statement</th><th align="left" valign="top" id="idm140159953709168" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159953710256"> <p>
								<code class="literal">SELECT</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953709168"> <p>
								The BNF for <code class="literal">SELECT</code> statements in HQL is:
							</p>
							 
<pre class="screen">select_statement :: =
        [select_clause]
        from_clause
        [where_clause]
        [groupby_clause]
        [having_clause]
        [orderby_clause]</pre>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953710256"> <p>
								<code class="literal">UPDATE</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953709168"> <p>
								The BNF for <code class="literal">UPDATE</code> statement in HQL is the same as it is in JPQL.
							</p>
							 
<pre class="screen">update_statement ::= update_clause [where_clause]

update_clause ::= UPDATE entity_name [[AS] identification_variable]
        SET update_item {, update_item}*

update_item ::= [identification_variable.]{state_field | single_valued_object_field}
        = new_value

new_value ::= scalar_expression |
                simple_entity_expression |
                NULL</pre>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953710256"> <p>
								<code class="literal">DELETE</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953709168"> <p>
								The BNF for <code class="literal">DELETE</code> statements in HQL is the same as it is in JPQL.
							</p>
							 
<pre class="screen">delete_statement ::= delete_clause [where_clause]

delete_clause ::= DELETE FROM entity_name [[AS] identification_variable]</pre>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159953710256"> <p>
								<code class="literal">INSERT</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159953709168"> <p>
								The BNF for <code class="literal">INSERT</code> statement in HQL is:
							</p>
							 
<pre class="screen">insert_statement ::= insert_clause select_statement

insert_clause ::= INSERT INTO entity_name (attribute_list)

attribute_list ::= state_field[, state_field ]*</pre>
							 <p>
								There is no JPQL equivalent to this.
							</p>
							 </td></tr></tbody></table></div></div><div class="admonition warning" id="about_bulk_updtae_insert_delete"><div class="admonition_header">Warning</div><div><p>
					Hibernate allows the use of Data Manipulation Language (DML) to bulk insert, update and delete data directly in the mapped database through the Hibernate Query Language (HQL).
				</p><p>
					Using DML may violate the object/relational mapping and may affect object state. Object state stays in memory and by using DML, the state of an in-memory object is not affected, depending on the operation that is performed on the underlying database. In-memory data must be used with care if DML is used.
				</p></div></div><h4 id="about_the_update_delete_statement">About the UPDATE and DELETE Statements</h4><p>
				The pseudo-syntax for <code class="literal">UPDATE</code> and <code class="literal">DELETE</code> statements is:
			</p><p>
				<code class="literal">( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</code>.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The <code class="literal">FROM</code> keyword and the <code class="literal">WHERE</code> Clause are optional. The <code class="literal">FROM</code> clause is responsible for defining the scope of object model types available to the rest of the query. It also is responsible for defining all the identification variables available to the rest of the query. The <code class="literal">WHERE</code> clause allows you to refine the list of instances returned.
				</p><p>
					The result of execution of a <code class="literal">UPDATE</code> or <code class="literal">DELETE</code> statement is the number of rows that are actually affected (updated or deleted).
				</p></div></div><div class="formalpara"><p class="title"><strong>Example: Bulk Update Statement</strong></p><p>
					
<pre class="programlisting language-java">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlUpdate = "update Company set name = :newName where name = :oldName";
int updatedEntities = s.createQuery( hqlUpdate )
        .setString( "newName", newName )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre>

				</p></div><div class="formalpara"><p class="title"><strong>Example: Bulk Delete Statement</strong></p><p>
					
<pre class="programlisting language-java">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlDelete = "delete Company where name = :oldName";
int deletedEntities = s.createQuery( hqlDelete )
        .setString( "oldName", oldName )
        .executeUpdate();
tx.commit();
session.close();</pre>

				</p></div><p>
				The <code class="literal">int</code> value returned by the <code class="literal">Query.executeUpdate()</code> method indicates the number of entities within the database that were affected by the operation.
			</p><p>
				Internally, the database might use multiple SQL statements to execute the operation in response to a DML <code class="literal">Update</code> or <code class="literal">Delete</code> request. This might be because of relationships that exist between tables and the join tables that need to be updated or deleted.
			</p><p>
				For example, issuing a delete statement, as in the example above, may actually result in deletes being executed against not just the <code class="literal">Company</code> table for companies that are named with <code class="literal">oldName</code>, but also against joined tables. Therefore a <code class="literal">Company</code> table in a bidirectional, many-to-many relationship with an <code class="literal">Employee</code> table would also lose rows from the corresponding join table, <code class="literal">Company_Employee</code>, as a result of the successful execution of the previous example.
			</p><p>
				The <code class="literal">deletedEntries</code> value above will contain a count of all the rows affected due to this operation, including the rows in the join tables.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Care should be taken when executing bulk update or delete operations because they may result in inconsistencies between the database and the entities in the active persistence context. In general, bulk update and delete operations should only be performed within a transaction in a new persistence context or before fetching or accessing entities whose state might be affected by such operations.
				</p></div></div><h4 id="about_the_insert_statement">About the INSERT Statement</h4><p>
				HQL adds the ability to define <code class="literal">INSERT</code> statements. There is no JPQL equivalent to this. The Backus-Naur Form (BNF) for an HQL <code class="literal">INSERT</code> statement is:
			</p><pre class="screen">insert_statement ::= insert_clause select_statement

insert_clause ::= INSERT INTO entity_name (attribute_list)

attribute_list ::= state_field[, state_field ]*</pre><p>
				The <code class="literal">attribute_list</code> is analogous to the column specification in the SQL <code class="literal">INSERT</code> statement. For entities involved in mapped inheritance, only attributes directly defined on the named entity can be used in the <code class="literal">attribute_list</code>. Superclass properties are not allowed and subclass properties do not make sense. In other words, <code class="literal">INSERT</code> statements are inherently non-polymorphic.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					The <code class="literal">select_statement</code> can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. This can cause problems with Hibernate Types that are <span class="emphasis"><em>equivalent</em></span> as opposed to <span class="emphasis"><em>equal</em></span>. For example, this might cause mismatch issues between an attribute mapped as an <code class="literal">org.hibernate.type.DateType</code> and an attribute defined as a <code class="literal">org.hibernate.type.TimestampType</code>, even though the database might not make a distinction or might be able to handle the conversion.
				</p></div></div><p>
				For the <code class="literal">id</code> attribute, the insert statement gives you two options. You can either explicitly specify the <code class="literal">id</code> property in the <code class="literal">attribute_list</code>, in which case its value is taken from the corresponding select expression, or omit it from the <code class="literal">attribute_list</code> in which case a generated value is used. This latter option is only available when using <code class="literal">id</code> generators that operate "in the database"; attempting to use this option with any "in memory" type generators will cause an exception during parsing.
			</p><p>
				For optimistic locking attributes, the insert statement again gives you two options. You can either specify the attribute in the <code class="literal">attribute_list</code> in which case its value is taken from the corresponding select expressions, or omit it from the <code class="literal">attribute_list</code> in which case the <code class="literal">seed value</code> defined by the corresponding <code class="literal">org.hibernate.type.VersionType</code> is used.
			</p><div class="formalpara"><p class="title"><strong>Example: INSERT Query Statements</strong></p><p>
					
<pre class="programlisting language-java">String hqlInsert = "insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery(hqlInsert).executeUpdate();</pre>

				</p></div><div id="bulk_insert" class="formalpara"><p class="title"><strong>Example: Bulk Insert Statement</strong></p><p>
					
<pre class="programlisting language-java">Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();

String hqlInsert = "insert into Account (id, name) select c.id, c.name from Customer c where ...";
int createdEntities = s.createQuery( hqlInsert )
        .executeUpdate();
tx.commit();
session.close();</pre>

				</p></div><p>
				If you do not supply the value for the <code class="literal">id</code> attribute using the <code class="literal">SELECT</code> statement, an identifier is generated for you, as long as the underlying database supports auto-generated keys. The return value of this bulk insert operation is the number of entries actually created in the database.
			</p></section><section class="section" id="about_hql_ordering"><div class="titlepage"><div><div><h2 class="title">4.3. About HQL Ordering</h2></div></div></div><p>
				The results of the query can also be ordered. The <code class="literal">ORDER BY</code> clause is used to specify the selected values to be used to order the result. The types of expressions considered valid as part of the order-by clause include:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						state fields
					</li><li class="listitem">
						component/embeddable attributes
					</li><li class="listitem">
						scalar expressions such as arithmetic operations, functions, etc.
					</li><li class="listitem">
						identification variable declared in the select clause for any of the previous expression types
					</li></ul></div><p>
				HQL does not mandate that all values referenced in the order-by clause must be named in the select clause, but it is required by JPQL. Applications desiring database portability should be aware that not all databases support referencing values in the order-by clause that are not referenced in the select clause.
			</p><p>
				Individual expressions in the order-by can be qualified with either <code class="literal">ASC</code> (ascending) or <code class="literal">DESC</code> (descending) to indicate the desired ordering direction.
			</p><div class="formalpara"><p class="title"><strong>Example: Order By</strong></p><p>
					
<pre class="screen">// legal because p.name is implicitly part of p
select p
from Person p
order by p.name

select c.id, sum( o.total ) as t
from Order o
    inner join o.customer c
group by c.id
order by t</pre>

				</p></div></section><section class="section" id="about_collection_memeber_references"><div class="titlepage"><div><div><h2 class="title">4.4. About Collection Member References</h2></div></div></div><p>
				References to collection-valued associations actually refer to the <span class="emphasis"><em>values</em></span> of that collection.
			</p><div class="formalpara"><p class="title"><strong>Example: Collection References</strong></p><p>
					
<pre class="screen">select c
from Customer c
    join c.orders o
    join o.lineItems l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder'

// alternate syntax
select c
from Customer c,
    in(c.orders) o,
    in(o.lineItems) l
    join l.product p
where o.status = 'pending'
  and p.status = 'backorder'</pre>

				</p></div><p>
				In the example, the identification variable <code class="literal">o</code> actually refers to the object model type Order which is the type of the elements of the Customer#orders association.
			</p><p>
				The example also shows the alternate syntax for specifying collection association joins using the <code class="literal">IN</code> syntax. Both forms are equivalent. Which form an application chooses to use is simply a matter of taste.
			</p></section><section class="section" id="about_qualified_path_expressions"><div class="titlepage"><div><div><h2 class="title">4.5. About Qualified Path Expressions</h2></div></div></div><p>
				It was previously stated that collection-valued associations actually refer to the <span class="emphasis"><em>values</em></span> of that collection. Based on the type of collection, there are also available a set of explicit qualification expressions.
			</p><div class="table" id="idm140159953583584"><p class="title"><strong>Table 4.2. Qualified Path Expressions</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159950536272" scope="col">Expression</th><th align="left" valign="top" id="idm140159950535184" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159950536272"> <p>
								<code class="literal">VALUE</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950535184"> <p>
								Refers to the collection value. Same as not specifying a qualifier. Useful to explicitly show intent. Valid for any type of collection-valued reference.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950536272"> <p>
								<code class="literal">INDEX</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950535184"> <p>
								According to HQL rules, this is valid for both Maps and Lists which specify a javax.persistence.OrderColumn annotation to refer to the Map key or the List position (aka the OrderColumn value). JPQL however, reserves this for use in the List case and adds <code class="literal">KEY</code> for the MAP case. Applications interested in JPA provider portability should be aware of this distinction.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950536272"> <p>
								<code class="literal">KEY</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950535184"> <p>
								Valid only for Maps. Refers to the map’s key. If the key is itself an entity, can be further navigated.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159950536272"> <p>
								<code class="literal">ENTRY</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159950535184"> <p>
								Only valid only for Maps. Refers to the Map’s logical java.util.Map.Entry tuple (the combination of its key and value). <code class="literal">ENTRY</code> is only valid as a terminal path and only valid in the select clause.
							</p>
							 </td></tr></tbody></table></div></div><div class="formalpara"><p class="title"><strong>Example: Qualified Collection References</strong></p><p>
					
<pre class="screen">// Product.images is a Map&lt;String,String&gt; : key = a name, value = file path

// select all the image file paths (the map value) for Product#123
select i
from Product p
    join p.images i
where p.id = 123

// same as above
select value(i)
from Product p
    join p.images i
where p.id = 123

// select all the image names (the map key) for Product#123
select key(i)
from Product p
    join p.images i
where p.id = 123

// select all the image names and file paths (the 'Map.Entry') for Product#123
select entry(i)
from Product p
    join p.images i
where p.id = 123

// total the value of the initial line items for all orders for a customer
select sum( li.amount )
from Customer c
        join c.orders o
        join o.lineItems li
where c.id = 123
  and index(li) = 1</pre>

				</p></div></section><section class="section" id="about_hql_functions"><div class="titlepage"><div><div><h2 class="title">4.6. About HQL Functions</h2></div></div></div><p>
				HQL defines some standard functions that are available regardless of the underlying database in use. HQL can also understand additional functions defined by the dialect and the application.
			</p><section class="section" id="hql_standardized_functions"><div class="titlepage"><div><div><h3 class="title">4.6.1. About HQL Standardized Functions</h3></div></div></div><p>
					The following functions are available in HQL regardless of the underlying database in use.
				</p><div class="table" id="idm140159943960784"><p class="title"><strong>Table 4.3. HQL Standardized Functions</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159943955248" scope="col">Function</th><th align="left" valign="top" id="idm140159943954160" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">BIT_LENGTH</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Returns the length of binary data.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">CAST</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Performs an SQL cast. The cast target should name the Hibernate mapping type to use.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">EXTRACT</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Performs an SQL extraction on datetime values. An extraction returns a part of the date/time value, for example, the year. See the abbreviated forms below.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">SECOND</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the second.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">MINUTE</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the minute.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">HOUR</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the hour.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">DAY</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the day.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">MONTH</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the month.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">YEAR</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated extract form for extracting the year.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159943955248"> <p>
									<code class="literal">STR</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159943954160"> <p>
									Abbreviated form for casting a value as character data.
								</p>
								 </td></tr></tbody></table></div></div></section><section class="section" id="about_hql_non_standardized_functions"><div class="titlepage"><div><div><h3 class="title">4.6.2. About HQL Non-Standardized Functions</h3></div></div></div><p>
					Hibernate dialects can register additional functions known to be available for that particular database product. They would only be available when using that database or dialect. Applications that aim for database portability should avoid using functions in this category.
				</p><p>
					Application developers can also supply their own set of functions. This would usually represent either custom SQL functions or aliases for snippets of SQL. Such function declarations are made by using the <code class="literal">addSqlFunction</code> method of <code class="literal">org.hibernate.cfg.Configuration</code>.
				</p></section><section class="section" id="about_the_concatenation_operation"><div class="titlepage"><div><div><h3 class="title">4.6.3. About the Concatenation Operation</h3></div></div></div><p>
					HQL defines a concatenation operator in addition to supporting the concatenation (<code class="literal">CONCAT</code>) function. This is not defined by JPQL, so portable applications should avoid using it. The concatenation operator is taken from the SQL concatenation operator (<code class="literal">||</code>).
				</p><div class="formalpara"><p class="title"><strong>Example: Concatenation Operation Example</strong></p><p>
						
<pre class="screen">select 'Mr. ' || c.name.first || ' ' || c.name.last
from Customer c
where c.gender = Gender.MALE</pre>

					</p></div></section></section><section class="section" id="about_dynamic_instantiation"><div class="titlepage"><div><div><h2 class="title">4.7. About Dynamic Instantiation</h2></div></div></div><p>
				There is a particular expression type that is only valid in the select clause. Hibernate calls this "dynamic instantiation". JPQL supports some of this feature and calls it a "constructor expression".
			</p><div class="formalpara"><p class="title"><strong>Example: Dynamic Instantiation Example - Constructor</strong></p><p>
					
<pre class="screen">select new Family( mother, mate, offspr )
from DomesticCat as mother
    join mother.mate as mate
    left join mother.kittens as offspr</pre>

				</p></div><p>
				So rather than dealing with the Object[] here we are wrapping the values in a type-safe java object that will be returned as the results of the query. The class reference must be fully qualified and it must have a matching constructor.
			</p><p>
				The class here does not need to be mapped. If it does represent an entity, the resulting instances are returned in the NEW state (not managed!).
			</p><p>
				This is the part JPQL supports as well. HQL supports additional "dynamic instantiation" features. First, the query can specify to return a List rather than an Object[] for scalar results:
			</p><div class="formalpara"><p class="title"><strong>Example: Dynamic Instantiation Example - List</strong></p><p>
					
<pre class="screen">select new list(mother, offspr, mate.name)
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr</pre>

				</p></div><p>
				The results from this query will be a List&lt;List&gt; as opposed to a List&lt;Object[]&gt;.
			</p><p>
				HQL also supports wrapping the scalar results in a Map.
			</p><div class="formalpara"><p class="title"><strong>Example: Dynamic Instantiation Example - Map</strong></p><p>
					
<pre class="screen">select new map( mother as mother, offspr as offspr, mate as mate )
from DomesticCat as mother
    inner join mother.mate as mate
    left outer join mother.kittens as offspr

select new map( max(c.bodyWeight) as max, min(c.bodyWeight) as min, count(*) as n )
from Cat cxt</pre>

				</p></div><p>
				The results from this query will be a List&lt;Map&lt;String,Object&gt;&gt; as opposed to a List&lt;Object[]&gt;. The keys of the map are defined by the aliases given to the select expressions.
			</p></section><section class="section" id="about_hql_predicates"><div class="titlepage"><div><div><h2 class="title">4.8. About HQL Predicates</h2></div></div></div><p>
				Predicates form the basis of the <code class="literal">where</code> clause, the <code class="literal">having</code> clause and searched case expressions. They are expressions which resolve to a truth value, generally <code class="literal">TRUE</code> or <code class="literal">FALSE</code>, although boolean comparisons involving NULL values generally resolve to <code class="literal">UNKNOWN</code>.
			</p><h4 id="hql_predicates">HQL Predicates</h4><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						Null Predicate
					</p><p class="simpara">
						Check a value for null. Can be applied to basic attribute references, entity references and parameters. HQL additionally allows it to be applied to component/embeddable types.
					</p><div class="formalpara"><p class="title"><strong>Example: NULL Check</strong></p><p>
							
<pre class="screen">// select everyone with an associated address
select p
from Person p
where p.address is not null

// select everyone without an associated address
select p
from Person p
  where p.address is null</pre>

						</p></div></li><li class="listitem"><p class="simpara">
						Like Predicate
					</p><p class="simpara">
						Performs a like comparison on string values. The syntax is:
					</p><pre class="screen">like_expression ::=
       string_expression
       [NOT] LIKE pattern_value
       [ESCAPE escape_character]</pre><p class="simpara">
						The semantics follow that of the SQL like expression. The <code class="literal">pattern_value</code> is the pattern to attempt to match in the <code class="literal">string_expression</code>. Just like SQL, <code class="literal">pattern_value</code> can use <code class="literal">_</code> (underscore) and <code class="literal">%</code> (percent) as wildcards. The meanings are the same. The <code class="literal">_</code> matches any single character. The <code class="literal">%</code> matches any number of characters.
					</p><p class="simpara">
						The optional <code class="literal">escape_character</code> is used to specify an escape character used to escape the special meaning of <code class="literal">_</code> and <code class="literal">%</code> in the <code class="literal">pattern_value</code>. This is useful when needing to search on patterns including either <code class="literal">_</code> or <code class="literal">%</code>.
					</p><div class="formalpara"><p class="title"><strong>Example: LIKE Predicate</strong></p><p>
							
<pre class="screen">select p
from Person p
where p.name like '%Schmidt'

select p
from Person p
where p.name not like 'Jingleheimmer%'

// find any with name starting with "sp_"
select sp
from StoredProcedureMetadata sp
where sp.name like 'sp|_%' escape '|'</pre>

						</p></div></li><li class="listitem"><p class="simpara">
						Between Predicate
					</p><p class="simpara">
						Analogous to the SQL <code class="literal">BETWEEN</code> expression. Perform an evaluation that a value is within the range of 2 other values. All the operands should have comparable types.
					</p><div class="formalpara"><p class="title"><strong>Example: BETWEEN Predicate</strong></p><p>
							
<pre class="screen">select p
from Customer c
    join c.paymentHistory p
where c.id = 123
  and index(p) between 0 and 9

select c
from Customer c
where c.president.dateOfBirth
        between {d '1945-01-01'}
            and {d '1965-01-01'}

select o
from Order o
where o.total between 500 and 5000

select p
from Person p
where p.name between 'A' and 'E'</pre>

						</p></div></li><li class="listitem"><p class="simpara">
						IN Predicate
					</p><p class="simpara">
						The <code class="literal">IN</code> predicate performs a check that a particular value is in a list of values. Its syntax is:
					</p><pre class="screen">in_expression ::= single_valued_expression
            [NOT] IN single_valued_list

single_valued_list ::= constructor_expression |
            (subquery) |
            collection_valued_input_parameter

constructor_expression ::= (expression[, expression]*)</pre><p class="simpara">
						The types of the <code class="literal">single_valued_expression</code> and the individual values in the <code class="literal">single_valued_list</code> must be consistent. JPQL limits the valid types here to string, numeric, date, time, timestamp, and enum types. In JPQL, <code class="literal">single_valued_expression</code> can only refer to:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
								"state fields", which is its term for simple attributes. Specifically this excludes association and component/embedded attributes.
							</li><li class="listitem"><p class="simpara">
								entity type expressions.
							</p><p class="simpara">
								In HQL, <code class="literal">single_valued_expression</code> can refer to a far more broad set of expression types. Single-valued association are allowed. So are component/embedded attributes, although that feature depends on the level of support for tuple or "row value constructor syntax" in the underlying database. Additionally, HQL does not limit the value type in any way, though application developers should be aware that different types may incur limited support based on the underlying database vendor. This is largely the reason for the JPQL limitations.
							</p><p class="simpara">
								The list of values can come from a number of different sources. In the <code class="literal">constructor_expression</code> and <code class="literal">collection_valued_input_parameter</code>, the list of values must not be empty; it must contain at least one value.
							</p><div class="formalpara"><p class="title"><strong>Example: IN Predicate</strong></p><p>
									
<pre class="screen">select p
from Payment p
where type(p) in (CreditCardPayment, WireTransferPayment)

select c
from Customer c
where c.hqAddress.state in ('TX', 'OK', 'LA', 'NM')

select c
from Customer c
where c.hqAddress.state in ?

select c
from Customer c
where c.hqAddress.state in (
    select dm.state
    from DeliveryMetadata dm
    where dm.salesTax is not null
)

// Not JPQL compliant!
select c
from Customer c
where c.name in (
    ('John','Doe'),
    ('Jane','Doe')
)

// Not JPQL compliant!
select c
from Customer c
where c.chiefExecutive in (
    select p
    from Person p
    where ...
)</pre>

								</p></div></li></ul></div></li></ul></div></section><section class="section" id="about_relational_comparisons"><div class="titlepage"><div><div><h2 class="title">4.9. About Relational Comparisons</h2></div></div></div><p>
				Comparisons involve one of the comparison operators - =, &gt;, &gt;=, &lt;, ⇐, &lt;&gt;. HQL also defines != as a comparison operator synonymous with &lt;&gt;. The operands should be of the same type.
			</p><div class="formalpara"><p class="title"><strong>Example: Relational Comparison Examples</strong></p><p>
					
<pre class="screen">// numeric comparison
select c
from Customer c
where c.chiefExecutive.age &lt; 30

// string comparison
select c
from Customer c
where c.name = 'Acme'

// datetime comparison
select c
from Customer c
where c.inceptionDate &lt; {d '2000-01-01'}

// enum comparison
select c
from Customer c
where c.chiefExecutive.gender = com.acme.Gender.MALE

// boolean comparison
select c
from Customer c
where c.sendEmail = true

// entity type comparison
select p
from Payment p
where type(p) = WireTransferPayment

// entity value comparison
select c
from Customer c
where c.chiefExecutive = c.chiefTechnologist</pre>

				</p></div><p>
				Comparisons can also involve subquery qualifiers - <code class="literal">ALL</code>, <code class="literal">ANY</code>, <code class="literal">SOME</code>. <code class="literal">SOME</code> and <code class="literal">ANY</code> are synonymous.
			</p><p>
				The <code class="literal">ALL</code> qualifier resolves to true if the comparison is true for all of the values in the result of the subquery. It resolves to false if the subquery result is empty.
			</p><div class="formalpara"><p class="title"><strong>Example: ALL Subquery Comparison Qualifier Example</strong></p><p>
					
<pre class="screen">// select all players that scored at least 3 points
// in every game.
select p
from Player p
where 3 &gt; all (
   select spg.points
   from StatsPerGame spg
   where spg.player = p
)</pre>

				</p></div><p>
				The <code class="literal">ANY</code>/<code class="literal">SOME</code> qualifier resolves to true if the comparison is true for at least one of the values in the result of the subquery. It resolves to false if the subquery result is empty.
			</p></section><section class="section" id="bytecode_enhancement"><div class="titlepage"><div><div><h2 class="title">4.10. Bytecode Enhancement</h2></div></div></div><section class="section" id="lazy_attribute_loading"><div class="titlepage"><div><div><h3 class="title">4.10.1. Lazy Attribute Loading</h3></div></div></div><p>
					Lazy attribute loading is a bytecode enhancement which allows you to tell Hibernate that only certain parts of an entity should be loaded upon fetching from the database, and when the other remaining parts should be loaded as well. This is different from proxy-based idea of lazy loading which is entity-centric where the entity’s state is loaded at once as needed. With bytecode enhancement, individual attributes or groups of attributes are loaded as needed.
				</p><p>
					Lazy attributes can be designated to be loaded together and this is called a <span class="emphasis"><em>lazy group</em></span>. By default, all singular attributes are part of a single group. When one lazy singular attribute is accessed, all lazy singular attributes are loaded. Contrary to lazy singular group, lazy plural attributes are each a discrete lazy group. This behavior is explicitly controllable through the <code class="literal">@org.hibernate.annotations.LazyGroup</code> annotation.
				</p><pre class="programlisting language-java">@Entity
public class Customer {

    @Id
    private Integer id;

    private String name;

    @Basic( fetch = FetchType.LAZY )
    private UUID accountsPayableXrefId;

    @Lob
    @Basic( fetch = FetchType.LAZY )
    @LazyGroup( "lobs" )
    private Blob image;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public UUID getAccountsPayableXrefId() {
        return accountsPayableXrefId;
    }

    public void setAccountsPayableXrefId(UUID accountsPayableXrefId) {
        this.accountsPayableXrefId = accountsPayableXrefId;
    }

    public Blob getImage() {
        return image;
    }

    public void setImage(Blob image) {
        this.image = image;
    }
}</pre><p>
					In the example above, there are two lazy attributes: <code class="literal">accountsPayableXrefId</code> and <code class="literal">image</code>. Each of these attributes is part of a different fetch group. The <code class="literal">accountsPayableXrefId</code> attribute is a part of the default fetch group, which means that accessing <code class="literal">accountsPayableXrefId</code> will not force the loading of the <code class="literal">image</code> attribute, and vice versa.
				</p></section></section></section><section class="chapter" id="hibernate_services"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Hibernate Services</h1></div></div></div><section class="section" id="about_hibernate_services"><div class="titlepage"><div><div><h2 class="title">5.1. About Hibernate Services</h2></div></div></div><p>
				Services are classes that provide Hibernate with pluggable implementations of various types of functionality. Specifically they are implementations of certain service contract interfaces. The interface is known as the service role; the implementation class is known as the service implementation. Generally speaking, users can plug in alternate implementations of all standard service roles (overriding); they can also define additional services beyond the base set of service roles (extending).
			</p></section><section class="section" id="about_service_contracts"><div class="titlepage"><div><div><h2 class="title">5.2. About Service Contracts</h2></div></div></div><p>
				The basic requirement for a service is to implement the marker interface org.hibernate.service.Service. Hibernate uses this internally for some basic type safety.
			</p><p>
				Optionally, the service can also implement the org.hibernate.service.spi.Startable and org.hibernate.service.spi.Stoppable interfaces to receive notifications of being started and stopped. Another optional service contract is org.hibernate.service.spi.Manageable which marks the service as manageable in JMX provided the JMX integration is enabled.
			</p></section><section class="section" id="types_of_service_dependencies"><div class="titlepage"><div><div><h2 class="title">5.3. Types of Service Dependencies</h2></div></div></div><p>
				Services are allowed to declare dependencies on other services using either of the following approaches:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">@org.hibernate.service.spi.InjectService</span></dt><dd><p class="simpara">
							Any method on the service implementation class accepting a single parameter and annotated with <code class="literal">@InjectService</code> is considered requesting injection of another service.
						</p><p class="simpara">
							By default the type of the method parameter is expected to be the service role to be injected. If the parameter type is different than the service role, the <code class="literal">serviceRole</code> attribute of the <code class="literal">InjectService</code> should be used to explicitly name the role.
						</p><p class="simpara">
							By default injected services are considered required, that is the startup will fail if a named dependent service is missing. If the service to be injected is optional, the required attribute of the <code class="literal">InjectService</code> should be declared as <code class="literal">false</code>. The default is <code class="literal">true</code>.
						</p></dd><dt><span class="term">org.hibernate.service.spi.ServiceRegistryAwareService</span></dt><dd><p class="simpara">
							The second approach is a pull approach where the service implements the optional service interface <code class="literal">org.hibernate.service.spi.ServiceRegistryAwareService</code> which declares a single <code class="literal">injectServices</code> method.
						</p><p class="simpara">
							During startup, Hibernate will inject the <code class="literal">org.hibernate.service.ServiceRegistry</code> itself into services which implement this interface. The service can then use the <code class="literal">ServiceRegistry</code> reference to locate any additional services it needs.
						</p></dd></dl></div><section class="section" id="the_service_registry"><div class="titlepage"><div><div><h3 class="title">5.3.1. The Service Registry</h3></div></div></div><section class="section" id="about_the_serviceRegistry"><div class="titlepage"><div><div><h4 class="title">5.3.1.1. About the ServiceRegistry</h4></div></div></div><p>
						The central service API, aside from the services themselves, is the org.hibernate.service.ServiceRegistry interface. The main purpose of a service registry is to hold, manage and provide access to services.
					</p><p>
						Service registries are hierarchical. Services in one registry can depend on and utilize services in that same registry as well as any parent registries.
					</p><p>
						Use org.hibernate.service.ServiceRegistryBuilder to build a org.hibernate.service.ServiceRegistry instance.
					</p><div class="formalpara"><p class="title"><strong>Example Using ServiceRegistryBuilder to Create a ServiceRegistry</strong></p><p>
							
<pre class="programlisting language-java">ServiceRegistryBuilder registryBuilder =
    new ServiceRegistryBuilder( bootstrapServiceRegistry );
    ServiceRegistry serviceRegistry = registryBuilder.buildServiceRegistry();</pre>

						</p></div></section></section><section class="section" id="custom_services"><div class="titlepage"><div><div><h3 class="title">5.3.2. Custom Services</h3></div></div></div><section class="section" id="about_custom_services"><div class="titlepage"><div><div><h4 class="title">5.3.2.1. About Custom Services</h4></div></div></div><p>
						Once a <code class="literal">org.hibernate.service.ServiceRegistry</code> is built it is considered immutable; the services themselves might accept reconfiguration, but immutability here means adding or replacing services. So another role provided by the <code class="literal">org.hibernate.service.ServiceRegistryBuilder</code> is to allow tweaking of the services that will be contained in the <code class="literal">org.hibernate.service.ServiceRegistry</code> generated from it.
					</p><p>
						There are two means to tell a <code class="literal">org.hibernate.service.ServiceRegistryBuilder</code> about custom services.
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Implement a <code class="literal">org.hibernate.service.spi.BasicServiceInitiator</code> class to control on-demand construction of the service class and add it to the <code class="literal">org.hibernate.service.ServiceRegistryBuilder</code> using its <code class="literal">addInitiator</code> method.
							</li><li class="listitem">
								Just instantiate the service class and add it to the <code class="literal">org.hibernate.service.ServiceRegistryBuilder</code> using its <code class="literal">addService</code> method.
							</li></ul></div><p>
						Either approach is valid for extending a registry, such as adding new service roles, and overriding services, such as replacing service implementations.
					</p><div class="formalpara"><p class="title"><strong>Example: Use ServiceRegistryBuilder to Replace an Existing Service with a Custom Service</strong></p><p>
							
<pre class="programlisting language-java">ServiceRegistryBuilder registryBuilder =
    new ServiceRegistryBuilder(bootstrapServiceRegistry);
registryBuilder.addService(JdbcServices.class, new MyCustomJdbcService());
ServiceRegistry serviceRegistry = registryBuilder.buildServiceRegistry();

public class MyCustomJdbcService implements JdbcServices{

   @Override
   public ConnectionProvider getConnectionProvider() {
       return null;
   }

   @Override
   public Dialect getDialect() {
       return null;
   }

   @Override
   public SqlStatementLogger getSqlStatementLogger() {
       return null;
   }

   @Override
   public SqlExceptionHelper getSqlExceptionHelper() {
       return null;
   }

   @Override
   public ExtractedDatabaseMetaData getExtractedMetaDataSupport() {
       return null;
   }

   @Override
   public LobCreator getLobCreator(LobCreationContext lobCreationContext) {
       return null;
   }

   @Override
   public ResultSetWrapper getResultSetWrapper() {
       return null;
   }
}</pre>

						</p></div></section></section><section class="section" id="the_boot_strap_registry"><div class="titlepage"><div><div><h3 class="title">5.3.3. The Boot-Strap Registry</h3></div></div></div><section class="section" id="about_the_boot-strap_registry"><div class="titlepage"><div><div><h4 class="title">5.3.3.1. About the Boot-strap Registry</h4></div></div></div><p>
						The boot-strap registry holds services that absolutely have to be available for most things to work. The main service here is the <code class="literal">ClassLoaderService</code> which is a perfect example. Even resolving configuration files needs access to class loading services i.e. resource look ups. This is the root registry, no parent, in normal use.
					</p><p>
						Instances of boot-strap registries are built using the <code class="literal">org.hibernate.service.BootstrapServiceRegistryBuilder</code> class.
					</p><h5 id="using_bootstrapserviceregistrybuilder">Using BootstrapServiceRegistryBuilder</h5><div class="formalpara"><p class="title"><strong>Example: Using BootstrapServiceRegistryBuilder</strong></p><p>
							
<pre class="programlisting language-java">BootstrapServiceRegistry bootstrapServiceRegistry =
    new BootstrapServiceRegistryBuilder()
    // pass in org.hibernate.integrator.spi.Integrator instances which are not
    // auto-discovered (for whatever reason) but which should be included
    .with(anExplicitIntegrator)
    // pass in a class loader that Hibernate should use to load application classes
    .with(anExplicitClassLoaderForApplicationClasses)
    // pass in a class loader that Hibernate should use to load resources
    .with(anExplicitClassLoaderForResources)
    // see BootstrapServiceRegistryBuilder for rest of available methods
    ...
    // finally, build the bootstrap registry with all the above options
    .build();</pre>

						</p></div></section><section class="section" id="bootstarpregistry_services"><div class="titlepage"><div><div><h4 class="title">5.3.3.2. BootstrapRegistry Services</h4></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">org.hibernate.service.classloading.spi.ClassLoaderService</code></span></dt><dd><p class="simpara">
									Hibernate needs to interact with class loaders. However, the manner in which Hibernate, or any library, should interact with class loaders varies based on the runtime environment that is hosting the application. Application servers, OSGi containers, and other modular class loading systems impose very specific class loading requirements. This service provides Hibernate an abstraction from this environmental complexity. And just as importantly, it does so in a single-swappable-component manner.
								</p><p class="simpara">
									In terms of interacting with a class loader, Hibernate needs the following capabilities:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											the ability to locate application classes
										</li><li class="listitem">
											the ability to locate integration classes
										</li><li class="listitem">
											the ability to locate resources, such as properties files and XML files
										</li><li class="listitem"><p class="simpara">
											the ability to load <code class="literal">java.util.ServiceLoader</code>
										</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
												Currently, the ability to load application classes and the ability to load integration classes are combined into a single <span class="strong strong"><strong>load class</strong></span> capability on the service. That may change in a later release.
											</p></div></div></li></ul></div></dd><dt><span class="term"><code class="literal">org.hibernate.integrator.spi.IntegratorService</code></span></dt><dd><p class="simpara">
									Applications, add-ons and other modules need to integrate with Hibernate. The previous approach required a component, usually an application, to coordinate the registration of each individual module. This registration was conducted on behalf of each module’s integrator.
								</p><p class="simpara">
									This service focuses on the discovery aspect. It leverages the standard Java <code class="literal">java.util.ServiceLoader</code> capability provided by the <code class="literal">org.hibernate.service.classloading.spi.ClassLoaderService</code> in order to discover implementations of the <code class="literal">org.hibernate.integrator.spi.Integrator</code> contract.
								</p><p class="simpara">
									Integrators would simply define a file named <code class="literal">/META-INF/services/org.hibernate.integrator.spi.Integrator</code> and make it available on the class path.
								</p><p class="simpara">
									This file is used by the <code class="literal">java.util.ServiceLoader</code> mechanism. It lists, one per line, the fully qualified names of classes which implement the <code class="literal">org.hibernate.integrator.spi.Integrator</code> interface.
								</p></dd></dl></div></section></section><section class="section" id="sessionFactory_registry"><div class="titlepage"><div><div><h3 class="title">5.3.4. SessionFactory Registry</h3></div></div></div><p>
					While it is best practice to treat instances of all the registry types as targeting a given <code class="literal">org.hibernate.SessionFactory</code>, the instances of services in this group explicitly belong to a single <code class="literal">org.hibernate.SessionFactory</code>.
				</p><p>
					The difference is a matter of timing in when they need to be initiated. Generally they need access to the <code class="literal">org.hibernate.SessionFactory</code> to be initiated. This special registry is <code class="literal">org.hibernate.service.spi.SessionFactoryServiceRegistry</code>.
				</p><section class="section" id="sessionFactory_services"><div class="titlepage"><div><div><h4 class="title">5.3.4.1. SessionFactory Services</h4></div></div></div><p>
						<code class="literal">org.hibernate.event.service.spi.EventListenerRegistry</code>
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Description</span></dt><dd>
									Service for managing event listeners.
								</dd><dt><span class="term">Initiator</span></dt><dd>
									<code class="literal">org.hibernate.event.service.internal.EventListenerServiceInitiator</code>
								</dd><dt><span class="term">Implementations</span></dt><dd>
									<code class="literal">org.hibernate.event.service.internal.EventListenerRegistryImpl</code>
								</dd></dl></div></section></section><section class="section" id="integrators"><div class="titlepage"><div><div><h3 class="title">5.3.5. Integrators</h3></div></div></div><p>
					The <code class="literal">org.hibernate.integrator.spi.Integrator</code> is intended to provide a simple means for allowing developers to hook into the process of building a functioning <code class="literal">SessionFactory</code>. The <code class="literal">org.hibernate.integrator.spi.Integrator</code> interface defines two methods of interest:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">integrate</code> allows us to hook into the building process
						</li><li class="listitem">
							<code class="literal">disintegrate</code> allows us to hook into a <code class="literal">SessionFactory</code> shutting down.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						There is a third method defined in <code class="literal">org.hibernate.integrator.spi.Integrator</code>, an overloaded form of integrate, accepting a <code class="literal">org.hibernate.metamodel.source.MetadataImplementor</code> instead of <code class="literal">org.hibernate.cfg.Configuration</code>.
					</p><p>
						In addition to the discovery approach provided by the <code class="literal">IntegratorService</code>, applications can manually register Integrator implementations when building the <code class="literal">BootstrapServiceRegistry</code>.
					</p></div></div><section class="section" id="integrator_use-cases"><div class="titlepage"><div><div><h4 class="title">5.3.5.1. Integrator Use Cases</h4></div></div></div><p>
						The main use cases for an <code class="literal">org.hibernate.integrator.spi.Integrator</code> are registering event listeners and providing services, see <a class="link mimir-link-warn" href="http://docs.jboss.org/hibernate/orm/5.2/javadocs/org/hibernate/integrator/spi/ServiceContributingIntegrator.html" title="Mimir does not include content from: docs.jboss.org"><code class="literal">org.hibernate.integrator.spi.ServiceContributingIntegrator</code></a>.
					</p><div class="formalpara"><p class="title"><strong>Example: Registering Event Listeners</strong></p><p>
							
<pre class="programlisting language-java">public class MyIntegrator implements org.hibernate.integrator.spi.Integrator {

    public void integrate(
            Configuration configuration,
            SessionFactoryImplementor sessionFactory,
            SessionFactoryServiceRegistry serviceRegistry) {
        // As you might expect, an EventListenerRegistry is the thing with which event listeners are registered  It is a
        // service so we look it up using the service registry
        final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService(EventListenerRegistry.class);

        // If you wish to have custom determination and handling of "duplicate" listeners, you would have to add an
        // implementation of the org.hibernate.event.service.spi.DuplicationStrategy contract like this
        eventListenerRegistry.addDuplicationStrategy(myDuplicationStrategy);

        // EventListenerRegistry defines 3 ways to register listeners:
        //     1) This form overrides any existing registrations with
        eventListenerRegistry.setListeners(EventType.AUTO_FLUSH, myCompleteSetOfListeners);
        //     2) This form adds the specified listener(s) to the beginning of the listener chain
        eventListenerRegistry.prependListeners(EventType.AUTO_FLUSH, myListenersToBeCalledFirst);
        //     3) This form adds the specified listener(s) to the end of the listener chain
        eventListenerRegistry.appendListeners(EventType.AUTO_FLUSH, myListenersToBeCalledLast);
    }
}</pre>

						</p></div></section></section></section></section><section class="chapter" id="hibernate_envers"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Hibernate Envers</h1></div></div></div><section class="section" id="about_hibernate_envers"><div class="titlepage"><div><div><h2 class="title">6.1. About Hibernate Envers</h2></div></div></div><p>
				Hibernate Envers is an auditing and versioning system, providing JBoss EAP with a means to track historical changes to persistent classes. Audit tables are created for entities annotated with <code class="literal">@Audited</code>, which store the history of changes made to the entity. The data can then be retrieved and queried.
			</p><p>
				Envers allows developers to:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						audit all mappings defined by the JPA specification
					</li><li class="listitem">
						audit all hibernate mappings that extend the JPA specification
					</li><li class="listitem">
						audit entities mapped by or using the native Hibernate API
					</li><li class="listitem">
						log data for each revision using a revision entity
					</li><li class="listitem">
						query historical data
					</li></ul></div></section><section class="section" id="about_auditing_persistent_classes"><div class="titlepage"><div><div><h2 class="title">6.2. About Auditing Persistent Classes</h2></div></div></div><p>
				Auditing of persistent classes is done in JBoss EAP through Hibernate Envers and the <code class="literal">@Audited</code> annotation. When the annotation is applied to a class, a table is created, which stores the revision history of the entity.
			</p><p>
				Each time a change is made to the class, an entry is added to the audit table. The entry contains the changes to the class, and is given a revision number. This means that changes can be rolled back, or previous revisions can be viewed.
			</p></section><section class="section" id="auditing_strategies"><div class="titlepage"><div><div><h2 class="title">6.3. Auditing Strategies</h2></div></div></div><section class="section" id="about_auditing_strategies"><div class="titlepage"><div><div><h3 class="title">6.3.1. About Auditing Strategies</h3></div></div></div><p>
					Auditing strategies define how audit information is persisted, queried and stored. There are currently two audit strategies available with Hibernate Envers:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Default Audit Strategy</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										This strategy persists the audit data together with a start revision. For each row that is inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, along with the start revision of its validity.
									</li><li class="listitem">
										Rows in the audit tables are never updated after insertion. Queries of audit information use subqueries to select the applicable rows in the audit tables, which are slow and difficult to index.
									</li></ul></div></dd><dt><span class="term">Validity Audit Strategy</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										This strategy stores the start revision, as well as the end revision of the audit information. For each row that is inserted, updated or deleted in an audited table, one or more rows are inserted in the audit tables, along with the start revision of its validity.
									</li><li class="listitem">
										At the same time, the end revision field of the previous audit rows (if available) is set to this revision. Queries on the audit information can then use <span class="emphasis"><em>between start and end revision</em></span>, instead of subqueries. This means that persisting audit information is a little slower because of the extra updates, but retrieving audit information is a lot faster.
									</li><li class="listitem">
										This can also be improved by adding extra indexes.
									</li></ul></div></dd></dl></div><p>
					For more information on auditing, see <a class="link" href="#about_auditing_persistent_classes" title="6.2. About Auditing Persistent Classes">About Auditing Persistent Classes</a>. To set the auditing strategy for the application, see <a class="link" href="#set_the_auditing_strategy" title="6.3.2. Set the Auditing Strategy">Set the Auditing Strategy</a>.
				</p></section><section class="section" id="set_the_auditing_strategy"><div class="titlepage"><div><div><h3 class="title">6.3.2. Set the Auditing Strategy</h3></div></div></div><p>
					There are two audit strategies supported by JBoss EAP:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The default audit strategy
						</li><li class="listitem">
							The validity audit strategy
						</li></ul></div><h5 id="define_an_auditing_strategy">Define an Auditing Strategy</h5><p>
					Configure the <code class="literal">org.hibernate.envers.audit_strategy</code> property in the <code class="literal">persistence.xml</code> file of the application. If the property is not set in the <code class="literal">persistence.xml</code> file, then the default audit strategy is used.
				</p><div class="formalpara"><p class="title"><strong>Set the <span class="strong strong"><strong>Default</strong></span> Audit Strategy</strong></p><p>
						
<pre class="programlisting language-xml">&lt;property name="org.hibernate.envers.audit_strategy" value="org.hibernate.envers.strategy.DefaultAuditStrategy"/&gt;</pre>

					</p></div><div class="formalpara"><p class="title"><strong>Set the <span class="strong strong"><strong>Validity</strong></span> Audit Strategy</strong></p><p>
						
<pre class="programlisting language-xml">&lt;property name="org.hibernate.envers.audit_strategy" value="org.hibernate.envers.strategy.ValidityAuditStrategy"/&gt;</pre>

					</p></div></section><section class="section" id="add_auditing_suppprt_to_a_jpa_entity"><div class="titlepage"><div><div><h3 class="title">6.3.3. Adding Auditing Support to a JPA Entity</h3></div></div></div><p>
					JBoss EAP uses entity auditing, through <a class="link" href="#about_hibernate_envers" title="6.1. About Hibernate Envers">About Hibernate Envers</a>, to track the historical changes of a persistent class. This section covers adding auditing support for a JPA entity.
				</p><div class="orderedlist"><p class="title"><strong>Add Auditing Support to a JPA Entity</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Configure the available auditing parameters to suit the deployment. See <a class="link" href="#configure_envres_parameters" title="6.4.1. Configure Envers Parameters">Configure Envers Parameters</a> for details.
						</li><li class="listitem">
							Open the JPA entity to be audited.
						</li><li class="listitem">
							Import the <code class="literal">org.hibernate.envers.Audited</code> interface.
						</li><li class="listitem"><p class="simpara">
							Apply the <code class="literal">@Audited</code> annotation to each field or property to be audited, or apply it once to the whole class.
						</p><div class="formalpara"><p class="title"><strong>Example: Audit Two Fields</strong></p><p>
								
<pre class="programlisting language-java">import org.hibernate.envers.Audited;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
public class Person {
    @Id
    @GeneratedValue
    private int id;

    @Audited
    private String name;

    private String surname;

    @ManyToOne
    @Audited
    private Address address;

    // add getters, setters, constructors, equals and hashCode here
}</pre>

							</p></div><div class="formalpara"><p class="title"><strong>Example: Audit an Entire Class</strong></p><p>
								
<pre class="programlisting language-java">import org.hibernate.envers.Audited;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Column;

@Entity
@Audited
public class Person {
    @Id
    @GeneratedValue
    private int id;

    private String name;

    private String surname;

    @ManyToOne
    private Address address;

    // add getters, setters, constructors, equals and hashCode here
}</pre>

							</p></div></li></ol></div><p>
					Once the JPA entity has been configured for auditing, a table called <code class="literal">_AUD</code> will be created to store the historical changes.
				</p></section></section><section class="section" id="configuration-1"><div class="titlepage"><div><div><h2 class="title">6.4. Configuration</h2></div></div></div><section class="section" id="configure_envres_parameters"><div class="titlepage"><div><div><h3 class="title">6.4.1. Configure Envers Parameters</h3></div></div></div><p>
					JBoss EAP uses entity auditing, through Hibernate Envers, to track the historical changes of a persistent class.
				</p><div class="orderedlist"><p class="title"><strong>Configuring the Available Envers Parameters</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Open the <code class="literal">persistence.xml</code> file for the application.
						</li><li class="listitem"><p class="simpara">
							Add, remove or configure Envers properties as required. For a list of available properties, see <a class="link" href="#envers_configuration_properties" title="6.4.4. Envers Configuration Properties">Envers Configuration Properties</a>.
						</p><div class="formalpara"><p class="title"><strong>Example: Envers Parameters</strong></p><p>
								
<pre class="programlisting language-xml">&lt;persistence-unit name="mypc"&gt;
  &lt;description&gt;Persistence Unit.&lt;/description&gt;
  &lt;jta-data-source&gt;java:jboss/datasources/ExampleDS&lt;/jta-data-source&gt;
  &lt;shared-cache-mode&gt;ENABLE_SELECTIVE&lt;/shared-cache-mode&gt;
  &lt;properties&gt;
    &lt;property name="hibernate.hbm2ddl.auto" value="create-drop" /&gt;
    &lt;property name="hibernate.show_sql" value="true" /&gt;
    &lt;property name="hibernate.cache.use_second_level_cache" value="true" /&gt;
    &lt;property name="hibernate.cache.use_query_cache" value="true" /&gt;
    &lt;property name="hibernate.generate_statistics" value="true" /&gt;
    &lt;property name="org.hibernate.envers.versionsTableSuffix" value="_V" /&gt;
    &lt;property name="org.hibernate.envers.revisionFieldName" value="ver_rev" /&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;</pre>

							</p></div></li></ol></div></section><section class="section" id="enable_or_disable_auditing_at_runtime"><div class="titlepage"><div><div><h3 class="title">6.4.2. Enable or Disable Auditing at Runtime</h3></div></div></div><div class="orderedlist"><p class="title"><strong>Enable or Disable Entity Version Auditing at Runtime</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Subclass the <code class="literal">AuditEventListener</code> class.
						</li><li class="listitem"><p class="simpara">
							Override the following methods that are called on Hibernate events:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<code class="literal">onPostInsert</code>
								</li><li class="listitem">
									<code class="literal">onPostUpdate</code>
								</li><li class="listitem">
									<code class="literal">onPostDelete</code>
								</li><li class="listitem">
									<code class="literal">onPreUpdateCollection</code>
								</li><li class="listitem">
									<code class="literal">onPreRemoveCollection</code>
								</li><li class="listitem">
									<code class="literal">onPostRecreateCollection</code>
								</li></ul></div></li><li class="listitem">
							Specify the subclass as the listener for the events.
						</li><li class="listitem">
							Determine if the change should be audited.
						</li><li class="listitem">
							Pass the call to the superclass if the change should be audited.
						</li></ol></div></section><section class="section" id="configure_conditional_auditing"><div class="titlepage"><div><div><h3 class="title">6.4.3. Configure Conditional Auditing</h3></div></div></div><p>
					Hibernate Envers persists audit data in reaction to various Hibernate events, using a series of event listeners. These listeners are registered automatically if the Envers JAR is in the class path.
				</p><div class="orderedlist"><p class="title"><strong>Implement Conditional Auditing</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Set the <code class="literal">hibernate.listeners.envers.autoRegister</code> Hibernate property to false in the <code class="literal">persistence.xml</code> file.
						</li><li class="listitem">
							Subclass each event listener to be overridden. Place the conditional auditing logic in the subclass, and call the super method if auditing should be performed.
						</li><li class="listitem">
							Create a custom implementation of <code class="literal">org.hibernate.integrator.spi.Integrator</code>, similar to <code class="literal">org.hibernate.envers.event.EnversIntegrator</code>. Use the event listener subclasses created in step two, rather than the default classes.
						</li><li class="listitem">
							Add a <code class="literal">META-INF/services/org.hibernate.integrator.spi.Integrator</code> file to the JAR. This file should contain the fully qualified name of the class implementing the interface.
						</li></ol></div></section><section class="section" id="envers_configuration_properties"><div class="titlepage"><div><div><h3 class="title">6.4.4. Envers Configuration Properties</h3></div></div></div><div class="table" id="idm140159951691888"><p class="title"><strong>Table 6.1. Entity Data Versioning Configuration Parameters</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 35%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 40%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159940520144" scope="col">Property Name</th><th align="left" valign="top" id="idm140159940519056" scope="col">Default Value</th><th align="left" valign="top" id="idm140159940517968" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_table_prefix</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									A string that is prepended to the name of an audited entity, to create the name of the entity that will hold the audit information.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_table_suffix</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									_AUD
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									A string that is appended to the name of an audited entity to create the name of the entity that will hold the audit information. For example, if an entity with a table name of <code class="literal">Person</code> is audited, Envers will generate a table called <code class="literal">Person_AUD</code> to store the historical data.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.revision_field_name</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									REV
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									The name of the field in the audit entity that holds the revision number.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.revision_type_field_name</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									REVTYPE
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									The name of the field in the audit entity that holds the type of revision. The current types of revisions possible are: <code class="literal">add</code>, <code class="literal">mod</code> and <code class="literal">del</code> for inserting, modifying or deleting respectively.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.revision_on_collection_change</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									true
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									This property determines if a revision should be generated if a relation field that is not owned changes. This can either be a collection in a one-to-many relation, or the field using the <code class="literal">mappedBy</code> attribute in a one-to-one relation.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.do_not_audit_optimistic_locking_field</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									true
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									When true, properties used for optimistic locking (annotated with <code class="literal">@Version</code>) will automatically be excluded from auditing.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.store_data_at_delete</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									false
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									This property defines whether or not entity data should be stored in the revision when the entity is deleted, instead of only the ID, with all other properties marked as null. This is not usually necessary, as the data is present in the last-but-one revision. Sometimes, however, it is easier and more efficient to access it in the last revision. However, this means the data the entity contained before deletion is stored twice.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.default_schema</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									null (same as normal tables)
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									The default schema name used for audit tables. Can be overridden using the <code class="literal">@AuditTable(schema="…​")</code> annotation. If not present, the schema will be the same as the schema of the normal tables.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.default_catalog</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									null (same as normal tables)
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									The default catalog name that should be used for audit tables. Can be overridden using the <code class="literal">@AuditTable(catalog="…​")</code> annotation. If not present, the catalog will be the same as the catalog of the normal tables.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									<code class="literal">org.hibernate.envers.strategy.DefaultAuditStrategy</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									This property defines the audit strategy that should be used when persisting audit data. By default, only the revision where an entity was modified is stored. Alternatively, <code class="literal">org.hibernate.envers.strategy.ValidityAuditStrategy</code> stores both the start revision and the end revision. Together, these define when an audit row was valid.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_end_rev_field_name</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									REVEND
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									The column name that will hold the end revision number in audit entities. This property is only valid if the validity audit strategy is used.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									false
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									This property defines whether the timestamp of the end revision, where the data was last valid, should be stored in addition to the end revision itself. This is useful to be able to purge old audit records out of a relational database by using table partitioning. Partitioning requires a column that exists within the table. This property is only evaluated if the <code class="literal">ValidityAuditStrategy</code> is used.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159940520144"> <p>
									<code class="literal">org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159940519056"> <p>
									REVEND_TSTMP
								</p>
								 </td><td align="left" valign="top" headers="idm140159940517968"> <p>
									Column name of the timestamp of the end revision at which point the data was still valid. Only used if the <code class="literal">ValidityAuditStrategy</code> is used, and <code class="literal">org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</code> evaluates to true.
								</p>
								 </td></tr></tbody></table></div></div></section></section><section class="section" id="querying_audit_information"><div class="titlepage"><div><div><h2 class="title">6.5. Querying Audit Information</h2></div></div></div><section class="section" id="retrieve_auditing_information"><div class="titlepage"><div><div><h3 class="title">6.5.1. Retrieve Auditing Information Through Queries</h3></div></div></div><p>
					Hibernate Envers provides the functionality to retrieve audit information through queries.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Queries on the audited data will be, in many cases, much slower than corresponding queries on <code class="literal">live</code> data, as they involve correlated subselects.
					</p></div></div><div class="formalpara"><p class="title"><strong>Querying for Entities of a Class at a Given Revision</strong></p><p>
						The entry point for this type of query is:
					</p></div><pre class="programlisting language-java">AuditQuery query = getAuditReader()
    .createQuery()
    .forEntitiesAtRevision(MyEntity.class, revisionNumber);</pre><p>
					Constraints can then be specified, using the <code class="literal">AuditEntity</code> factory class. The query below only selects entities where the <code class="literal">name</code> property is equal to <code class="literal">John</code>:
				</p><pre class="programlisting language-java">query.add(AuditEntity.property("name").eq("John"));</pre><p>
					The queries below only select entities that are related to a given entity:
				</p><pre class="programlisting language-java">query.add(AuditEntity.property("address").eq(relatedEntityInstance));
// or
query.add(AuditEntity.relatedId("address").eq(relatedEntityId));</pre><p>
					The results can then be ordered, limited, and have aggregations and projections (except grouping) set. The example below is a full query.
				</p><pre class="programlisting language-java">List personsAtAddress = getAuditReader().createQuery()
    .forEntitiesAtRevision(Person.class, 12)
    .addOrder(AuditEntity.property("surname").desc())
    .add(AuditEntity.relatedId("address").eq(addressId))
    .setFirstResult(4)
    .setMaxResults(2)
    .getResultList();</pre><div class="formalpara"><p class="title"><strong>Query Revisions where Entities of a Given Class Changed</strong></p><p>
						The entry point for this type of query is:
					</p></div><pre class="programlisting language-java">AuditQuery query = getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true);</pre><p>
					Constraints can be added to this query in the same way as the previous example. There are additional possibilities for this query:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">AuditEntity.revisionNumber()</code></span></dt><dd>
								Specify constraints, projections and order on the revision number in which the audited entity was modified.
							</dd><dt><span class="term"><code class="literal">AuditEntity.revisionProperty(propertyName)</code></span></dt><dd>
								Specify constraints, projections and order on a property of the revision entity, corresponding to the revision in which the audited entity was modified.
							</dd><dt><span class="term"><code class="literal">AuditEntity.revisionType()</code></span></dt><dd>
								Provides accesses to the type of the revision (ADD, MOD, DEL).
							</dd></dl></div><p>
					The query results can then be adjusted as necessary. The query below selects the smallest revision number at which the entity of the <code class="literal">MyEntity</code> class, with the <code class="literal">entityId</code> ID has changed, after revision number 42:
				</p><pre class="programlisting language-java">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.id().eq(entityId))
    .add(AuditEntity.revisionNumber().gt(42))
    .getSingleResult();</pre><p>
					Queries for revisions can also minimize/maximize a property. The query below selects the revision at which the value of the <code class="literal">actualDate</code> for a given entity was larger than a given value, but as small as possible:
				</p><pre class="programlisting language-java">Number revision = (Number) getAuditReader().createQuery()
    .forRevisionsOfEntity(MyEntity.class, false, true)
    // We are only interested in the first revision
    .setProjection(AuditEntity.revisionNumber().min())
    .add(AuditEntity.property("actualDate").minimize()
        .add(AuditEntity.property("actualDate").ge(givenDate))
        .add(AuditEntity.id().eq(givenEntityId)))
    .getSingleResult();</pre><p>
					The <code class="literal">minimize()</code> and <code class="literal">maximize()</code> methods return a criteria, to which constraints can be added, which must be met by the entities with the maximized/minimized properties.
				</p><p>
					There are two boolean parameters passed when creating the query.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">selectEntitiesOnly</code></span></dt><dd>
								<br/> This parameter is only valid when an explicit projection is not set. <br/> If <code class="literal">true</code>, the result of the query will be a list of entities that changed at revisions satisfying the specified constraints. <br/> If <code class="literal">false</code>, the result will be a list of three element arrays. The first element will be the changed entity instance. The second will be an entity containing revision data. If no custom entity is used, this will be an instance of <code class="literal">DefaultRevisionEntity</code>. The third element array will be the type of the revision (ADD, MOD, DEL).
							</dd><dt><span class="term"><code class="literal">selectDeletedEntities</code></span></dt><dd>
								This parameter specifies if revisions in which the entity was deleted must be included in the results. If true, the entities will have the revision type <code class="literal">DEL</code>, and all fields, except id, will have the value <code class="literal">null</code>.
							</dd></dl></div><div class="formalpara"><p class="title"><strong>Query Revisions of an Entity that Modified a Given Property</strong></p><p>
						The query below will return all revisions of <code class="literal">MyEntity</code> with a given id, where the <code class="literal">actualDate</code> property has been changed.
					</p></div><pre class="programlisting language-java">AuditQuery query = getAuditReader().createQuery()
  .forRevisionsOfEntity(MyEntity.class, false, true)
  .add(AuditEntity.id().eq(id));
  .add(AuditEntity.property("actualDate").hasChanged())</pre><p>
					The <code class="literal">hasChanged</code> condition can be combined with additional criteria. The query below will return a horizontal slice for <code class="literal">MyEntity</code> at the time the revisionNumber was generated. It will be limited to the revisions that modified <code class="literal">prop1</code>, but not <code class="literal">prop2</code>.
				</p><pre class="programlisting language-java">AuditQuery query = getAuditReader().createQuery()
  .forEntitiesAtRevision(MyEntity.class, revisionNumber)
  .add(AuditEntity.property("prop1").hasChanged())
  .add(AuditEntity.property("prop2").hasNotChanged());</pre><p>
					The result set will also contain revisions with numbers lower than the revisionNumber. This means that this query cannot be read as "Return all <code class="literal">MyEntities</code> changed in revisionNumber with <code class="literal">prop1</code> modified and <code class="literal">prop2</code> untouched."
				</p><p>
					The query below shows how this result can be returned, using the <code class="literal">forEntitiesModifiedAtRevision</code> query:
				</p><pre class="programlisting language-java">AuditQuery query = getAuditReader().createQuery()
  .forEntitiesModifiedAtRevision(MyEntity.class, revisionNumber)
  .add(AuditEntity.property("prop1").hasChanged())
  .add(AuditEntity.property("prop2").hasNotChanged());</pre><div class="formalpara"><p class="title"><strong>Query Entities Modified in a Given Revision</strong></p><p>
						The example below shows the basic query for entities modified in a given revision. It allows entity names and corresponding Java classes changed in a specified revision to be retrieved:
					</p></div><pre class="programlisting language-java">Set&lt;Pair&lt;String, Class&gt;&gt; modifiedEntityTypes = getAuditReader()
    .getCrossTypeRevisionChangesReader().findEntityTypes(revisionNumber);</pre><p>
					There are a number of other queries that are also accessible from org.hibernate.envers.CrossTypeRevisionChangesReader:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">List&lt;Object&gt; findEntities(Number)</code></span></dt><dd>
								Returns snapshots of all audited entities changed (added, updated and removed) in a given revision. Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within the specified revision.
							</dd><dt><span class="term"><code class="literal">List&lt;Object&gt; findEntities(Number, RevisionType)</code></span></dt><dd>
								Returns snapshots of all audited entities changed (added, updated or removed) in a given revision filtered by modification type. Executes <code class="literal">n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within specified revision. Map&lt;RevisionType, List&lt;Object&gt;&gt;
							</dd><dt><span class="term"><code class="literal">findEntitiesGroupByRevisionType(Number)</code></span></dt><dd>
								Returns a map containing lists of entity snapshots grouped by modification operation, for example, addition, update or removal. Executes <code class="literal">3n+1</code> SQL queries, where <code class="literal">n</code> is a number of different entity classes modified within specified revision.
							</dd></dl></div></section><section class="section" id="hibernate_envers_traversing_entities_using_properties"><div class="titlepage"><div><div><h3 class="title">6.5.2. Traversing Entity Associations Using Properties of Referenced Entities</h3></div></div></div><p>
					You can use the properties of a referenced entity to traverse entities in a query. This enables you to query for one-to-one and many-to-one associations.
				</p><p>
					The examples below demonstrate some of the ways you can traverse entities in a query.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							In revision number 1, find cars where the owner is age 20 or lives at address number 30, then order the result set by car make.
						</p><pre class="programlisting language-java">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.INNER, "p" )
                .traverseRelation( "address", JoinType.INNER, "a" )
                .up().up().add( AuditEntity.disjunction().add(AuditEntity.property( "p", "age" )
                       .eq( 20 ) ).add( AuditEntity.property( "a", "number" ).eq( 30 ) ) )
                .addOrder( AuditEntity.property( "make" ).asc() ).getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find the car where the owner age is equal to the owner address number.
						</p><pre class="programlisting language-java">Car result = (Car) auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.INNER, "p" )
                .traverseRelation( "address", JoinType.INNER, "a" )
                .up().up().add(AuditEntity.property( "p", "age" )
                        .eqProperty( "a", "number" ) ).getSingleResult();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the owner is age 20 or where there is no owner.
						</p><pre class="programlisting language-java">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.or( AuditEntity.property( "p", "age").eq( 20 ),
                        AuditEntity.relatedId( "owner" ).eq( null ) ) )
                .addOrder( AuditEntity.property( "make" ).asc() ).getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the make equals "car3", and where the owner is age 30 or there is no no owner.
						</p><pre class="programlisting language-java">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.and( AuditEntity.property( "make" ).eq( "car3" ), AuditEntity.property( "p", "age" ).eq( 30 ) ) )
                .getResultList();</pre></li><li class="listitem"><p class="simpara">
							In revision number 1, find all cars where the make equals "car3" or where or the owner is age 10 or where there is no owner.
						</p><pre class="programlisting language-java">List&lt;Car&gt; resultList = auditReader.createQuery()
                .forEntitiesAtRevision( Car.class, 1 )
                .traverseRelation( "owner", JoinType.LEFT, "p" )
                .up().add( AuditEntity.or( AuditEntity.property( "make" ).eq( "car3" ), AuditEntity.property( "p", "age" ).eq( 10 ) ) )
                .getResultList();</pre></li></ul></div></section></section><section class="section" id="performance_tuning"><div class="titlepage"><div><div><h2 class="title">6.6. Performance Tuning</h2></div></div></div><section class="section" id="alternative_batch_loading_algorithms"><div class="titlepage"><div><div><h3 class="title">6.6.1. Alternative Batch Loading Algorithms</h3></div></div></div><p>
					Hibernate allows you to load data for associations using one of four fetching strategies: join, select, subselect and batch. Out of these four strategies, batch loading allows for the biggest performance gains as it is an optimization strategy for select fetching. In this strategy, Hibernate retrieves a batch of entity instances or collections in a single SELECT statement by specifying a list of primary or foreign keys. Batch fetching is an optimization of the lazy select fetching strategy.
				</p><p>
					There are two ways to configure batch fetching: per-class level or per-collection level.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Per-class Level
						</p><p class="simpara">
							When Hibernate loads data on a per-class level, it requires the batch size of the association to pre-load when queried. For example, consider that at runtime you have 30 instances of a <code class="literal">car</code> object loaded in session. Each <code class="literal">car</code> object belongs to an <code class="literal">owner</code> object. If you were to iterate through all the <code class="literal">car</code> objects and request their owners, with <code class="literal">lazy</code> loading, Hibernate will issue 30 select statements - one for each owner. This is a performance bottleneck.
						</p><p class="simpara">
							You can instead, tell Hibernate to pre-load the data for the next batch of owners before they have been sought via a query. When an <code class="literal">owner</code> object has been queried, Hibernate will query many more of these objects in the same SELECT statement.
						</p><p class="simpara">
							The number of <code class="literal">owner</code> objects to query in advance depends upon the <code class="literal">batch-size</code> parameter specified at configuration time:
						</p><pre class="programlisting language-xml">&lt;class name="owner" batch-size="10"&gt;&lt;/class&gt;</pre><p class="simpara">
							This tells Hibernate to query at least 10 more <code class="literal">owner</code> objects in expectation of them being needed in the near future. When a user queries the <code class="literal">owner</code> of <code class="literal">car A</code>, the <code class="literal">owner</code> of <code class="literal">car B</code> may already have been loaded as part of batch loading. When the user actually needs the <code class="literal">owner</code> of <code class="literal">car B</code>, instead of going to the database (and issuing a SELECT statement), the value can be retrieved from the current session.
						</p><p class="simpara">
							In addition to the <code class="literal">batch-size</code> parameter, Hibernate 4.2.0 has introduced a new configuration item to improve in batch loading performance. The configuration item is called <code class="literal">Batch Fetch Style</code> configuration and specified by the <code class="literal">hibernate.batch_fetch_style</code> parameter.
						</p><p class="simpara">
							Three different batch fetch styles are supported: LEGACY, PADDED and DYNAMIC. To specify which style to use, use <code class="literal">org.hibernate.cfg.AvailableSettings#BATCH_FETCH_STYLE</code>.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									LEGACY: In the legacy style of loading, a set of pre-built batch sizes based on <code class="literal">ArrayHelper.getBatchSizes(int)</code> are utilized. Batches are loaded using the next-smaller pre-built batch size from the number of existing batchable identifiers.
								</p><p class="simpara">
									Continuing with the above example, with a <code class="literal">batch-size</code> setting of 30, the pre-built batch sizes would be [30, 15, 10, 9, 8, 7, .., 1]. An attempt to batch load 29 identifiers would result in batches of 15, 10, and 4. There will be 3 corresponding SQL queries, each loading 15, 10 and 4 owners from the database.
								</p></li><li class="listitem"><p class="simpara">
									PADDED - Padded is similar to LEGACY style of batch loading. It still utilizes pre-built batch sizes, but uses the next-bigger batch size and pads the extra identifier placeholders.
								</p><p class="simpara">
									As with the example above, if 30 owner objects are to be initialized, there will only be one query executed against the database.
								</p><p class="simpara">
									However, if 29 owner objects are to be initialized, Hibernate will still execute only one SQL select statement of batch size 30, with the extra space padded with a repeated identifier.
								</p></li><li class="listitem"><p class="simpara">
									Dynamic - While still conforming to batch-size restrictions, this style of batch loading dynamically builds its SQL SELECT statement using the actual number of objects to be loaded.
								</p><p class="simpara">
									For example, for 30 owner objects, and a maximum batch size of 30, a call to retrieve 30 owner objects will result in one SQL SELECT statement. A call to retrieve 35 will result in two SQL statements, of batch sizes 30 and 5 respectively. Hibernate will dynamically alter the second SQL statement to keep at 5, the required number, while still remaining under the restriction of 30 as the batch-size. This is different to the PADDED version, as the second SQL will not get PADDED, and unlike the LEGACY style, there is no fixed size for the second SQL statement - the second SQL is created dynamically.
								</p><p class="simpara">
									For a query of less than 30 identifiers, this style will dynamically only load the number of identifiers requested.
								</p></li></ul></div></li><li class="listitem"><p class="simpara">
							Per-collection Level
						</p><p class="simpara">
							Hibernate can also batch load collections honoring the batch fetch size and styles as listed in the per-class section above.
						</p><p class="simpara">
							To reverse the example used in the previous section, consider that you need to load all the <code class="literal">car</code> objects owned by each <code class="literal">owner</code> object. If 10 <code class="literal">owner</code> objects are loaded in the current session iterating through all owners will generate 10 SELECT statements, one for every call to <code class="literal">getCars()</code> method. If you enable batch fetching for the cars collection in the mapping of Owner, Hibernate can pre-fetch these collections, as shown below.
						</p><pre class="programlisting language-xml">&lt;class name="Owner"&gt;&lt;set name="cars" batch-size="5"&gt;&lt;/set&gt;&lt;/class&gt;</pre><p class="simpara">
							Thus, with a batch size of five and using legacy batch style to load 10 collections, Hibernate will execute two SELECT statements, each retrieving five collections.
						</p></li></ul></div></section><section class="section" id="second_level_caching_of_object_references_for_non-mutable_data"><div class="titlepage"><div><div><h3 class="title">6.6.2. Second Level Caching of Object References for Non-mutable Data</h3></div></div></div><p>
					Hibernate automatically caches data within memory for improved performance. This is accomplished by an in-memory cache which reduces the number of times that database lookups are required, especially for data that rarely changes.
				</p><p>
					Hibernate maintains two types of caches. The primary cache, also called the first-level cache, is mandatory. This cache is associated with the current session and all requests must pass through it. The secondary cache, also called the second-level cache, is optional, and is only consulted after the primary cache has been consulted.
				</p><p>
					Data is stored in the second-level cache by first disassembling it into a state array. This array is deep copied, and that deep copy is put into the cache. The reverse is done for reading from the cache. This works well for data that changes (mutable data), but is inefficient for immutable data.
				</p><p>
					Deep copying data is an expensive operation in terms of memory usage and processing speed. For large data sets, memory and processing speed become a performance-limiting factor. Hibernate allows you to specify that immutable data be referenced rather than copied. Instead of copying entire data sets, Hibernate can now store the reference to the data in the cache.
				</p><p>
					This can be done by changing the value of the configuration setting <code class="literal">hibernate.cache.use_reference_entries</code> to <code class="literal">true</code>. By default, <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">false</code>.
				</p><p>
					When <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">true</code>, an immutable data object that does not have any associations is not copied into the second-level cache, and only a reference to it is stored.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						When <code class="literal">hibernate.cache.use_reference_entries</code> is set to <code class="literal">true</code>, immutable data objects with associations are still deep copied into the second-level cache.
					</p></div></div></section></section></section><section class="chapter" id="hibernate_search"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Hibernate Search</h1></div></div></div><section class="section" id="getting_started_with_hibernate_search"><div class="titlepage"><div><div><h2 class="title">7.1. Getting Started with Hibernate Search</h2></div></div></div><section class="section" id="about_hibernate_search"><div class="titlepage"><div><div><h3 class="title">7.1.1. About Hibernate Search</h3></div></div></div><p>
					Hibernate Search provides full-text search capability to Hibernate applications. It is especially suited to search applications for which SQL-based solutions are not suited, including: full-text, fuzzy and geolocation searches. Hibernate Search uses Apache Lucene as its full-text search engine, but is designed to minimize the maintenance overhead. Once it is configured, indexing, clustering and data synchronization is maintained transparently, allowing you to focus on meeting your business requirements.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The prior release of JBoss EAP included Hibernate 4.2 and Hibernate Search 4.6. JBoss EAP 7 includes Hibernate 5 and Hibernate Search 5.5.
					</p><p>
						Hibernate Search 5.5 works with Java 7 and now builds upon Lucene 5.3.x. If you are using any native Lucene APIs make sure to align with this version.
					</p></div></div></section><section class="section" id="overview"><div class="titlepage"><div><div><h3 class="title">7.1.2. Overview</h3></div></div></div><p>
					Hibernate Search consists of an indexing component as well as an index search component, both are backed by Apache Lucene. Each time an entity is inserted, updated or removed from the database, Hibernate Search keeps track of this event through the Hibernate event system and schedules an index update. All these updates are handled without having to interact with the Apache Lucene APIs directly. Instead, interaction with the underlying Lucene indexes is handled via an <code class="literal">IndexManager</code>. By default there is a one-to-one relationship between IndexManager and Lucene index. The IndexManager abstracts the specific index configuration, including the selected <span class="emphasis"><em>back end</em></span>, <span class="emphasis"><em>reader strategy</em></span> and the <span class="emphasis"><em>DirectoryProvider</em></span>.
				</p><p>
					Once the index is created, you can search for entities and return lists of managed entities instead of dealing with the underlying Lucene infrastructure. The same persistence context is shared between Hibernate and Hibernate Search. The <code class="literal">FullTextSession</code> class is built on top of the Hibernate <code class="literal">Session</code> class so that the application code can use the unified <code class="literal">org.hibernate.Query</code> or <code class="literal">javax.persistence.Query</code> APIs exactly the same way an HQL, JPA-QL, or native query would.
				</p><p>
					Transactional batching mode is recommended for all operations, whether or not they are JDBC-based.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						It is recommended, for both your database and Hibernate Search, to execute your operations in a transaction, whether it is JDBC or JTA.
					</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Hibernate Search works perfectly fine in the Hibernate or EntityManager long conversation pattern, known as atomic conversation.
					</p></div></div></section><section class="section" id="about_directory_provider"><div class="titlepage"><div><div><h3 class="title">7.1.3. About the Directory Provider</h3></div></div></div><p>
					Apache Lucene, which is part of the Hibernate Search infrastructure, has the concept of a Directory for storage of indexes. Hibernate Search handles the initialization and configuration of a Lucene Directory instance via a <span class="emphasis"><em>Directory Provider</em></span>.
				</p><p>
					The <code class="literal">directory_provider</code> property specifies the directory provider to be used to store the indexes. The default file system directory provider is <code class="literal">filesystem</code>, which uses the local file system to store indexes.
				</p></section><section class="section" id="about_worker"><div class="titlepage"><div><div><h3 class="title">7.1.4. About the Worker</h3></div></div></div><p>
					Updates to Lucene indexes are handled by the Hibernate Search <span class="emphasis"><em>Worker</em></span>, which receives all entity changes, queues them by context and applies them once a context ends. The most common context is the transaction, but may be dependent on the number of entity changes or some other application events.
				</p><p>
					For better efficiency, interactions are batched and generally applied once the context ends. Outside a transaction, the index update operation is executed right after the actual database operation. In the case of an ongoing transaction, the index update operation is scheduled for the transaction commit phase and discarded in case of transaction rollback. A worker may be configured with a specific batch size limit, after which indexing occurs regardless of the context.
				</p><p>
					There are two immediate benefits to this method of handling index updates:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Performance: Lucene indexing works better when operation are executed in batch.
						</li><li class="listitem">
							ACIDity: The work executed has the same scoping as the one executed by the database transaction and is executed if and only if the transaction is committed. This is not ACID in the strict sense, but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the source at any time.
						</li></ul></div><p>
					The two batch modes, no scope vs transactional, are the equivalent of autocommit versus transactional behavior. From a performance perspective, the <span class="emphasis"><em>transactional</em></span> mode is recommended. The scoping choice is made transparently. Hibernate Search detects the presence of a transaction and adjust the scoping.
				</p></section><section class="section" id="back_end_setup_and_operations"><div class="titlepage"><div><div><h3 class="title">7.1.5. Back End Setup and Operations</h3></div></div></div><section class="section" id="back_end"><div class="titlepage"><div><div><h4 class="title">7.1.5.1. Back End</h4></div></div></div><p>
						Hibernate Search uses various back ends to process batches of work. The back end is not limited to the configuration option <code class="literal">default.worker.backend</code>. This property specifies a implementation of the <code class="literal">BackendQueueProcessor</code> interface which is a part of a back-end configuration. Additional settings are required to set up a back-end, for example the JMS back-end.
					</p></section><section class="section" id="lucene"><div class="titlepage"><div><div><h4 class="title">7.1.5.2. Lucene</h4></div></div></div><p>
						In the Lucene mode, all index updates for a node are executed by the same node to the Lucene directories using the directory providers. Use this mode in a non-clustered environment or in clustered environments with a shared directory store.
					</p><div class="figure" id="idm140159943458864"><p class="title"><strong>Figure 7.1. Lucene Back-end Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Continuous_Delivery-18-Developing_Hibernate_Applications-en-US/images/393ac85ec78b81428bcac4f721be8ce6/1603.png" alt="Lucene Back-end Configuration" /></div></div></div><p>
						Lucene mode targets non-clustered or clustered applications where the directory manages the locking strategy. The primary advantage of Lucene mode is simplicity and immediate visibility of changes in Lucene queries. The Near Real Time (NRT) back end is an alternative back end for non-clustered and non-shared index configurations.
					</p></section><section class="section" id="jms"><div class="titlepage"><div><div><h4 class="title">7.1.5.3. JMS</h4></div></div></div><p>
						Index updates for a node are sent to the JMS queue. A unique reader processes the queue and updates the master index. The master index is subsequently replicated regularly to slave copies, to establish the master and slave pattern. The master is responsible for Lucene index updates. The slaves accept read and write operations but process read operations on local index copies. The master is solely responsible for updating the Lucene index. Only the master applies the local changes in an update operation.
					</p><div class="figure" id="idm140159940601744"><p class="title"><strong>Figure 7.2. JMS Back-end Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Continuous_Delivery-18-Developing_Hibernate_Applications-en-US/images/124a5b16a5dd5dee1ea3c6d18a47e0cb/1602.png" alt="JMS Back-end Configuration" /></div></div></div><p>
						This mode targets clustered environment where throughput is critical and index update delays are affordable. The JMS provider ensures reliability and uses the slaves to change the local index copies.
					</p></section></section><section class="section" id="reader_strategies"><div class="titlepage"><div><div><h3 class="title">7.1.6. Reader Strategies</h3></div></div></div><p>
					When executing a query, Hibernate Search uses a reader strategy to interact with the Apache Lucene indexes. Choose a reader strategy based on the profile of the application like frequent updates, read mostly, asynchronous index update.
				</p><section class="section" id="the_shared_strategy"><div class="titlepage"><div><div><h4 class="title">7.1.6.1. The Shared Strategy</h4></div></div></div><p>
						Using the <code class="literal">shared</code> strategy, Hibernate Search shares the same <code class="literal">IndexReader</code> for a given Lucene index across multiple queries and threads provided that the <code class="literal">IndexReader</code> remains updated. If the <code class="literal">IndexReader</code> is not updated, a new one is opened and provided. Each <code class="literal">IndexReader</code> is made of several <code class="literal">SegmentReaders</code>. The shared strategy reopens segments that have been modified or created after the last opening and shares the already loaded segments from the previous instance. This is the default strategy.
					</p></section><section class="section" id="the_not_shared_strategy"><div class="titlepage"><div><div><h4 class="title">7.1.6.2. The Not-shared Strategy</h4></div></div></div><p>
						Using the <code class="literal">not-shared</code> strategy, a Lucene <code class="literal">IndexReader</code> opens every time a query executes. Opening and starting up a <code class="literal">IndexReader</code> is an expensive operation. As a result, opening an <code class="literal">IndexReader</code> for each query execution is not an efficient strategy.
					</p></section><section class="section" id="custom_reader_strategies"><div class="titlepage"><div><div><h4 class="title">7.1.6.3. Custom Reader Strategies</h4></div></div></div><p>
						You can write a custom reader strategy using an implementation of <code class="literal">org.hibernate.search.reader.ReaderProvider</code>. The implementation must be thread safe.
					</p></section></section></section><section class="section" id="configuration_2"><div class="titlepage"><div><div><h2 class="title">7.2. Configuration</h2></div></div></div><section class="section" id="minimum_configuration"><div class="titlepage"><div><div><h3 class="title">7.2.1. Minimum Configuration</h3></div></div></div><p>
					Hibernate Search has been designed to provide flexibility in its configuration and operation, with default values carefully chosen to suit the majority of use cases. At a minimum a Directory Provider must be configured, along with its properties. The default Directory Provider is <code class="literal">filesystem</code>, which uses the local file system for index storage. For details of available Directory Providers and their configuration, see <a class="link" href="#directory_provider_configuration" title="7.2.3. DirectoryProvider Configuration">DirectoryProvider Configuration</a>.
				</p><p>
					If you are using Hibernate directly, settings such as the DirectoryProvider must be set in the configuration file, either <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA, the configuration file is <code class="literal">persistence.xml</code>.
				</p></section><section class="section" id="configuring_indexmanager"><div class="titlepage"><div><div><h3 class="title">7.2.2. Configuring the IndexManager</h3></div></div></div><p>
					Hibernate Search offers several implementations for this interface:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">directory-based</code>: the default implementation which uses the Lucene <code class="literal">Directory</code> abstraction to manage index files.
						</li><li class="listitem">
							<code class="literal">near-real-time</code>: avoids flushing writes to disk at each commit. This index manager is also <code class="literal">Directory</code> based, but uses Lucene’s near real-time, NRT, functionality.
						</li></ul></div><p>
					To specify an IndexManager other than the default, specify the following property:
				</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</pre><section class="section" id="directory_based"><div class="titlepage"><div><div><h4 class="title">7.2.2.1. Directory-based</h4></div></div></div><p>
						The <code class="literal">Directory-based</code> implementation is the default <code class="literal">IndexManager</code> implementation. It is highly configurable and allows separate configurations for the reader strategy, back ends, and directory providers.
					</p></section><section class="section" id="near_real_time"><div class="titlepage"><div><div><h4 class="title">7.2.2.2. Near Real Time</h4></div></div></div><p>
						The <code class="literal">NRTIndexManager</code> is an extension of the default <code class="literal">IndexManager</code> and leverages the Lucene NRT, Near Real Time, feature for low latency index writes. However, it ignores configuration settings for alternative back ends other than <code class="literal">lucene</code> and acquires exclusive write locks on the <code class="literal">Directory</code>.
					</p><p>
						The <code class="literal">IndexWriter</code> does not flush every change to the disk to provide low latency. Queries can read the updated states from the unflushed index writer buffers. However, this means that if the <code class="literal">IndexWriter</code> is killed or the application crashes, updates can be lost so the indexes must be rebuilt.
					</p><p>
						The Near Real Time configuration is recommended for non-clustered websites with limited data due to the mentioned disadvantages and because a master node can be individually configured for improved performance as well.
					</p></section><section class="section" id="custom"><div class="titlepage"><div><div><h4 class="title">7.2.2.3. Custom</h4></div></div></div><p>
						Specify a fully qualified class name for the custom implementation to set up a customized <code class="literal">IndexManager</code>. Set up a no-argument constructor for the implementation as follows:
					</p><pre class="screen">[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre><p>
						The custom index manager implementation does not require the same components as the default implementations. For example, delegate to a remote indexing service which does not expose a <code class="literal">Directory</code> interface.
					</p></section></section><section class="section" id="directory_provider_configuration"><div class="titlepage"><div><div><h3 class="title">7.2.3. DirectoryProvider Configuration</h3></div></div></div><p>
					A <code class="literal">DirectoryProvider</code> is the Hibernate Search abstraction around a Lucene <code class="literal">Directory</code> and handles the configuration and the initialization of the underlying Lucene resources. <a class="link" href="#directory_providers_and_properties" title="Directory Providers and Their Properties">Directory Providers and Their Properties</a> shows the list of the directory providers available in Hibernate Search together with their corresponding options.
				</p><p>
					Each indexed entity is associated with a Lucene index (except of the case where multiple entities share the same index). The name of the index is given by the <code class="literal">index</code> property of the <code class="literal">@Indexed</code> annotation. If the <code class="literal">index</code> property is not specified the fully qualified name of the indexed class will be used as name (recommended).
				</p><p>
					The DirectoryProvider and any additional options can be configured by using the prefix <code class="literal">hibernate.search.<span class="emphasis"><em>&lt;indexname&gt;</em></span></code>. The name <code class="literal">default</code> (<code class="literal">hibernate.search.default</code>) is reserved and can be used to define properties which apply to all indexes. <a class="link" href="#configuring_directory_providers" title="Configuring Directory Providers">Configuring Directory Providers</a> shows how <code class="literal">hibernate.search.default.directory_provider</code> is used to set the default directory provider to be the filesystem one. <code class="literal">hibernate.search.default.indexBase</code> sets then the default base directory for the indexes. As a result the index for the entity <code class="literal">Status</code> is created in <code class="literal">/usr/lucene/indexes/org.hibernate.example.Status</code>.
				</p><p>
					The index for the <code class="literal">Rule</code> entity, however, is using an in-memory directory, because the default directory provider for this entity is overridden by the property <code class="literal">hibernate.search.Rules.directory_provider</code>.
				</p><p>
					Finally the <code class="literal">Action</code> entity uses a custom directory provider <code class="literal">CustomDirectoryProvider</code> specified via <code class="literal">hibernate.search.Actions.directory_provider</code>.
				</p><div id="specifying_index_name" class="formalpara"><p class="title"><strong>Specifying the Index Name</strong></p><p>
						
<pre class="programlisting language-java">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</pre>

					</p></div><div id="configuring_directory_providers" class="formalpara"><p class="title"><strong>Configuring Directory Providers</strong></p><p>
						
<pre class="screen">hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider = ram
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre>

					</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Using the described configuration scheme you can easily define common rules like the directory provider and base directory, and override those defaults later on a per index basis.
					</p></div></div><h5 id="directory_providers_and_properties">Directory Providers and Their Properties</h5><div class="variablelist"><dl class="variablelist"><dt><span class="term">ram </span></dt><dd>
								None
							</dd><dt><span class="term">filesystem </span></dt><dd><p class="simpara">
								File system based directory. The directory used will be &lt;indexBase&gt;/&lt; indexName &gt;
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<span class="strong strong"><strong>indexBase</strong></span> : base directory
									</li><li class="listitem">
										<span class="strong strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="#lockfactory_configuration" title="7.2.6. LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts they also have their issues.
									</li></ul></div></dd><dt><span class="term"><code class="literal">filesystem-master</code></span></dt><dd><p class="simpara">
								File system based directory. Like <code class="literal">filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular basis.
							</p><p class="simpara">
								The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
							</p><p class="simpara">
								Note that the copy is based on an incremental copy mechanism reducing the average copy time.
							</p><p class="simpara">
								DirectoryProvider typically used on the master node in a JMS back end cluster.
							</p><p class="simpara">
								The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<span class="strong strong"><strong>indexBase</strong></span>: base directory
									</li><li class="listitem">
										<span class="strong strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong strong"><strong>sourceBase</strong></span>: source (copy) base directory.
									</li><li class="listitem">
										<span class="strong strong"><strong>source</strong></span>: source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="literal">&lt;sourceBase&gt;/&lt;source&gt;</code>
									</li><li class="listitem">
										<span class="strong strong"><strong>refresh</strong></span>: refresh period in seconds (the copy will take place every <span class="strong strong"><strong>refresh</strong></span> seconds). If a copy is still in progress when the following <span class="strong strong"><strong>refresh</strong></span> period elapses, the second copy operation will be skipped.
									</li><li class="listitem">
										<span class="strong strong"><strong>buffer_size_on_copy</strong></span>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
									</li><li class="listitem">
										<span class="strong strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="#lockfactory_configuration" title="7.2.6. LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are <code class="literal">auto</code> (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts, there are also issues of which you need to be aware.
									</li></ul></div></dd><dt><span class="term"><code class="literal">filesystem-slave</code></span></dt><dd><p class="simpara">
								File system based directory. Like <code class="literal">filesystem</code>, but retrieves a master version (source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
							</p><p class="simpara">
								The recommended value for the refresh period is (at least) 50% higher that the time to copy the information (default 3600 seconds - 60 minutes).
							</p><p class="simpara">
								Note that the copy is based on an incremental copy mechanism reducing the average copy time. If a copy is still in progress when <span class="strong strong"><strong>refresh</strong></span> period elapses, the second copy operation will be skipped.
							</p><p class="simpara">
								DirectoryProvider typically used on slave nodes using a JMS back end.
							</p><p class="simpara">
								The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most people reported good results using values between 16 and 64MB.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<span class="strong strong"><strong>indexBase</strong></span>: Base directory
									</li><li class="listitem">
										<span class="strong strong"><strong>indexName</strong></span>: override @Indexed.index (useful for sharded indexes)
									</li><li class="listitem">
										<span class="strong strong"><strong>sourceBase</strong></span>: Source (copy) base directory.
									</li><li class="listitem">
										<span class="strong strong"><strong>source</strong></span>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name being <code class="literal">&lt;sourceBase&gt;/&lt;source&gt;</code>
									</li><li class="listitem">
										<span class="strong strong"><strong>refresh</strong></span>: refresh period in second (the copy will take place every refresh seconds).
									</li><li class="listitem">
										<span class="strong strong"><strong>buffer_size_on_copy</strong></span>: The amount of MegaBytes to move in a single low level copy instruction; defaults to 16MB.
									</li><li class="listitem">
										<span class="strong strong"><strong>locking_strategy</strong></span> : optional, see <a class="link" href="#lockfactory_configuration" title="7.2.6. LockFactory Configuration">LockFactory Configuration</a>
									</li><li class="listitem">
										<span class="strong strong"><strong>retry_marker_lookup</strong></span> : optional, default to 0. Defines how many times Hibernate Search checks for the marker files in the source directory before failing. Waiting 5 seconds between each try.
									</li><li class="listitem">
										<span class="strong strong"><strong>retry_initialize_period</strong></span> : optional, set an integer value in seconds to enable the retry initialize feature: if the slave cannot find the master index it will try again until it is found in background, without preventing the application to start: fullText queries performed before the index is initialized are not blocked but will return empty results. When not enabling the option or explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer. To prevent the application from starting without an invalid index but still control an initialization timeout, see <code class="literal">retry_marker_lookup</code> instead.
									</li><li class="listitem">
										<span class="strong strong"><strong>filesystem_access_type</strong></span>: allows to determine the exact type of <code class="literal">FSDirectory</code> implementation used by this <code class="literal">DirectoryProvider</code>. Allowed values are auto (the default value, selects <code class="literal">NIOFSDirectory</code> on non Windows systems, <code class="literal">SimpleFSDirectory</code> on Windows), <code class="literal">simple (SimpleFSDirectory)</code>, <code class="literal">nio (NIOFSDirectory)</code>, <code class="literal">mmap (MMapDirectory)</code>. See the Javadocs for these Directory implementations before changing this setting. Even though <code class="literal">NIOFSDirectory</code> or <code class="literal">MMapDirectory</code> can bring substantial performance boosts you need also to be aware of the issues.
									</li></ul></div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If the built-in directory providers do not fit your needs, you can write your own directory provider by implementing the <code class="literal">org.hibernate.store.DirectoryProvider</code> interface. In this case, pass the fully qualified class name of your provider into the <code class="literal">directory_provider</code> property. You can pass any additional properties using the prefix <code class="literal">hibernate.search.<span class="emphasis"><em>&lt;indexname&gt;</em></span></code>.
					</p></div></div></section><section class="section" id="worker_configuration"><div class="titlepage"><div><div><h3 class="title">7.2.4. Worker Configuration</h3></div></div></div><p>
					It is possible to refine how Hibernate Search interacts with Lucene through the worker configuration. There exist several architectural components and possible extension points. Let’s have a closer look.
				</p><p>
					Use the worker configuration to refine how Infinispan Query interacts with Lucene. Several architectural components and possible extension points are available for this configuration.
				</p><p>
					First there is a <code class="literal">Worker</code>. An implementation of the <code class="literal">Worker</code> interface is responsible for receiving all entity changes, queuing them by context and applying them once a context ends. The most intuitive context, especially in connection with ORM, is the transaction. For this reason Hibernate Search will per default use the <code class="literal">TransactionalWorker</code> to scope all changes per transaction. One can, however, imagine a scenario where the context depends for example on the number of entity changes or some other application lifecycle events.
				</p><div class="table" id="table_scope_configuration"><p class="title"><strong>Table 7.1. Scope Configuration</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159942868688" scope="col"><span class="strong strong"><strong>Property</strong></span></th><th align="left" valign="top" id="idm140159942867136" scope="col"><span class="strong strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159942868688"> <p>
									<code class="literal">hibernate.search.worker.scope</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159942867136"> <p>
									The fully qualified class name of the <code class="literal">Worker</code> implementation to use. If this property is not set, empty or <code class="literal">transaction</code> the default <code class="literal">TransactionalWorker</code> is used.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159942868688"> <p>
									<code class="literal">hibernate.search.worker.*</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159942867136"> <p>
									All configuration properties prefixed with <code class="literal">hibernate.search.worker</code> are passed to the Worker during initialization. This allows adding custom, worker specific parameters.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159942868688"> <p>
									<code class="literal">hibernate.search.worker.batch_size</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159942867136"> <p>
									Defines the maximum number of indexing operation batched per context. Once the limit is reached indexing will be triggered even though the context has not ended yet. This property only works if the <code class="literal">Worker</code> implementation delegates the queued work to BatchedQueueingProcessor, which is what the <code class="literal">TransactionalWorker</code> does.
								</p>
								 </td></tr></tbody></table></div></div><p>
					Once a context ends it is time to prepare and apply the index changes. This can be done synchronously or asynchronously from within a new thread. Synchronous updates have the advantage that the index is at all times in sync with the databases. Asynchronous updates, on the other hand, can help to minimize the user response time. The drawback is potential discrepancies between database and index states.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The following options can be different on each index; in fact they need the indexName prefix or use <code class="literal">default</code> to set the default value for all indexes.
					</p></div></div><div class="table" id="table_execution_configuration"><p class="title"><strong>Table 7.2. Execution Configuration</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159945524304" scope="col"><span class="strong strong"><strong>Property</strong></span></th><th align="left" valign="top" id="idm140159945522752" scope="col"><span class="strong strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159945524304"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.execution</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159945522752"> <p>
									<code class="literal">sync</code>: synchronous execution (default)
								</p>
								 <p>
									<code class="literal">async</code>: asynchronous execution
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159945524304"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.thread_pool.size</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159945522752"> <p>
									The back end can apply updates from the same transaction context (or batch) in parallel, using a thread pool. The default value is 1. You can experiment with larger values if you have many operations per transaction.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159945524304"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.buffer_queue.max</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159945522752"> <p>
									Defines the maximal number of work queue if the thread pool is starved. Useful only for asynchronous execution. Default to infinite. If the limit is reached, the work is done by the main thread.
								</p>
								 </td></tr></tbody></table></div></div><p>
					So far all work is done within the same virtual machine (VM), no matter which execution mode. The total amount of work has not changed for the single VM. Luckily there is a better approach, namely delegation. It is possible to send the indexing work to a different server by configuring <code class="literal">hibernate.search.default.worker.backend</code>. Again this option can be configured differently for each index.
				</p><div class="table" id="table_backend_configuration"><p class="title"><strong>Table 7.3. Back-end Configuration</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159942108640" scope="col"><span class="strong strong"><strong>Property</strong></span></th><th align="left" valign="top" id="idm140159942107088" scope="col"><span class="strong strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159942108640"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.backend</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159942107088"> <p>
									<code class="literal">lucene</code>: The default back end which runs index updates in the same VM. Also used when the property is undefined or empty.
								</p>
								 <p>
									<code class="literal">jms</code>: JMS back end. Index updates are send to a JMS queue to be processed by an indexing master. See <a class="link" href="#table_jms_backend_configuration" title="Table 7.4. JMS Back-end Configuration">JMS Back-end Configuration</a> for additional configuration options and for a more detailed description of this setup.
								</p>
								 <p>
									<code class="literal">blackhole</code>: Mainly a test/developer setting which ignores all indexing work
								</p>
								 <p>
									You can also specify the fully qualified name of a class implementing <code class="literal">BackendQueueProcessor</code>. This way you can implement your own communication layer. The implementation is responsible for returning a <code class="literal">Runnable</code> instance which on execution will process the index work.
								</p>
								 </td></tr></tbody></table></div></div><div class="table" id="table_jms_backend_configuration"><p class="title"><strong>Table 7.4. JMS Back-end Configuration</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159956907152" scope="col">Property</th><th align="left" valign="top" id="idm140159956906064" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159956907152"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jndi.*</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159956906064"> <p>
									Defines the JNDI properties to initiate the InitialContext, if necessary. JNDI is only used by the JMS back end.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159956907152"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jms.connection_factory</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159956906064"> <p>
									Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS connection factory from (<code class="literal">/ConnectionFactory</code> by default in Red Hat JBoss Enterprise Application Platform)
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159956907152"> <p>
									<code class="literal">hibernate.search.&lt;indexName&gt;.​worker.jms.queue</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159956906064"> <p>
									Mandatory for the JMS back end. Defines the JNDI name to lookup the JMS queue from. The queue will be used to post work messages.
								</p>
								 </td></tr></tbody></table></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						As you probably noticed, some of the shown properties are correlated which means that not all combinations of property values make sense. In fact you can end up with a non-functional configuration. This is especially true for the case that you provide your own implementations of some of the shown interfaces. Make sure to study the existing code before you write your own <code class="literal">Worker</code> or <code class="literal">BackendQueueProcessor</code> implementation.
					</p></div></div><section class="section" id="jms_master_slave_back_end"><div class="titlepage"><div><div><h4 class="title">7.2.4.1. JMS Master/Slave Back End</h4></div></div></div><p>
						This section describes in greater detail how to configure the master/slave Hibernate Search architecture.
					</p><div class="figure" id="idm140159941735008"><p class="title"><strong>Figure 7.3. JMS Backend Configuration</strong></p><div class="figure-contents"><div class="mediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Continuous_Delivery-18-Developing_Hibernate_Applications-en-US/images/124a5b16a5dd5dee1ea3c6d18a47e0cb/1602.png" alt="JMS Backend Configuration" /></div></div></div></section><section class="section" id="slave_nodes"><div class="titlepage"><div><div><h4 class="title">7.2.4.2. Slave Nodes</h4></div></div></div><p>
						Every index update operation is sent to a JMS queue. Index querying operations are executed on a local index copy.
					</p><div class="formalpara"><p class="title"><strong>JMS Slave Configuration</strong></p><p>
							
<pre class="screen">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Back-end configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.default.worker.execution = async
# hibernate.search.default.worker.thread_pool.size = 2
# hibernate.search.default.worker.buffer_queue.max = 50</pre>

						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							A file system local copy is recommended for faster search results.
						</p></div></div></section><section class="section" id="master_node"><div class="titlepage"><div><div><h4 class="title">7.2.4.3. Master Node</h4></div></div></div><p>
						Every index update operation is taken from a JMS queue and executed. The master index is copied on a regular basis.
					</p><p>
						Index update operations in the JMS queue are executed and the master index is copied regularly.
					</p><div class="formalpara"><p class="title"><strong>JMS Master Configuration</strong></p><p>
							
<pre class="screen">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Back-end configuration
#Back-end is the default for Lucene</pre>

						</p></div><p>
						In addition to the Hibernate Search framework configuration, a message-driven bean has to be written and set up to process the index works queue through JMS.
					</p><div class="formalpara"><p class="title"><strong>Message-driven Bean Processing the Indexing Queue</strong></p><p>
							
<pre class="programlisting language-java">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {
    @PersistenceContext EntityManager em;

    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session)
    }
}</pre>

						</p></div><p>
						This example inherits from the abstract JMS controller class available in the Hibernate Search source code and implements a Java EE MDB. This implementation is given as an example and can be adjusted to make use of non Java EE message-driven beans.
					</p></section></section><section class="section" id="tuning_lucene_indexing"><div class="titlepage"><div><div><h3 class="title">7.2.5. Tuning Lucene Indexing</h3></div></div></div><section class="section" id="tuning_lucene_indexing_performance"><div class="titlepage"><div><div><h4 class="title">7.2.5.1. Tuning Lucene Indexing Performance</h4></div></div></div><p>
						Hibernate Search is used to tune the Lucene indexing performance by specifying a set of parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code>, and <code class="literal">maxBufferedDocs</code>. Specify these parameters either as default values applying for all indexes, on a per index basis, or even per shard.
					</p><p>
						There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword:
					</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre><p>
						If no value is set for an <code class="literal">indexwriter</code> value in a specific shard configuration, Hibernate Search checks the index section, then at the default section.
					</p><p>
						The configuration in the following table will result in these settings applied on the second shard of the <code class="literal">Animal</code> index:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">max_merge_docs</code> = 10
							</li><li class="listitem">
								<code class="literal">merge_factor</code> = 20
							</li><li class="listitem">
								<code class="literal">ram_buffer_size</code> = 64MB
							</li><li class="listitem">
								<code class="literal">term_index_interval</code> = Lucene default
							</li></ul></div><p>
						All other values will use the defaults defined in Lucene.
					</p><p>
						The default for all values is to leave them at Lucene’s own default. The values listed in <a class="link" href="#table_performance_parameters" title="Table 7.5. Indexing Performance and Behavior Properties">Indexing Performance and Behavior Properties</a> depend for this reason on the version of Lucene you are using. The values shown are relative to version <code class="literal">2.4</code>.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Previous versions of Hibernate Search had the notion of <code class="literal">batch</code> and <code class="literal">transaction</code> properties. This is no longer the case as the back end will always perform work using the same settings.
						</p></div></div><div class="table" id="table_performance_parameters"><p class="title"><strong>Table 7.5. Indexing Performance and Behavior Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col><col style="width: 20%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159956923184" scope="col"><span class="strong strong"><strong>Property</strong></span></th><th align="left" valign="top" id="idm140159956921632" scope="col"><span class="strong strong"><strong>Description</strong></span></th><th align="left" valign="top" id="idm140159956920080" scope="col"><span class="strong strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].​exclusive_index_use</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables Hibernate Search to work in exclusive mode on the index and improve performance when writing changes to the index.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										<code class="literal">true</code> (improved performance, releases locks only at shutdown)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].max_queue_length</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting does not make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										<code class="literal">1000</code>
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_delete_terms</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										Unlimited (Integer.MAX_VALUE)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										10
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls segment merge frequency and size. Segments smaller than this size (in MB) are always considered for the next segment merge operation. Setting this too large might result in expensive merge operations, even though they are less frequent. See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										0 MB (actually ~1K)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.​[default|&lt;indexname&gt;].​indexwriter.merge_max_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are never merged in bigger segments.
									</p>
									 <p>
										This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										<code class="literal">true</code>
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
									</p>
									 <p>
										Generally for faster indexing performance it is best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										16 MB
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Set the interval between indexed terms.
									</p>
									 <p>
										Large values cause less memory to be used by IndexReader, but slow random-access to terms.Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										128
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.use_compound_file</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										true
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159956923184"> <p>
										<code class="literal">hibernate.search.​enable_dirty_check</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159956921632"> <p>
										Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, Hibernate Search skips the re-indexing process.
									</p>
									 <p>
										Disable this option if you use custom <code class="literal">FieldBridges</code> which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
									</p>
									 <p>
										This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159956920080"> <p>
										true
									</p>
									 </td></tr></tbody></table></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							The <code class="literal">blackhole</code> back end is not meant to be used in production, only as a tool to identify indexing bottlenecks.
						</p></div></div></section><section class="section" id="the_lucene_indexwriter"><div class="titlepage"><div><div><h4 class="title">7.2.5.2. The Lucene IndexWriter</h4></div></div></div><p>
						There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases. These parameters are grouped by the <code class="literal">indexwriter</code> keyword:
					</p><pre class="screen">default.&lt;indexname&gt;.indexwriter.&lt;parameter_name&gt;</pre><p>
						If no value is set for <code class="literal">indexwriter</code> in a shard configuration, Hibernate Search looks at the index section and then at the default section.
					</p></section><section class="section" id="performance_option_configuration"><div class="titlepage"><div><div><h4 class="title">7.2.5.3. Performance Option Configuration</h4></div></div></div><p>
						The following configuration will result in these settings being applied on the second shard of the <code class="literal">Animal</code> index:
					</p><div class="formalpara"><p class="title"><strong>Example performance option configuration</strong></p><p>
							
<pre class="screen">default.Animals.2.indexwriter.max_merge_docs = 10
default.Animals.2.indexwriter.merge_factor = 20
default.Animals.2.indexwriter.term_index_interval = default
default.indexwriter.max_merge_docs = 100
default.indexwriter.ram_buffer_size = 64</pre>

						</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">max_merge_docs</code> = 10
							</li><li class="listitem">
								<code class="literal">merge_factor</code> = 20
							</li><li class="listitem">
								<code class="literal">ram_buffer_size</code> = 64MB
							</li><li class="listitem">
								<code class="literal">term_index_interval</code> = Lucene default
							</li></ul></div><p>
						All other values will use the defaults defined in Lucene.
					</p><p>
						The Lucene default values are the default setting for Hibernate Search. Therefore, the values listed in the following table depend on the version of Lucene being used. The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance, see the Lucene documentation.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The back end will always perform work using the same settings.
						</p></div></div><div class="table" id="idm140159942522160"><p class="title"><strong>Table 7.6. Indexing Performance and Behavior Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col><col style="width: 20%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159942516368" scope="col"><span class="strong strong"><strong>Property</strong></span></th><th align="left" valign="top" id="idm140159942514816" scope="col"><span class="strong strong"><strong>Description</strong></span></th><th align="left" valign="top" id="idm140159942513264" scope="col"><span class="strong strong"><strong>Default Value</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.exclusive_index_use</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Set to <code class="literal">true</code> when no other process will need to write to the same index. This enables Hibernate Search to work in exclusive mode on the index and improve performance when writing changes to the index.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										<code class="literal">true</code> (improved performance, releases locks only at shutdown)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.max_queue_length</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Each index has a separate "pipeline" which contains the updates to be applied to the index. When this queue is full adding more operations to the queue becomes a blocking operation. Configuring this setting does not make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										<code class="literal">1000</code>
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_buffered_delete_terms</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Determines the minimal number of delete terms required before the buffered in-memory delete terms are applied and flushed. If there are documents buffered in memory at the time, they are merged and a new segment is created.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_buffered_docs</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is consumed.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										Disabled (flushes by RAM usage)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.max_merge_docs</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Defines the largest number of documents allowed in a segment. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										Unlimited (Integer.MAX_VALUE)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_factor</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Determines how often segment indexes are merged when insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized indexes are faster, but indexing speed is slower. With larger values, more RAM is used during indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are interactively maintained. The value must not be lower than 2.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										10
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_min_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments smaller than this size (in MB) are always considered for the next segment merge operation.
									</p>
									 <p>
										Setting this too large might result in expensive merge operations, even though they are less frequent.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										0 MB (actually ~1K)
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_max_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are never merged in bigger segments.
									</p>
									 <p>
										This helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. When optimizing an index this value is ignored.
									</p>
									 <p>
										See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_max_optimize_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Segments larger than this size (in MB) are not merged in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										Unlimited
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.merge_calibrate_by_deletes</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls segment merge frequency and size.
									</p>
									 <p>
										Set to <code class="literal">false</code> to not consider deleted documents when estimating the merge policy.
									</p>
									 <p>
										Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										<code class="literal">true</code>
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.ram_buffer_size</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs a flush occurs for whichever event happens first.
									</p>
									 <p>
										Generally for faster indexing performance it is best to flush by RAM usage instead of document count and use as large a RAM buffer as you can.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										16 MB
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.term_index_interval</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Set the interval between indexed terms.
									</p>
									 <p>
										Large values cause less memory to be used by IndexReader, but slow random-access to terms. Small values cause more memory to be used by an IndexReader, and speed random-access to terms. See Lucene documentation for more details.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										128
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.&lt;indexname&gt;.indexwriter.use_compound_file</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										The advantage of using the compound file format is that less file descriptors are used. The disadvantage is that indexing takes more time and temporary disk space. You can set this parameter to <code class="literal">false</code> in an attempt to improve the indexing time, but you could run out of file descriptors if <code class="literal">mergeFactor</code> is also large.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										true
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159942516368"> <p>
										<code class="literal">default.enable_dirty_check</code>
									</p>
									 </td><td align="left" valign="top" headers="idm140159942514816"> <p>
										Not all entity changes require a Lucene index update. If all of the updated entity properties (dirty properties) are not indexed, Hibernate Search skips the re-indexing process.
									</p>
									 <p>
										Disable this option if you use custom <code class="literal">FieldBridges</code> which need to be invoked at each update event (even though the property for which the field bridge is configured has not changed).
									</p>
									 <p>
										This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
									</p>
									 <p>
										Boolean parameter, use <code class="literal">true</code> or <code class="literal">false</code>. The default value for this option is <code class="literal">true</code>.
									</p>
									 </td><td align="left" valign="top" headers="idm140159942513264"> <p>
										true
									</p>
									 </td></tr></tbody></table></div></div></section><section class="section" id="tuning_the_indexing_speed"><div class="titlepage"><div><div><h4 class="title">7.2.5.4. Tuning the Indexing Speed</h4></div></div></div><p>
						When the architecture permits it, keep <code class="literal">default.exclusive_index_use=true</code> for improved index writing efficiency.
					</p><p>
						When tuning indexing speed the recommended approach is to focus first on optimizing the object loading, and then use the timings you achieve as a baseline to tune the indexing process. Set the <code class="literal">blackhole</code> as worker back end and start your indexing routines. This back end does not disable Hibernate Search. It generates the required change sets to the index, but discards them instead of flushing them to the index. In contrast to setting the <code class="literal">hibernate.search.indexing_strategy</code> to <code class="literal">manual</code>, using <code class="literal">blackhole</code> will possibly load more data from the database because associated entities are re-indexed as well.
					</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							The <code class="literal">blackhole</code> back end is not to be used in production, only as a diagnostic tool to identify indexing bottlenecks.
						</p></div></div></section><section class="section" id="control_segment_size"><div class="titlepage"><div><div><h4 class="title">7.2.5.5. Control Segment Size</h4></div></div></div><p>
						The following options configure the maximum size of segments created:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">merge_max_size</code>
							</li><li class="listitem">
								<code class="literal">merge_max_optimize_size</code>
							</li><li class="listitem">
								<code class="literal">merge_calibrate_by_deletes</code>
							</li></ul></div><div class="formalpara"><p class="title"><strong>Control Segment Size</strong></p><p>
							
<pre class="screen">//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre>

						</p></div><p>
						Set the <code class="literal">max_size</code> for merge operations to less than half of the hard limit segment size, as merging segments combines two segments into one larger segment.
					</p><p>
						A new segment may initially be a larger size than expected, however a segment is never created significantly larger than the <code class="literal">ram_buffer_size</code>. This threshold is checked as an estimate.
					</p></section></section><section class="section" id="lockfactory_configuration"><div class="titlepage"><div><div><h3 class="title">7.2.6. LockFactory Configuration</h3></div></div></div><p>
					The Lucene Directory can be configured with a custom locking strategy via <code class="literal">LockingFactory</code> for each index managed by Hibernate Search.
				</p><p>
					Some locking strategies require a filesystem level lock, and may be used on RAM-based indexes. When using this strategy the <code class="literal">IndexBase</code> configuration option must be specified to point to a filesystem location in which to store the lock marker files.
				</p><p>
					To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to one the following options:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="emphasis"><em>simple</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>native</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>single</em></span>
						</li><li class="listitem">
							<span class="emphasis"><em>none</em></span>
						</li></ul></div><div class="table" id="idm140159941010304"><p class="title"><strong>Table 7.7. List of Available LockFactory Implementations</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 10%; " class="col_1"><!--Empty--></col><col style="width: 40%; " class="col_2"><!--Empty--></col><col style="width: 50%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941004512" scope="col"><span class="strong strong"><strong>Name</strong></span></th><th align="left" valign="top" id="idm140159941002960" scope="col"><span class="strong strong"><strong>Class</strong></span></th><th align="left" valign="top" id="idm140159941001408" scope="col"><span class="strong strong"><strong>Description</strong></span></th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941004512"> <p>
									LockFactory Configuration <code class="literal">simple</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159941002960"> <p>
									org.apache.lucene.store.​SimpleFSLockFactory
								</p>
								 </td><td align="left" valign="top" headers="idm140159941001408"> <p>
									Safe implementation based on Java’s File API, it marks the usage of the index by creating a marker file.
								</p>
								 <p>
									If for some reason you had to kill your application, you will need to remove this file before restarting it.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941004512"> <p>
									<code class="literal">native</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159941002960"> <p>
									org.apache.lucene.store.​NativeFSLockFactory
								</p>
								 </td><td align="left" valign="top" headers="idm140159941001408"> <p>
									As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
								</p>
								 <p>
									This implementation has known problems on NFS, avoid it on network shares.
								</p>
								 <p>
									<code class="literal">native</code> is the default implementation for the <code class="literal">filesystem</code>, <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code> directory providers.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941004512"> <p>
									<code class="literal">single</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159941002960"> <p>
									org.apache.lucene.store.​SingleInstanceLockFactory
								</p>
								 </td><td align="left" valign="top" headers="idm140159941001408"> <p>
									This LockFactory does not use a file marker but is a Java object lock held in memory; therefore it is possible to use it only when you are sure the index is not going to be shared by any other process.
								</p>
								 <p>
									This is the default implementation for the <code class="literal">ram</code> directory provider.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941004512"> <p>
									<code class="literal">none</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140159941002960"> <p>
									org.apache.lucene.store.​NoLockFactory
								</p>
								 </td><td align="left" valign="top" headers="idm140159941001408"> <p>
									Changes to this index are not coordinated by a lock.
								</p>
								 </td></tr></tbody></table></div></div><p>
					The following is an example of locking strategy configuration:
				</p><pre class="screen">hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre></section><section class="section" id="index_format_compatibility"><div class="titlepage"><div><div><h3 class="title">7.2.7. Index Format Compatibility</h3></div></div></div><p>
					Hibernate Search does not currently offer a backwards compatible API or tool to facilitate porting applications to newer versions. The API uses Apache Lucene for index writing and searching. Occasionally an update to the index format may be required. In this case, there is a possibility that data will need to be re-indexed if Lucene is unable to read the old format.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Back up indexes before attempting to update the index format.
					</p></div></div><p>
					Hibernate Search exposes the <code class="literal">hibernate.search.lucene_version</code> configuration property. This property instructs Analyzers and other Lucene classes to conform to their behavior as defined in an older version of Lucene. See also <code class="literal">org.apache.lucene.util.Version</code> contained in the <code class="literal">lucene-core.jar</code>. If the option is not specified, Hibernate Search instructs Lucene to use the version default. It is recommended that the version used is explicitly defined in the configuration to prevent automatic changes when an upgrade occurs. After an upgrade, the configuration values can be updated explicitly if required.
				</p><div class="formalpara"><p class="title"><strong>Force Analyzers to Be Compatible with a Lucene 3.0 Created Index</strong></p><p>
						
<pre class="screen">hibernate.search.lucene_version = LUCENE_30</pre>

					</p></div><p>
					The configured <code class="literal">SearchFactory</code> is global and affects all Lucene APIs that contain the relevant parameter. If Lucene is used and Hibernate Search is bypassed, apply the same value to it for consistent results.
				</p></section></section><section class="section" id="hibernate_search_for_your_application"><div class="titlepage"><div><div><h2 class="title">7.3. Hibernate Search for Your Application</h2></div></div></div><section class="section" id="first_steps_with_hibernate_search"><div class="titlepage"><div><div><h3 class="title">7.3.1. First Steps with Hibernate Search</h3></div></div></div><p>
					To get started with Hibernate Search for your application, follow these topics.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="#enable_hibernate_search_using_maven" title="7.3.2. Enable Hibernate Search Using Maven">Enable Hibernate Search Using Maven</a>
						</li><li class="listitem">
							<a class="link" href="#indexing" title="7.3.4. Indexing">Indexing</a>
						</li><li class="listitem">
							<a class="link" href="#searching" title="7.3.5. Searching">Searching</a>
						</li><li class="listitem">
							<a class="link" href="#analyzer" title="7.3.6. Analyzer">Analyzer</a>
						</li></ul></div></section><section class="section" id="enable_hibernate_search_using_maven"><div class="titlepage"><div><div><h3 class="title">7.3.2. Enable Hibernate Search Using Maven</h3></div></div></div><p>
					Use the following configuration in your Maven project to add <code class="literal">hibernate-search-orm</code> dependencies:
				</p><pre class="programlisting language-xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
      &lt;version&gt;5.5.1.Final-redhat-1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></section><section class="section" id="add_annotations"><div class="titlepage"><div><div><h3 class="title">7.3.3. Add Annotations</h3></div></div></div><p>
					For this section, consider the example in which you have a database containing details of books. Your application contains the Hibernate managed classes <code class="literal">example.Book</code> and <code class="literal">example.Author</code> and you want to add free text search capabilities to your application to enable searching for books.
				</p><div class="formalpara"><p class="title"><strong>Example: Entities Book and Author Before Adding Hibernate Search Specific Annotations</strong></p><p>
						
<pre class="programlisting language-java">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;

  public Book() {}

  // standard getters/setters follow here
  ...
}</pre>

					</p></div><pre class="programlisting language-java">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {}

  // standard getters/setters follow here
  ...
}</pre><p>
					To achieve this you have to add a few annotations to the Book and Author class. The first annotation <code class="literal">@Indexed</code> marks Book as indexable. By design Hibernate Search stores an untokenized ID in the index to ensure index unicity for a given entity. <code class="literal">@DocumentId</code> marks the property to use for this purpose and is in most cases the same as the database primary key. The <code class="literal">@DocumentId</code> annotation is optional in the case where an <code class="literal">@Id</code> annotation exists.
				</p><p>
					Next the fields you want to make searchable must be marked as such. In this example, start with <code class="literal">title</code> and <code class="literal">subtitle</code> and annotate both with <code class="literal">@Field</code>. The parameter <code class="literal">index=Index.YES</code> will ensure that the text will be indexed, while <code class="literal">analyze=Analyze.YES</code> ensures that the text will be analyzed using the default Lucene analyzer. Usually, analyzing means chunking a sentence into individual words and potentially excluding common words like <code class="literal">'a'</code> or ‘the’. We will talk more about analyzers a little later on. The third parameter we specify within <code class="literal">@Field</code>, <code class="literal">store=Store.NO</code>, ensures that the actual data will not be stored in the index. Whether this data is stored in the index or not has nothing to do with the ability to search for it. From Lucene’s perspective it is not necessary to keep the data once the index is created. The benefit of storing it is the ability to retrieve it via <a class="link" href="#projection" title="7.5.1.10.5. Projection">projections</a>.
				</p><p>
					Without projections, Hibernate Search will per default execute a Lucene query in order to find the database identifiers of the entities matching the query criteria and use these identifiers to retrieve managed objects from the database. The decision for or against projection has to be made on a case to case basis. The default behavior is recommended since it returns managed objects whereas projections only return object arrays. Note that <code class="literal">index=Index.YES</code>, <code class="literal">analyze=Analyze.YES</code> and <code class="literal">store=Store.NO</code> are the default values for these parameters and could be omitted.
				</p><p>
					Another annotation not yet discussed is <code class="literal">@DateBridge</code>. This annotation is one of the built-in field bridges in Hibernate Search. The Lucene index is purely string based. For this reason Hibernate Search must convert the data types of the indexed fields to strings and vice-versa. A range of predefined bridges are provided, including the DateBridge which will convert a java.util.Date into a String with the specified resolution. For more details see <a class="link" href="#bridges" title="7.4.4. Bridges">Bridges</a>.
				</p><p>
					This leaves us with <code class="literal">@IndexedEmbedded</code>. This annotation is used to index associated entities (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code>, <code class="literal">@Embedded</code> and <code class="literal">@ElementCollection</code>) as part of the owning entity. This is needed since a Lucene index document is a flat data structure which does not know anything about object relations. To ensure that the authors' name will be searchable you have to ensure that the names are indexed as part of the book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also have to mark all fields of the associated entity you want to have included in the index with <code class="literal">@Indexed</code>. For more details see <a class="link" href="#embedded_and_associated_objects" title="7.4.1.7. Embedded and Associated Objects">Embedded and Associated Objects</a>.
				</p><p>
					These settings should be sufficient for now. For more details on entity mapping see <a class="link" href="#mapping_an_entity" title="7.4.1. Mapping an Entity">Mapping an Entity</a>.
				</p><div class="formalpara"><p class="title"><strong>Example: Entities After Adding Hibernate Search Annotations</strong></p><p>
						
<pre class="programlisting language-java">package example;
...
@Entity

public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @Field(index = Index.YES, analyze=Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</pre>

					</p></div><pre class="programlisting language-java">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {
  }

  // standard getters/setters follow here
  ...
}</pre></section><section class="section" id="indexing"><div class="titlepage"><div><div><h3 class="title">7.3.4. Indexing</h3></div></div></div><p>
					Hibernate Search will transparently index every entity persisted, updated or removed through Hibernate Core. However, you have to create an initial Lucene index for the data already present in your database. Once you have added the above properties and annotations it is time to trigger an initial batch index of your books. You can achieve this by using one of the following code snippets (see also ):
				</p><div class="formalpara"><p class="title"><strong>Example: Using the Hibernate Session to Index Data</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = org.hibernate.search.Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</pre>

					</p></div><div class="formalpara"><p class="title"><strong>Example: Using JPA to Index Data</strong></p><p>
						
<pre class="programlisting language-java">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</pre>

					</p></div><p>
					After executing the above code, you should be able to see a Lucene index under <code class="literal">/var/lucene/indexes/example.Book</code>. Inspect this index with <a class="link mimir-link-warn" href="http://code.google.com/p/luke/" title="Mimir does not include content from: code.google.com">Luke</a> to help you to understand how Hibernate Search works.
				</p></section><section class="section" id="searching"><div class="titlepage"><div><div><h3 class="title">7.3.5. Searching</h3></div></div></div><p>
					To execute a search, create a Lucene query using either the <a class="link" href="#building_a_lucene_query_using_the_lucene_api" title="7.5.1.1. Building a Lucene Query Using the Lucene API">Lucene API</a> or the <a class="link" href="#building_a_lucene_query" title="7.5.1.2. Building a Lucene Query">Hibernate Search query DSL</a>. Wrap the query in a org.hibernate.Query to get the required functionality from the Hibernate API. The following code prepares a query against the indexed fields. Executing the code returns a list of Books.
				</p><div class="formalpara"><p class="title"><strong>Example: Using a Hibernate Search Session to Create and Execute a Search</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity( Book.class ).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name", "publicationDate")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery =
    fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();

tx.commit();
session.close();</pre>

					</p></div><div class="formalpara"><p class="title"><strong>Example: Using JPA to Create and Execute a Search</strong></p><p>
						
<pre class="programlisting language-java">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Book.class ).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name", "publicationDate")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery =
    fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();</pre>

					</p></div></section><section class="section" id="analyzer"><div class="titlepage"><div><div><h3 class="title">7.3.6. Analyzer</h3></div></div></div><p>
					Assuming that the title of an indexed book entity is <code class="literal">Refactoring: Improving the Design of Existing Code</code> and that hits are required for the following queries: <code class="literal">refactor</code>, <code class="literal">refactors</code>, <code class="literal">refactored</code>, and <code class="literal">refactoring</code>. Select an analyzer class in Lucene that applies word stemming when indexing and searching. Hibernate Search offers several ways to configure the analyzer (see <a class="link" href="#default_analyzer_and_analyzer_by_class" title="7.4.3.1. Default Analyzer and Analyzer by Class">Default Analyzer and Analyzer by Class</a> for more information):
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Set the <code class="literal">analyzer</code> property in the configuration file. The specified class becomes the default analyzer.
						</li><li class="listitem">
							Set the <code class="literal">@Analyzer</code> annotation at the entity level.
						</li><li class="listitem">
							Set the <code class="literal">@Analyzer</code> annotation at the field level.
						</li></ul></div><p>
					Specify the fully qualified class name or the analyzer to use, or see an analyzer defined by the <code class="literal">@AnalyzerDef</code> annotation with the <code class="literal">@Analyzer</code> annotation. The Solr analyzer framework with its factories are utilized for the latter option. For more information about factory classes, see the Solr JavaDoc or read the corresponding section on the <a class="link mimir-link-warn" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" title="Mimir does not include content from: wiki.apache.org">Solr Wiki</a>.
				</p><p>
					In the example, a StandardTokenizerFactory is used by two filter factories: LowerCaseFilterFactory and SnowballPorterFilterFactory. The tokenizer splits words at punctuation characters and hyphens but keeping email addresses and internet hostnames intact. The standard tokenizer is ideal for this and other general operations. The lowercase filter converts all letters in the token into lowercase and the snowball filter applies language specific stemming.
				</p><p>
					If using the Solr framework, use the tokenizer with an arbitrary number of filters.
				</p><div class="formalpara"><p class="title"><strong>Example: Using @AnalyzerDef and the Solr Framework to Define and Use an Analyzer</strong></p><p>
						
<pre class="programlisting language-java">@Indexed
@AnalyzerDef(
   name = "customanalyzer",
   tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
   filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = SnowballPorterFilterFactory.class,
         params = { @Parameter(name = "language", value = "English") })
 })
public class Book implements Serializable {

  @Field
  @Analyzer(definition = "customanalyzer")
  private String title;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String subtitle;

  @IndexedEmbedded
  private Set authors = new HashSet();

  @Field(index = Index.YES, analyze = Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</pre>

					</p></div><p>
					Use @AnalyzerDef to define an analyzer, then apply it to entities and properties using @Analyzer. In the example, the <code class="literal">customanalyzer</code> is defined but not applied on the entity. The analyzer is only applied to the <code class="literal">title</code> and <code class="literal">subtitle</code> properties. An analyzer definition is global. Define the analyzer for an entity and reuse the definition for other entities as required.
				</p></section></section><section class="section" id="mapping_entities_to_the_index_structure"><div class="titlepage"><div><div><h2 class="title">7.4. Mapping Entities to the Index Structure</h2></div></div></div><section class="section" id="mapping_an_entity"><div class="titlepage"><div><div><h3 class="title">7.4.1. Mapping an Entity</h3></div></div></div><p>
					All the metadata information required to index entities is described through annotations, so there is no need for XML mapping files. You can still use Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific configuration has to be expressed via annotations.
				</p><section class="section" id="basic_mapping"><div class="titlepage"><div><div><h4 class="title">7.4.1.1. Basic Mapping</h4></div></div></div><p>
						Let us start with the most commonly used annotations for mapping an entity.
					</p><p>
						The Lucene-based Query API uses the following common annotations to map entities:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								@Indexed
							</li><li class="listitem">
								@Field
							</li><li class="listitem">
								@NumericField
							</li><li class="listitem">
								@Id
							</li></ul></div></section><section class="section" id="indexed"><div class="titlepage"><div><div><h4 class="title">7.4.1.2. @Indexed</h4></div></div></div><p>
						Foremost we must declare a persistent class as indexable. This is done by annotating the class with <code class="literal">@Indexed</code> (all entities not annotated with <code class="literal">@Indexed</code> will be ignored by the indexing process):
					</p><pre class="programlisting language-java">@Entity
@Indexed
public class Essay {
...
}</pre><p>
						You can optionally specify the <code class="literal">index</code> attribute of the @Indexed annotation to change the default name of the index.
					</p></section><section class="section" id="field"><div class="titlepage"><div><div><h4 class="title">7.4.1.3. @Field</h4></div></div></div><p>
						For each property (or attribute) of your entity, you have the ability to describe how it will be indexed. The default (no annotation present) means that the property is ignored by the indexing process.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Prior to Hibernate Search 5, numeric field encoding was only chosen if explicitly requested via <code class="literal">@NumericField</code>. As of Hibernate Search 5 this encoding is automatically chosen for numeric types. To avoid numeric encoding you can explicitly specify a non numeric field bridge via <code class="literal">@Field.bridge</code> or <code class="literal">@FieldBridge</code>. The package <code class="literal">org.hibernate.search.bridge.builtin</code> contains a set of bridges which encode numbers as strings, for example <code class="literal">org.hibernate.search.bridge.builtin.IntegerBridge</code>.
						</p></div></div><p>
						<code class="literal">@Field</code> does declare a property as indexed and allows to configure several aspects of the indexing process by setting one or more of the following attributes:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">name</code> : describe under which name, the property should be stored in the Lucene Document. The default value is the property name (following the JavaBeans convention)
							</li><li class="listitem">
								<code class="literal">store</code> : describe whether or not the property is stored in the Lucene index. You can store the value <code class="literal">Store.YES</code> (consuming more space in the index but allowing <a class="link" href="#projection" title="7.5.1.10.5. Projection">projection</a>, store it in a compressed way <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or avoid any storage <code class="literal">Store.NO</code> (this is the default value). When a property is stored, you can retrieve its original value from the Lucene Document. This is not related to whether the element is indexed or not.
							</li><li class="listitem"><p class="simpara">
								<code class="literal">index</code>: describe whether the property is indexed or not. The different values are <code class="literal">Index.NO</code>, meaning that it is not indexed and cannot be found by a query and <code class="literal">Index.YES</code>, meaning that the element gets indexed and is searchable. The default value is <code class="literal">Index.YES</code>. <code class="literal">Index.NO</code> can be useful for cases where a property is not required to be searchable, but should be available for projection.
							</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									<code class="literal">Index.NO</code> in combination with <code class="literal">Analyze.YES</code> or <code class="literal">Norms.YES</code> is not useful, since <code class="literal">analyze</code> and <code class="literal">norms</code> require the property to be indexed
								</p></div></div></li><li class="listitem"><p class="simpara">
								<code class="literal">analyze</code>: determines whether the property is analyzed (<code class="literal">Analyze.YES</code>) or not (<code class="literal">Analyze.NO</code>). The default value is <code class="literal">Analyze.YES</code>.
							</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									Whether or not you want to analyze a property depends on whether you wish to search the element as is, or by the words it contains. It make sense to analyze a text field, but probably not a date field.
								</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									Fields used for sorting <span class="emphasis"><em>must not</em></span> be analyzed.
								</p></div></div></li><li class="listitem">
								<code class="literal">norms</code>: describes whether index time boosting information should be stored (<code class="literal">Norms.YES</code>) or not (<code class="literal">Norms.NO</code>). Not storing it can save a considerable amount of memory, but there will not be any index time boosting information available. The default value is <code class="literal">Norms.YES</code>.
							</li><li class="listitem"><p class="simpara">
								<code class="literal">termVector</code>: describes collections of term-frequency pairs. This attribute enables the storing of the term vectors within the documents during indexing. The default value is <code class="literal">TermVector.NO</code>.
							</p><p class="simpara">
								The different values of this attribute are:
							</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 40%; " class="col_1"><!--Empty--></col><col style="width: 60%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159940563728" scope="col">Value</th><th align="left" valign="top" id="idm140159940562640" scope="col">Definition</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159940563728"> <p>
												TermVector.YES
											</p>
											 </td><td align="left" valign="top" headers="idm140159940562640"> <p>
												Store the term vectors of each document. This produces two synchronized arrays, one contains document terms and the other contains the term’s frequency.
											</p>
											 </td></tr><tr><td align="left" valign="top" headers="idm140159940563728"> <p>
												TermVector.NO
											</p>
											 </td><td align="left" valign="top" headers="idm140159940562640"> <p>
												Do not store term vectors.
											</p>
											 </td></tr><tr><td align="left" valign="top" headers="idm140159940563728"> <p>
												TermVector.WITH_OFFSETS
											</p>
											 </td><td align="left" valign="top" headers="idm140159940562640"> <p>
												Store the term vector and token offset information. This is the same as TermVector.YES plus it contains the starting and ending offset position information for the terms.
											</p>
											 </td></tr><tr><td align="left" valign="top" headers="idm140159940563728"> <p>
												TermVector.WITH_POSITIONS
											</p>
											 </td><td align="left" valign="top" headers="idm140159940562640"> <p>
												Store the term vector and token position information. This is the same as TermVector.YES plus it contains the ordinal positions of each occurrence of a term in a document.
											</p>
											 </td></tr><tr><td align="left" valign="top" headers="idm140159940563728"> <p>
												TermVector.WITH_POSITION_OFFSETS
											</p>
											 </td><td align="left" valign="top" headers="idm140159940562640"> <p>
												Store the term vector, token position and offset information. This is a combination of the YES, WITH_OFFSETS and WITH_POSITIONS.
											</p>
											 </td></tr></tbody></table></div></li><li class="listitem"><p class="simpara">
								<code class="literal">indexNullAs</code> : Per default null values are ignored and not indexed. However, using <code class="literal">indexNullAs</code> you can specify a string which will be inserted as token for the <code class="literal">null</code> value. Per default this value is set to <code class="literal">Field.DO_NOT_INDEX_NULL</code> indicating that <code class="literal">null</code> values should not be indexed. You can set this value to <code class="literal">Field.DEFAULT_NULL_TOKEN</code> to indicate that a default <code class="literal">null</code> token should be used. This default <code class="literal">null</code> token can be specified in the configuration using <code class="literal">hibernate.search.default_null_token</code>. If this property is not set and you specify <code class="literal">Field.DEFAULT_NULL_TOKEN</code> the string "<span class="emphasis"><em>null</em></span>" will be used as default.
							</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									When the <code class="literal">indexNullAs</code> parameter is used it is important to use the same token in the search query to search for <code class="literal">null</code> values. It is also advisable to use this feature only with un-analyzed fields (<code class="literal">Analyze.NO</code>).
								</p></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
									When implementing a custom FieldBridge or TwoWayFieldBridge it is up to the developer to handle the indexing of null values (see JavaDocs of LuceneOptions.indexNullAs()).
								</p></div></div></li></ul></div></section><section class="section" id="numericfield"><div class="titlepage"><div><div><h4 class="title">7.4.1.4. @NumericField</h4></div></div></div><p>
						There is a companion annotation to @Field called @NumericField that can be specified in the same scope as @Field or @DocumentId. It can be specified for Integer, Long, Float, and Double properties. At index time the value will be indexed using a Trie structure. When a property is indexed as numeric field, it enables efficient range query and sorting, orders of magnitude faster than doing the same query on standard @Field properties. The @NumericField annotation accept the following parameters:
					</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 70%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941121616" scope="col">Value</th><th align="left" valign="top" id="idm140159941120528" scope="col">Definition</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941121616"> <p>
										forField
									</p>
									 </td><td align="left" valign="top" headers="idm140159941120528"> <p>
										(Optional) Specify the name of the related @Field that will be indexed as numeric. It is only mandatory when the property contains more than a @Field declaration
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159941121616"> <p>
										precisionStep
									</p>
									 </td><td align="left" valign="top" headers="idm140159941120528"> <p>
										(Optional) Change the way that the Trie structure is stored in the index. Smaller precisionSteps lead to more disk space usage and faster range and sort queries. Larger values lead to less space used and range query performance more close to the range query in normal @Fields. Default value is 4.
									</p>
									 </td></tr></tbody></table></div><p>
						@NumericField supports only Double, Long, Integer and Float. It is not possible to take any advantage from similar functionality in Lucene for the other numeric types, so remaining types should use the string encoding via the default or custom TwoWayFieldBridge.
					</p><p>
						It is possible to use a custom NumericFieldBridge assuming you can deal with the approximation during type transformation:
					</p><div class="formalpara"><p class="title"><strong>Example: Defining a Custom NumericFieldBridge</strong></p><p>
							
<pre class="programlisting language-java">public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
   private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

   @Override
   public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
      if ( value != null ) {
         BigDecimal decimalValue = (BigDecimal) value;
         Long indexedValue = Long.valueOf( decimalValue.multiply( storeFactor ).longValue() );
         luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
      }
   }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }

}</pre>

						</p></div></section><section class="section" id="id"><div class="titlepage"><div><div><h4 class="title">7.4.1.5. @Id</h4></div></div></div><p>
						Finally, the <code class="literal">id</code> (identifier) property of an entity is a special property used by Hibernate Search to ensure index uniqueness of a given entity. By design, an <code class="literal">id</code> must be stored and must not be tokenized. To mark a property as an index identifier, use the <code class="literal">@DocumentId</code> annotation. If you are using JPA and you have specified @Id you can omit @DocumentId. The chosen entity identifier will also be used as the document identifier.
					</p><p>
						Infinispan Query uses the entity’s <code class="literal">id</code> property to ensure the index is uniquely identified. By design, an ID is stored and must not be converted into a token. To mark a property as index ID, use the <code class="literal">@DocumentId</code> annotation.
					</p><div class="formalpara"><p class="title"><strong>Example: Specifying Indexed Properties</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Essay {
    ...
    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES)
    public String getSummary() { return summary; }

    @Lob
    @Field
    public String getText() { return text; }

    @Field @NumericField( precisionStep = 6)
    public float getGrade() { return grade; }
}</pre>

						</p></div><p>
						The example above defines an index with four fields: <code class="literal">id</code> , <code class="literal">Abstract</code>, <code class="literal">text</code> and <code class="literal">grade</code> . Note that by default the field name is not capitalized, following the JavaBean specification. The <code class="literal">grade</code> field is annotated as numeric with a slightly larger precision step than the default.
					</p></section><section class="section" id="mapping_properties_multiple_times"><div class="titlepage"><div><div><h4 class="title">7.4.1.6. Mapping Properties Multiple Times</h4></div></div></div><p>
						Sometimes you need to map a property multiple times per index, with slightly different indexing strategies. For example, sorting a query by field requires the field to be un-analyzed. To search by words on this property and still sort it, it needs to be indexed - once analyzed and once un-analyzed. @Fields allows you to achieve this goal.
					</p><div class="formalpara"><p class="title"><strong>Example: Using @Fields to Map a Property Multiple Times</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed(index = "Book" )
public class Book {
    @Fields( {
            @Field,
            @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
            } )
    public String getSummary() {
        return summary;
    }
    ...
}</pre>

						</p></div><p>
						In this example the field <code class="literal">summary</code> is indexed twice, once as <code class="literal">summary</code> in a tokenized way, and once as <code class="literal">summary_forSort</code> in an untokenized way.
					</p></section><section class="section" id="embedded_and_associated_objects"><div class="titlepage"><div><div><h4 class="title">7.4.1.7. Embedded and Associated Objects</h4></div></div></div><p>
						Associated objects as well as embedded objects can be indexed as part of the root entity index. This is useful if you expect to search a given entity based on properties of associated objects. The aim is to return places where the associated city is Atlanta (In the Lucene query parser language, it would translate into <code class="literal">address.city:Atlanta</code>). The place fields will be indexed in the <code class="literal">Place</code> index. The <code class="literal">Place</code> index documents will also contain the fields <code class="literal">address.id</code>, <code class="literal">address.street</code>, and <code class="literal">address.city</code> which you will be able to query.
					</p><div class="formalpara"><p class="title"><strong>Example: Indexing Associations</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    @IndexedEmbedded
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre>

						</p></div><p>
						Because the data is denormalized in the Lucene index when using the <code class="literal">@IndexedEmbedded</code> technique, Hibernate Search must be aware of any change in the Place object and any change in the Address object to keep the index up to date. To ensure the Lucene document is updated when it is Address changes, mark the other side of the bidirectional relationship with <code class="literal">@ContainedIn</code>.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							<code class="literal">@ContainedIn</code> is useful on both associations pointing to entities and on embedded (collection of) objects.
						</p></div></div><p>
						To expand upon this, the following example demonstrates nesting <code class="literal">@IndexedEmbedded</code>.
					</p><div class="formalpara"><p class="title"><strong>Example: Nested Usage of @IndexedEmbedded and @ContainedIn</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    @IndexedEmbedded
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_")
    private Owner ownedBy;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field
    private String name;
   ...
}</pre>

						</p></div><p>
						Any <code class="literal">@*ToMany</code>, <code class="literal">@*ToOne</code> and <code class="literal">@Embedded</code> attribute can be annotated with <code class="literal">@IndexedEmbedded</code>. The attributes of the associated class will then be added to the main entity index. The index will contain the following fields:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								id
							</li><li class="listitem">
								name
							</li><li class="listitem">
								address.street
							</li><li class="listitem">
								address.city
							</li><li class="listitem">
								address.ownedBy_name
							</li></ul></div><p>
						The default prefix is <code class="literal">propertyName.</code>, following the traditional object navigation convention. You can override it using the <code class="literal">prefix</code> attribute as it is shown on the <code class="literal">ownedBy</code> property.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The prefix cannot be set to an empty string.
						</p></div></div><p>
						The <code class="literal">depth</code> property is necessary when the object graph contains a cyclic dependency of classes (not instances). For example, if Owner points to Place. Hibernate Search will stop including Indexed embedded attributes after reaching the expected depth (or the object graph boundaries are reached). A class having a self reference is an example of cyclic dependency. In our example, because <code class="literal">depth</code> is set to 1, any <code class="literal">@IndexedEmbedded</code> attribute in Owner will be ignored.
					</p><p>
						Using <code class="literal">@IndexedEmbedded</code> for object associations allows you to express queries (using Lucene’s query syntax) such as:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Return places where the name contains JBoss and where the address city is Atlanta. In Lucene query this would be:
							</p><pre class="screen">+name:jboss +address.city:atlanta</pre></li><li class="listitem"><p class="simpara">
								Return places where the name contains JBoss and where the owner’s name contains Joe. In Lucene query this would be
							</p><pre class="screen">+name:jboss +address.ownedBy_name:joe</pre></li></ul></div><p>
						This behavior mimics the relational join operation in a more efficient way (at the cost of data duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join operation does not exist. It might help to keep the relational model normalized while benefiting from the full text index speed and feature richness.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							An associated object can itself (but does not have to) be <code class="literal">@Indexed</code>
						</p></div></div><p>
						When <code class="literal">@IndexedEmbedded</code> points to an entity, the association has to be directional and the other side has to be annotated <code class="literal">@ContainedIn</code> (as seen in the previous example). If not, Hibernate Search has no way to update the root index when the associated entity is updated (in our example, a <code class="literal">Place</code> index document has to be updated when the associated Address instance is updated).
					</p><p>
						Sometimes, the object type annotated by <code class="literal">@IndexedEmbedded</code> is not the object type targeted by Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of their implementation. For this reason you can override the object type targeted by Hibernate Search using the <code class="literal">targetElement</code> parameter.
					</p><div class="formalpara"><p class="title"><strong>Example: Using the targetElement Property of @IndexedEmbedded</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", )
    @Target(Owner.class)
    private Person ownedBy;
    ...
}

@Embeddable
public class Owner implements Person { ... }</pre>

						</p></div></section><section class="section" id="limiting_object_embedding_to_specific_paths"><div class="titlepage"><div><div><h4 class="title">7.4.1.8. Limiting Object Embedding to Specific Paths</h4></div></div></div><p>
						The @IndexedEmbedded annotation provides also an attribute includePaths which can be used as an alternative to depth, or be combined with it.
					</p><p>
						When using only depth all indexed fields of the embedded type will be added recursively at the same depth. This makes it harder to select only a specific path without adding all other fields as well, which might not be needed.
					</p><p>
						To avoid unnecessarily loading and indexing entities you can specify exactly which paths are needed. A typical application might need different depths for different paths, or in other words it might need to specify paths explicitly, as shown in the example below:
					</p><div class="formalpara"><p class="title"><strong>Example: Using the includePaths Property of @IndexedEmbedded</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(includePaths = { "name" })
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</pre>

						</p></div><p>
						Using a mapping as in the example above, you would be able to search on a Person by <code class="literal">name</code> and/or <code class="literal">surname</code>, and/or the <code class="literal">name</code> of the parent. It will not index the <code class="literal">surname</code> of the parent, so searching on parent’s surnames will not be possible but speeds up indexing, saves space and improve overall performance.
					</p><p>
						The @IndexedEmbeddedincludePaths will include the specified paths <span class="emphasis"><em>in addition to</em></span> what you would index normally specifying a limited value for depth. When using includePaths, and leaving depth undefined, behavior is equivalent to setting depth=0: only the included paths are indexed.
					</p><div class="formalpara"><p class="title"><strong>Example: Using the includePaths Property of @IndexedEmbedded</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    ...//other fields omitted</pre>

						</p></div><p>
						In the example above, every human will have its name and surname attributes indexed. The name and surname of parents will also be indexed, recursively up to second line because of the depth attribute. It will be possible to search by name or surname, of the person directly, his parents or of his grand parents. Beyond the second level, we will in addition index one more level but only the name, not the surname.
					</p><p>
						This results in the following fields in the index:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">id</code>: as primary key
							</li><li class="listitem">
								<code class="literal">_hibernate_class</code>: stores entity type
							</li><li class="listitem">
								<code class="literal">name</code>: as direct field
							</li><li class="listitem">
								<code class="literal">surname</code>: as direct field
							</li><li class="listitem">
								<code class="literal">parents.name</code>: as embedded field at depth 1
							</li><li class="listitem">
								<code class="literal">parents.surname</code>: as embedded field at depth 1
							</li><li class="listitem">
								<code class="literal">parents.parents.name</code>: as embedded field at depth 2
							</li><li class="listitem">
								<code class="literal">parents.parents.surname</code>: as embedded field at depth 2
							</li><li class="listitem">
								<code class="literal">parents.parents.parents.name</code>: as additional path as specified by includePaths. The first <code class="literal">parents.</code> is inferred from the field name, the remaining path is the attribute of includePaths
							</li></ul></div><p>
						Having explicit control of the indexed paths might be easier if you are designing your application by defining the needed queries first, as at that point you might know exactly which fields you need, and which other fields are unnecessary to implement your use case.
					</p></section></section><section class="section" id="boosting"><div class="titlepage"><div><div><h3 class="title">7.4.2. Boosting</h3></div></div></div><p>
					Lucene has the notion of <span class="emphasis"><em>boosting</em></span> which allows you to give certain documents or fields more or less importance than others. Lucene differentiates between index and search time boosting. The following sections show you how you can achieve index time boosting using Hibernate Search.
				</p><section class="section" id="static_index_time_boosting"><div class="titlepage"><div><div><h4 class="title">7.4.2.1. Static Index Time Boosting</h4></div></div></div><p>
						To define a static boost value for an indexed class or property you can use the <code class="literal">@Boost</code> annotation. You can use this annotation within <code class="literal">@Field</code> or specify it directly on method or class level.
					</p><div class="formalpara"><p class="title"><strong>Example: Different Ways of Using @Boost</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed

public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=@Boost(2f))
    @Boost(1.5f)
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=@Boost(1.2f))
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }
}</pre>

						</p></div><p>
						In the example above, Essay’s probability to reach the top of the search list will be multiplied by 1.7. The summary field will be 3.0 (2 * 1.5, because @Field.boost and @Boost on a property are cumulative) more important than the isbn field. The text field will be 1.2 times more important than the isbn field. Note that this explanation is wrong in strictest terms, but it is simple and close enough to reality for all practical purposes.
					</p></section><section class="section" id="dynamic_index_time_boosting"><div class="titlepage"><div><div><h4 class="title">7.4.2.2. Dynamic Index Time Boosting</h4></div></div></div><p>
						The <code class="literal">@Boost</code> annotation used in <a class="link" href="#static_index_time_boosting" title="7.4.2.1. Static Index Time Boosting">Static Index Time Boosting</a> defines a static boost factor which is independent of the state of the indexed entity at runtime. However, there are use cases in which the boost factor may depend on the actual state of the entity. In this case you can use the <code class="literal">@DynamicBoost</code> annotation together with an accompanying custom BoostStrategy.
					</p><div class="formalpara"><p class="title"><strong>Example: Dynamic Boost</strong></p><p>
							
<pre class="programlisting language-java">public enum PersonType {
    NORMAL,
    VIP
}

@Entity
@Indexed
@DynamicBoost(impl = VIPBoostStrategy.class)
public class Person {
    private PersonType type;

    // ....
}

public class VIPBoostStrategy implements BoostStrategy {
    public float defineBoost(Object value) {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</pre>

						</p></div><p>
						In the example above, a dynamic boost is defined on class level specifying VIPBoostStrategy as implementation of the BoostStrategy interface to be used at indexing time. You can place the <code class="literal">@DynamicBoost</code> either at class or field level. Depending on the placement of the annotation either the whole entity is passed to the defineBoost method or just the annotated field/property value. It is up to you to cast the passed object to the correct type. In the example all indexed values of a VIP person would be double as important as the values of a normal person.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The specified BoostStrategy implementation must define a public no-arg constructor.
						</p></div></div><p>
						Of course you can mix and match <code class="literal">@Boost</code> and <code class="literal">@DynamicBoost</code> annotations in your entity. All defined boost factors are cumulative.
					</p></section></section><section class="section" id="analysis"><div class="titlepage"><div><div><h3 class="title">7.4.3. Analysis</h3></div></div></div><p>
					<code class="literal">Analysis</code> is the process of converting text into single terms (words) and can be considered as one of the key features of a full-text search engine. Lucene uses the concept of Analyzers to control this process. In the following section we cover the multiple ways Hibernate Search offers to configure the analyzers.
				</p><section class="section" id="default_analyzer_and_analyzer_by_class"><div class="titlepage"><div><div><h4 class="title">7.4.3.1. Default Analyzer and Analyzer by Class</h4></div></div></div><p>
						The default analyzer class used to index tokenized fields is configurable through the <code class="literal">hibernate.search.analyzer</code> property. The default value for this property is <code class="literal">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.
					</p><p>
						You can also define the analyzer class per entity, property and even per @Field (useful when multiple fields are indexed from a single property).
					</p><div class="formalpara"><p class="title"><strong>Example: Different Ways of Using @Analyzer</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
@Analyzer(impl = EntityAnalyzer.class)
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    @Analyzer(impl = PropertyAnalyzer.class)
    private String summary;

    @Field(analyzer = @Analyzer(impl = FieldAnalyzer.class)
    private String body;
    ...
}</pre>

						</p></div><p>
						In this example, EntityAnalyzer is used to index tokenized property (<code class="literal">name</code>), except <code class="literal">summary</code> and <code class="literal">body</code> which are indexed with PropertyAnalyzer and FieldAnalyzer respectively.
					</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							Mixing different analyzers in the same entity is most of the time a bad practice. It makes query building more complex and results less predictable (for the novice), especially if you are using a QueryParser (which uses the same analyzer for the whole query). As a rule of thumb, for any given field the same analyzer should be used for indexing and querying.
						</p></div></div></section><section class="section" id="named_analyzers"><div class="titlepage"><div><div><h4 class="title">7.4.3.2. Named Analyzers</h4></div></div></div><p>
						Analyzers can become quite complex to deal with. For this reason introduces Hibernate Search the notion of analyzer definitions. An analyzer definition can be reused by many @Analyzer declarations and is composed of:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<span class="strong strong"><strong>a name:</strong></span> the unique string used to refer to the definition
							</li><li class="listitem">
								<span class="strong strong"><strong>a list of char filters:</strong></span> each char filter is responsible to pre-process input characters before the tokenization. Char filters can add, change, or remove characters; one common usage is for characters normalization
							</li><li class="listitem">
								<span class="strong strong"><strong>a tokenizer:</strong></span> responsible for tokenizing the input stream into individual words
							</li><li class="listitem">
								<span class="strong strong"><strong>a list of filters:</strong></span> each filter is responsible to remove, modify, or sometimes even add words into the stream provided by the tokenizer
							</li></ul></div><p>
						This separation of tasks - a list of char filters, and a tokenizer followed by a list of filters - allows for easy reuse of each individual component and lets you build your customized analyzer in a very flexible way (like Lego). Generally speaking the char filters do some pre-processing in the character input, then the Tokenizer starts the tokenizing process by turning the character input into tokens which are then further processed by the TokenFilters. Hibernate Search supports this infrastructure by utilizing the Solr analyzer framework.
					</p><p>
						Let us review a concrete example stated below. First a char filter is defined by its factory. In our example, a mapping char filter is used, and will replace characters in the input based on the rules specified in the mapping file. Next a tokenizer is defined. This example uses the standard tokenizer. Last but not least, a list of filters is defined by their factories. In our example, the StopFilter filter is built reading the dedicated words property file. The filter is also expected to ignore case.
					</p><div class="formalpara"><p class="title"><strong>Example: @AnalyzerDef and the Solr Framework</strong></p><p>
							
<pre class="programlisting language-java">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    ...
}</pre>

						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Filters and char filters are applied in the order they are defined in the @AnalyzerDef annotation. Order matters!
						</p></div></div><p>
						Some tokenizers, token filters or char filters load resources like a configuration or metadata file. This is the case for the stop filter and the synonym filter. If the resource charset is not using the VM default, you can explicitly specify it by adding a <code class="literal">resource_charset</code> parameter.
					</p><div class="formalpara"><p class="title"><strong>Example: Use a Specific Charset to Load the Property File</strong></p><p>
							
<pre class="programlisting language-java">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
      @Parameter(name="resource_charset", value = "UTF-16BE"),
      @Parameter(name="ignoreCase", value="true")
  })
})
public class Team {
    ...
}</pre>

						</p></div><p>
						Once defined, an analyzer definition can be reused by an @Analyzer declaration as seen in the following example.
					</p><div class="formalpara"><p class="title"><strong>Example: Referencing an Analyzer by Name</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field
    @Analyzer(definition = "customanalyzer")
    private String description;
}</pre>

						</p></div><p>
						Analyzer instances declared by @AnalyzerDef are also available by their name in the SearchFactory which is quite useful when building queries.
					</p><pre class="programlisting language-java">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><p>
						Fields in queries must be analyzed with the same analyzer used to index the field so that they speak a common "language": the same tokens are reused between the query and the indexing process. This rule has some exceptions but is true most of the time. Respect it unless you know what you are doing.
					</p></section><section class="section" id="available_analyzers"><div class="titlepage"><div><div><h4 class="title">7.4.3.3. Available Analyzers</h4></div></div></div><p>
						Solr and Lucene come with many useful default char filters, tokenizers, and filters. You can find a complete list of char filter factories, tokenizer factories and filter factories at <a class="link mimir-link-warn" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" title="Mimir does not include content from: wiki.apache.org">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>. Let us check a few of them.
					</p><div class="table" id="idm140159940678848"><p class="title"><strong>Table 7.8. Available Char Filters</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 40%; " class="col_2"><!--Empty--></col><col style="width: 30%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159940673088" scope="col">Factory</th><th align="left" valign="top" id="idm140159940672000" scope="col">Description</th><th align="left" valign="top" id="idm140159940670912" scope="col">Parameters</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159940673088"> <p>
										MappingCharFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940672000"> <p>
										Replaces one or more characters with one or more characters, based on mappings specified in the resource file
									</p>
									 </td><td align="left" valign="top" headers="idm140159940670912"> <p>
										<code class="literal">mapping</code>: points to a resource file containing the mappings using the format: "á" ⇒ "a"; "ñ" ⇒ "n"; "ø" ⇒ "o"
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159940673088"> <p>
										HTMLStripCharFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940672000"> <p>
										Remove HTML standard tags, keeping the text
									</p>
									 </td><td align="left" valign="top" headers="idm140159940670912"> <p>
										none
									</p>
									 </td></tr></tbody></table></div></div><div class="table" id="idm140159944475328"><p class="title"><strong>Table 7.9. Available Tokenizers</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 40%; " class="col_2"><!--Empty--></col><col style="width: 30%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159944469568" scope="col">Factory</th><th align="left" valign="top" id="idm140159944468480" scope="col">Description</th><th align="left" valign="top" id="idm140159944467392" scope="col">Parameters</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159944469568"> <p>
										StandardTokenizerFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159944468480"> <p>
										Use the Lucene StandardTokenizer
									</p>
									 </td><td align="left" valign="top" headers="idm140159944467392"> <p>
										none
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159944469568"> <p>
										HTMLStripCharFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159944468480"> <p>
										Remove HTML tags, keep the text and pass it to a StandardTokenizer.
									</p>
									 </td><td align="left" valign="top" headers="idm140159944467392"> <p>
										none
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159944469568"> <p>
										PatternTokenizerFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159944468480"> <p>
										Breaks text at the specified regular expression pattern.
									</p>
									 </td><td align="left" valign="top" headers="idm140159944467392"> <p>
										<span class="strong strong"><strong>pattern</strong></span>: the regular expression to use for tokenizing
									</p>
									 <p>
										<span class="strong strong"><strong>group</strong></span>: says which pattern group to extract into tokens
									</p>
									 </td></tr></tbody></table></div></div><div class="table" id="idm140159940712352"><p class="title"><strong>Table 7.10. Available Filters</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 40%; " class="col_2"><!--Empty--></col><col style="width: 30%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159940706592" scope="col">Factory</th><th align="left" valign="top" id="idm140159940705504" scope="col">Description</th><th align="left" valign="top" id="idm140159940704416" scope="col">Parameters</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159940706592"> <p>
										StandardFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940705504"> <p>
										Remove dots from acronyms and 's from words
									</p>
									 </td><td align="left" valign="top" headers="idm140159940704416"> <p>
										none
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159940706592"> <p>
										LowerCaseFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940705504"> <p>
										Lowercases all words
									</p>
									 </td><td align="left" valign="top" headers="idm140159940704416"> <p>
										none
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159940706592"> <p>
										StopFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940705504"> <p>
										Remove words (tokens) matching a list of stop words
									</p>
									 </td><td align="left" valign="top" headers="idm140159940704416"> <p>
										<span class="strong strong"><strong>words</strong></span>: points to a resource file containing the stop words
									</p>
									 <p>
										<span class="strong strong"><strong>ignoreCase</strong></span>: true if case should be ignored when comparing stop words, false otherwise
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159940706592"> <p>
										SnowballPorterFilterFactory
									</p>
									 </td><td align="left" valign="top" headers="idm140159940705504"> <p>
										Reduces a word to its root in a given language. (example: protect, protects, protection share the same root). Using such a filter allows searches matching related words.
									</p>
									 </td><td align="left" valign="top" headers="idm140159940704416"> <p>
										<code class="literal">language</code>: Danish, Dutch, English, Finnish, French, German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish and a few more
									</p>
									 </td></tr></tbody></table></div></div><p>
						We recommend to check all the implementations of <code class="literal">org.apache.lucene.analysis.TokenizerFactory</code> and <code class="literal">org.apache.lucene.analysis.TokenFilterFactory</code> in your IDE to see the implementations available.
					</p></section><section class="section" id="dynamic_analyzer_selection"><div class="titlepage"><div><div><h4 class="title">7.4.3.4. Dynamic Analyzer Selection</h4></div></div></div><p>
						So far all the introduced ways to specify an analyzer were static. However, there are use cases where it is useful to select an analyzer depending on the current state of the entity to be indexed, for example in a multilingual applications. For an BlogEntry class for example the analyzer could depend on the language property of the entry. Depending on this property the correct language specific stemmer should be chosen to index the actual text.
					</p><p>
						To enable this dynamic analyzer selection Hibernate Search introduces the AnalyzerDiscriminator annotation. Following example demonstrates the usage of this annotation.
					</p><div class="formalpara"><p class="title"><strong>Example: Usage of @AnalyzerDiscriminator</strong></p><p>
							
<pre class="programlisting language-java">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;

    @Field
    private String text;

    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre>

						</p></div><pre class="programlisting language-java">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof BlogEntry ) ) {
            return null;
        }
        return (String) value;

    }
}</pre><p>
						The prerequisite for using <code class="literal">@AnalyzerDiscriminator</code> is that all analyzers which are going to be used dynamically are predefined via <code class="literal">@AnalyzerDef</code> definitions. If this is the case, one can place the <code class="literal">@AnalyzerDiscriminator</code> annotation either on the class or on a specific property of the entity for which to dynamically select an analyzer. Via the <code class="literal">impl</code> parameter of the <code class="literal">AnalyzerDiscriminator</code> you specify a concrete implementation of the Discriminator interface. It is up to you to provide an implementation for this interface. The only method you have to implement is <code class="literal">getAnalyzerDefinitionName()</code> which gets called for each field added to the Lucene document. The entity which is getting indexed is also passed to the interface method. The <code class="literal">value</code> parameter is only set if the <code class="literal">AnalyzerDiscriminator</code> is placed on property level instead of class level. In this case the value represents the current value of this property.
					</p><p>
						An implementation of the Discriminator interface has to return the name of an existing analyzer definition or null if the default analyzer should not be overridden. The example above assumes that the language parameter is either 'de' or 'en' which matches the specified names in the <code class="literal">@AnalyzerDefs</code>.
					</p></section><section class="section" id="retrieving_an_analyzer"><div class="titlepage"><div><div><h4 class="title">7.4.3.5. Retrieving an Analyzer</h4></div></div></div><p>
						Retrieving an analyzer can be used when multiple analyzers have been used in a domain model, in order to benefit from stemming or phonetic approximation, etc. In this case, use the same analyzers to building a query. Alternatively, use the Hibernate Search query DSL, which selects the correct analyzer automatically. See
					</p><p>
						Whether you are using the Lucene programmatic API or the Lucene query parser, you can retrieve the scoped analyzer for a given entity. A scoped analyzer is an analyzer which applies the right analyzers depending on the field indexed. Remember, multiple analyzers can be defined on a given entity each one working on an individual field. A scoped analyzer unifies all these analyzers into a context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is very easy.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							When you use programmatic mapping for a child entity, you can only see the fields defined by the child entity. Fields or methods inherited from a parent entity (annotated with @MappedSuperclass) are not configurable. To configure properties inherited from a parent entity, either override the property in the child entity or create a programmatic mapping for the parent entity. This mimics the usage of annotations where you cannot annotate a field or method of a parent entity unless it is redefined in the child entity.
						</p></div></div><div class="formalpara"><p class="title"><strong>Example: Using the Scoped Analyzer When Building a Full-text Query</strong></p><p>
							
<pre class="programlisting language-java">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title",
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery =
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</pre>

						</p></div><p>
						In the example above, the song title is indexed in two fields: the standard analyzer is used in the field <code class="literal">title</code> and a stemming analyzer is used in the field <code class="literal">title_stemmed</code>. By using the analyzer provided by the search factory, the query uses the appropriate analyzer depending on the field targeted.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							You can also retrieve analyzers defined via @AnalyzerDef by their definition name using <code class="literal">searchFactory.getAnalyzer(String)</code>.
						</p></div></div></section></section><section class="section" id="bridges"><div class="titlepage"><div><div><h3 class="title">7.4.4. Bridges</h3></div></div></div><p>
					When discussing the basic mapping for an entity one important fact was so far disregarded. In Lucene all index fields have to be represented as strings. All entity properties annotated with <code class="literal">@Field</code> have to be converted to strings to be indexed. The reason we have not mentioned it so far is, that for most of your properties Hibernate Search does the translation job for you thanks to set of built-in bridges. However, in some cases you need a more fine grained control over the translation process.
				</p><section class="section" id="built_in_bridges"><div class="titlepage"><div><div><h4 class="title">7.4.4.1. Built-in Bridges</h4></div></div></div><p>
						Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its full text representation.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">null</span></dt><dd>
									Per default <code class="literal">null</code> elements are not indexed. Lucene does not support null elements. However, in some situation it can be useful to insert a custom token representing the <code class="literal">null</code> value. See for more information.
								</dd><dt><span class="term">java.lang.String</span></dt><dd>
									Strings are indexed as are short, Short, integer, Integer, long, Long, float, Float, double,
								</dd><dt><span class="term">Double, BigInteger, BigDecimal</span></dt><dd><p class="simpara">
									Numbers are converted into their string representation. Note that numbers cannot be compared by Lucene (that is, used in ranged queries) out of the box: they have to be padded.
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										Using a Range query has drawbacks, an alternative approach is to use a Filter query which will filter the result query to the appropriate range. Hibernate Search also supports the use of a custom StringBridge as described in <a class="link" href="#custom_bridges" title="7.4.4.2. Custom Bridges">Custom Bridges</a>.
									</p></div></div></dd><dt><span class="term">java.util.Date</span></dt><dd><p class="simpara">
									Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You should not really bother with the internal format. What is important is that when using a TermRangeQuery, you should know that the dates have to be expressed in GMT time.
								</p><p class="simpara">
									Usually, storing the date up to the millisecond is not necessary. <code class="literal">@DateBridge</code> defines the appropriate resolution you are willing to store in the index (<code class="literal">@DateBridge(resolution=Resolution.DAY)</code>). The date pattern will then be truncated accordingly.
								</p></dd></dl></div><pre class="programlisting language-java">@Entity
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)

    private Date date;
    ...</pre><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							A Date whose resolution is lower than <code class="literal">MILLISECOND</code> cannot be a <code class="literal">@DocumentId</code>.
						</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							The default Date bridge uses Lucene’s DateTools to convert from and to String. This means that all dates are expressed in GMT time. If your requirements are to store dates in a fixed time zone you have to implement a custom date bridge. Make sure you understand the requirements of your applications regarding to date indexing and searching.
						</p></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">java.net.URI, java.net.URL</span></dt><dd>
									URI and URL are converted to their string representation.
								</dd><dt><span class="term">java.lang.Class</span></dt><dd>
									Class are converted to their fully qualified class name. The thread context class loader is used when the class is rehydrated.
								</dd></dl></div></section><section class="section" id="custom_bridges"><div class="titlepage"><div><div><h4 class="title">7.4.4.2. Custom Bridges</h4></div></div></div><p>
						Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the String representation used by the bridge does not meet your requirements. The following paragraphs describe several solutions to this problem.
					</p><section class="section" id="stringbridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.1. StringBridge</h5></div></div></div><p>
							The simplest custom solution is to give Hibernate Search an implementation of your expected Object to String bridge. To do so you need to implement the <code class="literal">org.hibernate.search.bridge.StringBridge</code> interface. All implementations have to be thread-safe as they are used concurrently.
						</p><div class="formalpara"><p class="title"><strong>Example: Custom StringBridge Implementation</strong></p><p>
								
<pre class="programlisting language-java">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements StringBridge {

    private int PADDING = 5;

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</pre>

							</p></div><p>
							Given the string bridge defined in the previous example, any property or field can use this bridge thanks to the <code class="literal">@FieldBridge</code> annotation:
						</p><pre class="programlisting language-java">@FieldBridge(impl = PaddedIntegerBridge.class)
private Integer length;</pre></section><section class="section" id="parameterized_bridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.2. Parameterized Bridge</h5></div></div></div><p>
							Parameters can also be passed to the bridge implementation making it more flexible. Following example implements a ParameterizedBridge interface and parameters are passed through the <code class="literal">@FieldBridge</code> annotation.
						</p><div class="formalpara"><p class="title"><strong>Example: Passing Parameters to Your Bridge Implementation</strong></p><p>
								
<pre class="programlisting language-java">public class PaddedIntegerBridge implements StringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map&lt;String,String&gt; parameters) {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
            )
private Integer length;</pre>

							</p></div><p>
							The <code class="literal">ParameterizedBridge</code> interface can be implemented by <code class="literal">StringBridge</code>, <code class="literal">TwoWayStringBridge</code>, <code class="literal">FieldBridge</code> implementations.
						</p><p>
							All implementations have to be thread-safe, but the parameters are set during initialization and no special care is required at this stage.
						</p></section><section class="section" id="type_away_bridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.3. Type Aware Bridge</h5></div></div></div><p>
							It is sometimes useful to get the type the bridge is applied on:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									the return type of the property for field/getter-level bridges.
								</li><li class="listitem">
									the class type for class-level bridges.
								</li></ul></div><p>
							An example is a bridge that deals with enums in a custom fashion but needs to access the actual enum type. Any bridge implementing AppliedOnTypeAwareBridge will get the type the bridge is applied on injected. Like parameters, the type injected needs no particular care with regard to thread-safety.
						</p></section><section class="section" id="two_way_bridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.4. Two-Way Bridge</h5></div></div></div><p>
							If you expect to use your bridge implementation on an id property (that is, annotated with <code class="literal">@DocumentId</code> ), you need to use a slightly extended version of <code class="literal">StringBridge</code> named TwoWayStringBridge. Hibernate Search needs to read the string representation of the identifier and generate the object out of it. There is no difference in the way the <code class="literal">@FieldBridge</code> annotation is used.
						</p><div class="formalpara"><p class="title"><strong>Example: Implementing a TwoWayStringBridge Usable for id Properties</strong></p><p>
								
<pre class="programlisting language-java">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    public Object stringToObject(String stringValue) {
        return new Integer(stringValue);
    }
}

//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
private Integer id;</pre>

							</p></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								It is important for the two-way process to be idempotent (i.e., object = stringToObject( objectToString( object ) ) ).
							</p></div></div></section><section class="section" id="fieldbridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.5. FieldBridge</h5></div></div></div><p>
							Some use cases require more than a simple object to string translation when mapping a property to a Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a FieldBridge. This interface gives you a property value and let you map it the way you want in your Lucene Document. You can for example store a property in two different document fields. The interface is very similar in its concept to the Hibernate UserTypes.
						</p><div class="formalpara"><p class="title"><strong>Example: Implementing the FieldBridge Interface</strong></p><p>
								
<pre class="programlisting language-java">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);

        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );

        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );

        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}

//property
@FieldBridge(impl = DateSplitBridge.class)
private Date date;</pre>

							</p></div><p>
							In the example above, the fields are not added directly to Document. Instead the addition is delegated to the LuceneOptions helper; this helper will apply the options you have selected on <code class="literal">@Field</code>, like <code class="literal">Store</code> or <code class="literal">TermVector</code>, or apply the chosen @Boost value. It is especially useful to encapsulate the complexity of <code class="literal">COMPRESS</code> implementations. Even though it is recommended to delegate to LuceneOptions to add fields to the Document, nothing stops you from editing the Document directly and ignore the LuceneOptions in case you need to.
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Classes like LuceneOptions are created to shield your application from changes in Lucene API and simplify your code. Use them if you can, but if you need more flexibility you are not required to.
							</p></div></div></section><section class="section" id="classbridge"><div class="titlepage"><div><div><h5 class="title">7.4.4.2.6. ClassBridge</h5></div></div></div><p>
							It is sometimes useful to combine more than one property of a given entity and index this combination in a specific way into the Lucene index. The <code class="literal">@ClassBridge</code> and <code class="literal">@ClassBridges</code> annotations can be defined at the class level, as opposed to the property level. In this case the custom field bridge implementation receives the entity instance as the value parameter instead of a particular property. Though not shown in following example, <code class="literal">@ClassBridge</code> supports the <code class="literal">termVector</code> attribute discussed in the <a class="link" href="#basic_mapping" title="7.4.1.1. Basic Mapping">Basic Mapping</a> section.
						</p><div class="formalpara"><p class="title"><strong>Example: Implementing a Class Bridge</strong></p><p>
								
<pre class="programlisting language-java">@Entity
@Indexed
(name="branchnetwork",
             store=Store.YES,
             impl = CatFieldsClassBridge.class,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}

public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    public void set( String name, Object value, Document document, LuceneOptions luceneOptions) {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</pre>

							</p></div><p>
							In this example, the particular <code class="literal">CatFieldsClassBridge</code> is applied to the <code class="literal">department</code> instance, the field bridge then concatenate both branch and network and index the concatenation.
						</p></section></section></section></section><section class="section" id="querying"><div class="titlepage"><div><div><h2 class="title">7.5. Querying</h2></div></div></div><p>
				Hibernate Search can execute Lucene queries and retrieve domain objects managed by an InfinispanHibernate session. The search provides the power of Lucene without leaving the Hibernate paradigm, giving another dimension to the Hibernate classic search mechanisms (HQL, Criteria query, native SQL query).
			</p><p>
				Preparing and executing a query consists of following four steps:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Creating a FullTextSession
					</li><li class="listitem">
						Creating a Lucene query using either Hibernate QueryHibernate Search query DSL (recommended) or using the Lucene Query API
					</li><li class="listitem">
						Wrapping the Lucene query using an org.hibernate.Query
					</li><li class="listitem">
						Executing the search by calling for example list() or scroll()
					</li></ul></div><p>
				To access the querying facilities, use a FullTextSession. This Search-specific session wraps a regular org.hibernate.Session in order to provide query and indexing capabilities.
			</p><div class="formalpara"><p class="title"><strong>Example: Creating a FullTextSession</strong></p><p>
					
<pre class="programlisting language-java">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);</pre>

				</p></div><p>
				Use the FullTextSession to build a full-text query using either the Hibernate Search query DSL or the native Lucene query.
			</p><p>
				Use the following code when using the Hibernate Search query DSL:
			</p><pre class="programlisting language-java">final QueryBuilder b = fullTextSession.getSearchFactory().buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );
List result = fullTextQuery.list(); //return a list of managed objects</pre><p>
				As an alternative, write the Lucene query using either the Lucene query parser or the Lucene programmatic API.
			</p><div class="formalpara"><p class="title"><strong>Example: Creating a Lucene Query Using the QueryParser</strong></p><p>
					
<pre class="programlisting language-java">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryParser.QueryParser parser =
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class) );
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse( "history:storm^3" );
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</pre>

				</p></div><p>
				A Hibernate query built on the Lucene query is a org.hibernate.Query. This query remains in the same paradigm as other Hibernate query facilities, such as HQL (Hibernate Query Language), Native, and Criteria. Use methods such as list(), uniqueResult(), iterate() and scroll() with the query.
			</p><p>
				The same extensions are available with the Hibernate Java Persistence APIs:
			</p><div class="formalpara"><p class="title"><strong>Example: Creating a Search Query Using the JPA API</strong></p><p>
					
<pre class="programlisting language-java">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
final QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );

List result = fullTextQuery.getResultList(); //return a list of managed objects</pre>

				</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					In these examples, the Hibernate API has been used. The same examples can also be written with the Java Persistence API by adjusting the way the <code class="literal">FullTextQuery</code> is retrieved.
				</p></div></div><section class="section" id="building_queries"><div class="titlepage"><div><div><h3 class="title">7.5.1. Building Queries</h3></div></div></div><p>
					Hibernate Search queries are built on Lucene queries, allowing users to use any Lucene query type. When the query is built, Hibernate Search uses org.hibernate.Query as the query manipulation API for further query processing.
				</p><section class="section" id="building_a_lucene_query_using_the_lucene_api"><div class="titlepage"><div><div><h4 class="title">7.5.1.1. Building a Lucene Query Using the Lucene API</h4></div></div></div><p>
						With the Lucene API, use either the query parser (simple queries) or the Lucene programmatic API (complex queries). Building a Lucene query is out of scope for the Hibernate Search documentation. For details, see the online Lucene documentation or a copy of <span class="emphasis"><em>Lucene in Action</em></span> or <span class="emphasis"><em>Hibernate Search in Action</em></span>.
					</p></section><section class="section" id="building_a_lucene_query"><div class="titlepage"><div><div><h4 class="title">7.5.1.2. Building a Lucene Query</h4></div></div></div><p>
						The Lucene programmatic API enables full-text queries. However, when using the Lucene programmatic API, the parameters must be converted to their string equivalent and must also apply the correct analyzer to the right field. A ngram analyzer for example uses several ngrams as the tokens for a given word and should be searched as such. It is recommended to use the QueryBuilder for this task.
					</p><p>
						The Hibernate Search query API is fluent, with the following key characteristics:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Method names are in English. As a result, API operations can be read and understood as a series of English phrases and instructions.
							</li><li class="listitem">
								It uses IDE autocompletion which helps possible completions for the current input prefix and allows the user to choose the right option.
							</li><li class="listitem">
								It often uses the chaining method pattern.
							</li><li class="listitem">
								It is easy to use and read the API operations.
							</li></ul></div><p>
						To use the API, first create a query builder that is attached to a given <code class="literal">indexedentitytype</code>. This QueryBuilder knows what analyzer to use and what field bridge to apply. Several QueryBuilders (one for each entity type involved in the root of your query) can be created. The QueryBuilder is derived from the SearchFactory.
					</p><pre class="programlisting language-java">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</pre><p>
						The analyzer used for a given field or fields can also be overridden.
					</p><pre class="programlisting language-java">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</pre><p>
						The query builder is now used to build Lucene queries. Customized queries generated using Lucene’s query parser or Query objects assembled using the Lucene programmatic API are used with the Hibernate Search DSL.
					</p></section><section class="section" id="keyword_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.3. Keyword Queries</h4></div></div></div><p>
						The following example shows how to search for a specific word:
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</pre><div class="table" id="idm140159941142368"><p class="title"><strong>Table 7.11. Keyword Query Parameters</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 70%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941137520" scope="col">Parameter</th><th align="left" valign="top" id="idm140159941136432" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941137520"> <p>
										keyword()
									</p>
									 </td><td align="left" valign="top" headers="idm140159941136432"> <p>
										Use this parameter to find a specific word.
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159941137520"> <p>
										onField()
									</p>
									 </td><td align="left" valign="top" headers="idm140159941136432"> <p>
										Use this parameter to specify in which lucene field to search the word.
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159941137520"> <p>
										matching()
									</p>
									 </td><td align="left" valign="top" headers="idm140159941136432"> <p>
										Use this parameter to specify the match for search string
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159941137520"> <p>
										createQuery()
									</p>
									 </td><td align="left" valign="top" headers="idm140159941136432"> <p>
										Creates the Lucene query object.
									</p>
									 </td></tr></tbody></table></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The value "storm" is passed through the <code class="literal">history</code> FieldBridge. This is useful when numbers or dates are involved.
							</li><li class="listitem">
								The field bridge value is then passed to the analyzer used to index the field <code class="literal">history</code>. This ensures that the query uses the same term transformation than the indexing (lower case, ngram, stemming and so on). If the analyzing process generates several terms for a given word, a boolean query is used with the <code class="literal">SHOULD</code> logic (roughly an <code class="literal">OR</code> logic).
							</li></ul></div><p>
						To search a property that is not of type string.
					</p><pre class="programlisting language-java">@Indexed
public class Myth {
  @Field(analyze = Analyze.NO)
  @DateBridge(resolution = Resolution.YEAR)
  public Date getCreationDate() { return creationDate; }
  public Date setCreationDate(Date creationDate) { this.creationDate = creationDate; }
  private Date creationDate;

  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("creationDate").matching(birthdate).createQuery();</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							In plain Lucene, the Date object had to be converted to its string representation, which in this case is the year.
						</p></div></div><p>
						This conversion works for any object, provided that the FieldBridge has an objectToString method (and all built-in FieldBridge implementations do).
					</p><p>
						The next example searches a field that uses ngram analyzers. The ngram analyzers index succession of ngrams of words, which helps to avoid user typos. For example, the 3-grams of the word hibernate are hib, ibe, ber, ern, rna, nat, ate.
					</p><pre class="programlisting language-java">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)

public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram")
  public String getName() { return name; }
  public String setName(String name) { this.name = name; }
  private String name;

  ...
}

Date birthdate = ...;
Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();</pre><p>
						The matching word "Sisiphus" will be lower-cased and then split into 3-grams: sis, isi, sip, iph, phu, hus. Each of these ngram will be part of the query. The user is then able to find the Sysiphus myth (with a <code class="literal">y</code>). All that is transparently done for the user.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							If the user does not want a specific field to use the field bridge or the analyzer then the ignoreAnalyzer() or ignoreFieldBridge() functions can be called.
						</p></div></div><p>
						To search for multiple possible words in the same field, add them all in the matching clause.
					</p><pre class="programlisting language-java">//search document with storm or lightning in their history
Query luceneQuery =
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</pre><p>
						To search the same word on multiple fields, use the onFields method.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</pre><p>
						Sometimes, one field should be treated differently from another field even if searching the same term, use the andField() method for that.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
      .boostedTo(5)
    .andField("description")
    .matching("storm")
    .createQuery();</pre><p>
						In the previous example, only field name is boosted to 5.
					</p></section><section class="section" id="fuzzy_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.4. Fuzzy Queries</h4></div></div></div><p>
						To execute a fuzzy query (based on the Levenshtein distance algorithm), start with a <code class="literal">keyword</code> query and add the <code class="literal">fuzzy</code> flag.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold( .8f )
        .withPrefixLength( 1 )
    .onField("history")
    .matching("starm")
    .createQuery();</pre><p>
						The <code class="literal">threshold</code> is the limit above which two terms are considering matching. It is a decimal between 0 and 1 and the default value is 0.5. The <code class="literal">prefixLength</code> is the length of the prefix ignored by the "fuzzyness". While the default value is 0, a nonzero value is recommended for indexes containing a huge number of distinct terms.
					</p></section><section class="section" id="wildcard_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.5. Wildcard Queries</h4></div></div></div><p>
						Wildcard queries are useful in circumstances where only part of the word is known. The <code class="literal">?</code> represents a single character and * represents multiple characters. Note that for performance purposes, it is recommended that the query does not start with either <code class="literal">?</code> or <code class="literal">*</code>.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Wildcard queries do not apply the analyzer on the matching terms. The risk of <code class="literal">*</code> or <code class="literal">?</code> being mangled is too high.
						</p></div></div></section><section class="section" id="phase_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.6. Phrase Queries</h4></div></div></div><p>
						So far we have been looking for words or sets of words, the user can also search exact or approximate sentences. Use phrase() to do so.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</pre><p>
						Approximate sentences can be searched by adding a slop factor. The slop factor represents the number of other words permitted in the sentence: this works like a within or near operator.
					</p><pre class="programlisting language-java">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</pre></section><section class="section" id="range_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.7. Range Queries</h4></div></div></div><p>
						A range query searches for a value in between given boundaries (included or not) or for a value below or above a given boundary.
					</p><pre class="programlisting language-java">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</pre></section><section class="section" id="combining_queries"><div class="titlepage"><div><div><h4 class="title">7.5.1.8. Combining Queries</h4></div></div></div><p>
						Queries can be combined to create more complex queries. The following aggregation operators are available:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">SHOULD</code>: the query should contain the matching elements of the subquery.
							</li><li class="listitem">
								<code class="literal">MUST</code>: the query must contain the matching elements of the subquery.
							</li><li class="listitem">
								<code class="literal">MUST NOT</code>: the query must not contain the matching elements of the subquery.
							</li></ul></div><p>
						The subqueries can be any Lucene query including a boolean query itself.
					</p><div class="formalpara"><p class="title"><strong>Example: SHOULD Query</strong></p><p>
							
<pre class="programlisting language-java">//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();</pre>

						</p></div><div class="formalpara"><p class="title"><strong>Example: MUST Query</strong></p><p>
							
<pre class="programlisting language-java">//look for popular urban myths
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();</pre>

						</p></div><div class="formalpara"><p class="title"><strong>Example: MUST NOT Query</strong></p><p>
							
<pre class="programlisting language-java">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();</pre>

						</p></div></section><section class="section" id="query_options"><div class="titlepage"><div><div><h4 class="title">7.5.1.9. Query Options</h4></div></div></div><p>
						The Hibernate Search query DSL is an easy-to-use and easy-to-read query API. In accepting and producing Lucene queries, you can incorporate query types not yet supported by the DSL.
					</p><p>
						The following is a summary of query options for query types and fields:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<span class="strong strong"><strong>boostedTo</strong></span> (on query type and on field) boosts the whole query or the specific field to a given factor.
							</li><li class="listitem">
								<span class="strong strong"><strong>withConstantScore</strong></span> (on query) returns all results that match the query have a constant score equals to the boost.
							</li><li class="listitem">
								<span class="strong strong"><strong>filteredBy(Filter)</strong></span> (on query) filters query results using the Filter instance.
							</li><li class="listitem">
								<span class="strong strong"><strong>ignoreAnalyzer</strong></span> (on field) ignores the analyzer when processing this field.
							</li><li class="listitem">
								<span class="strong strong"><strong>ignoreFieldBridge</strong></span> (on field) ignores field bridge when processing this field.
							</li></ul></div><div class="formalpara"><p class="title"><strong>Example: Combination of Query Options</strong></p><p>
							
<pre class="programlisting language-java">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();</pre>

						</p></div></section><section class="section" id="build_a_hibernate_search_query"><div class="titlepage"><div><div><h4 class="title">7.5.1.10. Build a Hibernate Search Query</h4></div></div></div><section class="section" id="generality"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.1. Generality</h5></div></div></div><p>
							After building the Lucene query, wrap it within a Hibernate query. The query searches all indexed entities and returns all types of indexed classes unless explicitly configured not to do so.
						</p><div class="formalpara"><p class="title"><strong>Example: Wrapping a Lucene Query in a Hibernate Query</strong></p><p>
								
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre>

							</p></div><p>
							For improved performance, restrict the returned types as follows:
						</p><div class="formalpara"><p class="title"><strong>Example: Filtering the Search Result by Entity Type</strong></p><p>
								
<pre class="programlisting language-java">fullTextQuery = fullTextSession
    .createFullTextQuery( luceneQuery, Customer.class );

// or

fullTextQuery = fullTextSession
    .createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre>

							</p></div><p>
							The first part of the second example only returns the matching Customers. The second part of the same example returns matching Actors and Items. The type restriction is polymorphic. As a result, if the two subclasses Salesman and Customer of the base class Person return, specify Person.class to filter based on result types.
						</p></section><section class="section" id="pagination"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.2. Pagination</h5></div></div></div><p>
							To avoid performance degradation, it is recommended to restrict the number of returned objects per query. A user navigating from one page to another page is a very common use case. The way to define pagination is similar to defining pagination in a plain HQL or Criteria query.
						</p><div class="formalpara"><p class="title"><strong>Example: Defining Pagination for a Search Query</strong></p><p>
								
<pre class="programlisting language-java">org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre>

							</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								It is still possible to get the total number of matching elements regardless of the pagination via <code class="literal">fulltextQuery.getResultSize()</code>.
							</p></div></div></section><section class="section" id="sorting"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.3. Sorting</h5></div></div></div><p>
							Apache Lucene contains a flexible and powerful result sorting mechanism. The default sorting is by relevance and is appropriate for a large variety of use cases. The sorting mechanism can be changed to sort by other properties using the Lucene Sort object to apply a Lucene sorting strategy.
						</p><div class="formalpara"><p class="title"><strong>Example: Specifying a Lucene Sort</strong></p><p>
								
<pre class="programlisting language-java">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("title", SortField.STRING));

List results = query.list();</pre>

							</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Fields used for sorting must not be tokenized. For more information about tokenizing, see <a class="link" href="#field" title="7.4.1.3. @Field">@Field</a>.
							</p></div></div></section><section class="section" id="fetching_strategy"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.4. Fetching Strategy</h5></div></div></div><p>
							Hibernate Search loads objects using a single query if the return types are restricted to one class. Hibernate Search is restricted by the static fetching strategy defined in the domain model. It is useful to refine the fetching strategy for a specific use case as follows:
						</p><div class="formalpara"><p class="title"><strong>Example: Specifying FetchMode on a Query</strong></p><p>
								
<pre class="programlisting language-java">Criteria criteria =
    s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre>

							</p></div><p>
							In this example, the query will return all Books matching the LuceneQuery. The authors collection will be loaded from the same query using an SQL outer join.
						</p><p>
							In a criteria query definition, the type is guessed based on the provided criteria query. As a result, it is not necessary to restrict the return entity types.
						</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								The fetch mode is the only adjustable property. Do not use a restriction (a where clause) on the Criteria query because the getResultSize() throws a SearchException if used in conjunction with a Criteria with restriction.
							</p></div></div><p>
							If more than one entity is expected, do not use <code class="literal">setCriteriaQuery</code>.
						</p></section><section class="section" id="projection"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.5. Projection</h5></div></div></div><p>
							In some cases, only a small subset of the properties is required. Use Hibernate Search to return a subset of properties as follows:
						</p><p>
							Hibernate Search extracts properties from the Lucene index and converts them to their object representation and returns a list of Object[]. Projections prevent a time consuming database round-trip. However, they have following constraints:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									The properties projected must be stored in the index (<code class="literal">@Field(store=Store.YES)</code>), which increases the index size.
								</li><li class="listitem"><p class="simpara">
									The properties projected must use a <code class="literal">FieldBridge</code> implementing org.hibernate.search.bridge.TwoWayFieldBridge or <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version.
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										All Hibernate Search built-in types are two-way.
									</p></div></div></li><li class="listitem">
									Only the simple properties of the indexed entity or its embedded associations can be projected. Therefore a whole embedded entity cannot be projected.
								</li><li class="listitem">
									Projection does not work on collections or maps which are indexed via @IndexedEmbedded.
								</li></ul></div><p>
							Lucene provides metadata information about query results. Use projection constants to retrieve the metadata.
						</p><div class="formalpara"><p class="title"><strong>Example: Using Projection to Retrieve Metadata</strong></p><p>
								
<pre class="programlisting language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</pre>

							</p></div><p>
							Fields can be mixed with the following projection constants:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.THIS:</strong></span> returns the initialized and managed entity (as a non projected query would have done).
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.DOCUMENT:</strong></span> returns the Lucene Document related to the object projected.
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.OBJECT_CLASS:</strong></span> returns the class of the indexed entity.
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.SCORE:</strong></span> returns the document score in the query. Scores are handy to compare one result against an other for a given query but are useless when comparing the result of different queries.
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.ID:</strong></span> the ID property value of the projected object.
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.DOCUMENT_ID:</strong></span> the Lucene document ID. Be careful in using this value as a Lucene document ID can change over time between two different IndexReader opening.
								</li><li class="listitem">
									<span class="strong strong"><strong>FullTextQuery.EXPLANATION:</strong></span> returns the Lucene Explanation object for the matching object/document in the given query. This is not suitable for retrieving large amounts of data. Running explanation typically is as costly as running the whole Lucene query per matching element. As a result, projection is recommended.
								</li></ul></div></section><section class="section" id="customizing_object_initialization_strategies"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.6. Customizing Object Initialization Strategies</h5></div></div></div><p>
							By default, Hibernate Search uses the most appropriate strategy to initialize entities matching the full text query. It executes one or more queries to retrieve the required entities. This approach minimizes database trips where few of the retrieved entities are present in the persistence context (the session) or the second level cache.
						</p><p>
							If entities are present in the second-level cache, force Hibernate Search to look into the cache before retrieving a database object.
						</p><div class="formalpara"><p class="title"><strong>Example: Check the Second-level Cache Before Using a Query</strong></p><p>
								
<pre class="programlisting language-java">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</pre>

							</p></div><p>
							<code class="literal">ObjectLookupMethod</code> defines the strategy to check if an object is easily accessible (without fetching it from the database). Other options are:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<code class="literal">ObjectLookupMethod.PERSISTENCE_CONTEXT</code> is used if many matching entities are already loaded into the persistence context (loaded in the Session or EntityManager).
								</li><li class="listitem">
									<code class="literal">ObjectLookupMethod.SECOND_LEVEL_CACHE</code> checks the persistence context and then the second-level cache.
								</li></ul></div><p>
							Set the following to search in the second-level cache:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									Correctly configure and activate the second-level cache.
								</li><li class="listitem">
									Enable the second-level cache for the relevant entity. This is done using annotations such as @Cacheable.
								</li><li class="listitem">
									Enable second-level cache read access for either Session, EntityManager or Query. Use <code class="literal">CacheMode.NORMAL</code> in Hibernate native APIs or <code class="literal">CacheRetrieveMode.USE</code> in Java Persistence APIs.
								</li></ul></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
								Unless the second-level cache implementation is Infinispan, do not use ObjectLookupMethod.SECOND_LEVEL_CACHE. Other second-level cache providers do not implement this operation efficiently.
							</p></div></div><p>
							Customize how objects are loaded from the database using <code class="literal">DatabaseRetrievalMethod</code> as follows:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<span class="strong strong"><strong>QUERY</strong></span> (default) uses a set of queries to load several objects in each batch. This approach is recommended.
								</li><li class="listitem">
									<span class="strong strong"><strong>FIND_BY_ID</strong></span> loads one object at a time using the <code class="literal">Session.get</code> or <code class="literal">EntityManager.find</code> semantic. This is recommended if the batch size is set for the entity, which allows Hibernate Core to load entities in batches.
								</li></ul></div></section><section class="section" id="limiting_the_time_of_a_query"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.7. Limiting the Time of a Query</h5></div></div></div><p>
							Limit the time a query takes in Hibernate Guide as follows:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									Raise an exception when arriving at the limit.
								</li><li class="listitem">
									Limit to the number of results retrieved when the time limit is raised.
								</li></ul></div></section><section class="section" id="raise_an_exception_on_time_limit"><div class="titlepage"><div><div><h5 class="title">7.5.1.10.8. Raise an Exception on Time Limit</h5></div></div></div><p>
							If a query uses more than the defined amount of time, a QueryTimeoutException is raised (org.hibernate.QueryTimeoutException or javax.persistence.QueryTimeoutException depending on the programmatic API).
						</p><p>
							To define the limit when using the native Hibernate APIs, use one of the following approaches:
						</p><div class="formalpara"><p class="title"><strong>Example: Defining a Timeout in Query Execution</strong></p><p>
								
<pre class="programlisting language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</pre>

							</p></div><p>
							The getResultSize(), iterate() and scroll() honor the timeout until the end of the method call. As a result, Iterable or the ScrollableResults ignore the timeout. Additionally, explain() does not honor this timeout period. This method is used for debugging and to check the reasons for slow performance of a query.
						</p><p>
							The following is the standard way to limit execution time using the Java Persistence API (JPA):
						</p><div class="formalpara"><p class="title"><strong>Example: Defining a Timeout in Query Execution</strong></p><p>
								
<pre class="programlisting language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</pre>

							</p></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								The example code does not guarantee that the query stops at the specified results amount.
							</p></div></div></section></section></section><section class="section" id="retrieving_the_results"><div class="titlepage"><div><div><h3 class="title">7.5.2. Retrieving the Results</h3></div></div></div><p>
					After building the Hibernate query, it is executed the same way as an HQL or Criteria query. The same paradigm and object semantic apply to a Lucene Query query and the common operations like <code class="literal">list()</code>, <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code>, and <code class="literal">scroll()</code> are available.
				</p><section class="section" id="performance_considerations"><div class="titlepage"><div><div><h4 class="title">7.5.2.1. Performance Considerations</h4></div></div></div><p>
						If you expect a reasonable number of results (for example using pagination) and expect to work on all of them, <code class="literal">list()</code> or <code class="literal">uniqueResult()</code> are recommended. <code class="literal">list()</code> work best if the entity <code class="literal">batch-size</code> is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the pagination) when using <code class="literal">list()</code> , <code class="literal">uniqueResult()</code> and <code class="literal">iterate()</code>.
					</p><p>
						If you wish to minimize Lucene document loading, <code class="literal">scroll()</code> is more appropriate. Do not forget to close the ScrollableResults object when you are done, since it keeps Lucene resources. If you expect to use scroll, but wish to load objects in batch, you can use query.<code class="literal">setFetchSize()</code>. When an object is accessed, and if not already loaded, Hibernate Search will load the next <code class="literal">fetchSize</code> objects in one pass.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Pagination is preferred over scrolling.
						</p></div></div></section><section class="section" id="result_size"><div class="titlepage"><div><div><h4 class="title">7.5.2.2. Result Size</h4></div></div></div><p>
						It is sometimes useful to know the total number of matching documents:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								to provide a total search results feature, as provided by Google searches. For example, "1-10 of about 888,000,000 results"
							</li><li class="listitem">
								to implement a fast pagination navigation
							</li><li class="listitem">
								to implement a multi-step search engine that adds approximation if the restricted query returns zero or not enough results
							</li></ul></div><p>
						Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you to retrieve the total number of matching documents regardless of the pagination parameters. Even more interesting, you can retrieve the number of matching elements without triggering a single object load.
					</p><div class="formalpara"><p class="title"><strong>Example: Determining the Result Size of a Query</strong></p><p>
							
<pre class="programlisting language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
//return the number of matching books without loading a single one
assert 3245 == ;

org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == ;</pre>

						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Like Google, the number of results is approximation if the index is not fully up-to-date with the database (asynchronous cluster for example).
						</p></div></div></section><section class="section" id="resulttransformer"><div class="titlepage"><div><div><h4 class="title">7.5.2.3. ResultTransformer</h4></div></div></div><p>
						Projection results are returned as Object arrays. If the data structure used for the object does not match the requirements of the application, apply a ResultTransformer. The ResultTransformer builds the required data structure after the query execution.
					</p><div class="formalpara"><p class="title"><strong>Example: Using ResultTransformer with Projections</strong></p><p>
							
<pre class="programlisting language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

query.setResultTransformer( new StaticAliasToBeanResultTransformer( BookView.class, "title", "author" ) );
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre>

						</p></div><p>
						Examples of <code class="literal">ResultTransformer</code> implementations can be found in the Hibernate Core codebase.
					</p></section><section class="section" id="understanding_results"><div class="titlepage"><div><div><h4 class="title">7.5.2.4. Understanding Results</h4></div></div></div><p>
						If the results of a query are not what you expected, the <code class="literal">Luke</code> tool is useful in understanding the outcome. However, Hibernate Search also gives you access to the Lucene Explanation object for a given result (in a given query). This class is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of an object. You have two ways to access the Explanation object for a given result:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Use the <code class="literal">fullTextQuery.explain(int)</code> method
							</li><li class="listitem">
								Use projection
							</li></ul></div><p>
						The first approach takes a document ID as a parameter and return the Explanation object. The document ID can be retrieved using projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code> constant.
					</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							The Document ID is unrelated to the entity ID. Be careful not to confuse these concepts.
						</p></div></div><p>
						In the second approach you project the Explanation object using the <code class="literal">FullTextQuery.EXPLANATION</code> constant.
					</p><div class="formalpara"><p class="title"><strong>Example: Retrieving the Lucene Explanation Object Using Projection</strong></p><p>
							
<pre class="programlisting language-java">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection(
             FullTextQuery.DOCUMENT_ID,
             ,
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</pre>

						</p></div><p>
						Use the Explanation object only when required as it is roughly as expensive as running the Lucene query again.
					</p></section><section class="section" id="filters"><div class="titlepage"><div><div><h4 class="title">7.5.2.5. Filters</h4></div></div></div><p>
						Apache Lucene has a powerful feature that allows you to filter query results according to a custom filtering process. This is a very powerful way to apply additional data restrictions, especially since filters can be cached and reused. Use cases include:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								security
							</li><li class="listitem">
								temporal data (example, view only last month’s data)
							</li><li class="listitem">
								population filter (example, search limited to a given category)
							</li></ul></div><p>
						Hibernate Search pushes the concept further by introducing the notion of parameterizable named filters which are transparently cached. For people familiar with the notion of Hibernate Core filters, the API is very similar:
					</p><div class="formalpara"><p class="title"><strong>Example: Enabling Fulltext Filters for a Query</strong></p><p>
							
<pre class="programlisting language-java">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre>

						</p></div><p>
						In this example we enabled two filters on top of the query. You can enable or disable as many filters as you like.
					</p><p>
						Declaring filters is done through the @FullTextFilterDef annotation. This annotation can be on any <code class="literal">@Indexed</code> entity regardless of the query the filter is later applied to. This implies that filter definitions are global and their names must be unique. A SearchException is thrown in case two different @FullTextFilterDef annotations with the same name are defined. Each named filter has to specify its actual filter implementation.
					</p><div class="formalpara"><p class="title"><strong>Example: Defining and Implementing a Filter</strong></p><p>
							
<pre class="programlisting language-java">@FullTextFilterDefs( {
    @FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class),
    @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)
})
public class Driver { ... }</pre>

						</p></div><pre class="programlisting language-java">public class BestDriversFilter extends org.apache.lucene.search.Filter {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre><p>
						BestDriversFilter is an example of a simple Lucene filter which reduces the result set to drivers whose score is 5. In this example the specified filter implements the <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a no-arg constructor.
					</p><p>
						If your Filter creation requires additional steps or if the filter you want to use does not have a no-arg constructor, you can use the factory pattern:
					</p><div class="formalpara"><p class="title"><strong>Example: Creating a Filter Using the Factory Pattern</strong></p><p>
							
<pre class="programlisting language-java">@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

@Factory
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre>

						</p></div><p>
						Hibernate Search will look for a <code class="literal">@Factory</code> annotated method and use it to build the filter instance. The factory must have a no-arg constructor.
					</p><p>
						Infinispan Query uses a @Factory annotated method to build the filter instance. The factory must have a no argument constructor.
					</p><p>
						Named filters come in handy where parameters have to be passed to the filter. For example a security filter might want to know which security level you want to apply:
					</p><div class="formalpara"><p class="title"><strong>Example: Passing Parameters to a Defined Filter</strong></p><p>
							
<pre class="programlisting language-java">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security").setParameter( "level", 5 );</pre>

						</p></div><p>
						Each parameter name should have an associated setter on either the filter or filter factory of the targeted named filter definition.
					</p><div class="formalpara"><p class="title"><strong>Example: Using Parameters in the Actual Filter Implementation</strong></p><p>
							
<pre class="programlisting language-java">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    public void setLevel(Integer level) {
        this.level = level;
    }

    @Key public FilterKey getKey() {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre>

						</p></div><p>
						Note the method annotated @Key returns a FilterKey object. The returned object has a special contract: the key object must implement equals() / hashCode() so that two keys are equal if and only if the given Filter types are the same and the set of parameters are the same. In other words, two filter keys are equal if and only if the filters from which the keys are generated can be interchanged. The key object is used as a key in the cache mechanism.
					</p><p>
						@Key methods are needed only if:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								the filter caching system is enabled (enabled by default)
							</li><li class="listitem">
								the filter has parameters
							</li></ul></div><p>
						In most cases, using the <code class="literal">StandardFilterKey</code> implementation will be good enough. It delegates the equals() / hashCode() implementation to each of the parameters equals and hashcode methods.
					</p><p>
						As mentioned before the defined filters are per default cached and the cache uses a combination of hard and soft references to allow disposal of memory when needed. The hard reference cache keeps track of the most recently used filters and transforms the ones least used to SoftReferences when needed. Once the limit of the hard reference cache is reached additional filters are cached as SoftReferences. To adjust the size of the hard reference cache, use <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advanced use of filter caching, implement your own FilterCachingStrategy. The classname is defined by <code class="literal">hibernate.search.filter.cache_strategy</code>.
					</p><p>
						This filter caching mechanism should not be confused with caching the actual filter results. In Lucene it is common practice to wrap filters using the IndexReader around a CachingWrapperFilter. The wrapper will cache the DocIdSet returned from the <code class="literal">getDocIdSet(IndexReader reader)</code> method to avoid expensive recomputation. It is important to mention that the computed DocIdSet is only cachable for the same IndexReader instance, because the reader effectively represents the state of the index at the moment it was opened. The document list cannot change within an opened IndexReader. A different/new IndexReader instance, however, works potentially on a different set of Documents (either from a different index or simply because the index has changed), hence the cached DocIdSet has to be recomputed.
					</p><p>
						Hibernate Search also helps with this aspect of caching. Per default the <code class="literal">cache</code> flag of @FullTextFilterDef is set to <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will automatically cache the filter instance as well as wrap the specified filter around a Hibernate specific implementation of CachingWrapperFilter. In contrast to Lucene’s version of this class SoftReferences are used together with a hard reference count (see discussion about filter cache). The hard reference count can be adjusted using <code class="literal">hibernate.search.filter.cache_docidresults.size</code> (defaults to 5). The wrapping behaviour can be controlled using the <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three different values for this parameter:
					</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 40%; " class="col_1"><!--Empty--></col><col style="width: 60%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159945061232" scope="col">Value</th><th align="left" valign="top" id="idm140159945060144" scope="col">Definition</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159945061232"> <p>
										FilterCacheModeType.NONE
									</p>
									 </td><td align="left" valign="top" headers="idm140159945060144"> <p>
										No filter instance and no result is cached by Hibernate Search. For every filter call, a new filter instance is created. This setting might be useful for rapidly changing data sets or heavily memory constrained environments.
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159945061232"> <p>
										FilterCacheModeType.INSTANCE_ONLY
									</p>
									 </td><td align="left" valign="top" headers="idm140159945060144"> <p>
										The filter instance is cached and reused across concurrent Filter.getDocIdSet() calls. DocIdSet results are not cached. This setting is useful when a filter uses its own specific caching mechanism or the filter results change dynamically due to application specific events making DocIdSet caching in both cases unnecessary.
									</p>
									 </td></tr><tr><td align="left" valign="top" headers="idm140159945061232"> <p>
										FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS
									</p>
									 </td><td align="left" valign="top" headers="idm140159945060144"> <p>
										Both the filter instance and the DocIdSet results are cached. This is the default value.
									</p>
									 </td></tr></tbody></table></div><p>
						Filters should be cached in the following situations:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								the system does not update the targeted entity index often (in other words, the IndexReader is reused a lot)
							</li><li class="listitem">
								the Filter’s DocIdSet is expensive to compute (compared to the time spent to execute the query)
							</li></ul></div></section><section class="section" id="using_filters_in_a_sharded_environment"><div class="titlepage"><div><div><h4 class="title">7.5.2.6. Using Filters in a Sharded Environment</h4></div></div></div><p>
						In a sharded environment it is possible to execute queries on a subset of the available shards. This can be done in two steps:
					</p><div class="orderedlist"><p class="title"><strong>Query a Subset of Index Shards</strong></p><ol class="orderedlist" type="1"><li class="listitem">
								Create a sharding strategy that does select a subset of IndexManagers depending on a filter configuration.
							</li><li class="listitem">
								Activate the filter at query time.
							</li></ol></div><div class="formalpara"><p class="title"><strong>Example: Query a Subset of Index Shards</strong></p><p>
							In this example the query is run against a specific customer shard if the <code class="literal">customer</code> filter is activated.
						</p></div><pre class="programlisting language-java">public class CustomerShardingStrategy implements IndexShardingStrategy {

     // stored IndexManagers in an array indexed by customerID
     private IndexManager[] indexManagers;

     public void initialize(Properties properties, IndexManager[] indexManagers) {
       this.indexManagers = indexManagers;
     }

     public IndexManager[] getIndexManagersForAllShards() {
       return indexManagers;
     }

     public IndexManager getIndexManagerForAddition(
         Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
       Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
       return indexManagers[customerID];
     }

     public IndexManager[] getIndexManagersForDeletion(
         Class&lt;?&gt; entity, Serializable id, String idInString) {
       return getIndexManagersForAllShards();
     }

      /**
      * Optimization; don't search ALL shards and union the results; in this case, we
      * can be certain that all the data for a particular customer Filter is in a single
      * shard; simply return that shard by customerID.
      */
     public IndexManager[] getIndexManagersForQuery(
         FullTextFilterImplementor[] filters) {
       FullTextFilter filter = getCustomerFilter(filters, "customer");
       if (filter == null) {
         return getIndexManagersForAllShards();
       }
       else {
         return new IndexManager[] { indexManagers[Integer.parseInt(
           filter.getParameter("customerID").toString())] };
       }
     }

     private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
       for (FullTextFilterImplementor filter: filters) {
         if (filter.getName().equals(name)) return filter;
       }
       return null;
     }
    }</pre><p>
						In this example, if the filter named <code class="literal">customer</code> is present, only the shard dedicated to this customer is queried, otherwise, all shards are returned. A given sharding strategy can react to one or more filters and depends on their parameters.
					</p><p>
						The second step is to activate the filter at query time. While the filter can be a regular filter (as defined in ) which also filters Lucene results after the query, you can make use of a special filter that will only be passed to the sharding strategy (and is otherwise ignored).
					</p><p>
						To use this feature, specify the ShardSensitiveOnlyFilter class when declaring your filter.
					</p><pre class="programlisting language-java">@Indexed
@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)
public class Customer {
   ...
}

FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
query.enableFulltextFilter("customer").setParameter("CustomerID", 5);
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</pre><p>
						Note that by using the ShardSensitiveOnlyFilter, you do not have to implement any Lucene filter. Using filters and sharding strategy reacting to these filters is recommended to speed up queries in a sharded environment.
					</p></section></section><section class="section" id="faceting"><div class="titlepage"><div><div><h3 class="title">7.5.3. Faceting</h3></div></div></div><p>
					Faceted search is a technique which allows the results of a query to be divided into multiple categories. This categorization includes the calculation of hit counts for each category and the ability to further restrict search results based on these facets (categories). The example below shows a faceting example. The search results in fifteen hits which are displayed on the main part of the page. The navigation bar on the left, however, shows the category <span class="emphasis"><em>Computers &amp; Internet</em></span> with its subcategories <span class="emphasis"><em>Programming</em></span>, <span class="emphasis"><em>Computer Science</em></span>, <span class="emphasis"><em>Databases</em></span>, <span class="emphasis"><em>Software</em></span>, <span class="emphasis"><em>Web Development,</em></span> <span class="emphasis"><em>Networking</em></span> and <span class="emphasis"><em>Home Computing</em></span>. For each of these subcategories the number of books is shown matching the main search criteria and belonging to the respective subcategory. This division of the category <span class="emphasis"><em>Computers &amp; Internet</em></span> is one concrete search facet. Another one is for example the average customer review.
				</p><p>
					Faceted search divides the results of a query into categories. The categorization includes the calculation of hit counts for each category and the further restricts search results based on these facets (categories). The following example displays a faceting search results in fifteen hits displayed on the main page.
				</p><p>
					The left side navigation bar displays the categories and subcategories. For each of these subcategories the number of books matches the main search criteria and belongs to the respective subcategory. This division of the category Computers &amp; Internet is one concrete search facet. Another example is the average customer review.
				</p><div class="formalpara"><p class="title"><strong>Example: Search for Hibernate Search on Amazon</strong></p><p>
						In Hibernate Search, the classes QueryBuilder and FullTextQuery are the entry point into the faceting API. The former creates faceting requests and the latter accesses the FacetManager. The FacetManager applies faceting requests on a query and selects facets that are added to an existing query to refine search results. The examples use the entity Cd as shown in the example below:
					</p></div><p>
					<span class="inlinemediaobject"><img src="/webassets/avalon/d/JBoss_Enterprise_Application_Platform_Continuous_Delivery-18-Developing_Hibernate_Applications-en-US/images/82a7fc8b750e3c3b4632f33dbf12588b/1605.png" alt="Search for Hibernate Search on Amazon" /></span>

				</p><div class="formalpara"><p class="title"><strong>Example: Entity Cd</strong></p><p>
						
<pre class="programlisting language-java">@Indexed
public class Cd {

    private int id;

    @Fields( {
        @Field,
        @Field(name = "name_un_analyzed", analyze = Analyze.NO)
    })
    private String name;

    @Field(analyze = Analyze.NO)
    @NumericField
    private int price;

    Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    private String label;


// setter/getter
...</pre>

					</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Prior to Hibernate Search 5.2, there was no need to explicitly use a @Facet annotation. In Hibernate Search 5.2 it became necessary in order to use Lucene’s native faceting API.
					</p></div></div><section class="section" id="creating_a_faceting_request"><div class="titlepage"><div><div><h4 class="title">7.5.3.1. Creating a Faceting Request</h4></div></div></div><p>
						The first step towards a faceted search is to create the FacetingRequest. Currently two types of faceting requests are supported. The first type is called <span class="emphasis"><em>discrete faceting</em></span> and the second type <span class="emphasis"><em>range faceting</em></span> request. In the case of a discrete faceting request you specify on which index field you want to facet (categorize) and which faceting options to apply. An example for a discrete faceting request can be seen in the following example:
					</p><div class="formalpara"><p class="title"><strong>Example: Creating a Discrete Faceting Request</strong></p><p>
							
<pre class="programlisting language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity( Cd.class )
            .get();
FacetingRequest labelFacetingRequest = builder.facet()
    .name( "labelFaceting" )
    .onField( "label")
    .discrete()
    .orderedBy( FacetSortOrder.COUNT_DESC )
    .includeZeroCounts( false )
    .maxFacetCount( 1 )
    .createFacetingRequest();</pre>

						</p></div><p>
						When executing this faceting request a Facet instance will be created for each discrete value for the indexed field <code class="literal">label</code>. The Facet instance will record the actual field value including how often this particular field value occurs within the original query results. orderedBy, includeZeroCounts and maxFacetCount are optional parameters which can be applied on any faceting request. orderedBy allows to specify in which order the created facets will be returned. The default is <code class="literal">FacetSortOrder.COUNT_DESC</code>, but you can also sort on the field value or the order in which ranges were specified. includeZeroCount determines whether facets with a count of 0 will be included in the result (by default they are) and maxFacetCount allows to limit the maximum amount of facets returned.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							At the moment there are several preconditions an indexed field has to meet in order to apply faceting on it. The indexed property must be of type String, Date or a subtype of Number and <code class="literal">null</code> values should be avoided. Furthermore the property has to be indexed with <code class="literal">Analyze.NO</code> and in case of a numeric property @NumericField needs to be specified.
						</p></div></div><p>
						The creation of a range faceting request is quite similar except that we have to specify ranges for the field values we are faceting on. A range faceting request can be seen below where three different price ranges are specified. The <code class="literal">below</code> and <code class="literal">above</code> can only be specified once, but you can specify as many <code class="literal">from</code> - <code class="literal">to</code> ranges as you want. For each range boundary you can also specify via excludeLimit whether it is included into the range or not.
					</p><div class="formalpara"><p class="title"><strong>Example: Creating a Range Faceting Request</strong></p><p>
							
<pre class="programlisting language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity( Cd.class )
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name( "priceFaceting" )
    .onField( "price" )
    .range()
    .below( 1000 )
    .from( 1001 ).to( 1500 )
    .above( 1500 ).excludeLimit()
    .createFacetingRequest();</pre>

						</p></div></section><section class="section" id="applying_a_faceting_request"><div class="titlepage"><div><div><h4 class="title">7.5.3.2. Applying a Faceting Request</h4></div></div></div><p>
						A faceting request is applied to a query via the FacetManager class which can be retrieved via the FullTextQuery class.
					</p><p>
						You can enable as many faceting requests as you like and retrieve them afterwards via getFacets() specifying the faceting request name. There is also a disableFaceting() method which allows you to disable a faceting request by specifying its name.
					</p><p>
						A faceting request can be applied on a query using the FacetManager, which can be retrieved via the FullTextQuery.
					</p><div class="formalpara"><p class="title"><strong>Example: Applying a Faceting Request</strong></p><p>
							
<pre class="programlisting language-java">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Cd.class );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cds
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
...</pre>

						</p></div><p>
						Multiple faceting requests can be retrieved using <code class="literal">getFacets()</code> and specifying the faceting request name.
					</p><p>
						The <code class="literal">disableFaceting()</code> method disables a faceting request by specifying its name.
					</p></section><section class="section" id="restricting_query_results"><div class="titlepage"><div><div><h4 class="title">7.5.3.3. Restricting Query Results</h4></div></div></div><p>
						Last but not least, you can apply any of the returned Facets as additional criteria on your original query in order to implement a "drill-down" functionality. For this purpose FacetSelection can be utilized. FacetSelections are available via the FacetManager and allow you to select a facet as query criteria (selectFacets), remove a facet restriction (deselectFacets), remove all facet restrictions (clearSelectedFacets) and retrieve all currently selected facets (getSelectedFacets). The following snippet shows an example.
					</p><pre class="programlisting language-java">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
facetManager.getFacetGroup( "priceFaceting" ).selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</pre></section></section><section class="section" id="optimizing_the_query_process"><div class="titlepage"><div><div><h3 class="title">7.5.4. Optimizing the Query Process</h3></div></div></div><p>
					Query performance depends on several criteria:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The Lucene query.
						</li><li class="listitem">
							The number of objects loaded: use pagination (always) or index projection (if needed).
						</li><li class="listitem">
							The way Hibernate Search interacts with the Lucene readers: defines the appropriate reader strategy.
						</li><li class="listitem">
							Caching frequently extracted values from the index. See <a class="link" href="#caching_index_values_fieldcache" title="7.5.4.1. Caching Index Values: FieldCache">Caching Index Values: FieldCache</a> for more information.
						</li></ul></div><section class="section" id="caching_index_values_fieldcache"><div class="titlepage"><div><div><h4 class="title">7.5.4.1. Caching Index Values: FieldCache</h4></div></div></div><p>
						The primary function of a Lucene index is to identify matches to your queries. After the query is performed the results must be analyzed to extract useful information. Hibernate Search would typically need to extract the class type and the primary key.
					</p><p>
						Extracting the needed values from the index has a performance cost, which in some cases might be very low and not noticeable, but in some other cases might be a good candidate for caching.
					</p><p>
						The requirements depend on the kind of <a class="link" href="#projection" title="7.5.1.10.5. Projection">Projections</a> being used, as in some cases the class type is not needed as it can be inferred from the query context or other means.
					</p><p>
						Using the @CacheFromIndex annotation you can experiment with different kinds of caching of the main metadata fields required by Hibernate Search:
					</p><pre class="programlisting language-java">import static org.hibernate.search.annotations.FieldCacheType.CLASS;
import static org.hibernate.search.annotations.FieldCacheType.ID;

@Indexed
@CacheFromIndex( { CLASS, ID } )
public class Essay {
    ...</pre><p>
						It is possible to cache class types and IDs using this annotation:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								<code class="literal">CLASS</code>: Hibernate Search will use a Lucene FieldCache to improve performance of the class type extraction from the index.
							</p><p class="simpara">
								This value is enabled by default, and is what Hibernate Search will apply if you do not specify the @CacheFromIndex annotation.
							</p></li><li class="listitem">
								<code class="literal">ID</code>: Extracting the primary identifier will use a cache. This is likely providing the best performing queries, but will consume much more memory which in turn might reduce performance.
							</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Measure the performance and memory consumption impact after warmup (executing some queries). Performance may improve by enabling Field Caches but this is not always the case.
						</p></div></div><p>
						Using a FieldCache has two downsides to consider:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Memory usage: these caches can be quite memory hungry. Typically the CLASS cache has lower requirements than the ID cache.
							</li><li class="listitem">
								Index warmup: when using field caches, the first query on a new index or segment will be slower than when you do not have caching enabled.
							</li></ul></div><p>
						With some queries, the class type will not be needed at all, in that case even if you enabled the <code class="literal">CLASS</code> field cache, this might not be used; for example if you are targeting a single class, obviously all returned values will be of that type (this is evaluated at each query execution).
					</p><p>
						For the ID FieldCache to be used, the IDs of targeted entities must be using a TwoWayFieldBridge (as all builting bridges), and all types being loaded in a specific query must use the fieldname for the id, and have IDs of the same type (this is evaluated at each query execution).
					</p></section></section></section><section class="section" id="manual_index_changes"><div class="titlepage"><div><div><h2 class="title">7.6. Manual Index Changes</h2></div></div></div><p>
				As Hibernate Core applies changes to the database, Hibernate Search detects these changes and will update the index automatically (unless the EventListeners are disabled). Sometimes changes are made to the database without using Hibernate, as when backup is restored or your data is otherwise affected. In these cases Hibernate Search exposes the Manual Index APIs to explicitly update or remove a single entity from the index, rebuild the index for the whole database, or remove all references to a specific type.
			</p><p>
				All these methods affect the Lucene Index only, no changes are applied to the database.
			</p><section class="section" id="adding_instances_to_the_index"><div class="titlepage"><div><div><h3 class="title">7.6.1. Adding Instances to the Index</h3></div></div></div><p>
					Using <code class="literal">FullTextSession.index(T entity)</code> you can directly add or update a specific object instance to the index. If this entity was already indexed, then the index will be updated. Changes to the index are only applied at transaction commit.
				</p><p>
					Directly add an object or instance to the index using <code class="literal">FullTextSession.index(T entity)</code>. The index is updated when the entity is indexed. Infinispan Query applies changes to the index during the transaction commit.
				</p><div class="formalpara"><p class="title"><strong>Example: Indexing an Entity Using FullTextSession.index(T entity)</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
fullTextSession.index(customer);
tx.commit(); //index only updated at commit time</pre>

					</p></div><p>
					In case you want to add all instances for a type, or for all indexed types, the recommended approach is to use a MassIndexer: see for more details.
				</p><p>
					Use a MassIndexer to add all instances for a type (or for all indexed types). See <a class="link" href="#using_a_massindexer" title="7.6.3.2. Using a MassIndexer">Using a MassIndexer</a> for more information.
				</p></section><section class="section" id="deleting_instances_from_the_index"><div class="titlepage"><div><div><h3 class="title">7.6.2. Deleting Instances from the Index</h3></div></div></div><p>
					It is possible to remove an entity or all entities of a given type from a Lucene index without the need to physically remove them from the database. This operation is named purging and is also done through the <code class="literal">FullTextSession</code>.
				</p><p>
					The purging operation permits the removal of a single entity or all entities of a given type from a Lucene index without physically removing them from the database. This operation is performed using the FullTextSession.
				</p><div class="formalpara"><p class="title"><strong>Example: Purging a Specific Instance of an Entity from the Index</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
fullTextSession.purgeAll( Customer.class );
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index is updated at commit time</pre>

					</p></div><p>
					It is recommended to optimize the index after such an operation.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Methods index, purge, and purgeAll are available on FullTextEntityManager as well.
					</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						All manual indexing methods (index, purge, and purgeAll) only affect the index, not the database, nevertheless they are transactional and as such they will not be applied until the transaction is successfully committed, or you make use of flushToIndexes.
					</p></div></div></section><section class="section" id="rebuilding_the_index"><div class="titlepage"><div><div><h3 class="title">7.6.3. Rebuilding the Index</h3></div></div></div><p>
					If you change the entity mapping to the index, chances are that the whole Index needs to be updated; For example if you decide to index an existing field using a different analyzer you’ll need to rebuild the index for affected types. Also if the Database is replaced (like restored from a backup, imported from a legacy system) you’ll want to be able to rebuild the index from existing data. Hibernate Search provides two main strategies to choose from:
				</p><p>
					Changing the entity mapping in the indexer may require the entire index to be updated. For example, if an existing field is to be indexed using a different analyzer, the index will need to be rebuilt for affected types.
				</p><p>
					Additionally, if the database is replaced by restoring from a backup or being imported from a legacy system, the index will need to be rebuilt from existing data. Infinispan Query provides two main strategies:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Using <code class="literal">FullTextSession.flushToIndexes()</code> periodically, while using <code class="literal">FullTextSession.index()</code> on all entities.
						</li><li class="listitem">
							Use a <code class="literal">MassIndexer</code>.
						</li></ul></div><section class="section" id="using_flushtoindexes"><div class="titlepage"><div><div><h4 class="title">7.6.3.1. Using flushToIndexes()</h4></div></div></div><p>
						This strategy consists of removing the existing index and then adding all entities back to the index using <code class="literal">FullTextSession.purgeAll()</code> and <code class="literal">FullTextSession.index()</code>, however there are some memory and efficiency constraints. For maximum efficiency Hibernate Search batches index operations and executes them at commit time. If you expect to index a lot of data you need to be careful about memory consumption since all documents are kept in a queue until the transaction commit. You can potentially face an <code class="literal">OutOfMemoryException</code> if you do not empty the queue periodically; to do this use <code class="literal">fullTextSession.flushToIndexes()</code>. Every time <code class="literal">fullTextSession.flushToIndexes()</code> is called (or if the transaction is committed), the batch queue is processed, applying all index changes. Be aware that, once flushed, the changes cannot be rolled back.
					</p><div class="formalpara"><p class="title"><strong>Example: Index Rebuilding Using index() and flushToIndexes()</strong></p><p>
							
<pre class="programlisting language-java">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</pre>

						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							<code class="literal">hibernate.search.default.worker.batch_size</code> has been deprecated in favor of this explicit API which provides better control
						</p></div></div><p>
						Try to use a batch size that guarantees that your application will not be out of memory: with a bigger batch size objects are fetched faster from database but more memory is needed.
					</p></section><section class="section" id="using_a_massindexer"><div class="titlepage"><div><div><h4 class="title">7.6.3.2. Using a MassIndexer</h4></div></div></div><p>
						Hibernate Search’s MassIndexer uses several parallel threads to rebuild the index. You can optionally select which entities need to be reloaded or have it reindex all entities. This approach is optimized for best performance but requires to set the application in maintenance mode. Querying the index is not recommended when a MassIndexer is busy.
					</p><div class="formalpara"><p class="title"><strong>Example: Rebuild the Index Using a MassIndexer</strong></p><p>
							
<pre class="programlisting language-java">fullTextSession.createIndexer().startAndWait();</pre>

						</p></div><p>
						This will rebuild the index, deleting it and then reloading all entities from the database. Although it is simple to use, some tweaking is recommended to speed up the process.
					</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							During the progress of a MassIndexer the content of the index is undefined. If a query is performed while the MassIndexer is working most likely some results will be missing.
						</p></div></div><div class="formalpara"><p class="title"><strong>Example: Using a Tuned MassIndexer</strong></p><p>
							
<pre class="programlisting language-java">fullTextSession
 .createIndexer( User.class )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 12 )
 .idFetchSize( 150 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</pre>

						</p></div><p>
						This will rebuild the index of all User instances (and subtypes), and will create 12 parallel threads to load the User instances using batches of 25 objects per query. These same 12 threads will also need to process indexed embedded relations and custom <code class="literal">FieldBridges</code> or <code class="literal">ClassBridges</code> to output a Lucene document. The threads trigger lazy loading of additional attributes during the conversion process. Because of this, a high number of threads working in parallel is required. The number of threads working on actual index writing is defined by the back-end configuration of each index.
					</p><p>
						It is recommended to leave cacheMode to <code class="literal">CacheMode.IGNORE</code> (the default), as in most reindexing situations the cache will be a useless additional overhead. It might be useful to enable some other <code class="literal">CacheMode</code> depending on your data as it could increase performance if the main entity is relating to enum-like data included in the index.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The ideal of number of threads to achieve best performance is highly dependent on your overall architecture, database design and data values. All internal thread groups have meaningful names so they should be easily identified with most diagnostic tools, including thread dumps.
						</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The MassIndexer is unaware of transactions, therefore there is no need to begin one or commit afterward. Because it is not transactional it is not recommended to let users use the system during its processing, as it is unlikely people will be able to find results and the system load might be too high anyway.
						</p></div></div><p>
						Other parameters that affect indexing time and memory consumption are:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
							</li><li class="listitem">
								<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
							</li></ul></div><p>
						Previous versions also had a <code class="literal">max_field_length</code> but this was removed from Lucene. It is possible to obtain a similar effect by using a <code class="literal">LimitTokenCountAnalyzer</code>.
					</p><p>
						All <code class="literal">.indexwriter</code> parameters are Lucene specific and Hibernate Search passes these parameters through.
					</p><p>
						The MassIndexer uses a forward only scrollable result to iterate on the primary keys to be loaded, but MySQL’s JDBC driver will load all values in memory. To avoid this "optimization" set <code class="literal">idFetchSize</code> to <code class="literal">Integer.MIN_VALUE</code>.
					</p></section></section></section><section class="section" id="index_optimization"><div class="titlepage"><div><div><h2 class="title">7.7. Index Optimization</h2></div></div></div><p>
				From time to time, the Lucene index needs to be optimized. The process is essentially a defragmentation. Until an optimization is triggered Lucene only marks deleted documents as such, no physical are applied. During the optimization process the deletions will be applied which also affects the number of files in the Lucene Directory.
			</p><p>
				Optimizing the Lucene index speeds up searches but has no effect on the indexation (update) performance. During an optimization, searches can be performed, but will most likely be slowed down. All index updates will be stopped. It is recommended to schedule optimization:
			</p><p>
				Optimizing the Lucene index speeds up searches, but has no effect on the index update performance. Searches can be performed during an optimization process, however they will be slower than expected. All index updates are on hold during the optimization. It is therefore recommended to schedule optimization:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						On an idle system or when searches are least frequent.
					</li><li class="listitem">
						After a large number of index modifications are applied.
					</li></ul></div><p>
				MassIndexer optimizes indexes by default at the start and at the end of processing. Use <code class="literal">MassIndexer.optimizeAfterPurge</code> and <code class="literal">MassIndexer.optimizeOnFinish</code> to change this default behavior. See <a class="link" href="#using_a_massindexer" title="7.6.3.2. Using a MassIndexer">Using a MassIndexer</a> for more information.
			</p><section class="section" id="automatic_optimization"><div class="titlepage"><div><div><h3 class="title">7.7.1. Automatic Optimization</h3></div></div></div><p>
					Hibernate Search can automatically optimize an index after either:
				</p><p>
					Infinispan Query automatically optimizes the index after:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							a certain amount of operations (insertion or deletion).
						</li><li class="listitem">
							a certain amount of transactions.
						</li></ul></div><p>
					The configuration for automatic index optimization can be defined either globally or per index:
				</p><div class="formalpara"><p class="title"><strong>Example: Defining Automatic Optimization Parameters</strong></p><p>
						
<pre class="programlisting language-java">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre>

					</p></div><p>
					An optimization will be triggered to the <code class="literal">Animal</code> index as soon as either:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							the number of additions and deletions reaches <code class="literal">1000</code>.
						</li><li class="listitem">
							the number of transactions reaches <code class="literal">50</code> (<code class="literal">hibernate.search.Animal.optimizer.transaction_limit.max</code> has priority over <code class="literal">hibernate.search.default.optimizer.transaction_limit.max</code>).
						</li></ul></div><p>
					If none of these parameters are defined, no optimization is processed automatically.
				</p><p>
					The default implementation of OptimizerStrategy can be overridden by implementing <code class="literal">org.hibernate.search.store.optimization.OptimizerStrategy</code> and setting the <code class="literal">optimizer.implementation</code> property to the fully qualified name of your implementation. This implementation must implement the interface, be a public class and have a public constructor taking no arguments.
				</p><div class="formalpara"><p class="title"><strong>Example: Loading a Custom OptimizerStrategy</strong></p><p>
						
<pre class="programlisting language-java">hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre>

					</p></div><p>
					The keyword <code class="literal">default</code> can be used to select the Hibernate Search default implementation; all properties after the <code class="literal">.optimizer</code> key separator will be passed to the implementation’s initialize method at start.
				</p></section><section class="section" id="manual_optimization"><div class="titlepage"><div><div><h3 class="title">7.7.2. Manual Optimization</h3></div></div></div><p>
					You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the SearchFactory:
				</p><div class="formalpara"><p class="title"><strong>Example: Programmatic Index Optimization</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</pre>

					</p></div><p>
					The first example optimizes the Lucene index holding Orders and the second optimizes all indexes.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						<code class="literal">searchFactory.optimize()</code> has no effect on a JMS back end. You must apply the optimize operation on the Master node.
					</p></div></div><p>
					<code class="literal">searchFactory.optimize()</code> is applied to the master node because it does not affect the JMC back end.
				</p></section><section class="section" id="adjusting_optimization"><div class="titlepage"><div><div><h3 class="title">7.7.3. Adjusting Optimization</h3></div></div></div><p>
					Apache Lucene has a few parameters to influence how optimization is performed. Hibernate Search exposes those parameters.
				</p><p>
					Further index optimization parameters include:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code>
						</li><li class="listitem">
							<code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code>
						</li></ul></div></section></section><section class="section" id="advanced_features"><div class="titlepage"><div><div><h2 class="title">7.8. Advanced Features</h2></div></div></div><section class="section" id="accessing_the_searchfactory"><div class="titlepage"><div><div><h3 class="title">7.8.1. Accessing the SearchFactory</h3></div></div></div><p>
					The SearchFactory object keeps track of the underlying Lucene resources for Hibernate Search. It is a convenient way to access Lucene natively. The <code class="literal">SearchFactory</code> can be accessed from a FullTextSession:
				</p><div class="formalpara"><p class="title"><strong>Example: Accessing the SearchFactory</strong></p><p>
						
<pre class="programlisting language-java">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre>

					</p></div></section><section class="section" id="using_an_indexreader"><div class="titlepage"><div><div><h3 class="title">7.8.2. Using an IndexReader</h3></div></div></div><p>
					Queries in Lucene are executed on an IndexReader. Hibernate Search might cache index readers to maximize performance, or provide other efficient strategies to retrieve an updated IndexReader minimizing I/O operations. Your code can access these cached resources, but there are several requirements.
				</p><div class="formalpara"><p class="title"><strong>Example: Accessing an IndexReader</strong></p><p>
						
<pre class="programlisting language-java">IndexReader reader = searchFactory.getIndexReaderAccessor().open(Order.class);
try {
   //perform read-only operations on the reader
}
finally {
   searchFactory.getIndexReaderAccessor().close(reader);
}</pre>

					</p></div><p>
					In this example the SearchFactory determines which indexes are needed to query this entity (considering a sharding strategy). Using the configured ReaderProvider on each index, it returns a compound <code class="literal">IndexReader</code> on top of all involved indexes. Because this IndexReader is shared amongst several clients, you must adhere to the following rules:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Never call indexReader.close(), instead use readerProvider.closeReader(reader) when necessary, preferably in a finally block.
						</li><li class="listitem">
							Don not use this IndexReader for modification operations (it is a readonly IndexReader, and any such attempt will result in an exception).
						</li></ul></div><p>
					Aside from those rules, you can use the IndexReader freely, especially to do native Lucene queries. Using the shared IndexReaders will make most queries more efficient than by opening one directly from, for example, the file system.
				</p><p>
					As an alternative to the method open(Class…​ types) you can use open(String…​ indexNames), allowing you to pass in one or more index names. Using this strategy you can also select a subset of the indexes for any indexed type if sharding is used.
				</p><div class="formalpara"><p class="title"><strong>Example: Accessing an IndexReader by Index Names</strong></p><p>
						
<pre class="programlisting language-java">IndexReader reader = searchFactory.getIndexReaderAccessor().open("Products.1", "Products.3");</pre>

					</p></div></section><section class="section" id="accessing_a_lucene_directory"><div class="titlepage"><div><div><h3 class="title">7.8.3. Accessing a Lucene Directory</h3></div></div></div><p>
					A Directory is the most common abstraction used by Lucene to represent the index storage; Hibernate Search does not interact directly with a Lucene Directory but abstracts these interactions via an IndexManager: an index does not necessarily need to be implemented by a Directory.
				</p><p>
					If you know your index is represented as a Directory and need to access it, you can get a reference to the Directory via the IndexManager. Cast the IndexManager to a DirectoryBasedIndexManager and then use <code class="literal">getDirectoryProvider().getDirectory()</code> to get a reference to the underlying Directory. This is not recommended, we would encourage to use the IndexReader instead.
				</p></section><section class="section" id="sharding_indexes"><div class="titlepage"><div><div><h3 class="title">7.8.4. Sharding Indexes</h3></div></div></div><p>
					In some cases it can be useful to split (shard) the indexed data of a given entity into several Lucene indexes.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Sharding should only be implemented if the advantages outweigh the disadvantages. Searching sharded indexes will typically be slower as all shards have to be opened for a single search.
					</p></div></div><p>
					Possible use cases for sharding are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							A single index is so large that index update times are slowing the application down.
						</li><li class="listitem">
							A typical search will only hit a subset of the index, such as when data is naturally segmented by customer, region or application.
						</li></ul></div><p>
					By default sharding is not enabled unless the number of shards is configured. To do this use the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards</code> property.
				</p><div class="formalpara"><p class="title"><strong>Example: Enabling Index Sharding</strong></p><p>
						In this example, five shards are enabled.
					</p></div><pre class="screen">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards = 5</pre><p>
					Responsible for splitting the data into sub-indexes is the IndexShardingStrategy. The default sharding strategy splits the data according to the hash value of the ID string representation (generated by the FieldBridge). This ensures a fairly balanced sharding. You can replace the default strategy by implementing a custom IndexShardingStrategy. To use your custom strategy you have to set the <code class="literal">hibernate.search.&lt;indexName&gt;.sharding_strategy</code> property.
				</p><div class="formalpara"><p class="title"><strong>Example: Specifying a Custom Sharding Strategy</strong></p><p>
						
<pre class="screen">hibernate.search.&lt;indexName&gt;.sharding_strategy = my.shardingstrategy.Implementation</pre>

					</p></div><p>
					The IndexShardingStrategy property also allows for optimizing searches by selecting which shard to run the query against. By activating a filter a sharding strategy can select a subset of the shards used to answer a query (IndexShardingStrategy.getIndexManagersForQuery) and thus speed up the query execution.
				</p><p>
					Each shard has an independent IndexManager and so can be configured to use a different directory provider and back-end configuration. The IndexManager index names for the Animal entity in the example below are <code class="literal">Animal.0</code> to <code class="literal">Animal.4</code>. In other words, each shard has the name of its owning index followed by <code class="literal">.</code> (dot) and its index number.
				</p><div class="formalpara"><p class="title"><strong>Example: Sharding Configuration for Entity Animal</strong></p><p>
						
<pre class="screen">hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Animal.sharding_strategy.nbr_of_shards = 5
hibernate.search.Animal.directory_provider = filesystem
hibernate.search.Animal.0.indexName = Animal00
hibernate.search.Animal.3.indexBase = /usr/lucene/sharded
hibernate.search.Animal.3.indexName = Animal03</pre>

					</p></div><p>
					In the example above, the configuration uses the default id string hashing strategy and shards the Animal index into 5 sub-indexes. All sub-indexes are filesystem instances and the directory where each sub-index is stored is as followed:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							for sub-index 0: <code class="literal">/usr/lucene/indexes/Animal00</code> (shared indexBase but overridden indexName)
						</li><li class="listitem">
							for sub-index 1: <code class="literal">/usr/lucene/indexes/Animal.1</code> (shared indexBase, default indexName)
						</li><li class="listitem">
							for sub-index 2: <code class="literal">/usr/lucene/indexes/Animal.2</code> (shared indexBase, default indexName)
						</li><li class="listitem">
							for sub-index 3: <code class="literal">/usr/lucene/shared/Animal03</code> (overridden indexBase, overridden indexName)
						</li><li class="listitem">
							for sub-index 4: <code class="literal">/usr/lucene/indexes/Animal.4</code> (shared indexBase, default indexName)
						</li></ul></div><p>
					When implementing a IndexShardingStrategy any field can be used to determine the sharding selection. Consider that to handle deletions, <code class="literal">purge</code> and <code class="literal">purgeAll</code> operations, the implementation might need to return one or more indexes without being able to read all the field values or the primary identifier. In that case the information is not enough to pick a single index, all indexes should be returned, so that the delete operation will be propagated to all indexes potentially containing the documents to be deleted.
				</p></section><section class="section" id="customizing_lucenes_scoring_formula"><div class="titlepage"><div><div><h3 class="title">7.8.5. Customizing Lucene’s Scoring Formula</h3></div></div></div><p>
					Lucene allows the user to customize its scoring formula by extending org.apache.lucene.search.Similarity. The abstract methods defined in this class match the factors of the following formula calculating the score of query q for document d:
				</p><p>
					Extend org.apache.lucene.search.Similarity to customize Lucene’s scoring formula. The abstract methods match the formula used to calculate the score of query <code class="literal">q</code> for document <code class="literal">d</code> as follows:
				</p><pre class="screen">*score(q,d) = coord(q,d) · queryNorm(q) · ∑ ~t in q~ ( tf(t in d) ·
idf(t) ^2^ · t.getBoost() · norm(t,d) )*</pre><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 70%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941643792" scope="col">Factor</th><th align="left" valign="top" id="idm140159941642704" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									tf(t ind)
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Term frequency factor for the term (t) in the document (d).
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									idf(t)
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Inverse document frequency of the term.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									coord(q,d)
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Score factor based on how many of the query terms are found in the specified document.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									queryNorm(q)
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Normalizing factor used to make scores between queries comparable.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									t.getBoost()
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Field boost.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140159941643792"> <p>
									norm(t,d)
								</p>
								 </td><td align="left" valign="top" headers="idm140159941642704"> <p>
									Encapsulates a few (indexing time) boost and length factors.
								</p>
								 </td></tr></tbody></table></div><p>
					It is beyond the scope of this manual to explain this formula in more detail. See Similarity’s Javadocs for more information.
				</p><p>
					Hibernate Search provides three ways to modify Lucene’s similarity calculation.
				</p><p>
					First you can set the default similarity by specifying the fully specified class name of your Similarity implementation using the property <code class="literal">hibernate.search.similarity</code>. The default value is org.apache.lucene.search.DefaultSimilarity.
				</p><p>
					You can also override the similarity used for a specific index by setting the <code class="literal">similarity</code> property
				</p><pre class="screen">hibernate.search.default.similarity = my.custom.Similarity</pre><p>
					Finally you can override the default similarity on class level using the <code class="literal">@Similarity</code> annotation.
				</p><pre class="programlisting language-java">@Entity
@Indexed
@Similarity(impl = DummySimilarity.class)
public class Book {
...
}</pre><p>
					As an example, let us assume it is not important how often a term appears in a document. Documents with a single occurrence of the term should be scored the same as documents with multiple occurrences. In this case your custom implementation of the method tf(float freq) should return 1.0.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						When two entities share the same index they must declare the same Similarity implementation. Classes in the same class hierarchy always share the index, so it is not allowed to override the Similarity implementation in a subtype.
					</p><p>
						Likewise, it does not make sense to define the similarity via the index setting and the class-level setting as they would conflict. Such a configuration will be rejected.
					</p></div></div></section><section class="section" id="exception_handling_configuration"><div class="titlepage"><div><div><h3 class="title">7.8.6. Exception Handling Configuration</h3></div></div></div><p>
					Hibernate Search allows you to configure how exceptions are handled during the indexing process. If no configuration is provided then exceptions are logged to the log output by default. It is possible to explicitly declare the exception logging mechanism as follows:
				</p><pre class="programlisting language-java">hibernate.search.error_handler = log</pre><p>
					The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate Search provides an easy mechanism to override the default error handling implementation.
				</p><p>
					In order to provide your own implementation you must implement the ErrorHandler interface, which provides the <code class="literal">handle(ErrorContext context)</code> method. <code class="literal">ErrorContext</code> provides a reference to the primary <code class="literal">LuceneWork</code> instance, the underlying exception and any subsequent <code class="literal">LuceneWork</code> instances that could not be processed due to the primary exception.
				</p><pre class="programlisting language-java">public interface ErrorContext  {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</pre><p>
					To register this error handler with Hibernate Search you must declare the fully qualified classname of your ErrorHandler implementation in the configuration properties:
				</p><pre class="programlisting language-java">hibernate.search.error_handler = CustomerErrorHandler</pre></section><section class="section" id="disable_hibernate_search"><div class="titlepage"><div><div><h3 class="title">7.8.7. Disable Hibernate Search</h3></div></div></div><p>
					Hibernate Search can be partially or completely disabled as required. Hibernate Search’s indexing can be disabled, for example, if the index is read-only, or you prefer to perform indexing manually, rather than automatically. It is also possible to completely disable Hibernate Search, preventing indexing and searching.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Disable Indexing</span></dt><dd><p class="simpara">
								To disable Hibernate Search indexing, change the <code class="literal">indexing_strategy</code> configuration option to <code class="literal">manual</code>, then restart JBoss EAP.
							</p><pre class="screen">hibernate.search.indexing_strategy = manual</pre></dd><dt><span class="term">Disable Hibernate Search Completely</span></dt><dd><p class="simpara">
								To disable Hibernate Search completely, disable all listeners by changing the <code class="literal">autoregister_listeners</code> configuration option to <code class="literal">false</code>, then restart JBoss EAP.
							</p><pre class="screen">hibernate.search.autoregister_listeners = false</pre></dd></dl></div></section></section><section class="section" id="monitoring"><div class="titlepage"><div><div><h2 class="title">7.9. Monitoring</h2></div></div></div><p>
				Hibernate Search offers access to a <code class="literal">Statistics</code> object via <code class="literal">SearchFactory.getStatistics()</code>. It allows you, for example, to determine which classes are indexed and how many entities are in the index. This information is always available. However, by specifying the <code class="literal">hibernate.search.generate_statistics</code> property in your configuration you can also collect total and average Lucene query and object loading timings.
			</p><h4 id="access_to_statistics_via_jmx">Access to Statistics via JMX</h4><p>
				To enable access to statistics via JMX, set the property <code class="literal">hibernate.search.jmx_enabled</code> to <code class="literal">true</code>. This will automatically register the <code class="literal">StatisticsInfoMBean</code> bean, providing access to statistics using the <code class="literal">Statistics</code> object. Depending on your configuration the <code class="literal">IndexingProgressMonitorMBean</code> bean may also be registered.
			</p><h4 id="monitoring_indexing">Monitoring Indexing</h4><p>
				If the mass indexer API is used, you can monitor indexing progress using the <code class="literal">IndexingProgressMonitorMBean</code> bean. The bean is only bound to JMX while indexing is in progress.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					JMX beans can be accessed remotely using JConsole by setting the system property <code class="literal">com.sun.management.jmxremote</code> to <code class="literal">true</code>.
				</p></div></div></section></section><section class="appendix" id="reference_material"><div class="titlepage"><div><div><h1 class="title">Appendix A. Reference Material</h1></div></div></div><section class="section" id="hibernate_properties"><div class="titlepage"><div><div><h2 class="title">A.1. Hibernate Properties</h2></div></div></div><div class="table" id="configurable_connection_properties"><p class="title"><strong>Table A.1. Connection Properties Configurable in the <code class="literal">persistence.xml</code> File</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 30%; " class="col_1"><!--Empty--></col><col style="width: 30%; " class="col_2"><!--Empty--></col><col style="width: 40%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941234912" scope="col">Property Name</th><th align="left" valign="top" id="idm140159941233824" scope="col">Value</th><th align="left" valign="top" id="idm140159941232736" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941234912"> <p>
								<code class="literal">javax.persistence.jdbc.driver</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941233824"> <p>
								<code class="literal">org.hsqldb.jdbcDriver</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941232736"> <p>
								The class name of the JDBC driver to be used.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941234912"> <p>
								<code class="literal">javax.persistence.jdbc.user</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941233824"> <p>
								sa
							</p>
							 </td><td align="left" valign="top" headers="idm140159941232736"> <p>
								The username.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941234912"> <p>
								<code class="literal">javax.persistence.jdbc.password</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941233824"> </td><td align="left" valign="top" headers="idm140159941232736"> <p>
								The password.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941234912"> <p>
								<code class="literal">javax.persistence.jdbc.url</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941233824"> <p>
								<code class="literal">jdbc:hsqldb:.</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941232736"> <p>
								The JDBC connection URL.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="hibernate_configuration_properties"><p class="title"><strong>Table A.2. Hibernate Configuration Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 40%; " class="col_1"><!--Empty--></col><col style="width: 60%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159944372032" scope="col">Property Name</th><th align="left" valign="top" id="idm140159944370944" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.dialect
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								The class name of a Hibernate <code class="literal">org.hibernate.dialect.Dialect</code>. Allows Hibernate to generate SQL optimized for a particular relational database.
							</p>
							 <p>
								In most cases Hibernate will be able to choose the correct <code class="literal">org.hibernate.dialect.Dialect</code> implementation, based on the JDBC metadata returned by the JDBC driver.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.show_sql
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. Writes all SQL statements to console. This is an alternative to setting the log category <code class="literal">org.hibernate.SQL</code> to <code class="literal">debug</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.format_sql
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. Pretty print the SQL in the log and console.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.default_schema
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Qualify unqualified table names with the given schema/tablespace in generated SQL.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.default_catalog
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Qualifies unqualified table names with the given catalog in generated SQL.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.session_factory_name
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								The org.hibernate.SessionFactory will be automatically bound to this name in JNDI after it has been created. For example, <code class="literal">jndi/composite/name</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.max_fetch_depth
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Sets a maximum depth for the outer join fetch tree for single-ended associations (one-to-one, many-to-one). A <code class="literal">0</code> disables default outer join fetching. The recommended value is between <code class="literal">0</code> and <code class="literal">3</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.default_batch_fetch_size
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Sets a default size for Hibernate batch fetching of associations. The recommended values are <code class="literal">4</code>, <code class="literal">8</code>, and <code class="literal">16</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.default_entity_mode
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Sets a default mode for entity representation for all sessions opened from this <code class="literal">SessionFactory</code>. Values include: <code class="literal">dynamic-map</code>, <code class="literal">dom4j</code>, <code class="literal">pojo</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.order_updates
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. Forces Hibernate to order SQL updates by the primary key value of the items being updated. This will result in fewer transaction deadlocks in highly concurrent systems.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.generate_statistics
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. If enabled, Hibernate will collect statistics useful for performance tuning.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.use_identifier_rollback
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. If enabled, generated identifier properties will be reset to default values when objects are deleted.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.use_sql_comments
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. If turned on, Hibernate will generate comments inside the SQL, for easier debugging. Default value is <code class="literal">false</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.id.new_generator_mappings
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Boolean. This property is relevant when using @GeneratedValue. It indicates whether or not the new IdentifierGenerator implementations are used for javax.persistence.GenerationType.AUTO, javax.persistence.GenerationType.TABLE and javax.persistence.GenerationType.SEQUENCE. Default value is <code class="literal">true</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.ejb.naming_strategy
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Chooses the org.hibernate.cfg.NamingStrategy implementation when using Hibernate EntityManager. <code class="literal">hibernate.ejb.naming_strategy</code> is no longer supported in Hibernate 5.0. If used, a deprecation message will be logged indicating that it is no longer supported and has been removed in favor of the split ImplicitNamingStrategy and PhysicalNamingStrategy.
							</p>
							 <p>
								If the application does not use EntityManager, follow the instructions here to configure the NamingStrategy: <a class="link mimir-link-warn" href="http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html#naming" title="Mimir does not include content from: docs.jboss.org">Hibernate Reference Documentation - Naming Strategies</a>.
							</p>
							 <p>
								For an example on native bootstrapping using MetadataBuilder and applying the implicit naming strategy, see <a class="link mimir-link-warn" href="http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html#bootstrap-native-metadata" title="Mimir does not include content from: docs.jboss.org">http://docs.jboss.org/hibernate/orm/5.0/userguide/html_single/Hibernate_User_Guide.html#bootstrap-native-metadata</a> in the Hibernate 5.0 documentation. The physical naming strategy can be applied by using <code class="literal">MetadataBuilder.applyPhysicalNamingStrategy()</code>. For further details on <code class="literal">org.hibernate.boot.MetadataBuilder</code>, see <a class="link mimir-link-warn" href="https://docs.jboss.org/hibernate/orm/5.0/javadocs/" title="Mimir does not include content from: docs.jboss.org">https://docs.jboss.org/hibernate/orm/5.0/javadocs/</a>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.implicit_naming_strategy
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Specifies the <code class="literal">org.hibernate.boot.model.naming.ImplicitNamingStrategy</code> class to be used. <code class="literal">hibernate.implicit_naming_strategy</code> can also be used to configure a custom class that implements ImplicitNamingStrategy. Following short names are defined for this setting:
							</p>
							 <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<code class="literal">default</code> - <code class="literal">ImplicitNamingStrategyJpaCompliantImpl</code>
									</li><li class="listitem">
										<code class="literal">jpa</code> - <code class="literal">ImplicitNamingStrategyJpaCompliantImpl</code>
									</li><li class="listitem">
										<code class="literal">legacy-jpa</code> - <code class="literal">ImplicitNamingStrategyLegacyJpaImpl</code>
									</li><li class="listitem">
										<code class="literal">legacy-hbm</code> - <code class="literal">ImplicitNamingStrategyLegacyHbmImpl</code>
									</li><li class="listitem">
										<code class="literal">component-path</code> - <code class="literal">ImplicitNamingStrategyComponentPathImpl</code>
									</li></ul></div>
							 <p>
								The default setting is defined by the <code class="literal">ImplicitNamingStrategy</code> in the <code class="literal">default</code> short name. If the default setting is empty, the fallback is to use <code class="literal">ImplicitNamingStrategyJpaCompliantImpl</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944372032"> <p>
								hibernate.physical_naming_strategy
							</p>
							 </td><td align="left" valign="top" headers="idm140159944370944"> <p>
								Pluggable strategy contract for applying physical naming rules for database object names. Specifies the PhysicalNamingStrategy class to be used. <code class="literal">PhysicalNamingStrategyStandardImpl</code> is used by default. <code class="literal">hibernate.physical_naming_strategy</code> can also be used to configure a custom class that implements PhysicalNamingStrategy.
							</p>
							 </td></tr></tbody></table></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					For <code class="literal">hibernate.id.new_generator_mappings</code>, new applications should keep the default value of <code class="literal">true</code>. Existing applications that used Hibernate 3.3.x may need to change it to <code class="literal">false</code> to continue using a sequence object or table based generator, and maintain backward compatibility.
				</p></div></div><div class="table" id="hibernate_jdbc_and_connection_properties"><p class="title"><strong>Table A.3. Hibernate JDBC and Connection Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159944731744" scope="col">Property Name</th><th align="left" valign="top" id="idm140159944730656" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.fetch_size
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								A non-zero value that determines the JDBC fetch size (calls <code class="literal">Statement.setFetchSize()</code>).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.batch_size
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								A non-zero value enables use of JDBC2 batch updates by Hibernate. The recommended values are between <code class="literal">5</code> and <code class="literal">30</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.batch_versioned_data
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Boolean. Set this property to <code class="literal">true</code> if the JDBC driver returns correct row counts from <code class="literal">executeBatch()</code>. Hibernate will then use batched DML for automatically versioned data. Default value is to <code class="literal">false</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.factory_class
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Select a custom org.hibernate.jdbc.Batcher. Most applications will not need this configuration property.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.use_scrollable_resultset
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Boolean. Enables use of JDBC2 scrollable resultsets by Hibernate. This property is only necessary when using user-supplied JDBC connections. Hibernate uses connection metadata otherwise.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.use_streams_for_binary
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Boolean. This is a system-level property. Use streams when writing/reading <code class="literal">binary</code> or <code class="literal">serializable</code> types to/from JDBC.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jdbc.use_get_generated_keys
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Boolean. Enables use of JDBC3 <code class="literal">PreparedStatement.getGeneratedKeys()</code> to retrieve natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+. Set to false if JDBC driver has problems with the Hibernate identifier generators. By default, it tries to determine the driver capabilities using connection metadata.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.connection.provider_class
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								The class name of a custom org.hibernate.connection.ConnectionProvider which provides JDBC connections to Hibernate.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.connection.isolation
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Sets the JDBC transaction isolation level. Check java.sql.Connection for meaningful values, but note that most databases do not support all isolation levels and some define additional, non-standard isolations. Standard values are <code class="literal">1, 2, 4, 8</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.connection.autocommit
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Boolean. This property is not recommended for use. Enables autocommit for JDBC pooled connections.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.connection.release_mode
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Specifies when Hibernate should release JDBC connections. By default, a JDBC connection is held until the session is explicitly closed or disconnected. The default value auto will choose <code class="literal">after_statement</code> for the JTA and CMT transaction strategies, and <code class="literal">after_transaction</code> for the JDBC transaction strategy.
							</p>
							 <p>
								Available values are auto (default), on_close, <code class="literal">after_transaction</code>, <code class="literal">after_statement</code>.
							</p>
							 <p>
								This setting only affects the session returned from <code class="literal">SessionFactory.openSession</code>. For the session obtained through <code class="literal">SessionFactory.getCurrentSession</code>, the <code class="literal">CurrentSessionContext</code> implementation configured for use controls the connection release mode for that session.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.connection.<span class="emphasis"><em>&lt;propertyName&gt;</em></span>
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Pass the JDBC property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to <code class="literal">DriverManager.getConnection()</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159944731744"> <p>
								hibernate.jndi.<span class="emphasis"><em>&lt;propertyName&gt;</em></span>
							</p>
							 </td><td align="left" valign="top" headers="idm140159944730656"> <p>
								Pass the property <span class="emphasis"><em>&lt;propertyName&gt;</em></span> to the JNDI <code class="literal">InitialContextFactory</code>.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="hibernate_cache_properties"><p class="title"><strong>Table A.4. Hibernate Cache Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941322704" scope="col">Property Name</th><th align="left" valign="top" id="idm140159941321616" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.region.factory_class</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								The class name of a custom <code class="literal">CacheProvider</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.use_minimal_puts</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								Boolean. Optimizes second-level cache operation to minimize writes, at the cost of more frequent reads. This setting is most useful for clustered caches and, in Hibernate3, is enabled by default for clustered cache implementations.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.use_query_cache</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								Boolean. Enables the query cache. Individual queries still have to be set cacheable.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.use_second_level_cache</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								Boolean. Used to completely disable the second level cache, which is enabled by default for classes that specify a <code class="literal">&lt;cache&gt;</code> mapping.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.query_cache_factory</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								The class name of a custom <code class="literal">QueryCache</code> interface. The default value is the built-in <code class="literal">StandardQueryCache</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.region_prefix</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								A prefix to use for second-level cache region names.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.use_structured_entries</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								Boolean. Forces Hibernate to store data in the second-level cache in a more human-friendly format.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941322704"> <p>
								<code class="literal">hibernate.cache.default_cache_concurrency_strategy</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941321616"> <p>
								Setting used to give the name of the default org.hibernate.annotations.CacheConcurrencyStrategy to use when either @Cacheable or @Cache is used. <code class="literal">@Cache(strategy="..")</code> is used to override this default.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="hibernate_transaction_properties"><p class="title"><strong>Table A.5. Hibernate Transaction Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159942146112" scope="col">Property Name</th><th align="left" valign="top" id="idm140159941580880" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159942146112"> <p>
								<code class="literal">hibernate.transaction.factory_class</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941580880"> <p>
								The classname of a <code class="literal">TransactionFactory</code> to use with Hibernate <code class="literal">Transaction</code> API. Defaults to <code class="literal">JDBCTransactionFactory</code>).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942146112"> <p>
								<code class="literal">jta.UserTransaction</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941580880"> <p>
								A JNDI name used by <code class="literal">JTATransactionFactory</code> to obtain the JTA <code class="literal">UserTransaction</code> from the application server.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942146112"> <p>
								<code class="literal">hibernate.transaction.manager_lookup_class</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941580880"> <p>
								The classname of a <code class="literal">TransactionManagerLookup</code>. It is required when JVM-level caching is enabled or when using hilo generator in a JTA environment.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942146112"> <p>
								<code class="literal">hibernate.transaction.flush_before_completion</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941580880"> <p>
								Boolean. If enabled, the session will be automatically flushed during the before completion phase of the transaction. Built-in and automatic session context management is preferred.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942146112"> <p>
								<code class="literal">hibernate.transaction.auto_close_session</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941580880"> <p>
								Boolean. If enabled, the session will be automatically closed during the after completion phase of the transaction. Built-in and automatic session context management is preferred.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="miscellaneous_hibernate_properties"><p class="title"><strong>Table A.6. Miscellaneous Hibernate Properties</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159941548544" scope="col">Property Name</th><th align="left" valign="top" id="idm140159941547456" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.current_session_context_class</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Supply a custom strategy for the scoping of the "current" <code class="literal">Session</code>. Values include <code class="literal">jta</code>, <code class="literal">thread</code>, <code class="literal">managed</code>, <code class="literal">custom.Class</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.query.factory_class</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Chooses the HQL parser implementation: <code class="literal">org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory</code> or <code class="literal">org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.query.substitutions</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Used to map from tokens in Hibernate queries to SQL tokens (tokens might be function or literal names). For example, <code class="literal">hqlLiteral=SQL_LITERAL, hqlFunction=SQLFUNC</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.query.conventional_java_constants</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Indicates whether the Java constants follow the Java naming conventions or not. Default is <code class="literal">false</code>. Existing applications may set it to <code class="literal">true</code> only if conventional Java constants are being used in the applications.
							</p>
							 <p>
								Setting this to <code class="literal">true</code> has significant performance improvement because then Hibernate can determine if an alias should be treated as a Java constant simply by checking if the alias follows the Java naming conventions.
							</p>
							 <p>
								When this property is set to <code class="literal">false</code>, Hibernate determines an alias should be treated as a Java constant by attempting to load the alias as a class, which is an overhead for the application. If alias fails to load as a class, then Hibernate treats the alias as a Java constant.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.hbm2ddl.auto</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Automatically validates or exports schema DDL to the database when the <code class="literal">SessionFactory</code> is created. With <code class="literal">create-drop</code>, the database schema will be dropped when the <code class="literal">SessionFactory</code> is closed explicitly. Property value options are <code class="literal">validate</code>, <code class="literal">update</code>, <code class="literal">create</code>, <code class="literal">create-drop</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.hbm2ddl.import_files</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Comma-separated names of the optional files containing SQL DML statements executed during the SessionFactory creation. This is useful for testing or demonstrating. For example, by adding INSERT statements, the database can be populated with a minimal set of data when it is deployed. An example value is <code class="literal">/humans.sql,/dogs.sql</code>.
							</p>
							 <p>
								File order matters, as the statements of a given file are executed before the statements of the following files. These statements are only executed if the schema is created, for example if <code class="literal">hibernate.hbm2ddl.auto</code> is set to <code class="literal">create</code> or <code class="literal">create-drop</code>.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.hbm2ddl.import_files_sql_extractor</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								The classname of a custom ImportSqlCommandExtractor. Defaults to the built-in SingleLineSqlCommandExtractor. This is useful for implementing a dedicated parser that extracts a single SQL statement from each import file. Hibernate also provides MultipleLinesSqlCommandExtractor, which supports instructions/comments and quoted strings spread over multiple lines (mandatory semicolon at the end of each statement).
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.bytecode.use_reflection_optimizer</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Boolean. This is a system-level property, which cannot be set in the <code class="literal">hibernate.cfg.xml</code> file. Enables the use of bytecode manipulation instead of runtime reflection. Reflection can sometimes be useful when troubleshooting. Hibernate always requires either cglib or javassist even if the optimizer is turned off.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159941548544"> <p>
								<code class="literal">hibernate.bytecode.provider</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140159941547456"> <p>
								Both javassist or cglib can be used as byte manipulation engines. The default is <code class="literal">javassist</code>. The value is either <code class="literal">javassist</code> or <code class="literal">cglib</code>.
							</p>
							 </td></tr></tbody></table></div></div><div class="table" id="hibernate_sql_dialects"><p class="title"><strong>Table A.7. Hibernate SQL Dialects (<code class="literal">hibernate.dialect</code>)</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 40%; " class="col_1"><!--Empty--></col><col style="width: 60%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140159942224304" scope="col">RDBMS</th><th align="left" valign="top" id="idm140159942223216" scope="col">Dialect</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								DB2
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.DB2Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								DB2 AS/400
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.DB2400Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								DB2 OS390
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.DB2390Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Firebird
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.FirebirdDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								FrontBase
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.FrontbaseDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								H2 Database
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.H2Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								HypersonicSQL
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.HSQLDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Informix
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.InformixDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Ingres
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.IngresDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Interbase
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.InterbaseDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								MariaDB 10
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MariaDB10Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								MariaDB Galera Cluster 10
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MariaDB10Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Mckoi SQL
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MckoiDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2000
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServerDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2005
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServer2005Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2008
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServer2008Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2012
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServer2012Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2014
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServer2012Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Microsoft SQL Server 2016
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SQLServer2012Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								MySQL5
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MySQL5Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								MySQL5.5
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MySQL55Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								MySQL5.7
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.MySQL57Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Oracle (any version)
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.OracleDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Oracle 9i
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.Oracle9iDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Oracle 10g
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.Oracle10gDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Oracle 11g
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.Oracle10gDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Oracle 12c
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.Oracle12cDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Pointbase
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PointbaseDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								PostgreSQL
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PostgreSQLDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								PostgreSQL 9.2
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PostgreSQL9Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								PostgreSQL 9.3
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PostgreSQL9Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								PostgreSQL 9.4
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PostgreSQL94Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Postgres Plus Advanced Server
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.PostgresPlusDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Progress
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.ProgressDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								SAP DB
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SAPDBDialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Sybase
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SybaseASE15Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Sybase 15.7
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SybaseASE157Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Sybase 16
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SybaseASE157Dialect</code>
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140159942224304"> <p>
								Sybase Anywhere
							</p>
							 </td><td align="left" valign="top" headers="idm140159942223216"> <p>
								<code class="literal">org.hibernate.dialect.SybaseAnywhereDialect</code>
							</p>
							 </td></tr></tbody></table></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					The <code class="literal">hibernate.dialect</code> property should be set to the correct <code class="literal">org.hibernate.dialect.Dialect</code> subclass for the application database. If a dialect is specified, Hibernate will use sensible defaults for some of the other properties. This means that they do not have to be specified manually.
				</p></div></div><p>
				<br/><br/><br/><br/>
			</p><p>
				<span class="emphasis"><em><span class="right right">Revised on 2019-12-05 13:41:30 UTC</span></em></span>
			</p></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm140159940805952"><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span>© 2019 Red Hat, Inc.
	</div><div class="para">
		The text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). An explanation of CC-BY-SA is available at <a class="uri mimir-link-warn" href="http://creativecommons.org/licenses/by-sa/3.0/" title="Mimir does not include content from: creativecommons.org">http://creativecommons.org/licenses/by-sa/3.0/</a>. In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div></body>

        
        
    </div>
    

</div> 


                            </bdo>
                        </main>
                    </div>
                </main>
            </div>
        
            <!--#include virtual="/includes/footer/index.html" -->
        </div>
    </body>
</html>
